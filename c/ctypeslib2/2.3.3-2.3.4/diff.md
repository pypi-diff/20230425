# Comparing `tmp/ctypeslib2-2.3.3-py3-none-any.whl.zip` & `tmp/ctypeslib2-2.3.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,26 @@
-Zip file size: 57865 bytes, number of entries: 24
--rw-rw-r--  2.0 unx     4282 b- defN 23-Apr-15 00:52 ctypeslib/__init__.py
--rw-rw-r--  2.0 unx    11153 b- defN 23-Apr-15 00:26 ctypeslib/clang2py.py
+Zip file size: 59689 bytes, number of entries: 24
+-rw-rw-r--  2.0 unx     5532 b- defN 23-Apr-22 17:19 ctypeslib/__init__.py
+-rw-rw-r--  2.0 unx    10324 b- defN 23-Apr-22 17:05 ctypeslib/clang2py.py
 -rw-rw-r--  2.0 unx     9830 b- defN 21-Feb-23 23:42 ctypeslib/dynamic_module.py
 -rw-rw-r--  2.0 unx     1770 b- defN 21-Feb-24 00:00 ctypeslib/library.py
 -rw-rw-r--  2.0 unx       32 b- defN 21-Feb-23 23:42 ctypeslib/codegen/__init__.py
--rw-rw-r--  2.0 unx    15850 b- defN 23-Apr-04 02:31 ctypeslib/codegen/clangparser.py
--rw-rw-r--  2.0 unx    47632 b- defN 23-Apr-04 05:22 ctypeslib/codegen/codegenerator.py
--rw-rw-r--  2.0 unx     3545 b- defN 23-Apr-04 02:36 ctypeslib/codegen/config.py
--rw-rw-r--  2.0 unx    51255 b- defN 23-Apr-04 03:58 ctypeslib/codegen/cursorhandler.py
--rw-rw-r--  2.0 unx     9106 b- defN 23-Apr-04 03:58 ctypeslib/codegen/handler.py
+-rw-rw-r--  2.0 unx    16278 b- defN 23-Apr-22 17:36 ctypeslib/codegen/clangparser.py
+-rw-rw-r--  2.0 unx    48167 b- defN 23-Apr-22 17:39 ctypeslib/codegen/codegenerator.py
+-rw-rw-r--  2.0 unx     3617 b- defN 23-Apr-22 16:55 ctypeslib/codegen/config.py
+-rw-rw-r--  2.0 unx    52565 b- defN 23-Apr-22 15:58 ctypeslib/codegen/cursorhandler.py
+-rw-rw-r--  2.0 unx     9107 b- defN 23-Apr-22 17:35 ctypeslib/codegen/handler.py
 -rw-rw-r--  2.0 unx     6454 b- defN 23-Apr-04 01:33 ctypeslib/codegen/typedesc.py
 -rw-rw-r--  2.0 unx     9684 b- defN 23-Apr-04 02:36 ctypeslib/codegen/typehandler.py
--rw-rw-r--  2.0 unx     5334 b- defN 21-Apr-13 02:30 ctypeslib/codegen/util.py
+-rw-rw-r--  2.0 unx     5351 b- defN 23-Apr-22 15:58 ctypeslib/codegen/util.py
 -rw-rw-r--  2.0 unx      231 b- defN 21-Feb-23 23:42 ctypeslib/data/fundamental_type_name.tpl
 -rw-rw-r--  2.0 unx      178 b- defN 21-Feb-23 23:42 ctypeslib/data/headers.tpl
 -rw-rw-r--  2.0 unx     1831 b- defN 21-Feb-23 23:42 ctypeslib/data/pointer_type.tpl
 -rw-rw-r--  2.0 unx      594 b- defN 21-Feb-23 23:42 ctypeslib/data/string_cast.tpl
 -rw-rw-r--  2.0 unx     3826 b- defN 23-Apr-04 02:36 ctypeslib/data/structure_type.tpl
--rw-rw-r--  2.0 unx     1071 b- defN 23-Apr-15 00:53 ctypeslib2-2.3.3.dist-info/LICENSE.txt
--rw-rw-r--  2.0 unx    10352 b- defN 23-Apr-15 00:53 ctypeslib2-2.3.3.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Apr-15 00:53 ctypeslib2-2.3.3.dist-info/WHEEL
--rw-rw-r--  2.0 unx       53 b- defN 23-Apr-15 00:53 ctypeslib2-2.3.3.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       10 b- defN 23-Apr-15 00:53 ctypeslib2-2.3.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2048 b- defN 23-Apr-15 00:53 ctypeslib2-2.3.3.dist-info/RECORD
-24 files, 196213 bytes uncompressed, 54539 bytes compressed:  72.2%
+-rw-rw-r--  2.0 unx     1071 b- defN 23-Apr-25 00:31 ctypeslib2-2.3.4.dist-info/LICENSE.txt
+-rw-rw-r--  2.0 unx    12204 b- defN 23-Apr-25 00:31 ctypeslib2-2.3.4.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Apr-25 00:31 ctypeslib2-2.3.4.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       53 b- defN 23-Apr-25 00:31 ctypeslib2-2.3.4.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       10 b- defN 23-Apr-25 00:31 ctypeslib2-2.3.4.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2048 b- defN 23-Apr-25 00:31 ctypeslib2-2.3.4.dist-info/RECORD
+24 files, 200849 bytes uncompressed, 56363 bytes compressed:  71.9%
```

## zipnote {}

```diff
@@ -48,26 +48,26 @@
 
 Filename: ctypeslib/data/string_cast.tpl
 Comment: 
 
 Filename: ctypeslib/data/structure_type.tpl
 Comment: 
 
-Filename: ctypeslib2-2.3.3.dist-info/LICENSE.txt
+Filename: ctypeslib2-2.3.4.dist-info/LICENSE.txt
 Comment: 
 
-Filename: ctypeslib2-2.3.3.dist-info/METADATA
+Filename: ctypeslib2-2.3.4.dist-info/METADATA
 Comment: 
 
-Filename: ctypeslib2-2.3.3.dist-info/WHEEL
+Filename: ctypeslib2-2.3.4.dist-info/WHEEL
 Comment: 
 
-Filename: ctypeslib2-2.3.3.dist-info/entry_points.txt
+Filename: ctypeslib2-2.3.4.dist-info/entry_points.txt
 Comment: 
 
-Filename: ctypeslib2-2.3.3.dist-info/top_level.txt
+Filename: ctypeslib2-2.3.4.dist-info/top_level.txt
 Comment: 
 
-Filename: ctypeslib2-2.3.3.dist-info/RECORD
+Filename: ctypeslib2-2.3.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## ctypeslib/__init__.py

```diff
@@ -1,17 +1,25 @@
 # -*- coding: utf-8 -*-
-# ctypeslib package
+"""
+ctypeslib2 package
+
+ctypeslib2 helps generate Python-friendly interfaces to C libraries, such as automatically generating Python classes
+that represent C data structures, simplifying the process of wrapping C functions with Python functions,
+and providing tools for handling errors and exceptions that may occur when calling C functions.
+
+"""
 
-from pkg_resources import get_distribution, DistributionNotFound
 import ctypes
-from ctypes.util import find_library
 import os
 import re
 import sys
 import warnings
+from ctypes.util import find_library
+
+from pkg_resources import get_distribution, DistributionNotFound
 
 try:
     __dist = get_distribution('ctypeslib2')
     # Normalize case for Windows systems
     # if you are in a virtualenv, ./local/* are aliases to ./*
     __dist_loc = os.path.normcase(os.path.realpath(__dist.location))
     __here = os.path.normcase(os.path.realpath(__file__))
@@ -23,34 +31,35 @@
 else:
     __version__ = __dist.version
 
 
 def __find_clang_libraries():
     """ configure python-clang to use the local clang library """
     _libs = []
+    # try for a file with a version match with the clang python package version
+    version_major = __clang_py_version__.split('.')[0]
     # try default system name
-    v0 = ["libclang", "clang"]
+    v_list = [f"clang-{__clang_py_version__}", f"clang-{version_major}", "libclang", "clang"]
     # tries clang version 16 to 7
-    v1 = ["clang-%d" % _ for _ in range(16, 6, -1)]
+    v_list += [f"clang-{_}" for _ in range(16, 6, -1)]
     # with the dotted form of clang 6.0 to 4.0
-    v2 = ["clang-%.1f" % _ for _ in range(6, 3, -1)]
+    v_list += [f"clang-{_:.1f}" for _ in range(6, 3, -1)]
     # clang 3 supported versions
-    v3 = ["clang-3.9", "clang-3.8", "clang-3.7"]
-    v_list = v0 + v1 + v2 + v3
+    v_list += ["clang-3.9", "clang-3.8", "clang-3.7"]
     for _version in v_list:
         _filename = find_library(_version)
         if _filename:
-            _libs.append((_version, _filename))
+            _libs.append(_filename)
     # On darwin, also consider either Xcode or CommandLineTools.
     if os.name == "posix" and sys.platform == "darwin":
         for _ in ['/Library/Developer/CommandLineTools/usr/lib/libclang.dylib',
                   '/Applications/Xcode.app/Contents/Frameworks/libclang.dylib',
                   ]:
             if os.path.exists(_):
-                _libs.insert(0, (_, _))
+                _libs.insert(0, _)
     return _libs
 
 
 def clang_version():
     """Pull the clang C library version from the API"""
     # avoid loading the cindex API (cindex.conf.lib) to avoid version conflicts
     get_version = cindex.conf.get_cindex_library().clang_getClangVersion
@@ -66,48 +75,62 @@
 
 def clang_py_version():
     """Return the python clang package version"""
     return __clang_py_version__
 
 
 def __configure_clang_cindex():
-    global __clang_py_version__
-    __clang_py_version__ = get_distribution('clang').version
-    # first try for a perfect match.
-    __lib_filename = find_library("clang-" + __clang_py_version__)
-    if __lib_filename is not None:
-        cindex.Config.set_library_file(__lib_filename)
-        return __lib_filename
-    else:
-        __libs = __find_clang_libraries()
-        if len(__libs) > 0:
-            __version, __filename = __libs[0]
-            cindex.Config.set_library_file(__filename)
-            return __filename
+    """
+    First we attempt to configure clang with the library path set in environment variable
+    Second we attempt to configure clang with a clang library version similar to the clang python package version
+    Third we attempt to configure clang with any clang library we can find
+    """
+    # first, use environment variables set by user
+    __libs = []
+    __lib_path = os.environ.get('CLANG_LIBRARY_PATH')
+    if __lib_path is not None:
+        if not os.path.exists(__lib_path):
+            warnings.warn("Filepath in CLANG_LIBRARY_PATH does not exist", RuntimeWarning)
+        else:
+            __libs.append(__lib_path)
+    __libs.extend(__find_clang_libraries())
+    for __library_path in __libs:
+        try:
+            if os.path.isdir(__library_path):
+                cindex.Config.set_library_path(__library_path)
+            else:
+                cindex.Config.set_library_file(__library_path)
+            # force-check that clang is configured properly
+            clang_version()
+        except cindex.LibclangError:
+            warnings.warn(f"Could not configure clang with library_path={__library_path}", RuntimeWarning)
+            continue
+        return __library_path
     return None
 
 
 # check which clang python module is available
 # check which clang library is available
 try:
     from clang import cindex
+    from ctypeslib.codegen.codegenerator import translate, translate_files
 
-    __clang_py_version__ = 'not-installed'
-    _filename = __configure_clang_cindex()
-    if _filename is None:
+    __clang_py_version__ = get_distribution('clang').version
+    __clang_library_filename = __configure_clang_cindex()
+    if __clang_library_filename is None:
         warnings.warn("Could not find the clang library. please install llvm libclang", RuntimeWarning)
         # do not fail - maybe the user has a plan
     else:
         # set a warning if major versions differs.
         if clang_version().split('.')[0] != clang_py_version().split('.')[0]:
             clang_major = clang_version().split('.')[0]
-            warnings.warn("Version of python-clang (%s) and clang C library (%s) are different. "
-                          "Did you try pip install clang==%s.*" % (
-                              clang_py_version(), clang_version(), clang_major), RuntimeWarning)
-except ImportError:
+            warnings.warn(f"Version of python-clang ({clang_py_version()}) and "
+                          f"clang C library ({clang_version()}) are different. "
+                          f"Did you try pip install clang=={clang_major}.*", RuntimeWarning)
+except ImportError as e:
     __clang_py_version__ = None
-    warnings.warn("Could not find a version of python-clang installed. please pip install clang", RuntimeWarning)
+    warnings.warn("Could not find a version of python-clang installed. "
+                  "Please pip install clang==<version>.*", RuntimeWarning)
+    raise e
 
-from clang import cindex
-from ctypeslib.codegen.codegenerator import translate, translate_files
 
-__all__ = ['translate', 'translate_files', 'clang_version']
+__all__ = ['translate', 'translate_files', 'clang_version', 'clang_py_version']
```

## ctypeslib/clang2py.py

```diff
@@ -1,24 +1,29 @@
 #!/usr/bin/env python3
+
+"""
+clang2py - generate Python-friendly interfaces to C libraries, such as automatically generating Python classes
+that represent C data structures, simplifying the process of wrapping C functions with Python functions,
+and providing tools for handling errors and exceptions that may occur when calling C functions.
+
+"""
+
 import argparse
 import logging
 import os
 import platform
-import re
 import sys
 import tempfile
 import traceback
 
-from ctypes import RTLD_GLOBAL
-
 import ctypeslib
-from ctypeslib.codegen import typedesc, config
-from ctypeslib.codegen.codegenerator import translate_files
-from ctypeslib.library import Library
 from ctypeslib import clang_version, clang_py_version
+from ctypeslib.codegen import config
+from ctypeslib.codegen.codegenerator import translate_files
+from ctypeslib.codegen.handler import InvalidTranslationUnitException
 
 ################################################################
 windows_dll_names = """\
 imagehlp
 user32
 kernel32
 gdi32
@@ -45,271 +50,309 @@
 netapi32
 rpcrt4""".split()
 
 
 # rpcndr
 # ntdll
 
+
 def _is_typedesc(item):
-    for c in item:
-        if c not in 'acdefmstu':
+    for char in item:
+        if char not in "acdefmstu":
             raise argparse.ArgumentTypeError("types choices are 'acdefmstu'")
     return item
 
 
 class Input:
+    """A context manager to abstract input file, files or stdin"""
+
     def __init__(self, options):
         self.files = []
         self._stdin = None
-        for f in options.files:
+        for in_file in options.files:
             # stdin case
-            if f == sys.stdin:
+            if in_file == sys.stdin:
+                # pylint: disable-next=consider-using-with
                 _stdin = tempfile.NamedTemporaryFile(mode="w", prefix="stdin", suffix=".c", delete=False)
-                _stdin.write(f.read())
-                f = _stdin
-            self.files.append(f.name)
-            f.close()
+                _stdin.write(in_file.read())
+                in_file = _stdin
+            self.files.append(in_file.name)
+            in_file.close()
 
     def __enter__(self):
         return self
 
-    def __exit__(self, exc_type, exc_value, tb):
+    def __exit__(self, exc_type, exc_value, ecx_tb):
         if self._stdin:
             os.remove(self._stdin.name)
         return False
 
 
 class Output:
+    """A context manager to abstract out file or stdout"""
+
     def __init__(self, options):
         # handle output
         if options.output == "-":
             self.stream = sys.stdout
             self.output_file = None
         else:
+            # pylint: disable-next=unspecified-encoding,consider-using-with
             self.stream = open(options.output, "w")
             self.output_file = self.stream
 
     def __enter__(self):
         return self
 
-    def __exit__(self, exc_type, exc_value, tb):
+    def __exit__(self, exc_type, exc_value, ecx_tb):
         if self.output_file is not None:
             self.output_file.close()
-            os.remove(self.options.output)
+            # we do not want to delete the output file.
+            # os.remove(self.output_file.name)
         # If an exception is supplied, and the method wishes to suppress the exception
         # (i.e., prevent it from being propagated), it should return a true value.
         return False
 
 
-def main(argv=None):
-    if argv is None:
-        argv = sys.argv[1:]
-    cfg = config.CodegenConfig()
-    cfg.local_platform_triple = "%s-%s" % (platform.machine(), platform.system())
-    cfg.known_symbols = {}
-    cfg.searched_dlls = []
-    cfg.clang_opts = []
-    files = None
+def _make_parser(cfg):
+    """Build the argparse parser"""
 
-    def windows_dlls(option, opt, value, parser):
-        parser.values.dlls.extend(windows_dll_names)
+    def windows_dlls(option, opt, value, _parser):  # pylint: disable=unused-argument
+        _parser.values.dlls.extend(windows_dll_names)
 
-    cfg.version = ctypeslib.__version__
-
-    parser = argparse.ArgumentParser(prog='clang2py',
-                                     description='Version %s. Generate python code from C headers' % cfg.version)
-    parser.add_argument("-c", "--comments",
-                        dest="generate_comments",
-                        action="store_true",
-                        help="include source doxygen-style comments",
-                        default=False)
-    parser.add_argument("-d", "--doc",
-                        dest="generate_docstrings", action="store_true",
-                        help="include docstrings containing C prototype and source file location",
-                        default=False)
-    parser.add_argument("--debug",
-                        action="store_const",
-                        const=True,
-                        help='setLevel to DEBUG')
-    parser.add_argument("-e", "--show-definition-location",
-                        dest="generate_locations",
-                        action="store_true",
-                        help="include source file location in comments",
-                        default=False)
-    parser.add_argument("-k", "--kind",
-                        action="store",
-                        dest="kind", help="kind of type descriptions to include: "
-                                          "a = Alias,\n"
-                                          "c = Class,\n"
-                                          "d = Variable,\n"
-                                          "e = Enumeration,\n"
-                                          "f = Function,\n"
-                                          "m = Macro, #define\n"
-                                          "s = Structure,\n"
-                                          "t = Typedef,\n"
-                                          "u = Union\n"
-                                          "default = 'cdefstu'\n",
-                        metavar="TYPEKIND",
-                        default="cdefstu",
-                        type=_is_typedesc)
-
-    parser.add_argument("-i", "--includes",
-                        dest="generate_includes",
-                        action="store_true",
-                        help="include declaration defined outside of the sourcefiles",
-                        default=False)
-
-    parser.add_argument("-l", "--include-library",
-                        dest="dll",
-                        help="library to search for exported functions. Add multiple times if required",
-                        action="append",
-                        default=[])
+    parser = argparse.ArgumentParser(
+        prog="clang2py", description=f"Version {ctypeslib.__version__}. Generate python code from C headers"
+    )
+    parser.add_argument(
+        "-c",
+        "--comments",
+        dest="generate_comments",
+        action="store_true",
+        help="include source doxygen-style comments",
+        default=False,
+    )
+    parser.add_argument(
+        "-d",
+        "--doc",
+        dest="generate_docstrings",
+        action="store_true",
+        help="include docstrings containing C prototype and source file location",
+        default=False,
+    )
+    parser.add_argument("--debug", action="store_const", const=True, help="setLevel to DEBUG")
+    parser.add_argument(
+        "-e",
+        "--show-definition-location",
+        dest="generate_locations",
+        action="store_true",
+        help="include source file location in comments",
+        default=False,
+    )
+    parser.add_argument(
+        "-k",
+        "--kind",
+        action="store",
+        dest="kind",
+        help="kind of type descriptions to include: "
+             "a = Alias,\n"
+             "c = Class,\n"
+             "d = Variable,\n"
+             "e = Enumeration,\n"
+             "f = Function,\n"
+             "m = Macro, #define\n"
+             "s = Structure,\n"
+             "t = Typedef,\n"
+             "u = Union\n"
+             "default = 'cdefstu'\n",
+        metavar="TYPEKIND",
+        default="cdefstu",
+        type=_is_typedesc,
+    )
+
+    parser.add_argument(
+        "-i",
+        "--includes",
+        dest="generate_includes",
+        action="store_true",
+        help="include declaration defined outside of the sourcefiles",
+        default=False,
+    )
+
+    parser.add_argument(
+        "-l",
+        "--include-library",
+        dest="dll",
+        help="library to search for exported functions. Add multiple times if required",
+        action="append",
+        default=[],
+    )
 
     if os.name in ("ce", "nt"):
         default_modules = ["ctypes.wintypes"]
     else:
         default_modules = []  # ctypes is already imported
 
-    parser.add_argument("-m", "--module",
-                        dest="modules",
-                        metavar="module",
-                        help="Python module(s) containing symbols which will "
-                             "be imported instead of generated",
-                        action="append",
-                        default=default_modules)
-
-    parser.add_argument("--nm",
-                        dest="nm",
-                        default="nm",
-                        help="nm program to use to extract symbols from libraries")
-
-    parser.add_argument("-o", "--output",
-                        dest="output",
-                        help="output filename (if not specified, standard output will be used)",
-                        default="-", )
+    parser.add_argument(
+        "-m",
+        "--module",
+        dest="modules",
+        metavar="module",
+        help="Python module(s) containing symbols which will " "be imported instead of generated",
+        action="append",
+        default=default_modules,
+    )
+
+    parser.add_argument("--nm", dest="nm", default="nm", help="nm program to use to extract symbols from libraries")
+
+    parser.add_argument(
+        "-o",
+        "--output",
+        dest="output",
+        help="output filename (if not specified, standard output will be used)",
+        default="-",
+    )
     # type=argparse.FileType('w'))
 
-    parser.add_argument("-p", "--preload",
-                        dest="preload",
-                        metavar="DLL",
-                        help="dll to be loaded before all others (to resolve symbols)",
-                        action="append",
-                        default=[])
-
-    parser.add_argument("-q", "--quiet",
-                        action="store_const",
-                        const="quiet",
-                        help="Shut down warnings and below",
-                        default=False)
-
-    parser.add_argument("-r", "--regex",
-                        dest="expressions",
-                        metavar="EXPRESSION",
-                        action="append",
-                        help="regular expression for symbols to include "
-                             "(if neither symbols nor expressions are specified,"
-                             "everything will be included)",
-                        default=[])
-
-    parser.add_argument("-s", "--symbol",
-                        dest="symbols",
-                        metavar="SYMBOL",
-                        action="append",
-                        help="symbol to include "
-                             "(if neither symbols nor expressions are specified,"
-                             "everything will be included)",
-                        default=[])
-
-    parser.add_argument("-t", "--target",
-                        dest="target",
-                        help="target architecture (default: %s)" % cfg.local_platform_triple,
-                        default=None)  # actually let clang alone decide.
-
-    parser.add_argument("-v", "--verbose",
-                        action="store_true",
-                        dest="verbose",
-                        help="verbose output",
-                        default=False)
-    parser.add_argument('-V', '--version',
-                        action='version',
-                        version="versions - %(prog)s:" + "%s clang:%s python-clang:%s" % (cfg.version, clang_version(),
-                                                                                          clang_py_version()))
-
-    parser.add_argument("-w",
-                        action="store",
-                        default=windows_dlls,
-                        help="add all standard windows dlls to the searched dlls list")
-
-    parser.add_argument("-x", "--exclude-includes",
-                        action="store_true",
-                        default=False,
-                        help="Parse object in sources files only. Ignore includes")
-
-    parser.add_argument("--show-ids", dest="showIDs",
-                        help="Don't compute cursor IDs (very slow)",
-                        default=False)
-
-    parser.add_argument("--max-depth", dest="maxDepth",
-                        help="Limit cursor expansion to depth N",
-                        metavar="N",
-                        type=int,
-                        default=None)
-
-    parser.add_argument("--validate", dest="validate",
-                        help="validate the python code is correct",
-                        type=bool,
-                        default=True)
-
-    # FIXME recognize - as stdin
-    # we do NOT support stdin
-    parser.add_argument("files", nargs="+",
-                        help="source filenames. stdin is not supported",
-                        type=argparse.FileType('r'))
-
-    parser.add_argument("--clang-args",
-                        action="store",
-                        default=None,
-                        required=False,
-                        help="clang options, in quotes: --clang-args=\"-std=c99 -Wall\"",
-                        type=str)
+    parser.add_argument(
+        "-p",
+        "--preload",
+        dest="preload",
+        metavar="DLL",
+        help="dll to be loaded before all others (to resolve symbols)",
+        action="append",
+        default=[],
+    )
+
+    parser.add_argument(
+        "-q", "--quiet", action="store_const", const="quiet", help="Shut down warnings and below", default=False
+    )
+
+    parser.add_argument(
+        "-r",
+        "--regex",
+        dest="expressions",
+        metavar="EXPRESSION",
+        action="append",
+        help="regular expression for symbols to include "
+             "(if neither symbols nor expressions are specified,"
+             "everything will be included)",
+        default=[],
+    )
+
+    parser.add_argument(
+        "-s",
+        "--symbol",
+        dest="symbols",
+        metavar="SYMBOL",
+        action="append",
+        help="symbol to include " "(if neither symbols nor expressions are specified," "everything will be included)",
+        default=[],
+    )
+
+    parser.add_argument(
+        "-t",
+        "--target",
+        dest="target",
+        help=f"target architecture (default: {cfg.local_platform_triple})",
+        default=None,
+    )  # actually let clang alone decide.
+
+    parser.add_argument("-v", "--verbose", action="store_true", dest="verbose", help="verbose output", default=False)
+
+    def version_string():
+        version = "versions - %(prog)s:" \
+                  f"{ctypeslib.__version__} python-clang:{clang_version()} clang:{clang_py_version()} " \
+                  f"clang_filename:{ctypeslib.__clang_library_filename}"  # pylint: disable=protected-access
+        return version
+
+    parser.add_argument("-V", "--version", action="version", version=version_string())
+
+    parser.add_argument(
+        "-w", action="store", default=windows_dlls, help="add all standard windows dlls to the searched dlls list"
+    )
+
+    parser.add_argument(
+        "-x",
+        "--exclude-includes",
+        action="store_true",
+        default=False,
+        help="Parse object in sources files only. Ignore includes",
+    )
+
+    parser.add_argument("--show-ids", dest="showIDs", help="Don't compute cursor IDs (very slow)", default=False)
+
+    parser.add_argument(
+        "--max-depth", dest="maxDepth", help="Limit cursor expansion to depth N", metavar="N", type=int, default=None
+    )
+
+    parser.add_argument(
+        "--validate", dest="validate", help="validate the python code is correct", type=bool, default=True
+    )
+
+    # we do support stdin
+    parser.add_argument(
+        "files", nargs="+", help="source filenames. use '-' for stdin ", type=argparse.FileType("r")
+    )
+
+    parser.add_argument(
+        "--clang-args",
+        action="store",
+        default=None,
+        required=False,
+        help='clang options, in quotes: --clang-args="-std=c99 -Wall"',
+        type=str,
+    )
 
     parser.epilog = """Cross-architecture: You can pass target modifiers to clang.
     For example, try --clang-args="-target x86_64" or "-target i386-linux" to change the target CPU arch."""
 
+    return parser
+
+
+def main(argv=None):
+    """entry point for clang2py"""
+    if argv is None:
+        argv = sys.argv[1:]
+    cfg = config.CodegenConfig()
+    cfg.local_platform_triple = f"{platform.machine()}-{platform.system()}"
+    cfg.known_symbols = {}
+    cfg.searched_dlls = []
+    cfg.clang_opts = []
+
+    parser = _make_parser(cfg)
     options = parser.parse_args(argv)
 
     # cfg is the CodegenConfig, not the runtime config.
     level = logging.INFO
     if options.debug:
         level = logging.DEBUG
     elif options.quiet:
         level = logging.ERROR
     logging.basicConfig(level=level, stream=sys.stderr)
 
     # capture codegen options in config
     cfg.parse_options(options)
 
     # handle input files, and outputs
-    from ctypeslib.codegen.handler import InvalidTranslationUnitException
     try:
         with Input(options) as inputs, Output(options) as outputs:
             # start codegen
             if cfg.generate_comments:
                 outputs.stream.write("# generated by 'clang2py'\n")
-                outputs.stream.write("# flags '%s'\n" % " ".join(argv[1:]))
+                outputs.stream.write(f"# flags '{' '.join(argv[1:])}'\n")
 
             # Preload libraries
             # [Library(name, mode=RTLD_GLOBAL) for name in options.preload]
 
             translate_files(inputs.files, outputs.stream, cfg)
     except InvalidTranslationUnitException:
         return 1
     return 0
 
 
 if __name__ == "__main__":
     try:
         sys.exit(main(sys.argv[1:]))
-    except Exception:
+    except Exception:  # pylint: disable=broad-exception-caught
         # return non-zero exit status in case of an unhandled exception
         traceback.print_exc()
         sys.exit(1)
```

## ctypeslib/codegen/clangparser.py

```diff
@@ -11,67 +11,75 @@
 from ctypeslib.codegen import typedesc
 from ctypeslib.codegen import typehandler
 from ctypeslib.codegen import util
 from ctypeslib.codegen.handler import DuplicateDefinitionException
 from ctypeslib.codegen.handler import InvalidDefinitionError
 from ctypeslib.codegen.handler import InvalidTranslationUnitException
 
-log = logging.getLogger('clangparser')
+log = logging.getLogger("clangparser")
 
 
-class Clang_Parser(object):
+class Clang_Parser:
     """
     Will parse libclang AST tree to create a representation of Types and
     different others source code objects objets as described in Typedesc.
 
     For each Declaration a declaration will be saved, and the type of that
     declaration will be cached and saved.
     """
 
-    has_values = {"Enumeration", "Function", "FunctionType",
-                  "OperatorFunction", "Method", "Constructor",
-                  "Destructor", "OperatorMethod",
-                  "Converter"}
+    has_values = {
+        "Enumeration",
+        "Function",
+        "FunctionType",
+        "OperatorFunction",
+        "Method",
+        "Constructor",
+        "Destructor",
+        "OperatorMethod",
+        "Converter",
+    }
 
     # FIXME, macro definition __SIZEOF_DOUBLE__
     ctypes_typename = {
-        TypeKind.VOID: 'None',  # because ctypes.POINTER(None) == c_void_p
-        TypeKind.BOOL: 'c_bool',
-        TypeKind.CHAR_U: 'c_ubyte',  # ?? used for PADDING
-        TypeKind.UCHAR: 'c_ubyte',  # unsigned char
-        TypeKind.CHAR16: 'c_wchar',  # char16_t
-        TypeKind.CHAR32: 'c_wchar',  # char32_t
-        TypeKind.USHORT: 'c_ushort',
-        TypeKind.UINT: 'c_uint',
-        TypeKind.ULONG: 'TBD',
-        TypeKind.ULONGLONG: 'c_ulonglong',
-        TypeKind.UINT128: 'c_uint128',  # FIXME
-        TypeKind.CHAR_S: 'c_char',  # char
-        TypeKind.SCHAR: 'c_byte',  # signed char
-        TypeKind.WCHAR: 'c_wchar',
-        TypeKind.SHORT: 'c_short',
-        TypeKind.INT: 'c_int',
-        TypeKind.LONG: 'TBD',
-        TypeKind.LONGLONG: 'c_longlong',
-        TypeKind.INT128: 'c_int128',  # FIXME
-        TypeKind.FLOAT: 'c_float',
-        TypeKind.DOUBLE: 'c_double',
-        TypeKind.LONGDOUBLE: 'c_longdouble',
-        TypeKind.POINTER: 'POINTER_T',
-        TypeKind.NULLPTR: 'c_void_p'
+        TypeKind.VOID: "None",  # because ctypes.POINTER(None) == c_void_p
+        TypeKind.BOOL: "c_bool",
+        TypeKind.CHAR_U: "c_ubyte",  # ?? used for PADDING
+        TypeKind.UCHAR: "c_ubyte",  # unsigned char
+        TypeKind.CHAR16: "c_wchar",  # char16_t
+        TypeKind.CHAR32: "c_wchar",  # char32_t
+        TypeKind.USHORT: "c_ushort",
+        TypeKind.UINT: "c_uint",
+        TypeKind.ULONG: "TBD",
+        TypeKind.ULONGLONG: "c_ulonglong",
+        TypeKind.UINT128: "c_uint128",  # FIXME
+        TypeKind.CHAR_S: "c_char",  # char
+        TypeKind.SCHAR: "c_byte",  # signed char
+        TypeKind.WCHAR: "c_wchar",
+        TypeKind.SHORT: "c_short",
+        TypeKind.INT: "c_int",
+        TypeKind.LONG: "TBD",
+        TypeKind.LONGLONG: "c_longlong",
+        TypeKind.INT128: "c_int128",  # FIXME
+        TypeKind.FLOAT: "c_float",
+        TypeKind.DOUBLE: "c_double",
+        TypeKind.LONGDOUBLE: "c_longdouble",
+        TypeKind.POINTER: "POINTER_T",
+        TypeKind.NULLPTR: "c_void_p",
     }
 
     def __init__(self, flags):
         self.all = collections.OrderedDict()
         # a shortcut to identify registered decl in cases of records
         self.all_set = set()
         self.cpp_data = {}
         self._unhandled = []
         self.fields = {}
         self.tu = None
+        self.tu_options = None
         self.flags = flags
         self.ctypes_sizes = {}
         self.init_parsing_options()
         self.make_ctypes_convertor(flags)
         self.cursorkind_handler = cursorhandler.CursorHandler(self)
         self.typekind_handler = typehandler.TypeHandler(self)
         self.__filter_location = None
@@ -90,16 +98,15 @@
         """Activates the comment parsing options in the Translation Unit."""
         self.tu_options |= TranslationUnit.PARSE_INCLUDE_BRIEF_COMMENTS_IN_CODE_COMPLETION
 
     def deactivate_function_body_parsing(self):
         self.tu_options |= TranslationUnit.PARSE_SKIP_FUNCTION_BODIES
 
     def filter_location(self, src_files):
-        self.__filter_location = list(
-            map(lambda f: os.path.abspath(f), src_files))
+        self.__filter_location = [os.path.abspath(f) for f in src_files]
 
     def parse(self, filename):
         """
         . reads 1 file
         . if there is a compilation error, print a warning
         . get root cursor and recurse
         . for each STRUCT_DECL, register a new struct type
@@ -108,198 +115,201 @@
             - underlying type is cursor.type.get_declaration() for Record
         . for each VAR_DECL, register a Variable
         . for each TYPEREF ??
         """
         if os.path.abspath(filename) in self.__processed_location:
             return
         index = Index.create()
-        tu = index.parse(filename, self.flags, options=self.tu_options)
-        if not tu:
+        translation_unit = index.parse(filename, self.flags, options=self.tu_options)
+        if not translation_unit:
             log.warning("unable to load input")
             return
-        self._parse_tu_diagnostics(tu, filename)
-        self.tu = tu
+        self._parse_tu_diagnostics(translation_unit, filename)
+        self.tu = translation_unit
         root = self.tu.cursor
         for node in root.get_children():
-            self.startElement(node)
+            self.start_element(node)
         return
 
-    def parse_string(self, input_data, lang='c', all_warnings=False, flags=None):
+    def parse_string(self, input_data, lang="c", all_warnings=False, flags=None):
         """Use this parser on a memory string/file, instead of a file on disk"""
-        tu = util.get_tu(input_data, lang, all_warnings, flags)
-        self._parse_tu_diagnostics(tu, "memory_input.c")
-        self.tu = tu
+        translation_unit = util.get_tu(input_data, lang, all_warnings, flags)
+        self._parse_tu_diagnostics(translation_unit, "memory_input.c")
+        self.tu = translation_unit
         root = self.tu.cursor
         for node in root.get_children():
-            self.startElement(node)
-        return
+            self.start_element(node)
 
     @staticmethod
-    def _parse_tu_diagnostics(tu, input_filename):
-        if len(tu.diagnostics) == 0:
+    def _parse_tu_diagnostics(translation_unit, input_filename):
+        if len(translation_unit.diagnostics) == 0:
             return
         errors = []
-        for x in tu.diagnostics:
-            msg = "{} ({}:{}:{}) during processing {}".format(
-                x.spelling, x.location.file,
-                x.location.line, x.location.column, input_filename)
+        for diagnostic in translation_unit.diagnostics:
+            msg = (
+                f"{diagnostic.spelling} ({diagnostic.location.file}:{diagnostic.location.line}:"
+                f"{diagnostic.location.column}) during processing {input_filename}"
+            )
             log.warning(msg)
-            if x.severity > 2:
+            if diagnostic.severity > 2:
                 errors.append(msg)
         if len(errors) > 0:
             log.warning("Source code has %d error. Please fix.", len(errors))
             # code.interact(local=locals())
             raise InvalidTranslationUnitException(errors[0])
 
-    def startElement(self, node):
+    def start_element(self, node):
         """Recurses in children of this node"""
         if node is None:
-            return
+            return None
 
         if self.__filter_location is not None:
             # dont even parse includes.
             # FIXME: go back on dependencies ?
             if node.location.file is None:
-                return
+                return None
             filepath = os.path.abspath(node.location.file.name)
             if filepath not in self.__filter_location:
-                if not filepath.startswith('/usr'):
+                if not filepath.startswith("/usr"):
                     log.debug("skipping include '%s'", filepath)
-                return
+                return None
         # find and call the handler for this element
         log.debug(
-            '%s:%d: Found a %s|%s|%s',
+            "%s:%d: Found a %s|%s|%s",
             node.location.file,
             node.location.line,
             node.kind.name,
             node.displayname,
-            node.spelling)
+            node.spelling,
+        )
         # build stuff.
         try:
             stop_recurse = self.parse_cursor(node)
             if node.location.file is not None:
                 filepath = os.path.abspath(node.location.file.name)
                 self.__processed_location.add(filepath)
             # Signature of parse_cursor is:
             # if the fn returns True, do not recurse into children.
             # anything else will be ignored.
             if stop_recurse is not False:  # True:
-                return
+                return None
             # if fn returns something, if this element has children, treat
             # them.
             for child in node.get_children():
-                self.startElement(child)
+                self.start_element(child)
         except InvalidDefinitionError:
-            log.exception('Invalid definition')
+            log.exception("Invalid definition")
             # if the definition is invalid
-            pass
         # startElement returns None.
         return None
 
     def register(self, name, obj):
         """Registers an unique type description"""
         if (name, obj) in self.all_set:
-            log.debug('register: %s already defined: %s', name, obj.name)
+            log.debug("register: %s already defined: %s", name, obj.name)
             return self.all[name]
         if name in self.all:
-            if not isinstance(self.all[name], typedesc.Structure) or (
-                    self.all[name].members is not None):
+            if not isinstance(self.all[name], typedesc.Structure) or (self.all[name].members is not None):
                 # code.interact(local=locals())
                 raise DuplicateDefinitionException(
-                    'register: %s which has a previous incompatible definition: %s'
-                    '\ndefined here: %s'
-                    '\npreviously defined here: %s'
-                    % (name, obj.name, obj.location, self.all[name].location))
-            if isinstance(self.all[name], typedesc.Structure) and (
-                    self.all[name].members is None):
+                    f"register: {name} which has a previous incompatible definition: {obj.name}"
+                    f"\ndefined here: {obj.location}"
+                    f"\npreviously defined here: {self.all[name].location}"
+                )
+            if isinstance(self.all[name], typedesc.Structure) and (self.all[name].members is None):
                 return obj
-        log.debug('register: %s ', name)
+        log.debug("register: %s ", name)
         self.all[name] = obj
         self.all_set.add((name, obj))
         return obj
 
     def get_registered(self, name):
-        """Returns an registered type description"""
+        """Returns a registered type description"""
         return self.all[name]
 
     def is_registered(self, name):
         """Checks if a named type description is registered"""
         return name in self.all
 
     def remove_registered(self, name):
         """Removes a named type"""
-        log.debug('Unregister %s', name)
+        log.debug("Unregister %s", name)
         self.all_set.remove((name, self.all[name]))
         del self.all[name]
 
     def make_ctypes_convertor(self, _flags):
         """
         Fix clang types to ctypes conversion for this parsing instance.
         Some architecture dependent size types have to be changed if the target
         architecture is not the same as local
         """
         # NOTE: one could also use the __SIZEOF_x__ MACROs to obtain sizes.
-        tu = util.get_tu('''
+        translation_unit = util.get_tu(
+            """
 typedef short short_t;
 typedef int int_t;
 typedef long long_t;
 typedef long long longlong_t;
 typedef float float_t;
 typedef double double_t;
 typedef long double longdouble_t;
-typedef void* pointer_t;''', flags=_flags)
-        size = util.get_cursor(tu, 'short_t').type.get_size() * 8
-        self.ctypes_typename[TypeKind.SHORT] = 'c_int%d' % (size)
-        self.ctypes_typename[TypeKind.USHORT] = 'c_uint%d' % (size)
+typedef void* pointer_t;""",
+            flags=_flags,
+        )
+        size = util.get_cursor(translation_unit, "short_t").type.get_size() * 8
+        self.ctypes_typename[TypeKind.SHORT] = f"c_int{size:d}"
+        self.ctypes_typename[TypeKind.USHORT] = f"c_uint{size:d}"
         self.ctypes_sizes[TypeKind.SHORT] = size
         self.ctypes_sizes[TypeKind.USHORT] = size
 
-        size = util.get_cursor(tu, 'int_t').type.get_size() * 8
-        self.ctypes_typename[TypeKind.INT] = 'c_int%d' % (size)
-        self.ctypes_typename[TypeKind.UINT] = 'c_uint%d' % (size)
+        size = util.get_cursor(translation_unit, "int_t").type.get_size() * 8
+        self.ctypes_typename[TypeKind.INT] = f"c_int{size:d}"
+        self.ctypes_typename[TypeKind.UINT] = f"c_uint{size:d}"
         self.ctypes_sizes[TypeKind.INT] = size
         self.ctypes_sizes[TypeKind.UINT] = size
 
-        size = util.get_cursor(tu, 'long_t').type.get_size() * 8
-        self.ctypes_typename[TypeKind.LONG] = 'c_int%d' % (size)
-        self.ctypes_typename[TypeKind.ULONG] = 'c_uint%d' % (size)
+        size = util.get_cursor(translation_unit, "long_t").type.get_size() * 8
+        self.ctypes_typename[TypeKind.LONG] = f"c_int{size:d}"
+        self.ctypes_typename[TypeKind.ULONG] = f"c_uint{size:d}"
         self.ctypes_sizes[TypeKind.LONG] = size
         self.ctypes_sizes[TypeKind.ULONG] = size
 
-        size = util.get_cursor(tu, 'longlong_t').type.get_size() * 8
-        self.ctypes_typename[TypeKind.LONGLONG] = 'c_int%d' % (size)
-        self.ctypes_typename[TypeKind.ULONGLONG] = 'c_uint%d' % (size)
+        size = util.get_cursor(translation_unit, "longlong_t").type.get_size() * 8
+        self.ctypes_typename[TypeKind.LONGLONG] = f"c_int{size:d}"
+        self.ctypes_typename[TypeKind.ULONGLONG] = f"c_uint{size:d}"
         self.ctypes_sizes[TypeKind.LONGLONG] = size
         self.ctypes_sizes[TypeKind.ULONGLONG] = size
 
         # FIXME : Float && http://en.wikipedia.org/wiki/Long_double
-        size0 = util.get_cursor(tu, 'float_t').type.get_size() * 8
-        size1 = util.get_cursor(tu, 'double_t').type.get_size() * 8
-        size2 = util.get_cursor(tu, 'longdouble_t').type.get_size() * 8
+        size0 = util.get_cursor(translation_unit, "float_t").type.get_size() * 8
+        size1 = util.get_cursor(translation_unit, "double_t").type.get_size() * 8
+        size2 = util.get_cursor(translation_unit, "longdouble_t").type.get_size() * 8
         # 2014-01 stop generating crap.
         # 2015-01 reverse until better solution is found
-        # the idea is that a you cannot assume a c_double will be same format as a c_long_double.
+        # the idea is that you cannot assume a c_double will be same format as a c_long_double.
         # at least this pass size TU
         if size1 != size2:
-            self.ctypes_typename[TypeKind.LONGDOUBLE] = 'c_long_double_t'
+            self.ctypes_typename[TypeKind.LONGDOUBLE] = "c_long_double_t"
         else:
-            self.ctypes_typename[TypeKind.LONGDOUBLE] = 'c_double'
+            self.ctypes_typename[TypeKind.LONGDOUBLE] = "c_double"
 
         self.ctypes_sizes[TypeKind.FLOAT] = size0
         self.ctypes_sizes[TypeKind.DOUBLE] = size1
         self.ctypes_sizes[TypeKind.LONGDOUBLE] = size2
 
         # save the target pointer size.
-        size = util.get_cursor(tu, 'pointer_t').type.get_size() * 8
+        size = util.get_cursor(translation_unit, "pointer_t").type.get_size() * 8
         self.ctypes_sizes[TypeKind.POINTER] = size
         self.ctypes_sizes[TypeKind.NULLPTR] = size
 
-        log.debug('ARCH sizes: long:%s longdouble:%s',
-                  self.ctypes_typename[TypeKind.LONG],
-                  self.ctypes_typename[TypeKind.LONGDOUBLE])
+        log.debug(
+            "ARCH sizes: long:%s longdouble:%s",
+            self.ctypes_typename[TypeKind.LONG],
+            self.ctypes_typename[TypeKind.LONGDOUBLE],
+        )
         return
 
     def get_ctypes_name(self, typekind):
         return self.ctypes_typename[typekind]
 
     def get_ctypes_size(self, typekind):
         return self.ctypes_sizes[typekind]
@@ -318,82 +328,90 @@
 
     def get_macros(self, text):
         if text is None:
             return
         text = "".join(text)
         # preprocessor definitions that look like macros with one or more
         # arguments
-        for m in text.splitlines():
-            name, body = m.split(None, 1)
+        for macro in text.splitlines():
+            name, body = macro.split(None, 1)
             name, args = name.split("(", 1)
-            args = "(%s" % args
+            args = f"({args}"
             self.all[name] = typedesc.Macro(name, args, body)
 
     def get_aliases(self, text, namespace):
         if text is None:
             return
         # preprocessor definitions that look like aliases:
         #  #define A B
         text = "".join(text)
         aliases = {}
-        for a in text.splitlines():
-            name, value = a.split(None, 1)
-            a = typedesc.Alias(name, value)
-            aliases[name] = a
-            self.all[name] = a
+        for alias in text.splitlines():
+            name, value = alias.split(None, 1)
+            alias = typedesc.Alias(name, value)
+            aliases[name] = alias
+            self.all[name] = alias
 
-        for name, a in aliases.items():
-            value = a.alias
+        for name, alias in aliases.items():
+            value = alias.alias
             # the value should be either in namespace...
             if value in namespace:
                 # set the type
-                a.typ = namespace[value]
+                alias.typ = namespace[value]
             # or in aliases...
             elif value in aliases:
-                a.typ = aliases[value]
+                alias.typ = aliases[value]
             # or unknown.
             else:
                 # not known
                 # print "skip %s = %s" % (name, value)
                 pass
 
     def get_result(self):
         # all of these should register()
-        interesting = (typedesc.Typedef, typedesc.Enumeration, typedesc.EnumValue,
-                       typedesc.Function, typedesc.Structure, typedesc.Union,
-                       typedesc.Variable, typedesc.Macro, typedesc.Alias,
-                       typedesc.FunctionType)
+        interesting = (
+            typedesc.Typedef,
+            typedesc.Enumeration,
+            typedesc.EnumValue,
+            typedesc.Function,
+            typedesc.Structure,
+            typedesc.Union,
+            typedesc.Variable,
+            typedesc.Macro,
+            typedesc.Alias,
+            typedesc.FunctionType,
+        )
         # typedesc.Field) #???
 
         self.get_macros(self.cpp_data.get("functions"))
         # fix all objects after that all are resolved
         remove = []
         for _id, _item in self.all.items():
             if _item is None:
-                log.warning('ignoring %s', _id)
+                log.warning("ignoring %s", _id)
                 continue
             location = getattr(_item, "location", None)
             # FIXME , why do we get different location types
-            if location and hasattr(location, 'file'):
+            if location and hasattr(location, "file"):
                 _item.location = location.file.name, location.line
-                log.error('%s %s came in with a SourceLocation', _id, _item)
+                log.error("%s %s came in with a SourceLocation", _id, _item)
             elif location is None:
                 # FIXME make this optional to be able to see internals
                 # FIXME macro/alias are here
                 log.warning("No source location in %s - ignoring", _id)
                 remove.append(_id)
 
         for _x in remove:
             self.remove_registered(_x)
 
         # Now we can build the namespace.
         namespace = {}
         for i in self.all.values():
             if not isinstance(i, interesting):
-                log.debug('ignoring %s', i)
+                log.debug("ignoring %s", i)
                 continue  # we don't want these
             name = getattr(i, "name", None)
             if name is not None:
                 namespace[name] = i
         self.get_aliases(self.cpp_data.get("aliases"), namespace)
 
         result = []
```

## ctypeslib/codegen/codegenerator.py

```diff
@@ -1,8 +1,9 @@
-"""Create ctypes wrapper code for abstract type descriptions.
+"""
+Create ctypes wrapper code for abstract type descriptions.
 Type descriptions are collections of typedesc instances.
 """
 
 from __future__ import print_function
 from __future__ import unicode_literals
 
 import collections
@@ -1123,44 +1124,59 @@
                     todo.append(i)
                     continue
         self.filtered_items = todo
 
 
 # easy to use API.
 
-def translate(input_io, cfg=None):
+def translate(input_io, outfile=None, cfg=None):
     """
         Take a readable C like input readable and translate it to python.
     """
     cfg = cfg or config.CodegenConfig()
     translator = CodeTranslator(cfg)
     translator.preload_dlls()
     translator.parse_input_string(input_io)
     # gen python code
+    if outfile:
+        return translator.generate_code(outfile)
+    # otherwise return python
     output = io.StringIO()
     translator.generate_code(output)
     output.seek(0)
     # inject generated code in python namespace
     ignore_coding = output.readline()
     # exec ofi.getvalue() in namespace
     output = ''.join(output.readlines())
     namespace = {}
     exec(output, namespace)
     return util.ADict(namespace)
 
 
-def translate_files(source_files, outfile, cfg: config.CodegenConfig):
+def translate_files(source_files, outfile=None, cfg: config.CodegenConfig=None):
     """
     Translate the content of source_files in python code in outfile
 
     source_files: list of filenames or single filename
     """
+    cfg = cfg or config.CodegenConfig()
     translator = CodeTranslator(cfg)
     translator.preload_dlls()
     if isinstance(source_files, list):
         translator.parse_input_files(source_files)
     else:
         translator.parse_input_file(source_files)
     log.debug("Input was parsed")
-    translator.generate_code(outfile)
-    return
+    if outfile:
+        return translator.generate_code(outfile)
+    # otherwise return python
+    output = io.StringIO()
+    translator.generate_code(output)
+    output.seek(0)
+    # inject generated code in python namespace
+    ignore_coding = output.readline()
+    # exec ofi.getvalue() in namespace
+    output = ''.join(output.readlines())
+    namespace = {}
+    exec(output, namespace)
+    return util.ADict(namespace)
```

## ctypeslib/codegen/config.py

```diff
@@ -1,7 +1,10 @@
+"""
+The configuration class that will modify the behavior of ctypeslib
+"""
 import re
 
 from ctypeslib.library import Library
 from ctypeslib.codegen import typedesc
 
 
 class CodegenConfig:
@@ -13,15 +16,15 @@
     verbose: bool = False
     # include source doxygen-style comments
     generate_comments: bool = False
     # include docstrings containing C prototype and source file location
     generate_docstrings: bool = False
     # include source file location in comments
     generate_locations: bool = False
-    # do not include declaration defined outside of the source files
+    # do not include declaration defined outside the source files
     filter_location: bool = True
     # dll to be loaded before all others (to resolve symbols)
     preloaded_dlls: list = []
     # kind of type descriptions to include
     types: list = []
     # the host's triplet
     local_platform_triple: str = None
```

## ctypeslib/codegen/cursorhandler.py

```diff
@@ -1,15 +1,15 @@
 """Handler for Cursor nodes from the clang AST tree."""
 
 import logging
 import re
 
 from clang.cindex import CursorKind, LinkageKind, TypeKind, TokenKind
 
-from ctypeslib.codegen import typedesc
+from ctypeslib.codegen import typedesc, util
 from ctypeslib.codegen.handler import ClangHandler
 from ctypeslib.codegen.handler import CursorKindException
 from ctypeslib.codegen.handler import DuplicateDefinitionException
 from ctypeslib.codegen.handler import InvalidDefinitionError
 from ctypeslib.codegen.util import log_entity
 
 log = logging.getLogger('cursorhandler')
@@ -33,83 +33,83 @@
     def __init__(self, parser):
         ClangHandler.__init__(self, parser)
 
     def parse_cursor(self, cursor):
         mth = getattr(self, cursor.kind.name)
         return mth(cursor)
 
-        ##########################################################################
-        ##### CursorKind handlers#######
-        ##########################################################################
-
-        ###########################################
-        # ATTRIBUTES
-
-        # @log_entity
-        # def UNEXPOSED_ATTR(self, cursor):
-        # FIXME: do we do something with these ?
-        # parent = cursor.semantic_parent
-        # print 'parent is',parent.displayname, parent.location, parent.extent
-        # TODO until attr is exposed by clang:
-        # readlines()[extent] .split(' ') | grep {inline,packed}
-        #    return
-
-        # @log_entity
-        # def PACKED_ATTR(self, cursor):
-        # FIXME: do we do something with these ?
-        # parent = cursor.semantic_parent
-        # print 'parent is',parent.displayname, parent.location, parent.extent
-        # TODO until attr is exposed by clang:
-        # readlines()[extent] .split(' ') | grep {inline,packed}
+    ##########################################################################
+    ##### CursorKind handlers#######
+    ##########################################################################
+
+    ###########################################
+    # ATTRIBUTES
+
+    # @log_entity
+    # def UNEXPOSED_ATTR(self, cursor):
+    # FIXME: do we do something with these ?
+    # parent = cursor.semantic_parent
+    # print 'parent is',parent.displayname, parent.location, parent.extent
+    # TODO until attr is exposed by clang:
+    # readlines()[extent] .split(' ') | grep {inline,packed}
+    #    return
+
+    # @log_entity
+    # def PACKED_ATTR(self, cursor):
+    # FIXME: do we do something with these ?
+    # parent = cursor.semantic_parent
+    # print 'parent is',parent.displayname, parent.location, parent.extent
+    # TODO until attr is exposed by clang:
+    # readlines()[extent] .split(' ') | grep {inline,packed}
 
     #    return
 
     ################################
     # EXPRESSIONS handlers
 
     # clang does not expose some types for some expression.
-    # Example: the type of a token group in a Char_s or char variable.
-    # Counter example: The type of an integer literal to a (int) variable.
+    # Example: the type of token group in a Char_s or char variable.
+    # Counter example: The type of integer literal to a (int) variable.
     @log_entity
-    def UNEXPOSED_EXPR(self, cursor):
+    def UNEXPOSED_EXPR(self, cursor):  # noqa
         ret = []
         for child in cursor.get_children():
             ret.append(self.parse_cursor(child))
         if len(ret) == 1:
             return ret[0]
         return ret
 
     @log_entity
-    def DECL_REF_EXPR(self, cursor):
+    def DECL_REF_EXPR(self, cursor):  # noqa
         return cursor.displayname
 
     @log_entity
-    def INIT_LIST_EXPR(self, cursor):
+    def INIT_LIST_EXPR(self, cursor):  # noqa
         """Returns a list of literal values."""
         values = [self.parse_cursor(child)
                   for child in list(cursor.get_children())]
         return values
 
     ################################
     # STATEMENTS handlers
 
     # Do not traverse into function bodies and other compound statements
     # now fixed by TranslationUnit.PARSE_SKIP_FUNCTION_BODIES
     COMPOUND_STMT = ClangHandler._do_nothing
 
     @log_entity
-    def NAMESPACE(self, cursor):
+    def NAMESPACE(self, cursor):  # noqa
         for child in cursor.get_children():
             self.parse_cursor(child)  # FIXME, where is the starElement
 
     ################################
     # TYPE REFERENCES handlers
 
     @log_entity
-    def TYPE_REF(self, cursor):
+    def TYPE_REF(self, cursor):  # noqa
         name = self.get_unique_name(cursor)
         if self.is_registered(name):
             return self.get_registered(name)
         # log.warning('TYPE_REF with no saved decl in self.all')
         # return None
         # Should probably never get here.
         # I'm a field. ?
@@ -131,26 +131,26 @@
 
     NO_DECL_FOUND = ClangHandler._do_nothing
 
     UNEXPOSED_DECL = ClangHandler._pass_through_children
     """Undexposed declaration. Go and see children. """
 
     @log_entity
-    def ENUM_CONSTANT_DECL(self, cursor):
+    def ENUM_CONSTANT_DECL(self, cursor):  # noqa
         """Gets the enumeration values"""
         name = cursor.displayname
         value = cursor.enum_value
         pname = self.get_unique_name(cursor.semantic_parent)
         parent = self.get_registered(pname)
         obj = typedesc.EnumValue(name, value, parent)
         parent.add_value(obj)
         return obj
 
     @log_entity
-    def ENUM_DECL(self, cursor):
+    def ENUM_DECL(self, cursor):  # noqa
         """Gets the enumeration declaration."""
         name = self.get_unique_name(cursor)
         if self.is_registered(name):
             return self.get_registered(name)
         align = cursor.type.get_align()
         size = cursor.type.get_size()
         obj = self.register(name, typedesc.Enumeration(name, size, align))
@@ -158,15 +158,15 @@
         self.set_comment(obj, cursor)
         # parse all children
         for child in cursor.get_children():
             self.parse_cursor(child)  # FIXME, where is the starElement
         return obj
 
     @log_entity
-    def FUNCTION_DECL(self, cursor):
+    def FUNCTION_DECL(self, cursor):  # noqa
         """Handles function declaration"""
         # FIXME to UT
         name = self.get_unique_name(cursor)
         if self.is_registered(name):
             return self.get_registered(name)
         returns = self.parse_cursor_type(cursor.type.get_result())
         attributes = []
@@ -180,15 +180,15 @@
         # code.interact(local=locals())
         self.register(name, obj)
         self.set_location(obj, cursor)
         self.set_comment(obj, cursor)
         return obj
 
     @log_entity
-    def PARM_DECL(self, cursor):
+    def PARM_DECL(self, cursor):  # noqa
         """Handles parameter declarations."""
         # try and get the type. If unexposed, The canonical type will work.
         _type = cursor.type
         _name = cursor.spelling
         if (self.is_array_type(_type) or
                 self.is_fundamental_type(_type) or
                 self.is_pointer_type(_type) or
@@ -204,15 +204,15 @@
                 _argtype = self.get_registered(_argtype_name)
         obj = typedesc.Argument(_name, _argtype)
         self.set_location(obj, cursor)
         self.set_comment(obj, cursor)
         return obj
 
     @log_entity
-    def TYPEDEF_DECL(self, cursor):
+    def TYPEDEF_DECL(self, cursor):  # noqa
         """
         Handles typedef statements.
         Gets Type from cache if we known it. Add it to cache otherwise.
         # typedef of an enum
         """
         name = self.get_unique_name(cursor)
         # if the typedef is known, get it from cache
@@ -229,23 +229,23 @@
             log.error(
                 'Bad TYPEREF parsing in TYPEDEF_DECL: %s',
                 _type.spelling)
             # import code
             # code.interact(local=locals())
             raise TypeError(
                 'Bad TYPEREF parsing in TYPEDEF_DECL: %s' %
-                (_type.spelling))
+                _type.spelling)
         # register the type
         obj = self.register(name, typedesc.Typedef(name, p_type))
         self.set_location(obj, cursor)
         self.set_comment(obj, cursor)
         return obj
 
     @log_entity
-    def VAR_DECL(self, cursor):
+    def VAR_DECL(self, cursor):  # noqa
         """Handles Variable declaration."""
         # get the name
         name = self.get_unique_name(cursor)
         log.debug('VAR_DECL: name: %s', name)
         # Check for a previous declaration in the register
         if self.is_registered(name):
             return self.get_registered(name)
@@ -258,78 +258,78 @@
         log.debug('VAR_DECL: _init:%s', init_value)
         log.debug('VAR_DECL: location:%s', getattr(cursor, 'location'))
         obj = self.register(name, typedesc.Variable(name, _type, init_value, extern))
         self.set_location(obj, cursor)
         self.set_comment(obj, cursor)
         return True
 
-    def _VAR_DECL_type(self, cursor):
+    def _VAR_DECL_type(self, cursor):  # noqa
         """Generates a typedesc object from a Variable declaration."""
         # Get the type
         _ctype = cursor.type.get_canonical()
-        extern = cursor.linkage in (LinkageKind.EXTERNAL, LinkageKind.UNIQUE_EXTERNAL)
+        extern = cursor.linkage in (LinkageKind.EXTERNAL, LinkageKind.UNIQUE_EXTERNAL)  # noqa
         log.debug('VAR_DECL: _ctype: %s ', _ctype.kind)
         # FIXME: Need working int128, long_double, etc.
         if self.is_fundamental_type(_ctype):
             ctypesname = self.get_ctypes_name(_ctype.kind)
             _type = typedesc.FundamentalType(ctypesname, 0, 0)
         elif self.is_unexposed_type(_ctype):
             st = 'PATCH NEEDED: %s type is not exposed by clang' % (
                 self.get_unique_name(cursor))
             log.error(st)
             raise RuntimeError(st)
-        elif self.is_array_type(_ctype) or _ctype.kind == TypeKind.RECORD:
+        elif self.is_array_type(_ctype) or _ctype.kind == TypeKind.RECORD:  # noqa
             _type = self.parse_cursor_type(_ctype)
         elif self.is_pointer_type(_ctype):
             # for example, extern Function pointer
             if self.is_unexposed_type(_ctype.get_pointee()):
                 _type = self.parse_cursor_type(
                     _ctype.get_canonical().get_pointee())
-            elif _ctype.get_pointee().kind == TypeKind.FUNCTIONPROTO:
+            elif _ctype.get_pointee().kind == TypeKind.FUNCTIONPROTO:  # noqa
                 # Function pointers
                 # Arguments are handled in here
                 _type = self.parse_cursor_type(_ctype.get_pointee())
             else:  # Pointer to Fundamental types, structs....
                 _type = self.parse_cursor_type(_ctype)
         else:
             # What else ?
             raise NotImplementedError(
                 'What other type of variable? %s' %
-                (_ctype.kind))
+                _ctype.kind)
         log.debug('VAR_DECL: _type: %s ', _type)
         return _type, extern
 
-    def _VAR_DECL_value(self, cursor, _type):
+    def _VAR_DECL_value(self, cursor, _type):  # noqa
         """Handles Variable value initialization."""
         # always expect list [(k,v)] as init value.from list(cursor.get_children())
         # get the init_value and special cases
         init_value = self._get_var_decl_init_value(cursor.type,
                                                    list(cursor.get_children()))
         _ctype = cursor.type.get_canonical()
         if self.is_unexposed_type(_ctype):
             # string are not exposed
-            init_value = '%s # UNEXPOSED TYPE. PATCH NEEDED.' % (init_value)
+            init_value = '%s # UNEXPOSED TYPE. PATCH NEEDED.' % init_value
         elif (self.is_pointer_type(_ctype) and
-                      _ctype.get_pointee().kind == TypeKind.FUNCTIONPROTO):
+                      _ctype.get_pointee().kind == TypeKind.FUNCTIONPROTO):  # noqa
             # Function pointers argument are handled at type creation time
             # but we need to put a CFUNCTYPE as a value of the name variable
             init_value = _type
         elif self.is_array_type(_ctype):
             # an integer literal will be the size
             # a string literal will be the value
             # any list member will be children of a init_list_expr
             # FIXME Move that code into typedesc
-            def countof(k, l):
-                return [item[0] for item in l].count(k)
+            def countof(k, _value):
+                return [item[0] for item in _value].count(k)
 
-            if countof(CursorKind.INIT_LIST_EXPR, init_value) == 1:
-                init_value = dict(init_value)[CursorKind.INIT_LIST_EXPR]
-            elif countof(CursorKind.STRING_LITERAL, init_value) == 1:
+            if countof(CursorKind.INIT_LIST_EXPR, init_value) == 1:  # noqa
+                init_value = dict(init_value)[CursorKind.INIT_LIST_EXPR]  # noqa
+            elif countof(CursorKind.STRING_LITERAL, init_value) == 1:  # noqa
                 # we have a initialised c_array
-                init_value = dict(init_value)[CursorKind.STRING_LITERAL]
+                init_value = dict(init_value)[CursorKind.STRING_LITERAL]  # noqa
             else:
                 # ignore size alone
                 init_value = []
             # check the array size versus elements.
             if _type.size < len(init_value):
                 _type.size = len(init_value)
         elif init_value == []:
@@ -376,15 +376,15 @@
         log.debug(
             '_get_var_decl_init_value_single: _ctype: %s Child.kind: %s',
             _ctype.kind,
             child.kind)
         # shorcuts.
         if not child.kind.is_expression() and not child.kind.is_declaration():
             raise CursorKindException(child.kind)
-        if child.kind == CursorKind.CALL_EXPR:
+        if child.kind == CursorKind.CALL_EXPR:  # noqa
             raise CursorKindException(child.kind)
         # POD init values handling.
         # As of clang 3.3, int, double literals are exposed.
         # float, long double, char , char* are not exposed directly in level1.
         # but really it depends...
         if child.kind.is_unexposed():
             # recurse until we find a literal kind
@@ -397,46 +397,46 @@
                 log.error('_get_var_decl_init_value_single: Unhandled case')
                 assert len(init_value) <= 1
         # elif child.kind == CursorKind.STRING_LITERAL:
         #     _v = self._literal_handling(child)
         #     init_value = (child.kind, _v)
         else:  # literal or others
             _v = self.parse_cursor(child)
-            if isinstance(_v, list) and len(_v) > 0 and child.kind not in [CursorKind.INIT_LIST_EXPR, CursorKind.STRING_LITERAL]:
+            if isinstance(_v, list) and len(_v) > 0 and child.kind not in [CursorKind.INIT_LIST_EXPR, CursorKind.STRING_LITERAL]:  # noqa
                 log.warning('_get_var_decl_init_value_single: TOKENIZATION BUG CHECK: %s', _v)
                 _v = _v[0]
             init_value = (child.kind, _v)
         log.debug('_get_var_decl_init_value_single: returns %s', str(init_value))
         return init_value
 
     def _clean_string_literal(self, cursor, value):
         # strip wchar_t type prefix for string/character
         # indicatively: u8 for utf-8, u for utf-16, U for utf32
         # assume that the source file is utf-8
         # utf-32 not supported in 2.7, lets keep all in utf8
         # string prefixes https://en.cppreference.com/w/cpp/language/string_literal
         # integer suffixes https://en.cppreference.com/w/cpp/language/integer_literal
-        if cursor.kind in [CursorKind.CHARACTER_LITERAL, CursorKind.STRING_LITERAL]:
+        if cursor.kind in [CursorKind.CHARACTER_LITERAL, CursorKind.STRING_LITERAL]:  # noqa
             # clean prefix
             value = re.sub(r'''^(L|u8|u|U)(R|"|')''', r'\2', value)
             # R for raw strings
             # we need to remove the raw-char-sequence prefix,suffix
             if value[0] == 'R':
                 s = value[1:]
                 # if there is no '(' in the 17 first char, its not valid
                 offset = s[:17].index('(')
                 delimiter = s[1:offset] # we skip the "
                 value = s[offset + 1:-offset - 1]
                 return value
             # we strip string delimiters
             return value[1:-1]
-        elif cursor.kind == CursorKind.MACRO_INSTANTIATION:
+        elif cursor.kind == CursorKind.MACRO_INSTANTIATION:  # noqa
             # prefix = value[:3].split('"')[0]
             return value
-        elif cursor.kind == CursorKind.MACRO_DEFINITION:
+        elif cursor.kind == CursorKind.MACRO_DEFINITION:  # noqa
             c = value[-1]
             if c in ['"', "'"]:
                 value = re.sub('''^L%s''' % c , c, value)
             else:
                 # unsigned int / long int / unsigned long int / long long int / unsigned long long int
                 # this works and doesn't eat STRING values because no '"' is before $ in the regexp.
                 # FIXME combinaisons of u/U, l/L, ll/LL, and combined, plus z/Z combined with u/U
@@ -455,41 +455,51 @@
         We can't use a shortcut by getting tokens
             # init_value = ' '.join([t.spelling for t in children[0].get_tokens()
             # if t.spelling != ';'])
         because some literal might need cleaning."""
         # FIXME #77, internal integer literal like __clang_major__ are not working here.
         # tokens == [] , because ??? clang problem ? so there is no spelling available.
         tokens = list(cursor.get_tokens())
+        if cursor.kind == CursorKind.INTEGER_LITERAL and len(tokens) == 0:
+            log.warning("INTEGER_LITERAL - clang provides no value - bug #77")
+            # https://stackoverflow.com/questions/10692015/libclang-get-primitive-value
+            # cursor.data[1] ?
+            # import clang
+            # # clang.cindex.conf.lib.clang_Cursor_Evaluate.restype = clang.cindex.conf.lib.CXEvalResult
+            # evaluated = clang.cindex.conf.lib.clang_Cursor_Evaluate(cursor)
+            # value = clang.cindex.conf.lib.clang_EvalResult_getAsInt(evaluated)
+            # clang.cindex.conf.lib.clang_EvalResult_dispose(evaluated)
+
         log.debug('literal has %d tokens.[ %s ]', len(tokens), ' '.join([str(t.spelling) for t in tokens]))
-        if len(tokens) == 1 and cursor.kind == CursorKind.STRING_LITERAL:
+        if len(tokens) == 1 and cursor.kind == CursorKind.STRING_LITERAL:  # noqa
             # use a shortcut that works for unicode
             value = tokens[0].spelling
             value = self._clean_string_literal(cursor, value)
             return value
-        elif cursor.kind == CursorKind.STRING_LITERAL:
+        elif cursor.kind == CursorKind.STRING_LITERAL:  # noqa
             # use a shortcut - does not work on unicode var_decl
             value = cursor.displayname
             value = self._clean_string_literal(cursor, value)
             return value
         final_value = []
         # code.interact(local=locals())
         log.debug('cursor.type:%s', cursor.type.kind.name)
         for i, token in enumerate(tokens):
             value = token.spelling
             log.debug('token:%s tk.kd:%11s tk.cursor.kd:%15s cursor.kd:%15s',
                       token.spelling, token.kind.name, token.cursor.kind.name,
                       cursor.kind.name)
             # Punctuation is probably not part of the init_value,
             # but only in specific case: ';' endl, or part of list_expr
-            if (token.kind == TokenKind.PUNCTUATION and
-                    (token.cursor.kind == CursorKind.INVALID_FILE or
-                             token.cursor.kind == CursorKind.INIT_LIST_EXPR)):
+            if (token.kind == TokenKind.PUNCTUATION and  # noqa
+                    (token.cursor.kind == CursorKind.INVALID_FILE or  # noqa
+                             token.cursor.kind == CursorKind.INIT_LIST_EXPR)):  # noqa
                 log.debug('IGNORE token %s', value)
                 continue
-            elif token.kind == TokenKind.COMMENT:
+            elif token.kind == TokenKind.COMMENT:  # noqa
                 log.debug('Ignore comment %s', value)
                 continue
             # elif token.cursor.kind == CursorKind.VAR_DECL:
             elif token.location not in cursor.extent:
                 # log.debug('FIXME BUG: token.location not in cursor.extent %s', value)
                 # 2021 clang 11, this seems fixed ?
                 # there is most probably a BUG in clang or python-clang
@@ -500,71 +510,71 @@
                 #   extern int i;
                 # // this will give "extern" the last token of Macro("A")
                 # Lexer is choking ?
                 # FIXME BUG: token.location not in cursor.extent
                 # code.interact(local=locals())
                 continue
             # Cleanup specific c-lang or c++ prefix/suffix for POD types.
-            if token.cursor.kind == CursorKind.INTEGER_LITERAL:
+            if token.cursor.kind == CursorKind.INTEGER_LITERAL:  # noqa
                 # strip type suffix for constants
                 value = value.replace('L', '').replace('U', '')
                 value = value.replace('l', '').replace('u', '')
                 if value[:2] == '0x' or value[:2] == '0X':
                     value = '0x%s' % value[2:]  # "int(%s,16)"%(value)
                 else:
                     value = int(value)
-            elif token.cursor.kind == CursorKind.FLOATING_LITERAL:
+            elif token.cursor.kind == CursorKind.FLOATING_LITERAL:  # noqa
                 # strip type suffix for constants
                 value = value.replace('f', '').replace('F', '')
                 value = float(value)
-            elif (token.cursor.kind == CursorKind.CHARACTER_LITERAL or
-                          token.cursor.kind == CursorKind.STRING_LITERAL):
+            elif (token.cursor.kind == CursorKind.CHARACTER_LITERAL or  # noqa
+                          token.cursor.kind == CursorKind.STRING_LITERAL):  # noqa
                 value = self._clean_string_literal(token.cursor, value)
-            elif token.cursor.kind == CursorKind.MACRO_INSTANTIATION:
+            elif token.cursor.kind == CursorKind.MACRO_INSTANTIATION:  # noqa
                 # get the macro value
                 value = self.get_registered(value).body
                 # already cleaned value = self._clean_string_literal(token.cursor, value)
-            elif token.cursor.kind == CursorKind.MACRO_DEFINITION:
+            elif token.cursor.kind == CursorKind.MACRO_DEFINITION:  # noqa
                 tk = token.kind
                 if i == 0:
                     # ignore, macro name
                     pass
-                elif token.kind == TokenKind.LITERAL:
+                elif token.kind == TokenKind.LITERAL:  # noqa
                     # and just clean it
                     value = self._clean_string_literal(token.cursor, value)
-                elif token.kind == TokenKind.IDENTIFIER:
+                elif token.kind == TokenKind.IDENTIFIER:  # noqa
                     # log.debug("Ignored MACRO_DEFINITION token identifier : %s", value)
                     # Identifier in Macro... Not sure what to do with that.
                     if self.is_registered(value):
                         # FIXME: if Macro is not a simple value replace, it should not be registered in the first place
                         # parse that, try to see if there is another Macro in there.
                         value = self.get_registered(value).body
                         log.debug("Found MACRO_DEFINITION token identifier : %s", value)
                     else:
                         value = typedesc.UndefinedIdentifier(value)
                         log.debug("Undefined MACRO_DEFINITION token identifier : %s", value)
                     pass
-                elif token.kind == TokenKind.KEYWORD:
+                elif token.kind == TokenKind.KEYWORD:  # noqa
                     log.debug("Got a MACRO_DEFINITION referencing a KEYWORD token.kind: %s", token.kind.name)
                     value = typedesc.UndefinedIdentifier(value)
-                elif token.kind in [TokenKind.COMMENT, TokenKind.PUNCTUATION]:
+                elif token.kind in [TokenKind.COMMENT, TokenKind.PUNCTUATION]:  # noqa
                     # log.debug("Ignored MACRO_DEFINITION token.kind: %s", token.kind.name)
                     pass
 
             # add token
             if value is not None:
                 final_value.append(value)
         # return the EXPR
         # code.interact(local=locals())
         # FIXME, that will break. We need constant type return
         if len(final_value) == 1:
             return final_value[0]
         # Macro definition of a string using multiple macro
         if isinstance(final_value, list):
-            if cursor.kind == CursorKind.STRING_LITERAL:
+            if cursor.kind == CursorKind.STRING_LITERAL:  # noqa
                 final_value = ''.join(final_value)
         log.debug('_literal_handling final_value: %s', final_value)
         return final_value
 
     INTEGER_LITERAL = _literal_handling
     FLOATING_LITERAL = _literal_handling
     IMAGINARY_LITERAL = _literal_handling
@@ -573,25 +583,25 @@
 
     @log_entity
     def _operator_handling(self, cursor):
         """Returns a string with the literal that are part of the operation."""
         values = self._literal_handling(cursor)
         retval = ''.join([str(val) for val in values])
         log.debug('cursor.type.kind:%s', cursor.type.kind.name)
-        if cursor.kind == CursorKind.UNARY_OPERATOR:
-            if cursor.type.kind in [TypeKind.INT, TypeKind.LONG]:
+        if cursor.kind == CursorKind.UNARY_OPERATOR:  # noqa
+            if cursor.type.kind in [TypeKind.INT, TypeKind.LONG]:  # noqa
                 if '0x' in retval:
                     retval = int(retval, 16)
                 else:
                     try:
                         retval = int(retval)
                     except ValueError:
                         # fall back on pass through
                         pass
-            elif cursor.type.kind in [TypeKind.FLOAT, TypeKind.DOUBLE]:
+            elif cursor.type.kind in [TypeKind.FLOAT, TypeKind.DOUBLE]:  # noqa
                 retval = float(retval)
         # Things we do not want to do:
         # elif cursor.kind == CursorKind.BINARY_OPERATOR:
         #     # cursor.kind == binary_operator, then need to make some additions
         #     retval = eval(retval)
 
         return retval
@@ -631,15 +641,15 @@
             log.debug(
                 '_record_decl: %s is already registered with members',
                 name)
             return self.get_registered(name)
         # CPP bases
         bases = []
         for c in cursor.get_children():
-            if c.kind == CursorKind.CXX_BASE_SPECIFIER:
+            if c.kind == CursorKind.CXX_BASE_SPECIFIER:  # noqa
                 bases.append(self.get_registered(self.get_unique_name(c)))
                 log.debug("got base class %s", c.displayname)
         size = cursor.type.get_size()
         align = cursor.type.get_align()
         if size == -2: #
             # CXTypeLayoutError_Incomplete = -2
             # produce an empty structure declaration
@@ -701,15 +711,15 @@
         #
         # check for other stuff
         for child in cursor.get_children():
             if child in fields:
                 continue
             elif child in decl_f:
                 continue
-            elif child.kind == CursorKind.PACKED_ATTR:
+            elif child.kind == CursorKind.PACKED_ATTR:  # noqa
                 obj.packed = True
                 log.debug('PACKED record')
                 continue  # dont mess with field calculations
             else:  # could be others.... struct_decl, etc...
                 log.debug(
                     'Unhandled field %s in record %s',
                     child.kind, name)
@@ -932,24 +942,24 @@
             members.append(padding)
             return padding_nb
         elif length > 8:
             pad_bytes = length // 8
             padding = typedesc.Field(name,
                                      typedesc.ArrayType(
                                          typedesc.FundamentalType(
-                                             self.get_ctypes_name(TypeKind.CHAR_U), length, 1),
+                                             self.get_ctypes_name(TypeKind.CHAR_U), length, 1),  # noqa
                                          pad_bytes),
                                      offset, length, is_padding=True)
             members.append(padding)
             return padding_nb
         # simple char padding
         padding = typedesc.Field(name,
                                  typedesc.FundamentalType(
                                      self.get_ctypes_name(
-                                         TypeKind.CHAR_U),
+                                         TypeKind.CHAR_U),  # noqa
                                      1,
                                      1),
                                  offset, length, is_padding=True)
         members.append(padding)
         return padding_nb
 
     # FIXME
@@ -969,28 +979,29 @@
         # we do NOT rely on get_unique_name for a bitfield name.
         # Anonymous Field:
         #    We have to create a name
         #    it will be the indice of the field (_0,_1,...)
         # offset of field:
         #    we will need it late. get the offset of the field in the record
         # Note: cursor.is_anonymous seems to be unreliable/inconsistent across
-        # libclang versions so we will consider the field as anonymous if
+        # libclang versions, and we will consider the field as anonymous if
         # cursor.spelling is empty
         name = cursor.spelling
         offset = parent.type.get_offset(name)
         if not name and cursor.is_anonymous() and not cursor.is_bitfield():
             # anonymous type, that is not a bitfield field case:
             offset = cursor.get_field_offsetof()
             # name = self.get_unique_name(cursor)
             # we want to keep name empty if the field is unnamed.
         elif not name:
             # anonymous bitfield case:
             # get offset by iterating all fields of parent
             # corner case for anonymous fields
             # if offset == -5: use field.get_offset_of()
+            fieldnum = 0
             offset = cursor.get_field_offsetof()
             for i, _f in enumerate(parent.type.get_fields()):
                 if _f == cursor:
                     fieldnum = i
                     break
             # make a name
             if fieldnum == -1:
@@ -1026,15 +1037,15 @@
                 self.is_fundamental_type(_canonical_type) or
                 self.is_pointer_type(_canonical_type)):
             _type = self.parse_cursor_type(_canonical_type)
         else:
             children = list(cursor.get_children())
             log.debug('FIELD_DECL: we now look for the declaration name.'
                       'kind %s', _decl.kind)
-            if len(children) > 0 and _decl.kind == CursorKind.NO_DECL_FOUND:
+            if len(children) > 0 and _decl.kind == CursorKind.NO_DECL_FOUND:  # noqa
                 # constantarray of typedef of pointer , and other cases ?
                 _decl_name = self.get_unique_name(
                     list(
                         cursor.get_children())[0])
             else:
                 # pass a field name to get a better name for an anonymous record, that is a named field
                 _decl_name = self.get_unique_name(_decl, field_name=name)
@@ -1109,33 +1120,37 @@
             # elif len(tokens) == 2:
             if len(tokens) == 2:
                 # #define key value
                 value = tokens[1]
             elif len(tokens) == 3 and tokens[1] == '-':
                 value = ''.join(tokens[1:])
             elif tokens[1] == '(':
-                # TODO, differentiate between function-like macro and expression in ()
-                # function macro or an expression.
-                str_tokens = [str(_) for _ in tokens[1:tokens.index(')')+1]]
-                args = ''.join(str_tokens).replace(',', ', ')
-                str_tokens = [str(_) for _ in tokens[tokens.index(')')+1:]]
-                value = ''.join(str_tokens)
+                # #107, differentiate between function-like macro and expression in ()
+                # valid tokens for us are are '()[0-9],.e' and terminating LluU
+                if any(filter(lambda x: isinstance(x, typedesc.UndefinedIdentifier), tokens)):
+                    # function macro or an expression.
+                    str_tokens = [str(_) for _ in tokens[1:tokens.index(')')+1]]
+                    args = ''.join(str_tokens).replace(',', ', ')
+                    str_tokens = [str(_) for _ in tokens[tokens.index(')')+1:]]
+                    value = ''.join(str_tokens)
+                else:
+                    value = ''.join((str(_) for _ in tokens[1:tokens.index(')') + 1]))
             elif len(tokens) > 2:
                 # #define key a b c
                 value = list(tokens[1:])
             else:
                 # FIXME no reach ?!
                 # just merge the list of tokens
                 value = ' '.join(tokens[1:])
         elif isinstance(tokens, str):
             # #define only
             value = True
         # macro comment maybe in tokens. Not in cursor.raw_comment
         for t in cursor.get_tokens():
-            if t.kind == TokenKind.COMMENT:
+            if t.kind == TokenKind.COMMENT:  ## noqa
                 comment = t.spelling
         # special case. internal __null or __thread
         # FIXME, there are probable a lot of others.
         # why not Cursor.kind GNU_NULL_EXPR child instead of a token ?
         if name in ['NULL', '__thread'] or value in ['__null', '__thread']:
             value = None
         log.debug('MACRO: #define %s%s %s', name, args or '', value)
```

## ctypeslib/codegen/handler.py

```diff
@@ -217,15 +217,15 @@
 
     ################################
     # do-nothing element handlers
 
     @log_entity
     def _pass_through_children(self, node, **args):
         for child in node.get_children():
-            self.parser.startElement(child)
+            self.parser.start_element(child)
         return True
 
     def _do_nothing(self, node, **args):
         name = self.get_unique_name(node)
         #import code
         # code.interact(local=locals())
         log.warning('_do_nothing for %s/%s',node.kind.name, name)
```

## ctypeslib/codegen/util.py

```diff
@@ -191,8 +191,9 @@
 
 
 __all__ = [
     'get_cursor',
     'get_cursors',
     'get_tu',
     'from_c_float_literal',
+    'log_entity'
 ]
```

## Comparing `ctypeslib2-2.3.3.dist-info/LICENSE.txt` & `ctypeslib2-2.3.4.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `ctypeslib2-2.3.3.dist-info/METADATA` & `ctypeslib2-2.3.4.dist-info/METADATA`

 * *Files 13% similar despite different names*

```diff
@@ -1,16 +1,15 @@
 Metadata-Version: 2.1
 Name: ctypeslib2
-Version: 2.3.3
+Version: 2.3.4
 Summary: ctypeslib2 - FFI toolkit, relies on clang
-Home-page: https://github.com/trolldbois/ctypeslib
-Download-URL: https://github.com/trolldbois/ctypeslib/releases
-Author: Loic Jaquemet
-Author-email: loic.jaquemet+python@gmail.com
+Author-email: Loic Jaquemet <loic.jaquemet+python@gmail.com>
 License: License :: OSI Approved :: MIT License
+Project-URL: Homepage, https://github.com/trolldbois/ctypeslib
+Project-URL: Download, https://github.com/trolldbois/ctypeslib/releases
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
@@ -29,59 +28,109 @@
 ![PyPI](https://img.shields.io/pypi/v/ctypeslib)
 ![Python](https://img.shields.io/pypi/pyversions/ctypeslib)
 
 [Quick usage guide](docs/ctypeslib_2.0_Introduction.ipynb) in the docs/ folder.
 
 ## Status update
 
+ - 2023-04:
+   - Please read the installation instructions
  - 2021-02:
-    - Thanks for the pull requests
-    - Note: libclang-xx-dev must be installed for stddef and other reasons.
-    - bump to libclang-11
+   - Thanks for the pull requests
+   - Note: libclang-xx-dev must be installed for stddef and other reasons.
+   - bump to libclang-11
  - 2018-01-03: master branch works with libclang-5.0 HEAD, python clang from pypi, python3
  - 2017-05-01: master branch works with libclang-4.0 HEAD
 
 ## Installation
 
-On Ubuntu, libclang libraries are installed with versions.
-This library tries to load a few different versions to help you out. (`__init__.py`)
-But if you encounter a version compatibility issue, you might have to fix the problem
-using one of the following solutions:
-
-1. Install libclang-11-dev to get libclang.so (maybe)
-2. OR create a link to libclang-11.so.1 named libclang.so
-3. OR hardcode a call to clang.cindex.Config.load_library_file('libclang-10.so.1') in your code
+### LLVM Clang library
+First, you should install LLVM clang.
+See the LLVM Clang instructions at http://apt.llvm.org/ or use your distribution's packages.
 
+Either use an installer relevant for your OS (APT, downloads, etc..) to install libclang 
+```
+$ sudo apt install libclang1-11
+```
+
+or you can use the LLVM install script that installs the whole llvm toolkit 
+```
+ wget https://apt.llvm.org/llvm.sh && chmod +x llvm.sh
+ # then install llvm version 16 
+ ./llvm.sh 16
+ # or version 11 or any other version
+ ./llvm.sh 11
+```
+or you can use anaconda, or any local installation of your favorite choice
 
-### Pypi
+### ctypeslib and python packages
+Then, install ctypeslib2 and the clang python package with the **same version as your llvm clang library**.
 
 Stable Distribution is available through PyPi at https://pypi.python.org/pypi/ctypeslib2/
+if you are not using the latest LLVM clang version, you will need to specify the correct clang python package version
 
-`sudo pip install ctypeslib2`
+  - If you have installed the latest llvm version: `pip install ctypeslib2` should work fine
+  - If you are using llvm clang 16: `pip install ctypeslib2 clang==16`
+  - If you are using llvm clang 14: `pip install ctypeslib2 clang==14` 
+  - If you are using llvm clang 11: `pip install ctypeslib2 clang==11`
+  - etc...
 
-### Setting up clang >= 3.7 dependency
+### Alternate configurations
 
-See the LLVM Clang instructions at http://apt.llvm.org/ or use your distribution's packages.
+On Ubuntu, libclang libraries are installed with version in the filename.
+This library tries to load a few different versions to help you out. (`__init__.py`)
+But if you encounter a version compatibility issue, you might have to fix the problem
+using one of the following solutions:
+
+1. set the CLANG_LIBRARY_PATH environmental variable to the clang library file or path
+```
+$ export CLANG_LIBRARY_PATH=/lib/x86_64-linux-gnu/libclang-11.so.1
+$ clang2py --version
+versions - clang2py:2.3.3 clang:11.1.0 python-clang:11.0
+```
+ 
+2. OR Install the development package libclang-<version\>-dev to get a file called libclang.so
+
+`$ sudo apt get install libclang-11-dev`
+2. OR create a link to libclang-<version\>.so.1 named libclang.so
+3. OR hardcode a call to clang.cindex.Config.load_library_file('libclang-<version\>.so.1') in your code before importing ctypeslib
 
-## Examples - Library usage
+
+## Usage
+### Use ctypeslib2 as a Library in your own python code
 
 
     import ctypeslib
     py_module = ctypeslib.translate('''int i = 12;''')
     print(py_module.i)  # Prints 12
 
     py_module2 = ctypeslib.translate('''struct coordinates { int i ; int y; };''')
     print(py_module2.struct_coordinates)  # <class 'struct_coordinates'>
     print(py_module2.struct_coordinates(1,2))  # <struct_coordinates object at 0xabcde12345>
 
+    # input files, output file
+    py_module3 = ctypeslib.translate_files(['mytest.c'], outfile=open('mytest.py', 'w'))
+    print(open('mytest.py').read())
 
-Look at `test/test_example_script.py` for more advanced Library usage
+    # input files, output code
+    py_module4 = ctypeslib.translate_files(['mytest.c'])
+    print(open('mytest.py').read())
 
+    # input files, output code, with clang options, like cross-platform
+    from ctypeslib.codegen import config
+    cfg = config.CodegenConfig()
+    cfg.clang_opts.extend(['-target', 'arm-gnu-linux'])
+    py_module5 = ctypeslib.translate_files(['mytest.c'], cfg=cfg)
+    print(open('mytest.py').read())
 
-## Other example - CLI
+
+Look at `test/test_api.py` for more advanced Library usage
+
+
+### Use ctypeslib2 on the command line
 
 Source file:
 
     $ cat t.c 
     struct my_bitfield {
     long a:3;
     long b:4;
@@ -114,15 +163,15 @@
         ('d', ctypes.c_int64, 3),
         ('f', ctypes.c_int64, 2),
         ('PADDING_0', ctypes.c_int64, 49)]
     
     __all__ = \
         ['struct_my_bitfield']
 
-## Other example with headers:
+### use ctypeslib with additional clang arguments:
 
 Source file:
 
     $ cat test-stdbool.c 
     #include <stdbool.h>
     
     typedef struct s_foo {
@@ -180,81 +229,66 @@
 
 The [_pack_](https://docs.python.org/3/library/ctypes.html#ctypes.Structure._pack_) attribute forces the alignment 
 on 0 bytes, to ensure all fields are as defined by this library, and not per the compiler used by the host python binary
 
 The objective of this, is to be able to produce cross-architecture python code, that can read memory structures from a 
 different architecture (like reading a memory dump from a different architecture)
 
+See `clang-11 -print-targets` for options
 
 
-## Usage
+## Usage details
 
-    usage: clang2py [-h] [-c] [-d] [--debug] [-e] [-k TYPEKIND] [-i] [-l DLL]
-                    [-m module] [--nm NM] [-o OUTPUT] [-p DLL] [-q]
-                    [-r EXPRESSION] [-s SYMBOL] [-t TARGET] [-v] [-V] [-w W] [-x]
-                    [--show-ids SHOWIDS] [--max-depth N] [--clang-args CLANG_ARGS]
+    usage: clang2py [-h] [-c] [-d] [--debug] [-e] [-k TYPEKIND] [-i] [-l DLL] [-m module] [--nm NM] [-o OUTPUT] [-p DLL] [-q] [-r EXPRESSION] [-s SYMBOL] [-t TARGET] [-v] [-V] [-w W] [-x] [--show-ids SHOWIDS] [--max-depth N]
+                    [--validate VALIDATE] [--clang-args CLANG_ARGS]
                     files [files ...]
     
-    Version 2.3.0. Generate python code from C headers
+    Version 2.3.3. Generate python code from C headers
     
     positional arguments:
       files                 source filenames. stdin is not supported
     
-    optional arguments:
+    options:
       -h, --help            show this help message and exit
       -c, --comments        include source doxygen-style comments
-      -d, --doc             include docstrings containing C prototype and source
-                            file location
+      -d, --doc             include docstrings containing C prototype and source file location
       --debug               setLevel to DEBUG
       -e, --show-definition-location
                             include source file location in comments
       -k TYPEKIND, --kind TYPEKIND
-                            kind of type descriptions to include: a = Alias, c =
-                            Class, d = Variable, e = Enumeration, f = Function, m
-                            = Macro, #define s = Structure, t = Typedef, u = Union
-                            default = 'cdefstu'
+                            kind of type descriptions to include: a = Alias, c = Class, d = Variable, e = Enumeration, f = Function, m = Macro, #define s = Structure, t = Typedef, u = Union default = 'cdefstu'
       -i, --includes        include declaration defined outside of the sourcefiles
       -l DLL, --include-library DLL
-                            library to search for exported functions. Add multiple
-                            times if required
+                            library to search for exported functions. Add multiple times if required
       -m module, --module module
-                            Python module(s) containing symbols which will be
-                            imported instead of generated
+                            Python module(s) containing symbols which will be imported instead of generated
       --nm NM               nm program to use to extract symbols from libraries
       -o OUTPUT, --output OUTPUT
-                            output filename (if not specified, standard output
-                            will be used)
+                            output filename (if not specified, standard output will be used)
       -p DLL, --preload DLL
-                            dll to be loaded before all others (to resolve
-                            symbols)
+                            dll to be loaded before all others (to resolve symbols)
       -q, --quiet           Shut down warnings and below
       -r EXPRESSION, --regex EXPRESSION
-                            regular expression for symbols to include (if neither
-                            symbols nor expressions are specified,everything will
-                            be included)
+                            regular expression for symbols to include (if neither symbols nor expressions are specified,everything will be included)
       -s SYMBOL, --symbol SYMBOL
-                            symbol to include (if neither symbols nor expressions
-                            are specified,everything will be included)
+                            symbol to include (if neither symbols nor expressions are specified,everything will be included)
       -t TARGET, --target TARGET
                             target architecture (default: x86_64-Linux)
       -v, --verbose         verbose output
       -V, --version         show program's version number and exit
-      -w W                  add all standard windows dlls to the searched dlls
-                            list
+      -w W                  add all standard windows dlls to the searched dlls list
       -x, --exclude-includes
                             Parse object in sources files only. Ignore includes
       --show-ids SHOWIDS    Don't compute cursor IDs (very slow)
       --max-depth N         Limit cursor expansion to depth N
+      --validate VALIDATE   validate the python code is correct
       --clang-args CLANG_ARGS
-                            clang options, in quotes: --clang-args="-std=c99
-                            -Wall"
+                            clang options, in quotes: --clang-args="-std=c99 -Wall"
     
-    Cross-architecture: You can pass target modifiers to clang. For example, try
-    --clang-args="-target x86_64" or "-target i386-linux" to change the target CPU
-    arch.
+    Cross-architecture: You can pass target modifiers to clang. For example, try --clang-args="-target x86_64" or "-target i386-linux" to change the target CPU arch.
 
 
 ## Inner workings for memo
 
 - clang2py is a script that calls ctypeslib/ctypeslib/clang2py.py
 - clang2py.py is mostly the old xml2py.py module forked to use libclang.
 - clang2py.py calls ctypeslib/ctypeslib/codegen/codegenerator.py
```

## Comparing `ctypeslib2-2.3.3.dist-info/RECORD` & `ctypeslib2-2.3.4.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-ctypeslib/__init__.py,sha256=zZtJ5b7VE_oKnaakFOPJoozR8PcKy72KL8Jhxb-D_kc,4282
-ctypeslib/clang2py.py,sha256=o5ALTu7gDPC7cmeQPfFklzUbcllaoVnN_ws83SBAm5E,11153
+ctypeslib/__init__.py,sha256=Dh9l4SXqJqqJCZM9-ZkCX0v-84ee0qePE8V5VBdiRV0,5532
+ctypeslib/clang2py.py,sha256=RK09bZb2MAPVYjoQWG-ociMyuEGr5C-P-xO-wc2xbpw,10324
 ctypeslib/dynamic_module.py,sha256=WVcZpOC7zuXEB3YPgUKuMroGPEqpHW8uGhOgmi7qDsc,9830
 ctypeslib/library.py,sha256=hXzb7EaqBhyQidUoNToNy1jxsZGOobb8LsGFQusHlPk,1770
 ctypeslib/codegen/__init__.py,sha256=T8esTPuM3QToUG45Oyx_Kw2ggRGMaHGPgBf8B0arnAU,32
-ctypeslib/codegen/clangparser.py,sha256=_gzWhWAHD02fiqbf9fKomQBo5IMxDSLn7Nm9-HB8Kfg,15850
-ctypeslib/codegen/codegenerator.py,sha256=qV7DDwsroOYwnsyoJedKcyaLCCEMX42ztBvQ2uGpPKM,47632
-ctypeslib/codegen/config.py,sha256=S3VXhOFEh4w7FQLKlLfvxnxdu9SZ27y5V72LBmbgjmg,3545
-ctypeslib/codegen/cursorhandler.py,sha256=B5e2FGMivsdUFmaBLH76cErVz0fh8mOhMgOu_6fQH3E,51255
-ctypeslib/codegen/handler.py,sha256=1IXhxvP16JyDb6X0BZQf0IrfMms8pUcJDUKUJddjnCk,9106
+ctypeslib/codegen/clangparser.py,sha256=9ci6CaPFuU5pPQH37C25BUo6nJC6q4QowE7--V-5X1Y,16278
+ctypeslib/codegen/codegenerator.py,sha256=yGQlUE20-g-_90MvpHdbFKOf-ndH9Ii3mSoTzes4c2Y,48167
+ctypeslib/codegen/config.py,sha256=R47TC61_XS6QulF-vqoYem8_NigYFYTWLzqG9pciuJE,3617
+ctypeslib/codegen/cursorhandler.py,sha256=hAIHDWYav0vEwOOiHR1aZ7CHf58zwSgqQjKrqyJk32o,52565
+ctypeslib/codegen/handler.py,sha256=jkzJI_u6pI_PACVZYt2qDjr9wyGHylzgD-OAVGujO80,9107
 ctypeslib/codegen/typedesc.py,sha256=AblVYpx145T9cLBrIXJjX1MsMIvXEULliClxO02raQ8,6454
 ctypeslib/codegen/typehandler.py,sha256=Q8oVJeB5x-7KM0r84h4ecHocj0o39NYOTovYqpYyi84,9684
-ctypeslib/codegen/util.py,sha256=Kp5vrghKvFTNghuP9J1qElg9wZdAeR-SWjjM_EjUuUA,5334
+ctypeslib/codegen/util.py,sha256=qUPfAgy01xPDtnidBBhO_-4y2aukhwi2NItmv_StiD0,5351
 ctypeslib/data/fundamental_type_name.tpl,sha256=mFzefC1rjw80EnFdkF00SoS8M80WxZlwxOpu1zNeuJo,231
 ctypeslib/data/headers.tpl,sha256=XCbV_fM0_DLHHhsBTm0rum1fy6caqEp_Q0fIlCbm_MU,178
 ctypeslib/data/pointer_type.tpl,sha256=ieCWx8qXRenzPLq_Zgfjql08rOVHRyWkV4qm6HkfYUs,1831
 ctypeslib/data/string_cast.tpl,sha256=knMRkTIJr9TmVOQSZ0hdT2uLcfGafttGGzmxZJJ9WcQ,594
 ctypeslib/data/structure_type.tpl,sha256=iQ4sNsOKTmEHF6J__H53DjaleRi-uLXqizW7CVylc7w,3826
-ctypeslib2-2.3.3.dist-info/LICENSE.txt,sha256=kqaFL2DflvBQMqJ1bKXxnyxRlFUzgKgSOFJT5IxFaMA,1071
-ctypeslib2-2.3.3.dist-info/METADATA,sha256=qQxwsiv4gF69apYHvuqylmnrId-R9cmynod1Tt0FSjs,10352
-ctypeslib2-2.3.3.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-ctypeslib2-2.3.3.dist-info/entry_points.txt,sha256=707pjFirQhKpw_djq2_ATnDcd1wRPMoeG3gtFl2M9WY,53
-ctypeslib2-2.3.3.dist-info/top_level.txt,sha256=bV9QhzPRI9C6RloTQeo1KZAm8jKNHdZ2R1CQgvmpNcU,10
-ctypeslib2-2.3.3.dist-info/RECORD,,
+ctypeslib2-2.3.4.dist-info/LICENSE.txt,sha256=kqaFL2DflvBQMqJ1bKXxnyxRlFUzgKgSOFJT5IxFaMA,1071
+ctypeslib2-2.3.4.dist-info/METADATA,sha256=n1D8sf_YdUlTxvYuxqbkAEF3ahKsS5d6hqAwa0bFUuM,12204
+ctypeslib2-2.3.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+ctypeslib2-2.3.4.dist-info/entry_points.txt,sha256=707pjFirQhKpw_djq2_ATnDcd1wRPMoeG3gtFl2M9WY,53
+ctypeslib2-2.3.4.dist-info/top_level.txt,sha256=bV9QhzPRI9C6RloTQeo1KZAm8jKNHdZ2R1CQgvmpNcU,10
+ctypeslib2-2.3.4.dist-info/RECORD,,
```

