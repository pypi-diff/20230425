# Comparing `tmp/geofileops-0.8.0a1.tar.gz` & `tmp/geofileops-0.8.0a2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "geofileops-0.8.0a1.tar", last modified: Fri Apr 14 15:51:29 2023, max compression
+gzip compressed data, was "geofileops-0.8.0a2.tar", last modified: Tue Apr 25 13:16:40 2023, max compression
```

## Comparing `geofileops-0.8.0a1.tar` & `geofileops-0.8.0a2.tar`

### file list

```diff
@@ -1,160 +1,92 @@
-drwxrwxrwx   0        0        0        0 2023-04-14 15:51:29.686628 geofileops-0.8.0a1/
--rw-rw-rw-   0        0        0     1558 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/LICENSE.txt
--rw-rw-rw-   0        0        0      285 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/MANIFEST.in
--rw-rw-rw-   0        0        0     3148 2023-04-14 15:51:29.687633 geofileops-0.8.0a1/PKG-INFO
--rw-rw-rw-   0        0        0     2692 2023-03-23 20:04:59.000000 geofileops-0.8.0a1/README.md
-drwxrwxrwx   0        0        0        0 2023-04-14 15:51:29.261630 geofileops-0.8.0a1/benchmark/
--rw-rw-rw-   0        0        0        0 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/benchmark/__init__.py
--rw-rw-rw-   0        0        0       84 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/benchmark/benchmark_all.py
--rw-rw-rw-   0        0        0      229 2023-03-01 13:49:50.000000 geofileops-0.8.0a1/benchmark/benchmark_geofileops.py
--rw-rw-rw-   0        0        0     5305 2023-03-01 17:27:02.000000 geofileops-0.8.0a1/benchmark/benchmarker.py
-drwxrwxrwx   0        0        0        0 2023-04-14 15:51:29.267640 geofileops-0.8.0a1/benchmark/benchmarks/
--rw-rw-rw-   0        0        0        0 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/benchmark/benchmarks/__init__.py
--rw-rw-rw-   0        0        0     9264 2023-03-04 19:42:48.000000 geofileops-0.8.0a1/benchmark/benchmarks/benchmarks_geofileops.py
--rw-rw-rw-   0        0        0     5386 2023-03-01 17:27:02.000000 geofileops-0.8.0a1/benchmark/benchmarks/testdata.py
--rw-rw-rw-   0        0        0     9470 2023-03-01 17:27:02.000000 geofileops-0.8.0a1/benchmark/reporter.py
-drwxrwxrwx   0        0        0        0 2023-04-14 15:51:29.282645 geofileops-0.8.0a1/geofileops/
--rw-rw-rw-   0        0        0      454 2023-04-14 15:38:24.000000 geofileops-0.8.0a1/geofileops/__init__.py
--rw-rw-rw-   0        0        0    88408 2023-04-14 10:22:55.000000 geofileops-0.8.0a1/geofileops/fileops.py
--rw-rw-rw-   0        0        0      278 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/geofileops/geofile.py
--rw-rw-rw-   0        0        0      280 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/geofileops/geofileops.py
--rw-rw-rw-   0        0        0    92202 2023-04-14 15:48:32.000000 geofileops-0.8.0a1/geofileops/geoops.py
-drwxrwxrwx   0        0        0        0 2023-04-14 15:51:29.303629 geofileops-0.8.0a1/geofileops/helpers/
--rw-rw-rw-   0        0        0      114 2023-03-24 16:38:05.000000 geofileops-0.8.0a1/geofileops/helpers/__init__.py
--rw-rw-rw-   0        0        0     3933 2023-03-24 16:38:05.000000 geofileops-0.8.0a1/geofileops/helpers/_parameter_helper.py
--rw-rw-rw-   0        0        0     8094 2023-04-14 15:48:32.000000 geofileops-0.8.0a1/geofileops/helpers/layer_styles.py
-drwxrwxrwx   0        0        0        0 2023-04-14 15:51:29.350630 geofileops-0.8.0a1/geofileops/util/
--rw-rw-rw-   0        0        0      123 2023-03-24 16:38:05.000000 geofileops-0.8.0a1/geofileops/util/__init__.py
--rw-rw-rw-   0        0        0     5697 2023-03-23 22:23:33.000000 geofileops-0.8.0a1/geofileops/util/_general_util.py
--rw-rw-rw-   0        0        0    73072 2023-03-30 17:18:51.000000 geofileops-0.8.0a1/geofileops/util/_geoops_gpd.py
--rw-rw-rw-   0        0        0     5398 2023-03-16 22:05:48.000000 geofileops-0.8.0a1/geofileops/util/_geoops_ogr.py
--rw-rw-rw-   0        0        0   103451 2023-04-14 15:38:24.000000 geofileops-0.8.0a1/geofileops/util/_geoops_sql.py
--rw-rw-rw-   0        0        0     4621 2023-03-23 23:17:43.000000 geofileops-0.8.0a1/geofileops/util/_io_util.py
--rw-rw-rw-   0        0        0     7758 2023-03-16 01:24:07.000000 geofileops-0.8.0a1/geofileops/util/_ogr_sql_util.py
--rw-rw-rw-   0        0        0    18704 2023-03-15 13:01:57.000000 geofileops-0.8.0a1/geofileops/util/_ogr_util.py
--rw-rw-rw-   0        0        0     5027 2023-03-23 22:23:33.000000 geofileops-0.8.0a1/geofileops/util/_processing_util.py
--rw-rw-rw-   0        0        0    19021 2023-03-23 22:23:33.000000 geofileops-0.8.0a1/geofileops/util/_sqlite_util.py
--rw-rw-rw-   0        0        0     1085 2023-02-17 14:19:10.000000 geofileops-0.8.0a1/geofileops/util/geodataframe_util.py
--rw-rw-rw-   0        0        0     4843 2023-03-06 15:13:08.000000 geofileops-0.8.0a1/geofileops/util/geofiletype.py
--rw-rw-rw-   0        0        0      633 2023-03-06 15:13:08.000000 geofileops-0.8.0a1/geofileops/util/geofiletypes.csv
--rw-rw-rw-   0        0        0    30943 2023-03-01 17:27:02.000000 geofileops-0.8.0a1/geofileops/util/geometry_util.py
--rw-rw-rw-   0        0        0    12225 2023-03-01 17:27:02.000000 geofileops-0.8.0a1/geofileops/util/geoseries_util.py
--rw-rw-rw-   0        0        0     8239 2023-03-01 17:27:02.000000 geofileops-0.8.0a1/geofileops/util/grid_util.py
--rw-rw-rw-   0        0        0    98304 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/geofileops/util/test.gpkg
--rw-rw-rw-   0        0        0      244 2023-03-01 17:27:02.000000 geofileops-0.8.0a1/geofileops/util/vector_util.py
--rw-rw-rw-   0        0        0        7 2023-04-14 15:48:32.000000 geofileops-0.8.0a1/geofileops/version.txt
-drwxrwxrwx   0        0        0        0 2023-04-14 15:51:29.295628 geofileops-0.8.0a1/geofileops.egg-info/
--rw-rw-rw-   0        0        0     3148 2023-04-14 15:51:28.000000 geofileops-0.8.0a1/geofileops.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0     6745 2023-04-14 15:51:28.000000 geofileops-0.8.0a1/geofileops.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-04-14 15:51:28.000000 geofileops-0.8.0a1/geofileops.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0      126 2023-04-14 15:51:28.000000 geofileops-0.8.0a1/geofileops.egg-info/requires.txt
--rw-rw-rw-   0        0        0       27 2023-04-14 15:51:28.000000 geofileops-0.8.0a1/geofileops.egg-info/top_level.txt
--rw-rw-rw-   0        0        0      104 2023-04-14 15:51:29.688649 geofileops-0.8.0a1/setup.cfg
--rw-rw-rw-   0        0        0     1103 2023-03-03 11:27:25.000000 geofileops-0.8.0a1/setup.py
-drwxrwxrwx   0        0        0        0 2023-04-14 15:51:29.406631 geofileops-0.8.0a1/tests/
--rw-rw-rw-   0        0        0        0 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/__init__.py
-drwxrwxrwx   0        0        0        0 2023-04-14 15:51:29.630625 geofileops-0.8.0a1/tests/__pycache__/
--rw-rw-rw-   0        0        0      151 2022-12-06 20:25:33.000000 geofileops-0.8.0a1/tests/__pycache__/__init__.cpython-39.pyc
--rw-rw-rw-   0        0        0     2562 2022-12-06 20:25:33.000000 geofileops-0.8.0a1/tests/__pycache__/test_backwards_compatibility.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     2562 2023-03-01 14:48:29.000000 geofileops-0.8.0a1/tests/__pycache__/test_backwards_compatibility.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     2562 2023-03-15 11:23:47.000000 geofileops-0.8.0a1/tests/__pycache__/test_backwards_compatibility.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     3272 2022-12-06 20:25:45.000000 geofileops-0.8.0a1/tests/__pycache__/test_general_util.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     3272 2023-03-01 14:48:31.000000 geofileops-0.8.0a1/tests/__pycache__/test_general_util.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     2105 2023-03-23 22:23:40.000000 geofileops-0.8.0a1/tests/__pycache__/test_general_util.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0    53419 2023-02-20 19:18:00.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofile.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0    59976 2023-03-06 16:39:06.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofile.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0    67034 2023-03-30 17:19:00.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofile.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0    13467 2023-02-20 08:04:44.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0    16903 2023-03-15 08:07:48.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0    18691 2023-03-30 17:19:00.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0    40249 2023-02-20 08:04:44.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer_gpd.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0    45726 2023-03-15 08:07:49.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer_gpd.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0    50404 2023-03-30 17:19:00.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer_gpd.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     7043 2022-12-06 20:25:45.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer_ogr.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     7043 2023-03-01 14:48:32.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer_ogr.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     7642 2023-03-16 22:06:01.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer_ogr.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0    11687 2023-02-20 08:04:44.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer_sql.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0    16225 2023-03-15 08:07:49.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer_sql.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0    17056 2023-04-14 15:38:34.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_singlelayer_sql.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0    30343 2023-02-20 19:18:00.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_twolayers.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0    36580 2023-03-15 08:07:49.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_twolayers.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0    43036 2023-03-24 15:21:28.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofileops_twolayers.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     4132 2022-12-06 20:25:45.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofiletype.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     4132 2023-03-01 14:48:32.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofiletype.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     4132 2023-03-15 11:23:51.000000 geofileops-0.8.0a1/tests/__pycache__/test_geofiletype.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0    36952 2023-03-01 12:34:06.000000 geofileops-0.8.0a1/tests/__pycache__/test_geometry_util.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0    36934 2023-03-01 17:27:02.000000 geofileops-0.8.0a1/tests/__pycache__/test_geometry_util.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0    36934 2023-03-15 11:23:52.000000 geofileops-0.8.0a1/tests/__pycache__/test_geometry_util.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     2450 2023-02-20 15:09:51.000000 geofileops-0.8.0a1/tests/__pycache__/test_geometry_util_centerline.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     2450 2023-03-01 17:02:59.000000 geofileops-0.8.0a1/tests/__pycache__/test_geometry_util_centerline.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0    17322 2023-03-01 12:34:06.000000 geofileops-0.8.0a1/tests/__pycache__/test_geoseries_util.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0    17322 2023-03-01 17:27:02.000000 geofileops-0.8.0a1/tests/__pycache__/test_geoseries_util.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0    17322 2023-03-15 11:23:52.000000 geofileops-0.8.0a1/tests/__pycache__/test_geoseries_util.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     2567 2022-12-06 20:25:46.000000 geofileops-0.8.0a1/tests/__pycache__/test_grid_util.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     2567 2023-03-01 14:48:32.000000 geofileops-0.8.0a1/tests/__pycache__/test_grid_util.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     2567 2023-03-15 11:23:52.000000 geofileops-0.8.0a1/tests/__pycache__/test_grid_util.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     7837 2023-02-20 19:17:59.000000 geofileops-0.8.0a1/tests/__pycache__/test_helper.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     8020 2023-03-06 16:23:35.000000 geofileops-0.8.0a1/tests/__pycache__/test_helper.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     8020 2023-03-15 11:23:50.000000 geofileops-0.8.0a1/tests/__pycache__/test_helper.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     6487 2022-12-10 10:01:54.000000 geofileops-0.8.0a1/tests/__pycache__/test_helper.cpython-39.pyc
--rw-rw-rw-   0        0        0     4469 2022-12-06 20:25:46.000000 geofileops-0.8.0a1/tests/__pycache__/test_io_util.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     4469 2023-03-01 14:48:32.000000 geofileops-0.8.0a1/tests/__pycache__/test_io_util.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     2814 2023-03-23 23:17:50.000000 geofileops-0.8.0a1/tests/__pycache__/test_io_util.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     3218 2023-04-14 15:38:34.000000 geofileops-0.8.0a1/tests/__pycache__/test_layer_styles.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     4799 2023-03-06 15:13:18.000000 geofileops-0.8.0a1/tests/__pycache__/test_ogr_sql_util.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     4801 2023-03-16 01:24:15.000000 geofileops-0.8.0a1/tests/__pycache__/test_ogr_sql_util.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     8089 2022-12-06 20:25:46.000000 geofileops-0.8.0a1/tests/__pycache__/test_ogr_util.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     6926 2023-03-07 07:22:53.000000 geofileops-0.8.0a1/tests/__pycache__/test_ogr_util.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     6926 2023-03-15 11:23:52.000000 geofileops-0.8.0a1/tests/__pycache__/test_ogr_util.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     2066 2023-03-24 16:38:12.000000 geofileops-0.8.0a1/tests/__pycache__/test_parameter_helper.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     1558 2023-03-24 16:38:12.000000 geofileops-0.8.0a1/tests/__pycache__/test_processing_util.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     1906 2023-02-16 12:42:48.000000 geofileops-0.8.0a1/tests/__pycache__/test_spatialite.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     1906 2023-03-01 14:48:32.000000 geofileops-0.8.0a1/tests/__pycache__/test_spatialite.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     1906 2023-03-15 11:23:52.000000 geofileops-0.8.0a1/tests/__pycache__/test_spatialite.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     3684 2023-03-05 14:54:14.000000 geofileops-0.8.0a1/tests/__pycache__/test_sql_util.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     2168 2022-12-06 20:25:46.000000 geofileops-0.8.0a1/tests/__pycache__/test_sqlite_util.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     2168 2023-03-01 14:48:32.000000 geofileops-0.8.0a1/tests/__pycache__/test_sqlite_util.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     2168 2023-03-15 11:23:52.000000 geofileops-0.8.0a1/tests/__pycache__/test_sqlite_util.cpython-39-pytest-7.2.2.pyc
--rw-rw-rw-   0        0        0     1043 2022-12-06 20:25:46.000000 geofileops-0.8.0a1/tests/__pycache__/test_version.cpython-39-pytest-7.2.0.pyc
--rw-rw-rw-   0        0        0     1043 2023-03-01 14:48:32.000000 geofileops-0.8.0a1/tests/__pycache__/test_version.cpython-39-pytest-7.2.1.pyc
--rw-rw-rw-   0        0        0     1043 2023-03-15 11:23:52.000000 geofileops-0.8.0a1/tests/__pycache__/test_version.cpython-39-pytest-7.2.2.pyc
-drwxrwxrwx   0        0        0        0 2023-04-14 15:51:29.683624 geofileops-0.8.0a1/tests/data/
--rw-rw-rw-   0        0        0   114688 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/BEFL-kbl.gpkg
--rw-rw-rw-   0        0        0    17534 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/geofileops_testdata.qgz
--rw-rw-rw-   0        0        0    98304 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/linestring-row-trees.gpkg
--rw-rw-rw-   0        0        0   765952 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/linestring-watercourse.gpkg
--rw-rw-rw-   0        0        0    98304 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/linestrings_hedges.gpkg
--rw-rw-rw-   0        0        0   106496 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/point.gpkg
--rw-rw-rw-   0        0        0   139264 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/polygon-invalid.gpkg
--rw-rw-rw-   0        0        0    98304 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/polygon-no-rows.gpkg
--rw-rw-rw-   0        0        0    98304 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/polygon-overlappingcircles-all.gpkg
--rw-rw-rw-   0        0        0    98304 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/polygon-overlappingcircles-one.gpkg
--rw-rw-rw-   0        0        0    98304 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/polygon-overlappingcircles-two+three.gpkg
--rw-rw-rw-   0        0        0   122880 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/polygon-parcel.gpkg
--rw-rw-rw-   0        0        0   126976 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/polygon-simplify-onborder-testcase.gpkg
--rw-rw-rw-   0        0        0   143360 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/polygon-twolayers.gpkg
--rw-rw-rw-   0        0        0    98304 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/data/polygon-zone.gpkg
--rw-rw-rw-   0        0        0    19833 2023-04-14 15:38:24.000000 geofileops-0.8.0a1/tests/data/polygonstyle.qml
--rw-rw-rw-   0        0        0     1671 2023-04-14 15:38:24.000000 geofileops-0.8.0a1/tests/data/polygonstyle.sld
--rw-rw-rw-   0        0        0     1167 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/test_backwards_compatibility.py
--rw-rw-rw-   0        0        0     1151 2023-03-23 22:23:33.000000 geofileops-0.8.0a1/tests/test_general_util.py
--rw-rw-rw-   0        0        0    39980 2023-03-30 17:18:51.000000 geofileops-0.8.0a1/tests/test_geofile.py
--rw-rw-rw-   0        0        0    17414 2023-03-30 17:18:51.000000 geofileops-0.8.0a1/tests/test_geofileops_singlelayer.py
--rw-rw-rw-   0        0        0    39414 2023-03-30 17:18:51.000000 geofileops-0.8.0a1/tests/test_geofileops_singlelayer_gpd.py
--rw-rw-rw-   0        0        0     4145 2023-03-16 22:05:48.000000 geofileops-0.8.0a1/tests/test_geofileops_singlelayer_ogr.py
--rw-rw-rw-   0        0        0    12594 2023-04-14 15:38:24.000000 geofileops-0.8.0a1/tests/test_geofileops_singlelayer_sql.py
--rw-rw-rw-   0        0        0    38395 2023-03-24 15:21:20.000000 geofileops-0.8.0a1/tests/test_geofileops_twolayers.py
--rw-rw-rw-   0        0        0     1698 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/test_geofiletype.py
--rw-rw-rw-   0        0        0    26001 2023-03-01 17:27:02.000000 geofileops-0.8.0a1/tests/test_geometry_util.py
--rw-rw-rw-   0        0        0    12159 2023-03-01 17:27:02.000000 geofileops-0.8.0a1/tests/test_geoseries_util.py
--rw-rw-rw-   0        0        0     1239 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/test_grid_util.py
--rw-rw-rw-   0        0        0    10199 2023-03-06 16:23:27.000000 geofileops-0.8.0a1/tests/test_helper.py
--rw-rw-rw-   0        0        0     1617 2023-03-23 23:17:43.000000 geofileops-0.8.0a1/tests/test_io_util.py
--rw-rw-rw-   0        0        0     2015 2023-04-14 15:38:24.000000 geofileops-0.8.0a1/tests/test_layer_styles.py
--rw-rw-rw-   0        0        0     4390 2023-03-16 01:24:07.000000 geofileops-0.8.0a1/tests/test_ogr_sql_util.py
--rw-rw-rw-   0        0        0     3973 2023-03-07 07:22:44.000000 geofileops-0.8.0a1/tests/test_ogr_util.py
--rw-rw-rw-   0        0        0     2617 2023-03-24 16:38:05.000000 geofileops-0.8.0a1/tests/test_parameter_helper.py
--rw-rw-rw-   0        0        0     1484 2023-03-24 16:38:05.000000 geofileops-0.8.0a1/tests/test_processing_util.py
--rw-rw-rw-   0        0        0     1136 2023-02-16 12:42:32.000000 geofileops-0.8.0a1/tests/test_spatialite.py
--rw-rw-rw-   0        0        0     2067 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/test_sqlite_util.py
--rw-rw-rw-   0        0        0      346 2022-12-03 18:13:01.000000 geofileops-0.8.0a1/tests/test_version.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:40.844609 geofileops-0.8.0a2/
+-rw-r--r--   0 runner    (1001) docker     (123)     1529 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      277 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     3106 2023-04-25 13:16:40.844609 geofileops-0.8.0a2/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     2664 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:40.832609 geofileops-0.8.0a2/benchmark/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/benchmark/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)       80 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/benchmark/benchmark_all.py
+-rw-r--r--   0 runner    (1001) docker     (123)      222 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/benchmark/benchmark_geofileops.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5158 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/benchmark/benchmarker.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:40.832609 geofileops-0.8.0a2/benchmark/benchmarks/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/benchmark/benchmarks/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8969 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/benchmark/benchmarks/benchmarks_geofileops.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5236 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/benchmark/benchmarks/testdata.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9213 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/benchmark/reporter.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:40.832609 geofileops-0.8.0a2/geofileops/
+-rw-r--r--   0 runner    (1001) docker     (123)      436 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)       78 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/_compat.py
+-rw-r--r--   0 runner    (1001) docker     (123)    83155 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/fileops.py
+-rw-r--r--   0 runner    (1001) docker     (123)    90643 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/geoops.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:40.836609 geofileops-0.8.0a2/geofileops/helpers/
+-rw-r--r--   0 runner    (1001) docker     (123)      110 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/helpers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3834 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/helpers/_parameter_helper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7865 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/helpers/layerstyles.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:40.836609 geofileops-0.8.0a2/geofileops/util/
+-rw-r--r--   0 runner    (1001) docker     (123)      119 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5529 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/_general_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    71319 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/_geoops_gpd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5224 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/_geoops_ogr.py
+-rw-r--r--   0 runner    (1001) docker     (123)   101634 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/_geoops_sql.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4487 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/_io_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7573 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/_ogr_sql_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18218 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/_ogr_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4882 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/_processing_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20519 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/_sqlite_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1052 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/geodataframe_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4699 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/geofiletype.py
+-rw-r--r--   0 runner    (1001) docker     (123)      628 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/geofiletypes.csv
+-rw-r--r--   0 runner    (1001) docker     (123)    30107 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/geometry_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11903 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/geoseries_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8013 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/grid_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    98304 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/util/test.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)        7 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/geofileops/version.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:40.836609 geofileops-0.8.0a2/geofileops.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     3106 2023-04-25 13:16:40.000000 geofileops-0.8.0a2/geofileops.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     2441 2023-04-25 13:16:40.000000 geofileops-0.8.0a2/geofileops.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-25 13:16:40.000000 geofileops-0.8.0a2/geofileops.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      126 2023-04-25 13:16:40.000000 geofileops-0.8.0a2/geofileops.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       27 2023-04-25 13:16:40.000000 geofileops-0.8.0a2/geofileops.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       96 2023-04-25 13:16:40.844609 geofileops-0.8.0a2/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     1063 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:40.840609 geofileops-0.8.0a2/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 13:16:40.844609 geofileops-0.8.0a2/tests/data/
+-rw-r--r--   0 runner    (1001) docker     (123)   114688 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/BEFL-kbl.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)    17534 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/geofileops_testdata.qgz
+-rw-r--r--   0 runner    (1001) docker     (123)    98304 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/linestring-row-trees.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)   765952 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/linestring-watercourse.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)    98304 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/linestrings_hedges.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)   106496 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/point.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)   139264 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/polygon-invalid.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)    98304 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/polygon-no-rows.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)    98304 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/polygon-overlappingcircles-all.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)    98304 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/polygon-overlappingcircles-one.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)    98304 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/polygon-overlappingcircles-two+three.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)   122880 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/polygon-parcel.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)   126976 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/polygon-simplify-onborder-testcase.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)   143360 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/polygon-twolayers.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)    98304 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/polygon-zone.gpkg
+-rw-r--r--   0 runner    (1001) docker     (123)    19428 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/polygonstyle.qml
+-rw-r--r--   0 runner    (1001) docker     (123)     1631 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/data/polygonstyle.sld
+-rw-r--r--   0 runner    (1001) docker     (123)     1111 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_general_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39071 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_geofile.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16948 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_geofileops_singlelayer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38479 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_geofileops_singlelayer_gpd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4344 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_geofileops_singlelayer_ogr.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15753 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_geofileops_singlelayer_sql.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38740 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_geofileops_twolayers.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1650 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_geofiletype.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25181 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_geometry_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11797 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_geoseries_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1196 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_grid_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9924 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_helper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1564 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_io_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1948 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_layerstyles.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4266 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_ogr_sql_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3874 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_ogr_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2542 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_parameter_helper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1439 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_processing_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_spatialite.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4497 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_sqlite_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)      331 2023-04-25 13:16:29.000000 geofileops-0.8.0a2/tests/test_version.py
```

### Comparing `geofileops-0.8.0a1/LICENSE.txt` & `geofileops-0.8.0a2/LICENSE.txt`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-BSD 3-Clause License
-
-Copyright (c) 2020-2021, Pieter Roggemans
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this
-   list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice,
-   this list of conditions and the following disclaimer in the documentation
-   and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its
-   contributors may be used to endorse or promote products derived from
-   this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+BSD 3-Clause License
+
+Copyright (c) 2020-2021, Pieter Roggemans
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its
+   contributors may be used to endorse or promote products derived from
+   this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

### Comparing `geofileops-0.8.0a1/PKG-INFO` & `geofileops-0.8.0a2/PKG-INFO`

 * *Files 5% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-Metadata-Version: 2.1
-Name: geofileops
-Version: 0.8.0a1
-Summary: Package to do spatial operations on large geo files.
-Home-page: https://github.com/geofileops/geofileops
-Author: Pieter Roggemans
-Author-email: pieter.roggemans@gmail.com
-Classifier: Programming Language :: Python :: 3
-Classifier: Operating System :: OS Independent
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Provides-Extra: full
-License-File: LICENSE.txt
-
-# geofileops 
-
-[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
-[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
-[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
-[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
-
-Library to make spatial operations on large geo files fast(er) and easy.
-
-Remarks: 
-* Most typical operations are available: 
-  [buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer),
-  [simplify](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.simolify),
-  [dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
-  [union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),
-  [erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
-  [intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection),...
-* Any python function can be applied to a geofile in parallel using [apply](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.apply)
-* The speed (improvement) depends on the operation, the number of available cores and the size of the input files.
-  * For CPU bound operations (eg. union,... between large input files) the processing time will depend on the number of available CPU cores. For (very) large files the typical processing time can be divided by the number of available cores.
-  * For dissolve on (very) large files, the speed improvement can be more than the processing time divided by the available cores.
-* Tested on geopackage and shapefile input/output files. However, geopackage is highly recommended as it will offer better performance in geofileops... and also for the reasons listed here: www.switchfromshapefile.org.
-
-Documentation on how to use geofileops can be found [here](https://geofileops.readthedocs.io).
-
-The following chart gives an impression of the speed improvement that can be expected when processing larger files (including I/O!). More information about this benchmark can be found [here](https://github.com/geofileops/geobenchmark).
-
-![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
+Metadata-Version: 2.1
+Name: geofileops
+Version: 0.8.0a2
+Summary: Package to do spatial operations on large geo files.
+Home-page: https://github.com/geofileops/geofileops
+Author: Pieter Roggemans
+Author-email: pieter.roggemans@gmail.com
+Classifier: Programming Language :: Python :: 3
+Classifier: Operating System :: OS Independent
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+Provides-Extra: full
+License-File: LICENSE.txt
+
+# geofileops 
+
+[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
+[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
+[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
+[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
+
+Library to make spatial operations on large geo files fast(er) and easy.
+
+Remarks: 
+* Most typical operations are available: 
+  [buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer),
+  [simplify](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.simolify),
+  [dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
+  [union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),
+  [erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
+  [intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection),...
+* Any python function can be applied to a geofile in parallel using [apply](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.apply)
+* The speed (improvement) depends on the operation, the number of available cores and the size of the input files.
+  * For CPU bound operations (eg. union,... between large input files) the processing time will depend on the number of available CPU cores. For (very) large files the typical processing time can be divided by the number of available cores.
+  * For dissolve on (very) large files, the speed improvement can be more than the processing time divided by the available cores.
+* Tested on geopackage and shapefile input/output files. However, geopackage is highly recommended as it will offer better performance in geofileops... and also for the reasons listed here: www.switchfromshapefile.org.
+
+Documentation on how to use geofileops can be found [here](https://geofileops.readthedocs.io).
+
+The following chart gives an impression of the speed improvement that can be expected when processing larger files (including I/O!). More information about this benchmark can be found [here](https://github.com/geofileops/geobenchmark).
+
+![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
```

### Comparing `geofileops-0.8.0a1/README.md` & `geofileops-0.8.0a2/geofileops.egg-info/PKG-INFO`

 * *Files 7% similar despite different names*

```diff
@@ -1,28 +1,42 @@
-# geofileops 
-
-[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
-[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
-[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
-[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
-
-Library to make spatial operations on large geo files fast(er) and easy.
-
-Remarks: 
-* Most typical operations are available: 
-  [buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer),
-  [simplify](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.simolify),
-  [dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
-  [union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),
-  [erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
-  [intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection),...
-* Any python function can be applied to a geofile in parallel using [apply](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.apply)
-* The speed (improvement) depends on the operation, the number of available cores and the size of the input files.
-  * For CPU bound operations (eg. union,... between large input files) the processing time will depend on the number of available CPU cores. For (very) large files the typical processing time can be divided by the number of available cores.
-  * For dissolve on (very) large files, the speed improvement can be more than the processing time divided by the available cores.
-* Tested on geopackage and shapefile input/output files. However, geopackage is highly recommended as it will offer better performance in geofileops... and also for the reasons listed here: www.switchfromshapefile.org.
-
-Documentation on how to use geofileops can be found [here](https://geofileops.readthedocs.io).
-
-The following chart gives an impression of the speed improvement that can be expected when processing larger files (including I/O!). More information about this benchmark can be found [here](https://github.com/geofileops/geobenchmark).
-
-![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
+Metadata-Version: 2.1
+Name: geofileops
+Version: 0.8.0a2
+Summary: Package to do spatial operations on large geo files.
+Home-page: https://github.com/geofileops/geofileops
+Author: Pieter Roggemans
+Author-email: pieter.roggemans@gmail.com
+Classifier: Programming Language :: Python :: 3
+Classifier: Operating System :: OS Independent
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+Provides-Extra: full
+License-File: LICENSE.txt
+
+# geofileops 
+
+[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
+[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
+[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
+[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
+
+Library to make spatial operations on large geo files fast(er) and easy.
+
+Remarks: 
+* Most typical operations are available: 
+  [buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer),
+  [simplify](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.simolify),
+  [dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
+  [union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),
+  [erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
+  [intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection),...
+* Any python function can be applied to a geofile in parallel using [apply](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.apply)
+* The speed (improvement) depends on the operation, the number of available cores and the size of the input files.
+  * For CPU bound operations (eg. union,... between large input files) the processing time will depend on the number of available CPU cores. For (very) large files the typical processing time can be divided by the number of available cores.
+  * For dissolve on (very) large files, the speed improvement can be more than the processing time divided by the available cores.
+* Tested on geopackage and shapefile input/output files. However, geopackage is highly recommended as it will offer better performance in geofileops... and also for the reasons listed here: www.switchfromshapefile.org.
+
+Documentation on how to use geofileops can be found [here](https://geofileops.readthedocs.io).
+
+The following chart gives an impression of the speed improvement that can be expected when processing larger files (including I/O!). More information about this benchmark can be found [here](https://github.com/geofileops/geobenchmark).
+
+![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
```

### Comparing `geofileops-0.8.0a1/benchmark/benchmarker.py` & `geofileops-0.8.0a2/benchmark/benchmarker.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,147 +1,147 @@
-# -*- coding: utf-8 -*-
-"""
-Module for benchmarking.
-"""
-
-import datetime
-import importlib
-import inspect
-import logging
-from pathlib import Path
-import sys
-import tempfile
-from typing import List, Optional
-
-import pandas as pd
-
-# Add path so the benchmark packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent))
-import reporter
-
-################################################################################
-# Some init
-################################################################################
-
-logger = logging.getLogger(__name__)
-
-################################################################################
-# The real work
-################################################################################
-
-
-class RunResult:
-    """The result of a benchmark run."""
-
-    def __init__(
-        self,
-        package: str,
-        package_version: str,
-        operation: str,
-        operation_descr: str,
-        secs_taken: float,
-        run_details: Optional[dict] = None,
-    ):
-        """
-        Constructor for a RunResult.
-
-        Args:
-            package (str): Package being benchmarked.
-            package_version (str): Version of the package.
-            operation (str): Operation name.
-            operation_descr (str): Description of the operation.
-            secs_taken (float): Seconds the operation took.
-            run_details (dict, optional): (Important) details of this specific
-                run with impact on performance. Eg. # CPU's used,...
-        """
-        self.run_datetime = datetime.datetime.now()
-        self.package = package
-        self.package_version = package_version
-        self.operation = operation
-        self.operation_descr = operation_descr
-        self.secs_taken = secs_taken
-        self.run_details = run_details
-
-    def __repr__(self):
-        return f"{self.__class__}({self.__dict__})"
-
-
-def run_benchmarks(
-    modules_to_run: Optional[List[str]] = None,
-    functions_to_run: Optional[List[str]] = None,
-):
-    # Init logging
-    logging.basicConfig(
-        format="%(asctime)s.%(msecs)03d|%(levelname)s|%(name)s|%(message)s",
-        datefmt="%H:%M:%S",
-        level=logging.INFO,
-    )
-
-    # Discover and run all benchmark implementations
-    tmp_dir = Path(tempfile.gettempdir()) / "geobenchmark"
-    logger.info(f"tmpdir: {tmp_dir}")
-    tmp_dir.mkdir(parents=True, exist_ok=True)
-
-    benchmarks_dir = Path(__file__).parent / "benchmarks"
-    results = []
-    for file in benchmarks_dir.glob("benchmarks_*.py"):
-        module_name = file.stem
-        if (not module_name.startswith("_")) and (module_name not in globals()):
-            if modules_to_run is not None and module_name not in modules_to_run:
-                # Benchmark whitelist specified, and this one isn't in it
-                logger.info(
-                    f"module {module_name} skipped, because not in modules_to_run: "
-                    f"{modules_to_run}"
-                )
-                continue
-
-            benchmark_implementation = importlib.import_module(
-                f"benchmarks.{module_name}", __package__
-            )
-
-            # Run the functions in this benchmark
-            functions = inspect.getmembers(benchmark_implementation, inspect.isfunction)
-            for function_name, function in functions:
-                if function_name.startswith("_"):
-                    continue
-                if (
-                    functions_to_run is not None
-                    and function_name not in functions_to_run
-                ):
-                    # Function whitelist specified, and this one isn't in it
-                    logger.info(
-                        f"function {function_name} skipped, because not in "
-                        f"functions_to_run: {functions_to_run}"
-                    )
-                    continue
-
-                # Run the operation benchmark
-                logger.info(f"benchmarks.{module_name}.{function_name} start")
-                result = function(tmp_dir=tmp_dir)
-                if result is not None and isinstance(result, RunResult) is True:
-                    logger.info(
-                        f"benchmarks.{module_name}.{function_name} ready in "
-                        f"{result.secs_taken:.2f} s"
-                    )
-                    results.append(result)
-                else:
-                    logger.warning(
-                        f"benchmarks.{module_name}.{function_name} ignored: instead of "
-                        f"a RunResult it returned {result}"
-                    )
-
-    # Add results to csv file
-    results_path = Path(__file__).resolve().parent / "results/benchmark_results.csv"
-    results_dictlist = [vars(result) for result in results]
-    results_df = pd.DataFrame(results_dictlist)
-    if not results_path.exists():
-        results_df.to_csv(results_path, index=False)
-    else:
-        results_df.to_csv(results_path, index=False, mode="a", header=False)
-
-    # Generate reports
-    output_dir = Path(__file__).resolve().parent / "results"
-    reporter.generate_reports(results_path, output_dir)
-
-
-if __name__ == "__main__":
-    run_benchmarks()
+# -*- coding: utf-8 -*-
+"""
+Module for benchmarking.
+"""
+
+import datetime
+import importlib
+import inspect
+import logging
+from pathlib import Path
+import sys
+import tempfile
+from typing import List, Optional
+
+import pandas as pd
+
+# Add path so the benchmark packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent))
+import reporter
+
+################################################################################
+# Some init
+################################################################################
+
+logger = logging.getLogger(__name__)
+
+################################################################################
+# The real work
+################################################################################
+
+
+class RunResult:
+    """The result of a benchmark run."""
+
+    def __init__(
+        self,
+        package: str,
+        package_version: str,
+        operation: str,
+        operation_descr: str,
+        secs_taken: float,
+        run_details: Optional[dict] = None,
+    ):
+        """
+        Constructor for a RunResult.
+
+        Args:
+            package (str): Package being benchmarked.
+            package_version (str): Version of the package.
+            operation (str): Operation name.
+            operation_descr (str): Description of the operation.
+            secs_taken (float): Seconds the operation took.
+            run_details (dict, optional): (Important) details of this specific
+                run with impact on performance. Eg. # CPU's used,...
+        """
+        self.run_datetime = datetime.datetime.now()
+        self.package = package
+        self.package_version = package_version
+        self.operation = operation
+        self.operation_descr = operation_descr
+        self.secs_taken = secs_taken
+        self.run_details = run_details
+
+    def __repr__(self):
+        return f"{self.__class__}({self.__dict__})"
+
+
+def run_benchmarks(
+    modules_to_run: Optional[List[str]] = None,
+    functions_to_run: Optional[List[str]] = None,
+):
+    # Init logging
+    logging.basicConfig(
+        format="%(asctime)s.%(msecs)03d|%(levelname)s|%(name)s|%(message)s",
+        datefmt="%H:%M:%S",
+        level=logging.INFO,
+    )
+
+    # Discover and run all benchmark implementations
+    tmp_dir = Path(tempfile.gettempdir()) / "geobenchmark"
+    logger.info(f"tmpdir: {tmp_dir}")
+    tmp_dir.mkdir(parents=True, exist_ok=True)
+
+    benchmarks_dir = Path(__file__).parent / "benchmarks"
+    results = []
+    for file in benchmarks_dir.glob("benchmarks_*.py"):
+        module_name = file.stem
+        if (not module_name.startswith("_")) and (module_name not in globals()):
+            if modules_to_run is not None and module_name not in modules_to_run:
+                # Benchmark whitelist specified, and this one isn't in it
+                logger.info(
+                    f"module {module_name} skipped, because not in modules_to_run: "
+                    f"{modules_to_run}"
+                )
+                continue
+
+            benchmark_implementation = importlib.import_module(
+                f"benchmarks.{module_name}", __package__
+            )
+
+            # Run the functions in this benchmark
+            functions = inspect.getmembers(benchmark_implementation, inspect.isfunction)
+            for function_name, function in functions:
+                if function_name.startswith("_"):
+                    continue
+                if (
+                    functions_to_run is not None
+                    and function_name not in functions_to_run
+                ):
+                    # Function whitelist specified, and this one isn't in it
+                    logger.info(
+                        f"function {function_name} skipped, because not in "
+                        f"functions_to_run: {functions_to_run}"
+                    )
+                    continue
+
+                # Run the operation benchmark
+                logger.info(f"benchmarks.{module_name}.{function_name} start")
+                result = function(tmp_dir=tmp_dir)
+                if result is not None and isinstance(result, RunResult) is True:
+                    logger.info(
+                        f"benchmarks.{module_name}.{function_name} ready in "
+                        f"{result.secs_taken:.2f} s"
+                    )
+                    results.append(result)
+                else:
+                    logger.warning(
+                        f"benchmarks.{module_name}.{function_name} ignored: instead of "
+                        f"a RunResult it returned {result}"
+                    )
+
+    # Add results to csv file
+    results_path = Path(__file__).resolve().parent / "results/benchmark_results.csv"
+    results_dictlist = [vars(result) for result in results]
+    results_df = pd.DataFrame(results_dictlist)
+    if not results_path.exists():
+        results_df.to_csv(results_path, index=False)
+    else:
+        results_df.to_csv(results_path, index=False, mode="a", header=False)
+
+    # Generate reports
+    output_dir = Path(__file__).resolve().parent / "results"
+    reporter.generate_reports(results_path, output_dir)
+
+
+if __name__ == "__main__":
+    run_benchmarks()
```

### Comparing `geofileops-0.8.0a1/benchmark/benchmarks/benchmarks_geofileops.py` & `geofileops-0.8.0a2/benchmark/benchmarks/benchmarks_geofileops.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,295 +1,295 @@
-# -*- coding: utf-8 -*-
-"""
-Module to benchmark geofileops operations.
-"""
-
-from datetime import datetime
-import logging
-import multiprocessing
-from pathlib import Path
-import sys
-
-from benchmarker import RunResult
-from benchmarks import testdata
-
-# Add path so the benchmark packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent.parent))
-import geofileops as gfo
-from geofileops.util import _geoops_sql
-from geofileops.util import _geoops_gpd
-
-################################################################################
-# Some init
-################################################################################
-
-logger = logging.getLogger(__name__)
-
-################################################################################
-# The real work
-################################################################################
-
-
-def _get_package() -> str:
-    return "geofileops"
-
-
-def _get_version() -> str:
-    return gfo.__version__
-
-
-def buffer(tmp_dir: Path) -> RunResult:
-    # Init
-    input_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
-
-    # Go!
-    start_time = datetime.now()
-    output_path = tmp_dir / f"{input_path.stem}_buf.gpkg"
-    gfo.buffer(input_path, output_path, distance=1, force=True)
-    result = RunResult(
-        package=_get_package(),
-        package_version=_get_version(),
-        operation="buffer",
-        secs_taken=(datetime.now() - start_time).total_seconds(),
-        operation_descr="buffer on agri parcel layer BEFL (~500.000 polygons)",
-        run_details={"nb_cpu": multiprocessing.cpu_count()},
-    )
-
-    # Cleanup and return
-    output_path.unlink()
-    return result
-
-
-def buffer_spatialite(tmp_dir: Path) -> RunResult:
-    # Init
-    input_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
-
-    # Go!
-    start_time = datetime.now()
-    output_path = tmp_dir / f"{input_path.stem}_buf_spatialite.gpkg"
-    _geoops_sql.buffer(input_path, output_path, distance=1, force=True)
-    result = RunResult(
-        package=_get_package(),
-        package_version=_get_version(),
-        operation="buffer_spatialite",
-        secs_taken=(datetime.now() - start_time).total_seconds(),
-        operation_descr="buffer on agri parcel layer BEFL (~500.000 polygons)",
-        run_details={"nb_cpu": multiprocessing.cpu_count()},
-    )
-
-    # Cleanup and return
-    output_path.unlink()
-    return result
-
-
-def buffer_gpd(tmp_dir: Path) -> RunResult:
-    # Init
-    input_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
-
-    # Go!
-    start_time = datetime.now()
-    output_path = tmp_dir / f"{input_path.stem}_buf_gpd.gpkg"
-    _geoops_gpd.buffer(input_path, output_path, distance=1, force=True)
-    result = RunResult(
-        package=_get_package(),
-        package_version=_get_version(),
-        operation="buffer_gpd",
-        secs_taken=(datetime.now() - start_time).total_seconds(),
-        operation_descr="buffer on agri parcel layer BEFL (~500.000 polygons)",
-        run_details={"nb_cpu": multiprocessing.cpu_count()},
-    )
-
-    # Cleanup and return
-    output_path.unlink()
-    return result
-
-
-def dissolve_nogroupby(tmp_dir: Path) -> RunResult:
-    # Init
-    input_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
-
-    # Go!
-    start_time = datetime.now()
-    output_path = tmp_dir / f"{input_path.stem}_diss_nogroupby.gpkg"
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        explodecollections=True,
-        force=True,
-    )
-    result = RunResult(
-        package=_get_package(),
-        package_version=_get_version(),
-        operation="dissolve",
-        secs_taken=(datetime.now() - start_time).total_seconds(),
-        operation_descr="dissolve on agri parcels BEFL (~500.000 polygons)",
-        run_details={"nb_cpu": multiprocessing.cpu_count()},
-    )
-
-    # Cleanup and return
-    output_path.unlink()
-    return result
-
-
-def dissolve_groupby(tmp_dir: Path) -> RunResult:
-    # Init
-    input_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
-
-    # Go!
-    start_time = datetime.now()
-    output_path = tmp_dir / f"{input_path.stem}_diss_groupby.gpkg"
-    gfo.dissolve(
-        input_path,
-        output_path,
-        groupby_columns=["GEWASGROEP"],
-        explodecollections=True,
-        force=True,
-    )
-    result = RunResult(
-        package=_get_package(),
-        package_version=_get_version(),
-        operation="dissolve_groupby",
-        secs_taken=(datetime.now() - start_time).total_seconds(),
-        operation_descr=(
-            "dissolve on agri parcels BEFL (~500.000 polygons), groupby=[GEWASGROEP]"
-        ),
-        run_details={"nb_cpu": multiprocessing.cpu_count()},
-    )
-
-    # Cleanup and return
-    output_path.unlink()
-    return result
-
-
-def clip(tmp_dir: Path) -> RunResult:
-    # Init
-    input1_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
-    input2_path = testdata.TestFile.AGRIPRC_2019.get_file(tmp_dir)
-
-    # Go!
-    start_time = datetime.now()
-    output_path = tmp_dir / f"{input1_path.stem}_clip_{input2_path.stem}.gpkg"
-    gfo.clip(
-        input_path=input1_path,
-        clip_path=input2_path,
-        output_path=output_path,
-        force=True,
-    )
-    result = RunResult(
-        package="geofileops",
-        package_version=gfo.__version__,
-        operation="clip",
-        secs_taken=(datetime.now() - start_time).total_seconds(),
-        operation_descr="clip between 2 agri parcel layers BEFL (2*~500.000 polygons)",
-        run_details={"nb_cpu": multiprocessing.cpu_count()},
-    )
-
-    # Cleanup and return
-    # output_path.unlink()
-    return result
-
-
-def intersection(tmp_dir: Path) -> RunResult:
-    # Init
-    input1_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
-    input2_path = testdata.TestFile.AGRIPRC_2019.get_file(tmp_dir)
-
-    # Go!
-    start_time = datetime.now()
-    output_path = tmp_dir / f"{input1_path.stem}_inters_{input2_path.stem}.gpkg"
-    gfo.intersection(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        force=True,
-    )
-    result = RunResult(
-        package=_get_package(),
-        package_version=_get_version(),
-        operation="intersection",
-        secs_taken=(datetime.now() - start_time).total_seconds(),
-        operation_descr=(
-            "intersection between 2 agri parcel layers BEFL (2*~500.000 polygons)"
-        ),
-        run_details={"nb_cpu": multiprocessing.cpu_count()},
-    )
-
-    # Cleanup and return
-    output_path.unlink()
-    return result
-
-
-def join_by_location_intersects(tmp_dir: Path) -> RunResult:
-    # Init-
-    input1_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
-    input2_path = testdata.TestFile.AGRIPRC_2019.get_file(tmp_dir)
-
-    '''
-    input2_all_path = testdata.TestFile.COMMUNES.get_file(tmp_dir)
-    input2_path = input2_all_path.parent / f"{input2_all_path.stem}_filtered.gpkg"
-    sql_stmt = f"""
-                SELECT *
-                    FROM "{{input_layer}}" layer
-                    WHERE """
-    gfo.select(
-            input_path=input2_all_path,
-            output_path=input2_path,
-            sql_stmt=sql_stmt)
-    '''
-
-    # Go!
-    start_time = datetime.now()
-    output_path = (
-        tmp_dir
-        / f"{input1_path.stem}_join_inters_{input2_path.stem}_{_get_package()}.gpkg"
-    )
-    gfo.join_by_location(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        spatial_relations_query="intersects is True",
-        force=True,
-    )
-    result = RunResult(
-        package=_get_package(),
-        package_version=_get_version(),
-        operation="join_by_location_intersects",
-        secs_taken=(datetime.now() - start_time).total_seconds(),
-        operation_descr=(
-            "join_by_location_intersects between 2 agri parcel layers BEFL "
-            "(2*~500.000 polygons)"
-        ),
-        run_details={"nb_cpu": multiprocessing.cpu_count()},
-    )
-
-    # Cleanup and return
-    logger.info(f"nb features in result: {gfo.get_layerinfo(output_path).featurecount}")
-    output_path.unlink()
-    return result
-
-
-def union(tmp_dir: Path) -> RunResult:
-    # Init
-    input1_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
-    input2_path = testdata.TestFile.AGRIPRC_2019.get_file(tmp_dir)
-
-    # Go!
-    start_time = datetime.now()
-    output_path = tmp_dir / f"{input1_path.stem}_inters_{input2_path.stem}.gpkg"
-    gfo.union(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        force=True,
-    )
-    result = RunResult(
-        package=_get_package(),
-        package_version=_get_version(),
-        operation="union",
-        secs_taken=(datetime.now() - start_time).total_seconds(),
-        operation_descr="union between 2 agri parcel layers BEFL (2*~500.000 polygons)",
-        run_details={"nb_cpu": multiprocessing.cpu_count()},
-    )
-
-    # Cleanup and return
-    output_path.unlink()
-    return result
+# -*- coding: utf-8 -*-
+"""
+Module to benchmark geofileops operations.
+"""
+
+from datetime import datetime
+import logging
+import multiprocessing
+from pathlib import Path
+import sys
+
+from benchmarker import RunResult
+from benchmarks import testdata
+
+# Add path so the benchmark packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent.parent))
+import geofileops as gfo
+from geofileops.util import _geoops_sql
+from geofileops.util import _geoops_gpd
+
+################################################################################
+# Some init
+################################################################################
+
+logger = logging.getLogger(__name__)
+
+################################################################################
+# The real work
+################################################################################
+
+
+def _get_package() -> str:
+    return "geofileops"
+
+
+def _get_version() -> str:
+    return gfo.__version__
+
+
+def buffer(tmp_dir: Path) -> RunResult:
+    # Init
+    input_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
+
+    # Go!
+    start_time = datetime.now()
+    output_path = tmp_dir / f"{input_path.stem}_buf.gpkg"
+    gfo.buffer(input_path, output_path, distance=1, force=True)
+    result = RunResult(
+        package=_get_package(),
+        package_version=_get_version(),
+        operation="buffer",
+        secs_taken=(datetime.now() - start_time).total_seconds(),
+        operation_descr="buffer on agri parcel layer BEFL (~500.000 polygons)",
+        run_details={"nb_cpu": multiprocessing.cpu_count()},
+    )
+
+    # Cleanup and return
+    output_path.unlink()
+    return result
+
+
+def buffer_spatialite(tmp_dir: Path) -> RunResult:
+    # Init
+    input_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
+
+    # Go!
+    start_time = datetime.now()
+    output_path = tmp_dir / f"{input_path.stem}_buf_spatialite.gpkg"
+    _geoops_sql.buffer(input_path, output_path, distance=1, force=True)
+    result = RunResult(
+        package=_get_package(),
+        package_version=_get_version(),
+        operation="buffer_spatialite",
+        secs_taken=(datetime.now() - start_time).total_seconds(),
+        operation_descr="buffer on agri parcel layer BEFL (~500.000 polygons)",
+        run_details={"nb_cpu": multiprocessing.cpu_count()},
+    )
+
+    # Cleanup and return
+    output_path.unlink()
+    return result
+
+
+def buffer_gpd(tmp_dir: Path) -> RunResult:
+    # Init
+    input_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
+
+    # Go!
+    start_time = datetime.now()
+    output_path = tmp_dir / f"{input_path.stem}_buf_gpd.gpkg"
+    _geoops_gpd.buffer(input_path, output_path, distance=1, force=True)
+    result = RunResult(
+        package=_get_package(),
+        package_version=_get_version(),
+        operation="buffer_gpd",
+        secs_taken=(datetime.now() - start_time).total_seconds(),
+        operation_descr="buffer on agri parcel layer BEFL (~500.000 polygons)",
+        run_details={"nb_cpu": multiprocessing.cpu_count()},
+    )
+
+    # Cleanup and return
+    output_path.unlink()
+    return result
+
+
+def dissolve_nogroupby(tmp_dir: Path) -> RunResult:
+    # Init
+    input_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
+
+    # Go!
+    start_time = datetime.now()
+    output_path = tmp_dir / f"{input_path.stem}_diss_nogroupby.gpkg"
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        explodecollections=True,
+        force=True,
+    )
+    result = RunResult(
+        package=_get_package(),
+        package_version=_get_version(),
+        operation="dissolve",
+        secs_taken=(datetime.now() - start_time).total_seconds(),
+        operation_descr="dissolve on agri parcels BEFL (~500.000 polygons)",
+        run_details={"nb_cpu": multiprocessing.cpu_count()},
+    )
+
+    # Cleanup and return
+    output_path.unlink()
+    return result
+
+
+def dissolve_groupby(tmp_dir: Path) -> RunResult:
+    # Init
+    input_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
+
+    # Go!
+    start_time = datetime.now()
+    output_path = tmp_dir / f"{input_path.stem}_diss_groupby.gpkg"
+    gfo.dissolve(
+        input_path,
+        output_path,
+        groupby_columns=["GEWASGROEP"],
+        explodecollections=True,
+        force=True,
+    )
+    result = RunResult(
+        package=_get_package(),
+        package_version=_get_version(),
+        operation="dissolve_groupby",
+        secs_taken=(datetime.now() - start_time).total_seconds(),
+        operation_descr=(
+            "dissolve on agri parcels BEFL (~500.000 polygons), groupby=[GEWASGROEP]"
+        ),
+        run_details={"nb_cpu": multiprocessing.cpu_count()},
+    )
+
+    # Cleanup and return
+    output_path.unlink()
+    return result
+
+
+def clip(tmp_dir: Path) -> RunResult:
+    # Init
+    input1_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
+    input2_path = testdata.TestFile.AGRIPRC_2019.get_file(tmp_dir)
+
+    # Go!
+    start_time = datetime.now()
+    output_path = tmp_dir / f"{input1_path.stem}_clip_{input2_path.stem}.gpkg"
+    gfo.clip(
+        input_path=input1_path,
+        clip_path=input2_path,
+        output_path=output_path,
+        force=True,
+    )
+    result = RunResult(
+        package="geofileops",
+        package_version=gfo.__version__,
+        operation="clip",
+        secs_taken=(datetime.now() - start_time).total_seconds(),
+        operation_descr="clip between 2 agri parcel layers BEFL (2*~500.000 polygons)",
+        run_details={"nb_cpu": multiprocessing.cpu_count()},
+    )
+
+    # Cleanup and return
+    # output_path.unlink()
+    return result
+
+
+def intersection(tmp_dir: Path) -> RunResult:
+    # Init
+    input1_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
+    input2_path = testdata.TestFile.AGRIPRC_2019.get_file(tmp_dir)
+
+    # Go!
+    start_time = datetime.now()
+    output_path = tmp_dir / f"{input1_path.stem}_inters_{input2_path.stem}.gpkg"
+    gfo.intersection(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        force=True,
+    )
+    result = RunResult(
+        package=_get_package(),
+        package_version=_get_version(),
+        operation="intersection",
+        secs_taken=(datetime.now() - start_time).total_seconds(),
+        operation_descr=(
+            "intersection between 2 agri parcel layers BEFL (2*~500.000 polygons)"
+        ),
+        run_details={"nb_cpu": multiprocessing.cpu_count()},
+    )
+
+    # Cleanup and return
+    output_path.unlink()
+    return result
+
+
+def join_by_location_intersects(tmp_dir: Path) -> RunResult:
+    # Init-
+    input1_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
+    input2_path = testdata.TestFile.AGRIPRC_2019.get_file(tmp_dir)
+
+    '''
+    input2_all_path = testdata.TestFile.COMMUNES.get_file(tmp_dir)
+    input2_path = input2_all_path.parent / f"{input2_all_path.stem}_filtered.gpkg"
+    sql_stmt = f"""
+                SELECT *
+                    FROM "{{input_layer}}" layer
+                    WHERE """
+    gfo.select(
+            input_path=input2_all_path,
+            output_path=input2_path,
+            sql_stmt=sql_stmt)
+    '''
+
+    # Go!
+    start_time = datetime.now()
+    output_path = (
+        tmp_dir
+        / f"{input1_path.stem}_join_inters_{input2_path.stem}_{_get_package()}.gpkg"
+    )
+    gfo.join_by_location(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        spatial_relations_query="intersects is True",
+        force=True,
+    )
+    result = RunResult(
+        package=_get_package(),
+        package_version=_get_version(),
+        operation="join_by_location_intersects",
+        secs_taken=(datetime.now() - start_time).total_seconds(),
+        operation_descr=(
+            "join_by_location_intersects between 2 agri parcel layers BEFL "
+            "(2*~500.000 polygons)"
+        ),
+        run_details={"nb_cpu": multiprocessing.cpu_count()},
+    )
+
+    # Cleanup and return
+    logger.info(f"nb features in result: {gfo.get_layerinfo(output_path).featurecount}")
+    output_path.unlink()
+    return result
+
+
+def union(tmp_dir: Path) -> RunResult:
+    # Init
+    input1_path = testdata.TestFile.AGRIPRC_2018.get_file(tmp_dir)
+    input2_path = testdata.TestFile.AGRIPRC_2019.get_file(tmp_dir)
+
+    # Go!
+    start_time = datetime.now()
+    output_path = tmp_dir / f"{input1_path.stem}_inters_{input2_path.stem}.gpkg"
+    gfo.union(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        force=True,
+    )
+    result = RunResult(
+        package=_get_package(),
+        package_version=_get_version(),
+        operation="union",
+        secs_taken=(datetime.now() - start_time).total_seconds(),
+        operation_descr="union between 2 agri parcel layers BEFL (2*~500.000 polygons)",
+        run_details={"nb_cpu": multiprocessing.cpu_count()},
+    )
+
+    # Cleanup and return
+    output_path.unlink()
+    return result
```

### Comparing `geofileops-0.8.0a1/benchmark/benchmarks/testdata.py` & `geofileops-0.8.0a2/benchmark/benchmarks/testdata.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,150 +1,150 @@
-# -*- coding: utf-8 -*-
-"""
-Module to prepare test data for benchmarking geo operations.
-"""
-
-import enum
-import logging
-from pathlib import Path
-import pprint
-import shutil
-import sys
-import tempfile
-from typing import Optional
-import urllib.request
-import zipfile
-
-# Add path so the benchmark packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent.parent))
-import geofileops as gfo
-
-################################################################################
-# Some inits
-################################################################################
-
-logger = logging.getLogger(__name__)
-
-################################################################################
-# The real work
-################################################################################
-
-
-class TestFile(enum.Enum):
-    AGRIPRC_2018 = (
-        0,
-        "https://downloadagiv.blob.core.windows.net/landbouwgebruikspercelen/2018/Landbouwgebruikspercelen_LV_2018_GewVLA_Shape.zip",  # noqa: E501
-        "agriprc_2018.gpkg",
-    )
-    AGRIPRC_2019 = (
-        1,
-        "https://downloadagiv.blob.core.windows.net/landbouwgebruikspercelen/2019/Landbouwgebruikspercelen_LV_2019_GewVLA_Shapefile.zip",  # noqa: E501
-        "agriprc_2019.gpkg",
-    )
-    COMMUNES = (
-        2,
-        "https://downloadagiv.blob.core.windows.net/referentiebestand-gemeenten/VoorlopigRefBestandGemeentegrenzen_2019-01-01/VRBG_toestand_16_05_2018_(geldend_vanaf_01_01_2019)_GewVLA_Shape.zip",  # noqa: E501
-        "communes.gpkg",
-    )
-
-    def __init__(self, value, url, filename):
-        self._value_ = value
-        self.url = url
-        self.filename = filename
-
-    def get_file(self, tmp_dir: Path) -> Path:
-        testfile_path = download_samplefile(
-            url=self.url, dst_name=self.filename, dst_dir=tmp_dir
-        )
-        testfile_info = gfo.get_layerinfo(testfile_path)
-        logger.debug(
-            f"TestFile {self.name} contains {testfile_info.featurecount} rows."
-        )
-
-        return testfile_path
-
-
-def download_samplefile(
-    url: str, dst_name: str, dst_dir: Optional[Path] = None
-) -> Path:
-    """
-    Download a sample file to dest_path.
-
-    If it is zipped, it will be unzipped. If needed, it will be converted to
-    the file type as determined by the suffix of dst_name.
-
-    Args:
-        url (str): the url of the file to download
-        dst_dir (Path): the dir to downloaded the sample file to.
-            If it is None, a dir in the default tmp location will be
-            used. Defaults to None.
-
-    Returns:
-        Path: the path to the downloaded sample file.
-    """
-    # If the destination path is a directory, use the default file name
-    dst_path = prepare_dst_path(dst_name, dst_dir)
-    # If the sample file already exists, return
-    if dst_path.exists():
-        return dst_path
-    # Make sure the destination directory exists
-    dst_path.parent.mkdir(parents=True, exist_ok=True)
-
-    # If the url points to a file with the same suffix as the dst_path,
-    # just download
-    url_path = Path(url)
-    if url_path.suffix.lower() == dst_path.suffix.lower():
-        logger.info(f"Download to {dst_path}")
-        urllib.request.urlretrieve(url, dst_path)
-    else:
-        # The file downloaded is different that the destination wanted, so some
-        # converting will need to be done
-        tmp_dir = dst_path.parent / "tmp"
-
-        try:
-            # Remove tmp dir if it exists already
-            if tmp_dir.exists():
-                shutil.rmtree(tmp_dir)
-            tmp_dir.mkdir(parents=True, exist_ok=True)
-
-            # Download file
-            tmp_path = tmp_dir / f"{dst_path.stem}{url_path.suffix.lower()}"
-            logger.info(f"Download tmp data to {tmp_path}")
-            urllib.request.urlretrieve(url, tmp_path)
-
-            # If the temp file is a .zip file, unzip to dir
-            if tmp_path.suffix == ".zip":
-                # Unzip
-                unzippedzip_dir = dst_path.parent / tmp_path.stem
-                logger.info(f"Unzip to {unzippedzip_dir}")
-                with zipfile.ZipFile(tmp_path, "r") as zip_ref:
-                    zip_ref.extractall(unzippedzip_dir)
-
-                # Look for the file
-                tmp_paths = []
-                for suffix in [".shp", ".gpkg"]:
-                    tmp_paths.extend(list(unzippedzip_dir.rglob(f"*{suffix}")))
-                if len(tmp_paths) == 1:
-                    tmp_path = tmp_paths[0]
-                else:
-                    raise Exception(
-                        f"Should find 1 geofile, found {len(tmp_paths)}: \n"
-                        f"{pprint.pformat(tmp_paths)}"
-                    )
-
-            if dst_path.suffix == tmp_path.suffix:
-                gfo.move(tmp_path, dst_path)
-            else:
-                logger.info(f"Convert tmp file to {dst_path}")
-                gfo.makevalid(tmp_path, dst_path)
-        finally:
-            if tmp_dir.exists():
-                shutil.rmtree(tmp_dir)
-
-    return dst_path
-
-
-def prepare_dst_path(dst_name: str, dst_dir: Optional[Path] = None):
-    if dst_dir is None:
-        return Path(tempfile.gettempdir()) / "geofileops_sampledata" / dst_name
-    else:
-        return dst_dir / dst_name
+# -*- coding: utf-8 -*-
+"""
+Module to prepare test data for benchmarking geo operations.
+"""
+
+import enum
+import logging
+from pathlib import Path
+import pprint
+import shutil
+import sys
+import tempfile
+from typing import Optional
+import urllib.request
+import zipfile
+
+# Add path so the benchmark packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent.parent))
+import geofileops as gfo
+
+################################################################################
+# Some inits
+################################################################################
+
+logger = logging.getLogger(__name__)
+
+################################################################################
+# The real work
+################################################################################
+
+
+class TestFile(enum.Enum):
+    AGRIPRC_2018 = (
+        0,
+        "https://downloadagiv.blob.core.windows.net/landbouwgebruikspercelen/2018/Landbouwgebruikspercelen_LV_2018_GewVLA_Shape.zip",  # noqa: E501
+        "agriprc_2018.gpkg",
+    )
+    AGRIPRC_2019 = (
+        1,
+        "https://downloadagiv.blob.core.windows.net/landbouwgebruikspercelen/2019/Landbouwgebruikspercelen_LV_2019_GewVLA_Shapefile.zip",  # noqa: E501
+        "agriprc_2019.gpkg",
+    )
+    COMMUNES = (
+        2,
+        "https://downloadagiv.blob.core.windows.net/referentiebestand-gemeenten/VoorlopigRefBestandGemeentegrenzen_2019-01-01/VRBG_toestand_16_05_2018_(geldend_vanaf_01_01_2019)_GewVLA_Shape.zip",  # noqa: E501
+        "communes.gpkg",
+    )
+
+    def __init__(self, value, url, filename):
+        self._value_ = value
+        self.url = url
+        self.filename = filename
+
+    def get_file(self, tmp_dir: Path) -> Path:
+        testfile_path = download_samplefile(
+            url=self.url, dst_name=self.filename, dst_dir=tmp_dir
+        )
+        testfile_info = gfo.get_layerinfo(testfile_path)
+        logger.debug(
+            f"TestFile {self.name} contains {testfile_info.featurecount} rows."
+        )
+
+        return testfile_path
+
+
+def download_samplefile(
+    url: str, dst_name: str, dst_dir: Optional[Path] = None
+) -> Path:
+    """
+    Download a sample file to dest_path.
+
+    If it is zipped, it will be unzipped. If needed, it will be converted to
+    the file type as determined by the suffix of dst_name.
+
+    Args:
+        url (str): the url of the file to download
+        dst_dir (Path): the dir to downloaded the sample file to.
+            If it is None, a dir in the default tmp location will be
+            used. Defaults to None.
+
+    Returns:
+        Path: the path to the downloaded sample file.
+    """
+    # If the destination path is a directory, use the default file name
+    dst_path = prepare_dst_path(dst_name, dst_dir)
+    # If the sample file already exists, return
+    if dst_path.exists():
+        return dst_path
+    # Make sure the destination directory exists
+    dst_path.parent.mkdir(parents=True, exist_ok=True)
+
+    # If the url points to a file with the same suffix as the dst_path,
+    # just download
+    url_path = Path(url)
+    if url_path.suffix.lower() == dst_path.suffix.lower():
+        logger.info(f"Download to {dst_path}")
+        urllib.request.urlretrieve(url, dst_path)
+    else:
+        # The file downloaded is different that the destination wanted, so some
+        # converting will need to be done
+        tmp_dir = dst_path.parent / "tmp"
+
+        try:
+            # Remove tmp dir if it exists already
+            if tmp_dir.exists():
+                shutil.rmtree(tmp_dir)
+            tmp_dir.mkdir(parents=True, exist_ok=True)
+
+            # Download file
+            tmp_path = tmp_dir / f"{dst_path.stem}{url_path.suffix.lower()}"
+            logger.info(f"Download tmp data to {tmp_path}")
+            urllib.request.urlretrieve(url, tmp_path)
+
+            # If the temp file is a .zip file, unzip to dir
+            if tmp_path.suffix == ".zip":
+                # Unzip
+                unzippedzip_dir = dst_path.parent / tmp_path.stem
+                logger.info(f"Unzip to {unzippedzip_dir}")
+                with zipfile.ZipFile(tmp_path, "r") as zip_ref:
+                    zip_ref.extractall(unzippedzip_dir)
+
+                # Look for the file
+                tmp_paths = []
+                for suffix in [".shp", ".gpkg"]:
+                    tmp_paths.extend(list(unzippedzip_dir.rglob(f"*{suffix}")))
+                if len(tmp_paths) == 1:
+                    tmp_path = tmp_paths[0]
+                else:
+                    raise Exception(
+                        f"Should find 1 geofile, found {len(tmp_paths)}: \n"
+                        f"{pprint.pformat(tmp_paths)}"
+                    )
+
+            if dst_path.suffix == tmp_path.suffix:
+                gfo.move(tmp_path, dst_path)
+            else:
+                logger.info(f"Convert tmp file to {dst_path}")
+                gfo.makevalid(tmp_path, dst_path)
+        finally:
+            if tmp_dir.exists():
+                shutil.rmtree(tmp_dir)
+
+    return dst_path
+
+
+def prepare_dst_path(dst_name: str, dst_dir: Optional[Path] = None):
+    if dst_dir is None:
+        return Path(tempfile.gettempdir()) / "geofileops_sampledata" / dst_name
+    else:
+        return dst_dir / dst_name
```

### Comparing `geofileops-0.8.0a1/benchmark/reporter.py` & `geofileops-0.8.0a2/benchmark/reporter.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,257 +1,257 @@
-# -*- coding: utf-8 -*-
-"""
-Module to generate reports for benchmarks.
-"""
-
-import ast
-import math
-import os
-from pathlib import Path
-from typing import Literal, Optional, Tuple
-
-import matplotlib.pyplot as plt
-import numpy as np
-import pandas as pd
-import pandas.api
-
-A4_LONG_SIDE = 11.69
-A4_SHORT_SIDE = 8.27
-
-
-def generate_reports(results_path: Path, output_dir: Path):
-    benchmark_df = pd.read_csv(results_path)
-
-    def format_run_details(input: dict) -> str:
-        if input is None or input == np.nan:
-            return ""
-        if isinstance(input, str):
-            input = ast.literal_eval(input)
-            result_list = [f"{key}:{input[key]}" for key in input]
-            return ";".join(result_list)
-
-        return ""
-
-    # Detailed report per package and per operation
-    for package in benchmark_df["package"].unique():
-        reports_package_dir = output_dir / package
-        reports_package_dir.mkdir(parents=True, exist_ok=True)
-
-        package_df = benchmark_df.loc[benchmark_df["package"] == package]
-        for operation in package_df["operation"].unique():
-            package_operation_df = package_df.loc[
-                benchmark_df["operation"] == operation
-            ]
-            operation_descr = package_operation_df[
-                package_operation_df["run_datetime"]
-                == package_operation_df["run_datetime"].max()
-            ]["operation_descr"].item()
-            package_operation_df = package_operation_df[
-                ["package_version", "run_details", "secs_taken"]
-            ]
-            package_operation_df["run_details"] = package_operation_df[
-                "run_details"
-            ].apply(lambda x: format_run_details(x))
-            package_operation_df = package_operation_df.set_index(
-                ["package_version", "run_details"]
-            )
-            results_report_path = reports_package_dir / f"{package}_{operation}.png"
-            save_chart(
-                df=package_operation_df,
-                title=f"{package}-{operation}\n({operation_descr})",
-                size=(8, 6),
-                print_labels_on_points=True,
-                y_value_formatter="{0:.2f}",
-                output_path=results_report_path,
-            )
-
-    # Report for last version of each package+operation for comparison
-    benchmark_maxversions_df = (
-        benchmark_df[["package", "operation", "package_version"]]
-        .sort_values(["package", "operation", "package_version"], ascending=False)
-        .groupby(["package", "operation"])
-        .first()
-        .reset_index()
-        .set_index(["package", "operation", "package_version"])
-    )
-    benchmark_maxversion_df = benchmark_df.set_index(
-        ["package", "operation", "package_version"]
-    )
-    benchmark_maxversion_df = (
-        benchmark_maxversion_df.loc[
-            benchmark_maxversion_df.index.isin(benchmark_maxversions_df.index)
-        ].reset_index()
-    )[["package", "package_version", "operation", "secs_taken"]]
-    benchmark_maxversion_df = benchmark_maxversion_df.pivot_table(
-        index="operation", columns=["package", "package_version"]
-    )
-    # Drop the "secs_taken" level to cleanup legend in chart
-    benchmark_maxversion_df = benchmark_maxversion_df.droplevel(level=0, axis=1)
-    results_report_path = output_dir / "GeoBenchmark.png"
-    save_chart(
-        df=benchmark_maxversion_df,
-        title="Comparison of libraries, time in sec",
-        output_path=results_report_path,
-        yscale="log",
-        print_labels_on_points=True,
-        y_value_formatter="{0:.0f}",
-        size=(8, 6),
-        linestyle="None",
-        gridlines="y",
-    )
-
-
-def save_chart(
-    df: pd.DataFrame,
-    title: str,
-    output_path: Path,
-    yscale: Optional[Literal["linear", "log", "symlog", "logit"]] = None,
-    y_value_formatter: Optional[str] = None,
-    print_labels_on_points: bool = False,
-    open_output_file: bool = False,
-    size: Tuple[float, float] = (8, 4),
-    plot_kind: Literal[
-        "line",
-        "bar",
-        "barh",
-        "hist",
-        "box",
-        "kde",
-        "density",
-        "area",
-        "pie",
-        "scatter",
-        "hexbin",
-    ] = "line",
-    gridlines: Optional[Literal["both", "x", "y"]] = None,
-    linestyle: Optional[str] = None,
-):
-    """
-    Render and save a chart.
-
-    Args:
-        df (pd.DataFrame): _description_
-        title (str): _description_
-        output_path (Path): _description_
-        yscale (Literal["linear", "log", "symlog", "logit"], optional): y scale to use.
-        y_value_formatter (str, optional): a formatter for the y axes and
-            labels. Examples:
-              - {0:.2%} for a percentage.
-              - {0:.2f} for a float with two decimals.
-            Defaults to None.
-        print_labels_on_points (bool, optional): _description_. Defaults to False.
-        open_output_file (bool, optional): _description_. Defaults to False.
-        size (Tuple[float, float], optional): _description_. Defaults to (8, 4).
-        plot_kind (str, optional): _description_. Defaults to "line".
-        gridlines (str, optional): where to draw grid lines:
-
-                - 'x': draw grid lines on the x axis
-                - 'y': draw grid lines on the x axis
-                - 'both': draw grid lines on both axes
-            If None, the default for the style used is used. Defaults to None.
-        linestyle (Optional[str], optional): _description_. Defaults to None.
-
-    Raises:
-        Exception: _description_
-    """
-
-    # Init
-    # Check input
-    non_numeric_columns = [
-        column
-        for column in df.columns
-        if not pandas.api.types.is_numeric_dtype(df[column])
-    ]
-    if len(non_numeric_columns) > 0:
-        raise Exception(
-            f"df has non-numeric columns, so cannot be plotted: {non_numeric_columns}"
-        )
-
-    # Init some things based on input
-    rot = 90
-
-    # Prepare plot figure and axes
-    fig, axs = plt.subplots(figsize=(size))
-    # Make sure all x axis values are shown
-    axs.set_xticks(range(len(df)))
-    if yscale is not None:
-        plt.yscale(yscale)
-
-    # Plot
-    df.plot(ax=axs, kind=plot_kind, rot=rot, title=title, linestyle=linestyle)
-
-    # Show y axes as percentages is asked
-    if y_value_formatter is not None:
-        axs.yaxis.set_major_formatter(
-            plt.FuncFormatter(y_value_formatter.format)  # type: ignore
-        )
-        axs.yaxis.set_minor_formatter(
-            plt.FuncFormatter(y_value_formatter.format)  # type: ignore
-        )
-
-    # Show grid lines if specified
-    if gridlines is not None:
-        axs.grid(axis=gridlines, which="both")
-
-    # Set different markers + print labels
-    # Set different markers for each line + get mn/max values + print labels
-    markers = ("+", ".", "o", "*")
-    max_y_value = None
-    min_y_value = None
-    for i, line in enumerate(axs.get_lines()):
-        line.set_marker(markers[i % len(markers)])
-
-        label_above_line = True
-        for index, row in enumerate(df.itertuples()):
-            for row_fieldname, row_fieldvalue in row._asdict().items():
-                if row_fieldname != "Index":
-                    if max_y_value is None or row_fieldvalue > max_y_value:
-                        max_y_value = row_fieldvalue
-                    if min_y_value is None or row_fieldvalue < min_y_value:
-                        min_y_value = row_fieldvalue
-                    if print_labels_on_points is True:
-                        # Format label
-                        if y_value_formatter is not None:
-                            text = y_value_formatter.format(row_fieldvalue)
-                        else:
-                            text = str(row_fieldvalue)
-
-                        # Label below or above line? + switch
-                        if label_above_line is True:
-                            xytext = (0, 5)
-                            label_above_line = False
-                        else:
-                            xytext = (0, -15)
-                            label_above_line = True
-
-                        axs.annotate(
-                            text=text,  # type: ignore
-                            # s=text,
-                            # xy=(row.Index, row_fieldvalue),
-                            xy=(index, row_fieldvalue),
-                            xytext=xytext,
-                            textcoords="offset points",
-                            ha="center",
-                        )
-
-    # Set bottom and top values for y axis
-    if max_y_value is not None:
-        max_y_value *= 1.1
-    if max_y_value is not None and math.isnan(max_y_value) is False:
-        plt.ylim(bottom=0, top=max_y_value)
-    else:
-        plt.ylim(bottom=0)
-
-    # Set legend to the right of the chart
-    plt.legend(loc="center left", bbox_to_anchor=(1, 0.5))
-    plt.tight_layout()
-
-    # Save and open if wanted
-    fig.savefig(str(output_path))
-    if open_output_file is True:
-        os.startfile(output_path)
-
-
-if __name__ == "__main__":
-    results_path = Path(__file__).resolve().parent / "results/benchmark_results.csv"
-    output_dir = Path(__file__).resolve().parent / "results"
-    generate_reports(results_path, output_dir)
+# -*- coding: utf-8 -*-
+"""
+Module to generate reports for benchmarks.
+"""
+
+import ast
+import math
+import os
+from pathlib import Path
+from typing import Literal, Optional, Tuple
+
+import matplotlib.pyplot as plt
+import numpy as np
+import pandas as pd
+import pandas.api
+
+A4_LONG_SIDE = 11.69
+A4_SHORT_SIDE = 8.27
+
+
+def generate_reports(results_path: Path, output_dir: Path):
+    benchmark_df = pd.read_csv(results_path)
+
+    def format_run_details(input: dict) -> str:
+        if input is None or input == np.nan:
+            return ""
+        if isinstance(input, str):
+            input = ast.literal_eval(input)
+            result_list = [f"{key}:{input[key]}" for key in input]
+            return ";".join(result_list)
+
+        return ""
+
+    # Detailed report per package and per operation
+    for package in benchmark_df["package"].unique():
+        reports_package_dir = output_dir / package
+        reports_package_dir.mkdir(parents=True, exist_ok=True)
+
+        package_df = benchmark_df.loc[benchmark_df["package"] == package]
+        for operation in package_df["operation"].unique():
+            package_operation_df = package_df.loc[
+                benchmark_df["operation"] == operation
+            ]
+            operation_descr = package_operation_df[
+                package_operation_df["run_datetime"]
+                == package_operation_df["run_datetime"].max()
+            ]["operation_descr"].item()
+            package_operation_df = package_operation_df[
+                ["package_version", "run_details", "secs_taken"]
+            ]
+            package_operation_df["run_details"] = package_operation_df[
+                "run_details"
+            ].apply(lambda x: format_run_details(x))
+            package_operation_df = package_operation_df.set_index(
+                ["package_version", "run_details"]
+            )
+            results_report_path = reports_package_dir / f"{package}_{operation}.png"
+            save_chart(
+                df=package_operation_df,
+                title=f"{package}-{operation}\n({operation_descr})",
+                size=(8, 6),
+                print_labels_on_points=True,
+                y_value_formatter="{0:.2f}",
+                output_path=results_report_path,
+            )
+
+    # Report for last version of each package+operation for comparison
+    benchmark_maxversions_df = (
+        benchmark_df[["package", "operation", "package_version"]]
+        .sort_values(["package", "operation", "package_version"], ascending=False)
+        .groupby(["package", "operation"])
+        .first()
+        .reset_index()
+        .set_index(["package", "operation", "package_version"])
+    )
+    benchmark_maxversion_df = benchmark_df.set_index(
+        ["package", "operation", "package_version"]
+    )
+    benchmark_maxversion_df = (
+        benchmark_maxversion_df.loc[
+            benchmark_maxversion_df.index.isin(benchmark_maxversions_df.index)
+        ].reset_index()
+    )[["package", "package_version", "operation", "secs_taken"]]
+    benchmark_maxversion_df = benchmark_maxversion_df.pivot_table(
+        index="operation", columns=["package", "package_version"]
+    )
+    # Drop the "secs_taken" level to cleanup legend in chart
+    benchmark_maxversion_df = benchmark_maxversion_df.droplevel(level=0, axis=1)
+    results_report_path = output_dir / "GeoBenchmark.png"
+    save_chart(
+        df=benchmark_maxversion_df,
+        title="Comparison of libraries, time in sec",
+        output_path=results_report_path,
+        yscale="log",
+        print_labels_on_points=True,
+        y_value_formatter="{0:.0f}",
+        size=(8, 6),
+        linestyle="None",
+        gridlines="y",
+    )
+
+
+def save_chart(
+    df: pd.DataFrame,
+    title: str,
+    output_path: Path,
+    yscale: Optional[Literal["linear", "log", "symlog", "logit"]] = None,
+    y_value_formatter: Optional[str] = None,
+    print_labels_on_points: bool = False,
+    open_output_file: bool = False,
+    size: Tuple[float, float] = (8, 4),
+    plot_kind: Literal[
+        "line",
+        "bar",
+        "barh",
+        "hist",
+        "box",
+        "kde",
+        "density",
+        "area",
+        "pie",
+        "scatter",
+        "hexbin",
+    ] = "line",
+    gridlines: Optional[Literal["both", "x", "y"]] = None,
+    linestyle: Optional[str] = None,
+):
+    """
+    Render and save a chart.
+
+    Args:
+        df (pd.DataFrame): _description_
+        title (str): _description_
+        output_path (Path): _description_
+        yscale (Literal["linear", "log", "symlog", "logit"], optional): y scale to use.
+        y_value_formatter (str, optional): a formatter for the y axes and
+            labels. Examples:
+              - {0:.2%} for a percentage.
+              - {0:.2f} for a float with two decimals.
+            Defaults to None.
+        print_labels_on_points (bool, optional): _description_. Defaults to False.
+        open_output_file (bool, optional): _description_. Defaults to False.
+        size (Tuple[float, float], optional): _description_. Defaults to (8, 4).
+        plot_kind (str, optional): _description_. Defaults to "line".
+        gridlines (str, optional): where to draw grid lines:
+
+                - 'x': draw grid lines on the x axis
+                - 'y': draw grid lines on the x axis
+                - 'both': draw grid lines on both axes
+            If None, the default for the style used is used. Defaults to None.
+        linestyle (Optional[str], optional): _description_. Defaults to None.
+
+    Raises:
+        Exception: _description_
+    """
+
+    # Init
+    # Check input
+    non_numeric_columns = [
+        column
+        for column in df.columns
+        if not pandas.api.types.is_numeric_dtype(df[column])
+    ]
+    if len(non_numeric_columns) > 0:
+        raise Exception(
+            f"df has non-numeric columns, so cannot be plotted: {non_numeric_columns}"
+        )
+
+    # Init some things based on input
+    rot = 90
+
+    # Prepare plot figure and axes
+    fig, axs = plt.subplots(figsize=(size))
+    # Make sure all x axis values are shown
+    axs.set_xticks(range(len(df)))
+    if yscale is not None:
+        plt.yscale(yscale)
+
+    # Plot
+    df.plot(ax=axs, kind=plot_kind, rot=rot, title=title, linestyle=linestyle)
+
+    # Show y axes as percentages is asked
+    if y_value_formatter is not None:
+        axs.yaxis.set_major_formatter(
+            plt.FuncFormatter(y_value_formatter.format)  # type: ignore
+        )
+        axs.yaxis.set_minor_formatter(
+            plt.FuncFormatter(y_value_formatter.format)  # type: ignore
+        )
+
+    # Show grid lines if specified
+    if gridlines is not None:
+        axs.grid(axis=gridlines, which="both")
+
+    # Set different markers + print labels
+    # Set different markers for each line + get mn/max values + print labels
+    markers = ("+", ".", "o", "*")
+    max_y_value = None
+    min_y_value = None
+    for i, line in enumerate(axs.get_lines()):
+        line.set_marker(markers[i % len(markers)])
+
+        label_above_line = True
+        for index, row in enumerate(df.itertuples()):
+            for row_fieldname, row_fieldvalue in row._asdict().items():
+                if row_fieldname != "Index":
+                    if max_y_value is None or row_fieldvalue > max_y_value:
+                        max_y_value = row_fieldvalue
+                    if min_y_value is None or row_fieldvalue < min_y_value:
+                        min_y_value = row_fieldvalue
+                    if print_labels_on_points is True:
+                        # Format label
+                        if y_value_formatter is not None:
+                            text = y_value_formatter.format(row_fieldvalue)
+                        else:
+                            text = str(row_fieldvalue)
+
+                        # Label below or above line? + switch
+                        if label_above_line is True:
+                            xytext = (0, 5)
+                            label_above_line = False
+                        else:
+                            xytext = (0, -15)
+                            label_above_line = True
+
+                        axs.annotate(
+                            text=text,  # type: ignore
+                            # s=text,
+                            # xy=(row.Index, row_fieldvalue),
+                            xy=(index, row_fieldvalue),
+                            xytext=xytext,
+                            textcoords="offset points",
+                            ha="center",
+                        )
+
+    # Set bottom and top values for y axis
+    if max_y_value is not None:
+        max_y_value *= 1.1
+    if max_y_value is not None and math.isnan(max_y_value) is False:
+        plt.ylim(bottom=0, top=max_y_value)
+    else:
+        plt.ylim(bottom=0)
+
+    # Set legend to the right of the chart
+    plt.legend(loc="center left", bbox_to_anchor=(1, 0.5))
+    plt.tight_layout()
+
+    # Save and open if wanted
+    fig.savefig(str(output_path))
+    if open_output_file is True:
+        os.startfile(output_path)
+
+
+if __name__ == "__main__":
+    results_path = Path(__file__).resolve().parent / "results/benchmark_results.csv"
+    output_dir = Path(__file__).resolve().parent / "results"
+    generate_reports(results_path, output_dir)
```

### Comparing `geofileops-0.8.0a1/geofileops/fileops.py` & `geofileops-0.8.0a2/geofileops/fileops.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,5526 +1,5198 @@
 00000000: 2320 2d2a 2d20 636f 6469 6e67 3a20 7574  # -*- coding: ut
-00000010: 662d 3820 2d2a 2d0d 0a22 2222 0d0a 4d6f  f-8 -*-.."""..Mo
-00000020: 6475 6c65 2077 6974 6820 6865 6c70 6572  dule with helper
-00000030: 2066 756e 6374 696f 6e73 2066 6f72 2067   functions for g
-00000040: 656f 2066 696c 6573 2e0d 0a22 2222 0d0a  eo files..."""..
-00000050: 0d0a 696d 706f 7274 2065 6e75 6d0d 0a69  ..import enum..i
-00000060: 6d70 6f72 7420 6461 7465 7469 6d65 0d0a  mport datetime..
-00000070: 696d 706f 7274 2066 696c 6563 6d70 0d0a  import filecmp..
-00000080: 696d 706f 7274 206c 6f67 6769 6e67 0d0a  import logging..
-00000090: 696d 706f 7274 206f 730d 0a66 726f 6d20  import os..from 
-000000a0: 7061 7468 6c69 6220 696d 706f 7274 2050  pathlib import P
-000000b0: 6174 680d 0a69 6d70 6f72 7420 7070 7269  ath..import ppri
-000000c0: 6e74 0d0a 696d 706f 7274 2073 6875 7469  nt..import shuti
-000000d0: 6c0d 0a69 6d70 6f72 7420 7374 7269 6e67  l..import string
-000000e0: 0d0a 696d 706f 7274 2074 656d 7066 696c  ..import tempfil
-000000f0: 650d 0a69 6d70 6f72 7420 7469 6d65 0d0a  e..import time..
-00000100: 6672 6f6d 2074 7970 696e 6720 696d 706f  from typing impo
-00000110: 7274 2041 6e79 2c20 4469 6374 2c20 4974  rt Any, Dict, It
-00000120: 6572 6162 6c65 2c20 4c69 7374 2c20 4c69  erable, List, Li
-00000130: 7465 7261 6c2c 204f 7074 696f 6e61 6c2c  teral, Optional,
-00000140: 2054 7570 6c65 2c20 556e 696f 6e0d 0a69   Tuple, Union..i
-00000150: 6d70 6f72 7420 7761 726e 696e 6773 0d0a  mport warnings..
-00000160: 0d0a 696d 706f 7274 2066 696f 6e61 0d0a  ..import fiona..
-00000170: 696d 706f 7274 2067 656f 7061 6e64 6173  import geopandas
-00000180: 2061 7320 6770 640d 0a66 726f 6d20 6765   as gpd..from ge
-00000190: 6f70 616e 6461 732e 696f 2069 6d70 6f72  opandas.io impor
-000001a0: 7420 6669 6c65 2061 7320 6770 645f 696f  t file as gpd_io
-000001b0: 5f66 696c 650d 0a69 6d70 6f72 7420 6e75  _file..import nu
-000001c0: 6d70 7920 6173 206e 700d 0a66 726f 6d20  mpy as np..from 
-000001d0: 6f73 6765 6f20 696d 706f 7274 2067 6461  osgeo import gda
-000001e0: 6c0d 0a69 6d70 6f72 7420 7061 6e64 6173  l..import pandas
-000001f0: 2061 7320 7064 0d0a 696d 706f 7274 2070   as pd..import p
-00000200: 796f 6772 696f 0d0a 696d 706f 7274 2070  yogrio..import p
-00000210: 7970 726f 6a0d 0a0d 0a66 726f 6d20 6765  yproj....from ge
-00000220: 6f66 696c 656f 7073 2e75 7469 6c20 696d  ofileops.util im
-00000230: 706f 7274 2067 656f 6d65 7472 795f 7574  port geometry_ut
-00000240: 696c 0d0a 6672 6f6d 2067 656f 6669 6c65  il..from geofile
-00000250: 6f70 732e 7574 696c 2e67 656f 6d65 7472  ops.util.geometr
-00000260: 795f 7574 696c 2069 6d70 6f72 7420 4765  y_util import Ge
-00000270: 6f6d 6574 7279 5479 7065 2c20 5072 696d  ometryType, Prim
-00000280: 6974 6976 6554 7970 6520 2023 206e 6f71  itiveType  # noq
-00000290: 613a 2046 3430 310d 0a66 726f 6d20 6765  a: F401..from ge
-000002a0: 6f66 696c 656f 7073 2e75 7469 6c20 696d  ofileops.util im
-000002b0: 706f 7274 2067 656f 7365 7269 6573 5f75  port geoseries_u
-000002c0: 7469 6c0d 0a66 726f 6d20 6765 6f66 696c  til..from geofil
-000002d0: 656f 7073 2e75 7469 6c20 696d 706f 7274  eops.util import
-000002e0: 205f 696f 5f75 7469 6c0d 0a66 726f 6d20   _io_util..from 
-000002f0: 6765 6f66 696c 656f 7073 2e75 7469 6c20  geofileops.util 
-00000300: 696d 706f 7274 205f 6f67 725f 7574 696c  import _ogr_util
-00000310: 0d0a 6672 6f6d 2067 656f 6669 6c65 6f70  ..from geofileop
-00000320: 732e 7574 696c 2069 6d70 6f72 7420 5f6f  s.util import _o
-00000330: 6772 5f73 716c 5f75 7469 6c0d 0a66 726f  gr_sql_util..fro
-00000340: 6d20 6765 6f66 696c 656f 7073 2e75 7469  m geofileops.uti
-00000350: 6c2e 6765 6f66 696c 6574 7970 6520 696d  l.geofiletype im
-00000360: 706f 7274 2047 656f 6669 6c65 5479 7065  port GeofileType
-00000370: 0d0a 0d0a 2323 2323 2323 2323 2323 2323  ....############
-00000380: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000390: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000003a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000003b0: 2323 2323 2323 2323 230d 0a23 2046 6972  #########..# Fir
-000003c0: 7374 2064 6566 696e 652f 696e 6974 2073  st define/init s
-000003d0: 6f6d 6520 6765 6e65 7261 6c20 7661 7269  ome general vari
-000003e0: 6162 6c65 732f 636f 6e73 7461 6e74 730d  ables/constants.
-000003f0: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
-00000400: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000410: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000420: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000430: 2323 2323 2323 0d0a 0d0a 2320 4765 7420  ######....# Get 
-00000440: 6120 6c6f 6767 6572 2e2e 2e0d 0a6c 6f67  a logger.....log
-00000450: 6765 7220 3d20 6c6f 6767 696e 672e 6765  ger = logging.ge
-00000460: 744c 6f67 6765 7228 5f5f 6e61 6d65 5f5f  tLogger(__name__
-00000470: 290d 0a23 206c 6f67 6765 722e 7365 744c  )..# logger.setL
-00000480: 6576 656c 286c 6f67 6769 6e67 2e44 4542  evel(logging.DEB
-00000490: 5547 290d 0a0d 0a23 2045 6e61 626c 6520  UG)....# Enable 
-000004a0: 6578 6365 7074 696f 6e73 2066 6f72 2047  exceptions for G
-000004b0: 4441 4c0d 0a67 6461 6c2e 5573 6545 7863  DAL..gdal.UseExc
-000004c0: 6570 7469 6f6e 7328 290d 0a0d 0a23 2044  eptions()....# D
-000004d0: 6973 6162 6c65 2074 6869 7320 7761 726e  isable this warn
-000004e0: 696e 6720 696e 2066 696f 6e61 0d0a 7761  ing in fiona..wa
-000004f0: 726e 696e 6773 2e66 696c 7465 7277 6172  rnings.filterwar
-00000500: 6e69 6e67 7328 0d0a 2020 2020 6163 7469  nings(..    acti
-00000510: 6f6e 3d22 6967 6e6f 7265 222c 0d0a 2020  on="ignore",..  
-00000520: 2020 6361 7465 676f 7279 3d52 756e 7469    category=Runti
-00000530: 6d65 5761 726e 696e 672c 0d0a 2020 2020  meWarning,..    
-00000540: 6d65 7373 6167 653d 280d 0a20 2020 2020  message=(..     
-00000550: 2020 2022 5e53 6571 7565 6e74 6961 6c20     "^Sequential 
-00000560: 7265 6164 206f 6620 6974 6572 6174 6f72  read of iterator
-00000570: 2077 6173 2069 6e74 6572 7275 7074 6564   was interrupted
-00000580: 2e20 5265 7365 7474 696e 6720 6974 6572  . Resetting iter
-00000590: 6174 6f72 2e20 220d 0a20 2020 2020 2020  ator. "..       
-000005a0: 2022 5468 6973 2063 616e 206e 6567 6174   "This can negat
-000005b0: 6976 656c 7920 696d 7061 6374 2074 6865  ively impact the
-000005c0: 2070 6572 666f 726d 616e 6365 2e24 220d   performance.$".
-000005d0: 0a20 2020 2029 2c0d 0a29 0d0a 0d0a 2320  .    ),..)....# 
-000005e0: 4469 7361 626c 6520 7468 6973 2077 6172  Disable this war
-000005f0: 6e69 6e67 2069 6e20 7079 6f67 7269 6f0d  ning in pyogrio.
-00000600: 0a77 6172 6e69 6e67 732e 6669 6c74 6572  .warnings.filter
-00000610: 7761 726e 696e 6773 280d 0a20 2020 2061  warnings(..    a
-00000620: 6374 696f 6e3d 2269 676e 6f72 6522 2c0d  ction="ignore",.
-00000630: 0a20 2020 2063 6174 6567 6f72 793d 5573  .    category=Us
-00000640: 6572 5761 726e 696e 672c 0d0a 2020 2020  erWarning,..    
-00000650: 6d65 7373 6167 653d 225e 4c61 7965 7220  message="^Layer 
-00000660: 2e2a 2064 6f65 7320 6e6f 7420 6861 7665  .* does not have
-00000670: 2061 6e79 2066 6561 7475 7265 7320 746f   any features to
-00000680: 2072 6561 6424 222c 0d0a 290d 0a23 2053   read$",..)..# S
-00000690: 6574 206c 6f67 6769 6e67 206c 6576 656c  et logging level
-000006a0: 2066 6f72 2070 796f 6772 696f 2074 6f20   for pyogrio to 
-000006b0: 7761 726e 696e 670d 0a70 796f 6772 696f  warning..pyogrio
-000006c0: 5f6c 6f67 6765 7220 3d20 6c6f 6767 696e  _logger = loggin
-000006d0: 672e 6765 744c 6f67 6765 7228 2270 796f  g.getLogger("pyo
-000006e0: 6772 696f 2229 0d0a 7079 6f67 7269 6f5f  grio")..pyogrio_
-000006f0: 6c6f 6767 6572 2e73 6574 4c65 7665 6c28  logger.setLevel(
-00000700: 6c6f 6767 696e 672e 5741 524e 494e 4729  logging.WARNING)
-00000710: 0d0a 0d0a 2320 4861 7264 636f 6465 6420  ....# Hardcoded 
-00000720: 3331 3337 3020 7072 6a20 7374 7269 6e67  31370 prj string
-00000730: 2074 6f20 7265 706c 6163 6520 6661 756c   to replace faul
-00000740: 7479 206f 6e65 730d 0a50 524a 5f45 5053  ty ones..PRJ_EPS
-00000750: 475f 3331 3337 3020 3d20 280d 0a20 2020  G_31370 = (..   
-00000760: 2027 5052 4f4a 4353 5b22 4265 6c67 655f   'PROJCS["Belge_
-00000770: 3139 3732 5f42 656c 6769 616e 5f4c 616d  1972_Belgian_Lam
-00000780: 6265 7274 5f37 3222 2c27 0d0a 2020 2020  bert_72",'..    
-00000790: 2747 454f 4743 535b 2242 656c 6765 2031  'GEOGCS["Belge 1
-000007a0: 3937 3222 2c27 0d0a 2020 2020 2744 4154  972",'..    'DAT
-000007b0: 554d 5b22 445f 4265 6c67 655f 3139 3732  UM["D_Belge_1972
-000007c0: 222c 5350 4845 524f 4944 5b22 496e 7465  ",SPHEROID["Inte
-000007d0: 726e 6174 696f 6e61 6c5f 3139 3234 222c  rnational_1924",
-000007e0: 3633 3738 3338 382c 3239 375d 5d2c 270d  6378388,297]],'.
-000007f0: 0a20 2020 2027 5052 494d 454d 5b22 4772  .    'PRIMEM["Gr
-00000800: 6565 6e77 6963 6822 2c30 5d2c 270d 0a20  eenwich",0],'.. 
-00000810: 2020 2027 554e 4954 5b22 4465 6772 6565     'UNIT["Degree
-00000820: 222c 302e 3031 3734 3533 3239 3235 3139  ",0.017453292519
-00000830: 3934 3332 3935 5d27 0d0a 2020 2020 225d  943295]'..    "]
-00000840: 2c22 0d0a 2020 2020 2750 524f 4a45 4354  ,"..    'PROJECT
-00000850: 494f 4e5b 224c 616d 6265 7274 5f43 6f6e  ION["Lambert_Con
-00000860: 666f 726d 616c 5f43 6f6e 6963 225d 2c27  formal_Conic"],'
-00000870: 0d0a 2020 2020 2750 4152 414d 4554 4552  ..    'PARAMETER
-00000880: 5b22 7374 616e 6461 7264 5f70 6172 616c  ["standard_paral
-00000890: 6c65 6c5f 3122 2c35 312e 3136 3636 3637  lel_1",51.166667
-000008a0: 3233 3333 3333 3333 5d2c 270d 0a20 2020  23333333],'..   
-000008b0: 2027 5041 5241 4d45 5445 525b 2273 7461   'PARAMETER["sta
-000008c0: 6e64 6172 645f 7061 7261 6c6c 656c 5f32  ndard_parallel_2
-000008d0: 222c 3439 2e38 3333 3333 3339 5d2c 270d  ",49.8333339],'.
-000008e0: 0a20 2020 2027 5041 5241 4d45 5445 525b  .    'PARAMETER[
-000008f0: 226c 6174 6974 7564 655f 6f66 5f6f 7269  "latitude_of_ori
-00000900: 6769 6e22 2c39 305d 2c27 0d0a 2020 2020  gin",90],'..    
-00000910: 2750 4152 414d 4554 4552 5b22 6365 6e74  'PARAMETER["cent
-00000920: 7261 6c5f 6d65 7269 6469 616e 222c 342e  ral_meridian",4.
-00000930: 3336 3734 3836 3636 3636 3636 3636 365d  367486666666666]
-00000940: 2c27 0d0a 2020 2020 2750 4152 414d 4554  ,'..    'PARAMET
-00000950: 4552 5b22 6661 6c73 655f 6561 7374 696e  ER["false_eastin
-00000960: 6722 2c31 3530 3030 302e 3031 335d 2c27  g",150000.013],'
-00000970: 0d0a 2020 2020 2750 4152 414d 4554 4552  ..    'PARAMETER
-00000980: 5b22 6661 6c73 655f 6e6f 7274 6869 6e67  ["false_northing
-00000990: 222c 3534 3030 3038 382e 3433 385d 2c27  ",5400088.438],'
-000009a0: 0d0a 2020 2020 2755 4e49 545b 224d 6574  ..    'UNIT["Met
-000009b0: 6572 222c 315d 2c27 0d0a 2020 2020 2741  er",1],'..    'A
-000009c0: 5554 484f 5249 5459 5b22 4550 5347 222c  UTHORITY["EPSG",
-000009d0: 3331 3337 305d 270d 0a20 2020 2022 5d22  31370]'..    "]"
-000009e0: 0d0a 290d 0a0d 0a23 2323 2323 2323 2323  ..)....#########
+00000010: 662d 3820 2d2a 2d0a 2222 220a 4d6f 6475  f-8 -*-.""".Modu
+00000020: 6c65 2077 6974 6820 6865 6c70 6572 2066  le with helper f
+00000030: 756e 6374 696f 6e73 2066 6f72 2067 656f  unctions for geo
+00000040: 2066 696c 6573 2e0a 2222 220a 0a69 6d70   files.."""..imp
+00000050: 6f72 7420 656e 756d 0a69 6d70 6f72 7420  ort enum.import 
+00000060: 6461 7465 7469 6d65 0a69 6d70 6f72 7420  datetime.import 
+00000070: 6669 6c65 636d 700a 696d 706f 7274 206c  filecmp.import l
+00000080: 6f67 6769 6e67 0a69 6d70 6f72 7420 6f73  ogging.import os
+00000090: 0a66 726f 6d20 7061 7468 6c69 6220 696d  .from pathlib im
+000000a0: 706f 7274 2050 6174 680a 696d 706f 7274  port Path.import
+000000b0: 2070 7072 696e 740a 696d 706f 7274 2073   pprint.import s
+000000c0: 6875 7469 6c0a 696d 706f 7274 2073 7472  hutil.import str
+000000d0: 696e 670a 696d 706f 7274 2074 656d 7066  ing.import tempf
+000000e0: 696c 650a 696d 706f 7274 2074 696d 650a  ile.import time.
+000000f0: 6672 6f6d 2074 7970 696e 6720 696d 706f  from typing impo
+00000100: 7274 2041 6e79 2c20 4469 6374 2c20 4974  rt Any, Dict, It
+00000110: 6572 6162 6c65 2c20 4c69 7374 2c20 4c69  erable, List, Li
+00000120: 7465 7261 6c2c 204f 7074 696f 6e61 6c2c  teral, Optional,
+00000130: 2054 7570 6c65 2c20 556e 696f 6e0a 696d   Tuple, Union.im
+00000140: 706f 7274 2077 6172 6e69 6e67 730a 0a69  port warnings..i
+00000150: 6d70 6f72 7420 6669 6f6e 610a 696d 706f  mport fiona.impo
+00000160: 7274 2067 656f 7061 6e64 6173 2061 7320  rt geopandas as 
+00000170: 6770 640a 6672 6f6d 2067 656f 7061 6e64  gpd.from geopand
+00000180: 6173 2e69 6f20 696d 706f 7274 2066 696c  as.io import fil
+00000190: 6520 6173 2067 7064 5f69 6f5f 6669 6c65  e as gpd_io_file
+000001a0: 0a69 6d70 6f72 7420 6e75 6d70 7920 6173  .import numpy as
+000001b0: 206e 700a 6672 6f6d 206f 7367 656f 2069   np.from osgeo i
+000001c0: 6d70 6f72 7420 6764 616c 0a69 6d70 6f72  mport gdal.impor
+000001d0: 7420 7061 6e64 6173 2061 7320 7064 0a69  t pandas as pd.i
+000001e0: 6d70 6f72 7420 7079 6f67 7269 6f0a 696d  mport pyogrio.im
+000001f0: 706f 7274 2070 7970 726f 6a0a 0a66 726f  port pyproj..fro
+00000200: 6d20 6765 6f66 696c 656f 7073 2e75 7469  m geofileops.uti
+00000210: 6c2e 6765 6f6d 6574 7279 5f75 7469 6c20  l.geometry_util 
+00000220: 696d 706f 7274 2047 656f 6d65 7472 7954  import GeometryT
+00000230: 7970 652c 2050 7269 6d69 7469 7665 5479  ype, PrimitiveTy
+00000240: 7065 2020 2320 6e6f 7161 3a20 4634 3031  pe  # noqa: F401
+00000250: 0a66 726f 6d20 6765 6f66 696c 656f 7073  .from geofileops
+00000260: 2e75 7469 6c20 696d 706f 7274 2067 656f  .util import geo
+00000270: 7365 7269 6573 5f75 7469 6c0a 6672 6f6d  series_util.from
+00000280: 2067 656f 6669 6c65 6f70 732e 7574 696c   geofileops.util
+00000290: 2069 6d70 6f72 7420 5f69 6f5f 7574 696c   import _io_util
+000002a0: 0a66 726f 6d20 6765 6f66 696c 656f 7073  .from geofileops
+000002b0: 2e75 7469 6c20 696d 706f 7274 205f 6f67  .util import _og
+000002c0: 725f 7574 696c 0a66 726f 6d20 6765 6f66  r_util.from geof
+000002d0: 696c 656f 7073 2e75 7469 6c20 696d 706f  ileops.util impo
+000002e0: 7274 205f 6f67 725f 7371 6c5f 7574 696c  rt _ogr_sql_util
+000002f0: 0a66 726f 6d20 6765 6f66 696c 656f 7073  .from geofileops
+00000300: 2e75 7469 6c2e 6765 6f66 696c 6574 7970  .util.geofiletyp
+00000310: 6520 696d 706f 7274 2047 656f 6669 6c65  e import Geofile
+00000320: 5479 7065 0a0a 2323 2323 2323 2323 2323  Type..##########
+00000330: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000340: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000350: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000360: 2323 2323 2323 2323 2323 230a 2320 4669  ###########.# Fi
+00000370: 7273 7420 6465 6669 6e65 2f69 6e69 7420  rst define/init 
+00000380: 736f 6d65 2067 656e 6572 616c 2076 6172  some general var
+00000390: 6961 626c 6573 2f63 6f6e 7374 616e 7473  iables/constants
+000003a0: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
+000003b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000003c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000003d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000003e0: 2323 2323 2323 0a0a 2320 4765 7420 6120  ######..# Get a 
+000003f0: 6c6f 6767 6572 2e2e 2e0a 6c6f 6767 6572  logger....logger
+00000400: 203d 206c 6f67 6769 6e67 2e67 6574 4c6f   = logging.getLo
+00000410: 6767 6572 285f 5f6e 616d 655f 5f29 0a23  gger(__name__).#
+00000420: 206c 6f67 6765 722e 7365 744c 6576 656c   logger.setLevel
+00000430: 286c 6f67 6769 6e67 2e44 4542 5547 290a  (logging.DEBUG).
+00000440: 0a23 2045 6e61 626c 6520 6578 6365 7074  .# Enable except
+00000450: 696f 6e73 2066 6f72 2047 4441 4c0a 6764  ions for GDAL.gd
+00000460: 616c 2e55 7365 4578 6365 7074 696f 6e73  al.UseExceptions
+00000470: 2829 0a67 6461 6c2e 6f67 722e 5573 6545  ().gdal.ogr.UseE
+00000480: 7863 6570 7469 6f6e 7328 290a 0a23 2044  xceptions()..# D
+00000490: 6973 6162 6c65 2074 6869 7320 7761 726e  isable this warn
+000004a0: 696e 6720 696e 2066 696f 6e61 0a77 6172  ing in fiona.war
+000004b0: 6e69 6e67 732e 6669 6c74 6572 7761 726e  nings.filterwarn
+000004c0: 696e 6773 280a 2020 2020 6163 7469 6f6e  ings(.    action
+000004d0: 3d22 6967 6e6f 7265 222c 0a20 2020 2063  ="ignore",.    c
+000004e0: 6174 6567 6f72 793d 5275 6e74 696d 6557  ategory=RuntimeW
+000004f0: 6172 6e69 6e67 2c0a 2020 2020 6d65 7373  arning,.    mess
+00000500: 6167 653d 280a 2020 2020 2020 2020 225e  age=(.        "^
+00000510: 5365 7175 656e 7469 616c 2072 6561 6420  Sequential read 
+00000520: 6f66 2069 7465 7261 746f 7220 7761 7320  of iterator was 
+00000530: 696e 7465 7272 7570 7465 642e 2052 6573  interrupted. Res
+00000540: 6574 7469 6e67 2069 7465 7261 746f 722e  etting iterator.
+00000550: 2022 0a20 2020 2020 2020 2022 5468 6973   ".        "This
+00000560: 2063 616e 206e 6567 6174 6976 656c 7920   can negatively 
+00000570: 696d 7061 6374 2074 6865 2070 6572 666f  impact the perfo
+00000580: 726d 616e 6365 2e24 220a 2020 2020 292c  rmance.$".    ),
+00000590: 0a29 0a0a 2320 4469 7361 626c 6520 7468  .)..# Disable th
+000005a0: 6973 2077 6172 6e69 6e67 2069 6e20 7079  is warning in py
+000005b0: 6f67 7269 6f0a 7761 726e 696e 6773 2e66  ogrio.warnings.f
+000005c0: 696c 7465 7277 6172 6e69 6e67 7328 0a20  ilterwarnings(. 
+000005d0: 2020 2061 6374 696f 6e3d 2269 676e 6f72     action="ignor
+000005e0: 6522 2c0a 2020 2020 6361 7465 676f 7279  e",.    category
+000005f0: 3d55 7365 7257 6172 6e69 6e67 2c0a 2020  =UserWarning,.  
+00000600: 2020 6d65 7373 6167 653d 225e 4c61 7965    message="^Laye
+00000610: 7220 2e2a 2064 6f65 7320 6e6f 7420 6861  r .* does not ha
+00000620: 7665 2061 6e79 2066 6561 7475 7265 7320  ve any features 
+00000630: 746f 2072 6561 6424 222c 0a29 0a23 2053  to read$",.).# S
+00000640: 6574 206c 6f67 6769 6e67 206c 6576 656c  et logging level
+00000650: 2066 6f72 2070 796f 6772 696f 2074 6f20   for pyogrio to 
+00000660: 7761 726e 696e 670a 7079 6f67 7269 6f5f  warning.pyogrio_
+00000670: 6c6f 6767 6572 203d 206c 6f67 6769 6e67  logger = logging
+00000680: 2e67 6574 4c6f 6767 6572 2822 7079 6f67  .getLogger("pyog
+00000690: 7269 6f22 290a 7079 6f67 7269 6f5f 6c6f  rio").pyogrio_lo
+000006a0: 6767 6572 2e73 6574 4c65 7665 6c28 6c6f  gger.setLevel(lo
+000006b0: 6767 696e 672e 5741 524e 494e 4729 0a0a  gging.WARNING)..
+000006c0: 2320 4861 7264 636f 6465 6420 3331 3337  # Hardcoded 3137
+000006d0: 3020 7072 6a20 7374 7269 6e67 2074 6f20  0 prj string to 
+000006e0: 7265 706c 6163 6520 6661 756c 7479 206f  replace faulty o
+000006f0: 6e65 730a 5052 4a5f 4550 5347 5f33 3133  nes.PRJ_EPSG_313
+00000700: 3730 203d 2028 0a20 2020 2027 5052 4f4a  70 = (.    'PROJ
+00000710: 4353 5b22 4265 6c67 655f 3139 3732 5f42  CS["Belge_1972_B
+00000720: 656c 6769 616e 5f4c 616d 6265 7274 5f37  elgian_Lambert_7
+00000730: 3222 2c27 0a20 2020 2027 4745 4f47 4353  2",'.    'GEOGCS
+00000740: 5b22 4265 6c67 6520 3139 3732 222c 270a  ["Belge 1972",'.
+00000750: 2020 2020 2744 4154 554d 5b22 445f 4265      'DATUM["D_Be
+00000760: 6c67 655f 3139 3732 222c 5350 4845 524f  lge_1972",SPHERO
+00000770: 4944 5b22 496e 7465 726e 6174 696f 6e61  ID["Internationa
+00000780: 6c5f 3139 3234 222c 3633 3738 3338 382c  l_1924",6378388,
+00000790: 3239 375d 5d2c 270a 2020 2020 2750 5249  297]],'.    'PRI
+000007a0: 4d45 4d5b 2247 7265 656e 7769 6368 222c  MEM["Greenwich",
+000007b0: 305d 2c27 0a20 2020 2027 554e 4954 5b22  0],'.    'UNIT["
+000007c0: 4465 6772 6565 222c 302e 3031 3734 3533  Degree",0.017453
+000007d0: 3239 3235 3139 3934 3332 3935 5d27 0a20  292519943295]'. 
+000007e0: 2020 2022 5d2c 220a 2020 2020 2750 524f     "],".    'PRO
+000007f0: 4a45 4354 494f 4e5b 224c 616d 6265 7274  JECTION["Lambert
+00000800: 5f43 6f6e 666f 726d 616c 5f43 6f6e 6963  _Conformal_Conic
+00000810: 225d 2c27 0a20 2020 2027 5041 5241 4d45  "],'.    'PARAME
+00000820: 5445 525b 2273 7461 6e64 6172 645f 7061  TER["standard_pa
+00000830: 7261 6c6c 656c 5f31 222c 3531 2e31 3636  rallel_1",51.166
+00000840: 3636 3732 3333 3333 3333 335d 2c27 0a20  66723333333],'. 
+00000850: 2020 2027 5041 5241 4d45 5445 525b 2273     'PARAMETER["s
+00000860: 7461 6e64 6172 645f 7061 7261 6c6c 656c  tandard_parallel
+00000870: 5f32 222c 3439 2e38 3333 3333 3339 5d2c  _2",49.8333339],
+00000880: 270a 2020 2020 2750 4152 414d 4554 4552  '.    'PARAMETER
+00000890: 5b22 6c61 7469 7475 6465 5f6f 665f 6f72  ["latitude_of_or
+000008a0: 6967 696e 222c 3930 5d2c 270a 2020 2020  igin",90],'.    
+000008b0: 2750 4152 414d 4554 4552 5b22 6365 6e74  'PARAMETER["cent
+000008c0: 7261 6c5f 6d65 7269 6469 616e 222c 342e  ral_meridian",4.
+000008d0: 3336 3734 3836 3636 3636 3636 3636 365d  367486666666666]
+000008e0: 2c27 0a20 2020 2027 5041 5241 4d45 5445  ,'.    'PARAMETE
+000008f0: 525b 2266 616c 7365 5f65 6173 7469 6e67  R["false_easting
+00000900: 222c 3135 3030 3030 2e30 3133 5d2c 270a  ",150000.013],'.
+00000910: 2020 2020 2750 4152 414d 4554 4552 5b22      'PARAMETER["
+00000920: 6661 6c73 655f 6e6f 7274 6869 6e67 222c  false_northing",
+00000930: 3534 3030 3038 382e 3433 385d 2c27 0a20  5400088.438],'. 
+00000940: 2020 2027 554e 4954 5b22 4d65 7465 7222     'UNIT["Meter"
+00000950: 2c31 5d2c 270a 2020 2020 2741 5554 484f  ,1],'.    'AUTHO
+00000960: 5249 5459 5b22 4550 5347 222c 3331 3337  RITY["EPSG",3137
+00000970: 305d 270a 2020 2020 225d 220a 290a 0a23  0]'.    "]".)..#
+00000980: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000990: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000009a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000009b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000009c0: 2323 2323 0a23 2054 6865 2072 6561 6c20  ####.# The real 
+000009d0: 776f 726b 0a23 2323 2323 2323 2323 2323  work.###########
+000009e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000009f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000a00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000a10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000a20: 2323 2323 2323 2323 2323 2323 0d0a 2320  ############..# 
-00000a30: 5468 6520 7265 616c 2077 6f72 6b0d 0a23  The real work..#
-00000a40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000a50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000a60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000a70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000a80: 2323 2323 0d0a 0d0a 0d0a 6465 6620 6c69  ####......def li
-00000a90: 7374 6c61 7965 7273 280d 0a20 2020 2070  stlayers(..    p
-00000aa0: 6174 683a 2055 6e69 6f6e 5b73 7472 2c20  ath: Union[str, 
-00000ab0: 226f 732e 5061 7468 4c69 6b65 5b41 6e79  "os.PathLike[Any
-00000ac0: 5d22 5d2c 0d0a 2020 2020 6f6e 6c79 5f73  ]"],..    only_s
-00000ad0: 7061 7469 616c 5f6c 6179 6572 733a 2062  patial_layers: b
-00000ae0: 6f6f 6c20 3d20 5472 7565 2c0d 0a29 202d  ool = True,..) -
-00000af0: 3e20 4c69 7374 5b73 7472 5d3a 0d0a 2020  > List[str]:..  
-00000b00: 2020 2222 220d 0a20 2020 2047 6574 2074    """..    Get t
-00000b10: 6865 206c 6973 7420 6f66 206c 6179 6572  he list of layer
-00000b20: 7320 696e 2061 2067 656f 6669 6c65 2e0d  s in a geofile..
-00000b30: 0a0d 0a20 2020 2041 7267 733a 0d0a 2020  ...    Args:..  
-00000b40: 2020 2020 2020 7061 7468 2028 5061 7468        path (Path
-00000b50: 4c69 6b65 293a 2070 6174 6820 746f 2074  Like): path to t
-00000b60: 6865 2066 696c 6520 746f 2067 6574 2069  he file to get i
-00000b70: 6e66 6f20 6162 6f75 740d 0a20 2020 2020  nfo about..     
-00000b80: 2020 206f 6e6c 795f 7370 6174 6961 6c5f     only_spatial_
-00000b90: 6c61 7965 7273 2028 626f 6f6c 2c20 6f70  layers (bool, op
-00000ba0: 7469 6f6e 616c 293a 2054 7275 6520 746f  tional): True to
-00000bb0: 206f 6e6c 7920 6c69 7374 2073 7061 7469   only list spati
-00000bc0: 616c 206c 6179 6572 732e 0d0a 2020 2020  al layers...    
-00000bd0: 2020 2020 2020 2020 4661 6c73 6520 746f          False to
-00000be0: 206c 6973 7420 616c 6c20 7461 626c 6573   list all tables
-00000bf0: 2e0d 0a0d 0a20 2020 2052 6574 7572 6e73  .....    Returns
-00000c00: 3a0d 0a20 2020 2020 2020 204c 6973 745b  :..        List[
-00000c10: 7374 725d 3a20 7468 6520 6c69 7374 206f  str]: the list o
-00000c20: 6620 6c61 7965 7273 0d0a 2020 2020 2222  f layers..    ""
-00000c30: 220d 0a20 2020 2070 6174 6820 3d20 5061  "..    path = Pa
-00000c40: 7468 2870 6174 6829 0d0a 2020 2020 6966  th(path)..    if
-00000c50: 2070 6174 682e 7375 6666 6978 2e6c 6f77   path.suffix.low
-00000c60: 6572 2829 203d 3d20 222e 7368 7022 3a0d  er() == ".shp":.
-00000c70: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00000c80: 5b70 6174 682e 7374 656d 5d0d 0a0d 0a20  [path.stem].... 
-00000c90: 2020 2064 6174 6173 6f75 7263 6520 3d20     datasource = 
-00000ca0: 4e6f 6e65 0d0a 2020 2020 6c61 7965 7273  None..    layers
-00000cb0: 203d 205b 5d0d 0a20 2020 2074 7279 3a0d   = []..    try:.
-00000cc0: 0a20 2020 2020 2020 2064 6174 6173 6f75  .        datasou
-00000cd0: 7263 6520 3d20 6764 616c 2e4f 7065 6e45  rce = gdal.OpenE
-00000ce0: 7828 7374 7228 7061 7468 2929 0d0a 2020  x(str(path))..  
-00000cf0: 2020 2020 2020 6e62 5f6c 6179 6572 7320        nb_layers 
-00000d00: 3d20 6461 7461 736f 7572 6365 2e47 6574  = datasource.Get
-00000d10: 4c61 7965 7243 6f75 6e74 2829 0d0a 2020  LayerCount()..  
-00000d20: 2020 2020 2020 666f 7220 6c61 7965 725f        for layer_
-00000d30: 6964 2069 6e20 7261 6e67 6528 6e62 5f6c  id in range(nb_l
-00000d40: 6179 6572 7329 3a0d 0a20 2020 2020 2020  ayers):..       
-00000d50: 2020 2020 2064 6174 6173 6f75 7263 655f       datasource_
-00000d60: 6c61 7965 7220 3d20 6461 7461 736f 7572  layer = datasour
-00000d70: 6365 2e47 6574 4c61 7965 7242 7949 6e64  ce.GetLayerByInd
-00000d80: 6578 286c 6179 6572 5f69 6429 0d0a 2020  ex(layer_id)..  
-00000d90: 2020 2020 2020 2020 2020 6966 2028 0d0a            if (..
-00000da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000db0: 6f6e 6c79 5f73 7061 7469 616c 5f6c 6179  only_spatial_lay
-00000dc0: 6572 7320 6973 2046 616c 7365 0d0a 2020  ers is False..  
-00000dd0: 2020 2020 2020 2020 2020 2020 2020 6f72                or
-00000de0: 2064 6174 6173 6f75 7263 655f 6c61 7965   datasource_laye
-00000df0: 722e 4765 7447 656f 6d65 7472 7943 6f6c  r.GetGeometryCol
-00000e00: 756d 6e28 2920 213d 2022 220d 0a20 2020  umn() != ""..   
-00000e10: 2020 2020 2020 2020 2029 3a0d 0a20 2020           ):..   
-00000e20: 2020 2020 2020 2020 2020 2020 206c 6179               lay
-00000e30: 6572 732e 6170 7065 6e64 2864 6174 6173  ers.append(datas
-00000e40: 6f75 7263 655f 6c61 7965 722e 4765 744e  ource_layer.GetN
-00000e50: 616d 6528 2929 0d0a 2020 2020 6669 6e61  ame())..    fina
-00000e60: 6c6c 793a 0d0a 2020 2020 2020 2020 6966  lly:..        if
-00000e70: 2064 6174 6173 6f75 7263 6520 6973 206e   datasource is n
-00000e80: 6f74 204e 6f6e 653a 0d0a 2020 2020 2020  ot None:..      
-00000e90: 2020 2020 2020 6465 6c20 6461 7461 736f        del dataso
-00000ea0: 7572 6365 0d0a 0d0a 2020 2020 7265 7475  urce....    retu
-00000eb0: 726e 206c 6179 6572 730d 0a0d 0a0d 0a63  rn layers......c
-00000ec0: 6c61 7373 2043 6f6c 756d 6e49 6e66 6f3a  lass ColumnInfo:
-00000ed0: 0d0a 2020 2020 2222 220d 0a20 2020 2041  ..    """..    A
-00000ee0: 2064 6174 6120 6f62 6a65 6374 2063 6f6e   data object con
-00000ef0: 7461 696e 696e 6720 6d65 7461 2d69 6e66  taining meta-inf
-00000f00: 6f72 6d61 7469 6f6e 2061 626f 7574 2061  ormation about a
-00000f10: 2063 6f6c 756d 6e2e 0d0a 0d0a 2020 2020   column.....    
-00000f20: 4174 7472 6962 7574 6573 3a0d 0a20 2020  Attributes:..   
-00000f30: 2020 2020 206e 616d 6520 2873 7472 293a       name (str):
-00000f40: 2074 6865 206e 616d 6520 6f66 2074 6865   the name of the
-00000f50: 2063 6f6c 756d 6e2e 0d0a 2020 2020 2020   column...      
-00000f60: 2020 6764 616c 5f74 7970 6520 2873 7472    gdal_type (str
-00000f70: 293a 2074 6865 2074 7970 6520 6f66 2074  ): the type of t
-00000f80: 6865 2063 6f6c 756d 6e20 6163 636f 7264  he column accord
-00000f90: 696e 6720 746f 2067 6461 6c2e 0d0a 2020  ing to gdal...  
-00000fa0: 2020 2020 2020 7769 6474 6820 2869 6e74        width (int
-00000fb0: 293a 2074 6865 2077 6964 7468 206f 6620  ): the width of 
-00000fc0: 7468 6520 636f 6c75 6d6e 2c20 6966 2073  the column, if s
-00000fd0: 7065 6369 6669 6564 2e0d 0a20 2020 2022  pecified...    "
-00000fe0: 2222 0d0a 0d0a 2020 2020 6465 6620 5f5f  ""....    def __
-00000ff0: 696e 6974 5f5f 280d 0a20 2020 2020 2020  init__(..       
-00001000: 2073 656c 662c 0d0a 2020 2020 2020 2020   self,..        
-00001010: 6e61 6d65 3a20 7374 722c 0d0a 2020 2020  name: str,..    
-00001020: 2020 2020 6764 616c 5f74 7970 653a 2073      gdal_type: s
-00001030: 7472 2c0d 0a20 2020 2020 2020 2077 6964  tr,..        wid
-00001040: 7468 3a20 4f70 7469 6f6e 616c 5b69 6e74  th: Optional[int
-00001050: 5d2c 0d0a 2020 2020 2020 2020 7072 6563  ],..        prec
-00001060: 6973 696f 6e3a 204f 7074 696f 6e61 6c5b  ision: Optional[
-00001070: 696e 745d 2c0d 0a20 2020 2029 3a0d 0a20  int],..    ):.. 
-00001080: 2020 2020 2020 2073 656c 662e 6e61 6d65         self.name
-00001090: 203d 206e 616d 650d 0a20 2020 2020 2020   = name..       
-000010a0: 2073 656c 662e 6764 616c 5f74 7970 6520   self.gdal_type 
-000010b0: 3d20 6764 616c 5f74 7970 650d 0a20 2020  = gdal_type..   
-000010c0: 2020 2020 2073 656c 662e 7769 6474 6820       self.width 
-000010d0: 3d20 7769 6474 680d 0a20 2020 2020 2020  = width..       
-000010e0: 2073 656c 662e 7072 6563 6973 696f 6e20   self.precision 
-000010f0: 3d20 7072 6563 6973 696f 6e0d 0a0d 0a20  = precision.... 
-00001100: 2020 2064 6566 205f 5f72 6570 725f 5f28     def __repr__(
-00001110: 7365 6c66 293a 0d0a 2020 2020 2020 2020  self):..        
-00001120: 7265 7475 726e 2066 227b 7365 6c66 2e5f  return f"{self._
-00001130: 5f63 6c61 7373 5f5f 7d28 7b73 656c 662e  _class__}({self.
-00001140: 5f5f 6469 6374 5f5f 7d29 220d 0a0d 0a0d  __dict__})".....
-00001150: 0a63 6c61 7373 204c 6179 6572 496e 666f  .class LayerInfo
-00001160: 3a0d 0a20 2020 2022 2222 0d0a 2020 2020  :..    """..    
-00001170: 4120 6461 7461 206f 626a 6563 7420 636f  A data object co
-00001180: 6e74 6169 6e69 6e67 206d 6574 612d 696e  ntaining meta-in
-00001190: 666f 726d 6174 696f 6e20 6162 6f75 7420  formation about 
-000011a0: 6120 6c61 7965 722e 0d0a 0d0a 2020 2020  a layer.....    
-000011b0: 4174 7472 6962 7574 6573 3a0d 0a20 2020  Attributes:..   
-000011c0: 2020 2020 206e 616d 6520 2873 7472 293a       name (str):
-000011d0: 2074 6865 206e 616d 6520 6f66 2074 6865   the name of the
-000011e0: 206c 6179 6572 2e0d 0a20 2020 2020 2020   layer...       
-000011f0: 2066 6561 7475 7265 636f 756e 7420 2869   featurecount (i
-00001200: 6e74 293a 2074 6865 206e 756d 6265 7220  nt): the number 
-00001210: 6f66 2066 6561 7475 7265 7320 2872 6f77  of features (row
-00001220: 7329 2069 6e20 7468 6520 6c61 7965 722e  s) in the layer.
-00001230: 0d0a 2020 2020 2020 2020 746f 7461 6c5f  ..        total_
-00001240: 626f 756e 6473 2028 5475 706c 655b 666c  bounds (Tuple[fl
-00001250: 6f61 742c 2066 6c6f 6174 2c20 666c 6f61  oat, float, floa
-00001260: 742c 2066 6c6f 6174 5d29 3a20 7468 6520  t, float]): the 
-00001270: 626f 756e 6469 6e67 2062 6f78 206f 660d  bounding box of.
-00001280: 0a20 2020 2020 2020 2020 2020 2074 6865  .            the
-00001290: 206c 6179 6572 2e0d 0a20 2020 2020 2020   layer...       
-000012a0: 2067 656f 6d65 7472 7963 6f6c 756d 6e20   geometrycolumn 
-000012b0: 2873 7472 293a 206e 616d 6520 6f66 2074  (str): name of t
-000012c0: 6865 2063 6f6c 756d 6e20 7468 6174 2063  he column that c
-000012d0: 6f6e 7461 696e 7320 7468 650d 0a20 2020  ontains the..   
-000012e0: 2020 2020 2020 2020 2070 7269 6d61 7279           primary
-000012f0: 2067 656f 6d65 7472 792e 0d0a 2020 2020   geometry...    
-00001300: 2020 2020 6765 6f6d 6574 7279 7479 7065      geometrytype
-00001310: 6e61 6d65 2028 7374 7229 3a20 7468 6520  name (str): the 
-00001320: 6765 6f6d 6574 7279 2074 7970 6520 6e61  geometry type na
-00001330: 6d65 206f 6620 7468 6520 6765 6f6d 6574  me of the geomet
-00001340: 7279 636f 6c75 6d6e 2e0d 0a20 2020 2020  rycolumn...     
-00001350: 2020 2020 2020 2054 6865 2074 7970 6520         The type 
-00001360: 6e61 6d65 2072 6574 7572 6e65 6420 6973  name returned is
-00001370: 206f 6e65 206f 6620 7468 6520 666f 6c6c   one of the foll
-00001380: 6f77 696e 673a 2050 4f49 4e54 2c20 4d55  owing: POINT, MU
-00001390: 4c54 4950 4f49 4e54 2c0d 0a20 2020 2020  LTIPOINT,..     
-000013a0: 2020 2020 2020 204c 494e 4553 5452 494e         LINESTRIN
-000013b0: 472c 204d 554c 5449 4c49 4e45 5354 5249  G, MULTILINESTRI
-000013c0: 4e47 2c20 504f 4c59 474f 4e2c 204d 554c  NG, POLYGON, MUL
-000013d0: 5449 504f 4c59 474f 4e2c 2043 4f4c 4c45  TIPOLYGON, COLLE
-000013e0: 4354 494f 4e2e 0d0a 2020 2020 2020 2020  CTION...        
-000013f0: 6765 6f6d 6574 7279 7479 7065 2028 4765  geometrytype (Ge
-00001400: 6f6d 6574 7279 5479 7065 293a 2074 6865  ometryType): the
-00001410: 2067 656f 6d65 7472 7920 7479 7065 206f   geometry type o
-00001420: 6620 7468 6520 6765 6f6d 6574 7279 636f  f the geometryco
-00001430: 6c75 6d6e 2e0d 0a20 2020 2020 2020 2063  lumn...        c
-00001440: 6f6c 756d 6e73 2028 6469 6374 293a 2074  olumns (dict): t
-00001450: 6865 2063 6f6c 756d 6e73 2028 6f74 6865  he columns (othe
-00001460: 7220 7468 616e 2074 6865 2067 656f 6d65  r than the geome
-00001470: 7472 7920 636f 6c75 6d6e 2920 7468 6174  try column) that
-00001480: 0d0a 2020 2020 2020 2020 2020 2020 6172  ..            ar
-00001490: 6520 6176 6169 6c61 626c 6520 6f6e 2074  e available on t
-000014a0: 6865 206c 6179 6572 2077 6974 6820 7468  he layer with th
-000014b0: 6569 7220 7072 6f70 6572 7469 6573 2061  eir properties a
-000014c0: 7320 6120 6469 6374 2e0d 0a20 2020 2020  s a dict...     
-000014d0: 2020 2066 6964 5f63 6f6c 756d 6e20 2873     fid_column (s
-000014e0: 7472 293a 2063 6f6c 756d 6e20 6e61 6d65  tr): column name
-000014f0: 206f 6620 7468 6520 4649 4420 636f 6c75   of the FID colu
-00001500: 6d6e 2e20 4973 2022 2220 666f 7220 6669  mn. Is "" for fi
-00001510: 6c65 2074 7970 6573 2074 6861 7420 646f  le types that do
-00001520: 6e27 740d 0a20 2020 2020 2020 2020 2020  n't..           
-00001530: 2065 7870 6c69 6369 746c 7920 7374 6f72   explicitly stor
-00001540: 6520 616e 2046 4944 2c20 6c69 6b65 2073  e an FID, like s
-00001550: 6861 7065 6669 6c65 2e0d 0a20 2020 2020  hapefile...     
-00001560: 2020 2063 7273 2028 7079 7072 6f6a 2e43     crs (pyproj.C
-00001570: 5253 293a 2074 6865 2073 7061 7469 616c  RS): the spatial
-00001580: 2072 6566 6572 656e 6365 206f 6620 7468   reference of th
-00001590: 6520 6c61 7965 722e 0d0a 2020 2020 2020  e layer...      
-000015a0: 2020 6572 726f 7273 2028 4c69 7374 5b73    errors (List[s
-000015b0: 7472 5d29 3a20 6c69 7374 206f 6620 6572  tr]): list of er
-000015c0: 726f 7273 2069 6e20 7468 6520 6c61 7965  rors in the laye
-000015d0: 722c 2065 672e 2069 6e76 616c 6964 2063  r, eg. invalid c
-000015e0: 6f6c 756d 6e0d 0a20 2020 2020 2020 2020  olumn..         
-000015f0: 2020 206e 616d 6573 2c2e 2e2e 0d0a 2020     names,.....  
-00001600: 2020 2222 220d 0a0d 0a20 2020 2064 6566    """....    def
-00001610: 205f 5f69 6e69 745f 5f28 0d0a 2020 2020   __init__(..    
-00001620: 2020 2020 7365 6c66 2c0d 0a20 2020 2020      self,..     
-00001630: 2020 206e 616d 653a 2073 7472 2c0d 0a20     name: str,.. 
-00001640: 2020 2020 2020 2066 6561 7475 7265 636f         featureco
-00001650: 756e 743a 2069 6e74 2c0d 0a20 2020 2020  unt: int,..     
-00001660: 2020 2074 6f74 616c 5f62 6f75 6e64 733a     total_bounds:
-00001670: 2054 7570 6c65 5b66 6c6f 6174 2c20 666c   Tuple[float, fl
-00001680: 6f61 742c 2066 6c6f 6174 2c20 666c 6f61  oat, float, floa
-00001690: 745d 2c0d 0a20 2020 2020 2020 2067 656f  t],..        geo
-000016a0: 6d65 7472 7963 6f6c 756d 6e3a 2073 7472  metrycolumn: str
-000016b0: 2c0d 0a20 2020 2020 2020 2067 656f 6d65  ,..        geome
-000016c0: 7472 7974 7970 656e 616d 653a 2073 7472  trytypename: str
-000016d0: 2c0d 0a20 2020 2020 2020 2067 656f 6d65  ,..        geome
-000016e0: 7472 7974 7970 653a 2047 656f 6d65 7472  trytype: Geometr
-000016f0: 7954 7970 652c 0d0a 2020 2020 2020 2020  yType,..        
-00001700: 636f 6c75 6d6e 733a 2044 6963 745b 7374  columns: Dict[st
-00001710: 722c 2043 6f6c 756d 6e49 6e66 6f5d 2c0d  r, ColumnInfo],.
-00001720: 0a20 2020 2020 2020 2066 6964 5f63 6f6c  .        fid_col
-00001730: 756d 6e3a 2073 7472 2c0d 0a20 2020 2020  umn: str,..     
-00001740: 2020 2063 7273 3a20 4f70 7469 6f6e 616c     crs: Optional
-00001750: 5b70 7970 726f 6a2e 4352 535d 2c0d 0a20  [pyproj.CRS],.. 
-00001760: 2020 2020 2020 2065 7272 6f72 733a 204c         errors: L
-00001770: 6973 745b 7374 725d 2c0d 0a20 2020 2029  ist[str],..    )
-00001780: 3a0d 0a20 2020 2020 2020 2073 656c 662e  :..        self.
-00001790: 6e61 6d65 203d 206e 616d 650d 0a20 2020  name = name..   
-000017a0: 2020 2020 2073 656c 662e 6665 6174 7572       self.featur
-000017b0: 6563 6f75 6e74 203d 2066 6561 7475 7265  ecount = feature
-000017c0: 636f 756e 740d 0a20 2020 2020 2020 2073  count..        s
-000017d0: 656c 662e 746f 7461 6c5f 626f 756e 6473  elf.total_bounds
-000017e0: 203d 2074 6f74 616c 5f62 6f75 6e64 730d   = total_bounds.
-000017f0: 0a20 2020 2020 2020 2073 656c 662e 6765  .        self.ge
-00001800: 6f6d 6574 7279 636f 6c75 6d6e 203d 2067  ometrycolumn = g
-00001810: 656f 6d65 7472 7963 6f6c 756d 6e0d 0a20  eometrycolumn.. 
-00001820: 2020 2020 2020 2073 656c 662e 6765 6f6d         self.geom
-00001830: 6574 7279 7479 7065 6e61 6d65 203d 2067  etrytypename = g
-00001840: 656f 6d65 7472 7974 7970 656e 616d 650d  eometrytypename.
-00001850: 0a20 2020 2020 2020 2073 656c 662e 6765  .        self.ge
-00001860: 6f6d 6574 7279 7479 7065 203d 2067 656f  ometrytype = geo
-00001870: 6d65 7472 7974 7970 650d 0a20 2020 2020  metrytype..     
-00001880: 2020 2073 656c 662e 636f 6c75 6d6e 7320     self.columns 
-00001890: 3d20 636f 6c75 6d6e 730d 0a20 2020 2020  = columns..     
-000018a0: 2020 2073 656c 662e 6669 645f 636f 6c75     self.fid_colu
-000018b0: 6d6e 203d 2066 6964 5f63 6f6c 756d 6e0d  mn = fid_column.
-000018c0: 0a20 2020 2020 2020 2073 656c 662e 6372  .        self.cr
-000018d0: 7320 3d20 6372 730d 0a20 2020 2020 2020  s = crs..       
-000018e0: 2073 656c 662e 6572 726f 7273 203d 2065   self.errors = e
-000018f0: 7272 6f72 730d 0a0d 0a20 2020 2064 6566  rrors....    def
-00001900: 205f 5f72 6570 725f 5f28 7365 6c66 293a   __repr__(self):
-00001910: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00001920: 2066 227b 7365 6c66 2e5f 5f63 6c61 7373   f"{self.__class
-00001930: 5f5f 7d28 7b73 656c 662e 5f5f 6469 6374  __}({self.__dict
-00001940: 5f5f 7d29 220d 0a0d 0a0d 0a64 6566 2067  __})"......def g
-00001950: 6574 5f6c 6179 6572 5f67 656f 6d65 7472  et_layer_geometr
-00001960: 7974 7970 6573 280d 0a20 2020 2070 6174  ytypes(..    pat
-00001970: 683a 2055 6e69 6f6e 5b73 7472 2c20 226f  h: Union[str, "o
-00001980: 732e 5061 7468 4c69 6b65 5b41 6e79 5d22  s.PathLike[Any]"
-00001990: 5d2c 206c 6179 6572 3a20 4f70 7469 6f6e  ], layer: Option
-000019a0: 616c 5b73 7472 5d20 3d20 4e6f 6e65 0d0a  al[str] = None..
-000019b0: 2920 2d3e 204c 6973 745b 7374 725d 3a0d  ) -> List[str]:.
-000019c0: 0a20 2020 2022 2222 0d0a 2020 2020 4765  .    """..    Ge
-000019d0: 7420 7468 6520 6765 6f6d 6574 7279 2074  t the geometry t
-000019e0: 7970 6573 2069 6e20 7468 6520 6c61 7965  ypes in the laye
-000019f0: 7220 6279 2065 7861 6d69 6e69 6e67 2065  r by examining e
-00001a00: 6163 6820 6765 6f6d 6574 7279 2069 6e20  ach geometry in 
-00001a10: 7468 6520 6c61 7965 722e 0d0a 0d0a 2020  the layer.....  
-00001a20: 2020 5468 6520 6765 6e65 7261 6c20 6765    The general ge
-00001a30: 6f6d 6574 7279 2074 7970 6520 6f66 2074  ometry type of t
-00001a40: 6865 206c 6179 6572 2063 616e 2062 6520  he layer can be 
-00001a50: 6465 7465 726d 696e 6564 2075 7369 6e67  determined using
-00001a60: 0d0a 2020 2020 3a6d 6574 683a 607e 6765  ..    :meth:`~ge
-00001a70: 745f 6c61 7965 7269 6e66 6f60 2e0d 0a0d  t_layerinfo`....
-00001a80: 0a20 2020 2041 7267 733a 0d0a 2020 2020  .    Args:..    
-00001a90: 2020 2020 7061 7468 2028 5061 7468 4c69      path (PathLi
-00001aa0: 6b65 293a 2070 6174 6820 746f 2074 6865  ke): path to the
-00001ab0: 2066 696c 6520 746f 2067 6574 2069 6e66   file to get inf
-00001ac0: 6f20 6162 6f75 740d 0a20 2020 2020 2020  o about..       
-00001ad0: 206c 6179 6572 2028 7374 7229 3a20 7468   layer (str): th
-00001ae0: 6520 6c61 7965 7220 796f 7520 7761 6e74  e layer you want
-00001af0: 2069 6e66 6f20 6162 6f75 742e 2044 6f65   info about. Doe
-00001b00: 736e 2774 206e 6565 6420 746f 2062 650d  sn't need to be.
-00001b10: 0a20 2020 2020 2020 2020 2020 2073 7065  .            spe
-00001b20: 6369 6669 6564 2069 6620 7468 6572 6520  cified if there 
-00001b30: 6973 206f 6e6c 7920 6f6e 6520 6c61 7965  is only one laye
-00001b40: 7220 696e 2074 6865 2067 656f 6669 6c65  r in the geofile
-00001b50: 2e0d 0a0d 0a20 2020 2052 6574 7572 6e73  .....    Returns
-00001b60: 3a0d 0a20 2020 2020 2020 204c 6973 745b  :..        List[
-00001b70: 7374 725d 3a20 7468 6520 6765 6f6d 6574  str]: the geomet
-00001b80: 7279 2074 7970 6573 2069 6e20 7468 6520  ry types in the 
-00001b90: 6c61 7965 722e 0d0a 2020 2020 2222 220d  layer...    """.
-00001ba0: 0a20 2020 2073 716c 5f73 746d 7420 3d20  .    sql_stmt = 
-00001bb0: 2222 220d 0a20 2020 2020 2020 2053 454c  """..        SEL
-00001bc0: 4543 5420 4449 5354 494e 4354 0d0a 2020  ECT DISTINCT..  
-00001bd0: 2020 2020 2020 2020 2020 2020 2043 4153               CAS
-00001be0: 450d 0a20 2020 2020 2020 2020 2020 2020  E..             
-00001bf0: 2020 2020 5748 454e 2043 6173 7454 6f53      WHEN CastToS
-00001c00: 696e 676c 6528 7b67 656f 6d65 7472 7963  ingle({geometryc
-00001c10: 6f6c 756d 6e7d 2920 4953 204e 4f54 204e  olumn}) IS NOT N
-00001c20: 554c 4c20 5448 454e 0d0a 2020 2020 2020  ULL THEN..      
-00001c30: 2020 2020 2020 2020 2020 2020 2020 2053                 S
-00001c40: 545f 4765 6f6d 6574 7279 5479 7065 2843  T_GeometryType(C
-00001c50: 6173 7454 6f53 696e 676c 6528 7b67 656f  astToSingle({geo
-00001c60: 6d65 7472 7963 6f6c 756d 6e7d 2929 0d0a  metrycolumn}))..
-00001c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001c80: 2045 4c53 4520 5354 5f47 656f 6d65 7472   ELSE ST_Geometr
-00001c90: 7954 7970 6528 7b67 656f 6d65 7472 7963  yType({geometryc
-00001ca0: 6f6c 756d 6e7d 290d 0a20 2020 2020 2020  olumn})..       
-00001cb0: 2020 2020 2020 2020 454e 4420 4153 2067          END AS g
-00001cc0: 656f 6d5f 7479 7065 0d0a 2020 2020 2020  eom_type..      
-00001cd0: 2020 2020 4652 4f4d 2022 7b69 6e70 7574      FROM "{input
-00001ce0: 5f6c 6179 6572 7d22 206c 6179 6572 0d0a  _layer}" layer..
-00001cf0: 2020 2020 2222 220d 0a20 2020 2072 6573      """..    res
-00001d00: 756c 745f 6466 203d 2072 6561 645f 6669  ult_df = read_fi
-00001d10: 6c65 2870 6174 682c 2073 716c 5f73 746d  le(path, sql_stm
-00001d20: 743d 7371 6c5f 7374 6d74 2c20 7371 6c5f  t=sql_stmt, sql_
-00001d30: 6469 616c 6563 743d 2253 514c 4954 4522  dialect="SQLITE"
-00001d40: 290d 0a20 2020 2072 6574 7572 6e20 7265  )..    return re
-00001d50: 7375 6c74 5f64 665b 2267 656f 6d5f 7479  sult_df["geom_ty
-00001d60: 7065 225d 2e74 6f5f 6c69 7374 2829 2020  pe"].to_list()  
-00001d70: 2320 7479 7065 3a20 6967 6e6f 7265 0d0a  # type: ignore..
-00001d80: 0d0a 0d0a 6465 6620 6765 745f 6c61 7965  ....def get_laye
-00001d90: 7269 6e66 6f28 0d0a 2020 2020 7061 7468  rinfo(..    path
-00001da0: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
-00001db0: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
-00001dc0: 2c20 6c61 7965 723a 204f 7074 696f 6e61  , layer: Optiona
-00001dd0: 6c5b 7374 725d 203d 204e 6f6e 650d 0a29  l[str] = None..)
-00001de0: 202d 3e20 4c61 7965 7249 6e66 6f3a 0d0a   -> LayerInfo:..
-00001df0: 2020 2020 2222 220d 0a20 2020 2047 6574      """..    Get
-00001e00: 2069 6e66 6f72 6d61 7469 6f6e 2061 626f   information abo
-00001e10: 7574 2061 206c 6179 6572 2069 6e20 7468  ut a layer in th
-00001e20: 6520 6765 6f66 696c 652e 0d0a 0d0a 2020  e geofile.....  
-00001e30: 2020 5261 6973 6573 2061 6e20 6578 6365    Raises an exce
-00001e40: 7074 696f 6e20 6966 2074 6865 206c 6179  ption if the lay
-00001e50: 6572 2064 6566 696e 6974 696f 6e20 6861  er definition ha
-00001e60: 7320 6572 726f 7273 206c 696b 6520 696e  s errors like in
-00001e70: 7661 6c69 6420 636f 6c75 6d6e 0d0a 2020  valid column..  
-00001e80: 2020 6e61 6d65 732c 2e2e 2e0d 0a0d 0a20    names,....... 
-00001e90: 2020 2041 7267 733a 0d0a 2020 2020 2020     Args:..      
-00001ea0: 2020 7061 7468 2028 5061 7468 4c69 6b65    path (PathLike
-00001eb0: 293a 2070 6174 6820 746f 2074 6865 2066  ): path to the f
-00001ec0: 696c 6520 746f 2067 6574 2069 6e66 6f20  ile to get info 
-00001ed0: 6162 6f75 740d 0a20 2020 2020 2020 206c  about..        l
-00001ee0: 6179 6572 2028 7374 7229 3a20 7468 6520  ayer (str): the 
-00001ef0: 6c61 7965 7220 796f 7520 7761 6e74 2069  layer you want i
-00001f00: 6e66 6f20 6162 6f75 742e 2044 6f65 736e  nfo about. Doesn
-00001f10: 2774 206e 6565 6420 746f 2062 650d 0a20  't need to be.. 
-00001f20: 2020 2020 2020 2020 2020 2073 7065 6369             speci
-00001f30: 6669 6564 2069 6620 7468 6572 6520 6973  fied if there is
-00001f40: 206f 6e6c 7920 6f6e 6520 6c61 7965 7220   only one layer 
-00001f50: 696e 2074 6865 2067 656f 6669 6c65 2e0d  in the geofile..
-00001f60: 0a0d 0a20 2020 2052 6574 7572 6e73 3a0d  ...    Returns:.
-00001f70: 0a20 2020 2020 2020 204c 6179 6572 496e  .        LayerIn
-00001f80: 666f 3a20 7468 6520 696e 666f 726d 6174  fo: the informat
-00001f90: 696f 6e20 6162 6f75 7420 7468 6520 6c61  ion about the la
-00001fa0: 7965 722e 0d0a 2020 2020 2222 220d 0a20  yer...    """.. 
-00001fb0: 2020 2023 2049 6e69 740d 0a20 2020 2070     # Init..    p
-00001fc0: 6174 6820 3d20 5061 7468 2870 6174 6829  ath = Path(path)
-00001fd0: 0d0a 2020 2020 6966 206e 6f74 2070 6174  ..    if not pat
-00001fe0: 682e 6578 6973 7473 2829 3a0d 0a20 2020  h.exists():..   
-00001ff0: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-00002000: 4572 726f 7228 6622 696e 7075 745f 7061  Error(f"input_pa
-00002010: 7468 2064 6f65 736e 2774 2065 7869 7374  th doesn't exist
-00002020: 3a20 7b70 6174 687d 2229 0d0a 0d0a 2020  : {path}")....  
-00002030: 2020 6966 206c 6179 6572 2069 7320 4e6f    if layer is No
-00002040: 6e65 3a0d 0a20 2020 2020 2020 206c 6179  ne:..        lay
-00002050: 6572 203d 2067 6574 5f6f 6e6c 795f 6c61  er = get_only_la
-00002060: 7965 7228 7061 7468 290d 0a0d 0a20 2020  yer(path)....   
-00002070: 2064 6174 6173 6f75 7263 6520 3d20 4e6f   datasource = No
-00002080: 6e65 0d0a 2020 2020 7472 793a 0d0a 2020  ne..    try:..  
-00002090: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
-000020a0: 203d 2067 6461 6c2e 4f70 656e 4578 2873   = gdal.OpenEx(s
-000020b0: 7472 2870 6174 6829 290d 0a20 2020 2020  tr(path))..     
-000020c0: 2020 2064 6174 6173 6f75 7263 655f 6c61     datasource_la
-000020d0: 7965 7220 3d20 6461 7461 736f 7572 6365  yer = datasource
-000020e0: 2e47 6574 4c61 7965 7228 6c61 7965 7229  .GetLayer(layer)
-000020f0: 0d0a 0d0a 2020 2020 2020 2020 2320 4966  ....        # If
-00002100: 2074 6865 206c 6179 6572 2064 6f65 736e   the layer doesn
-00002110: 2774 2065 7869 7374 2c20 7265 7475 726e  't exist, return
-00002120: 0d0a 2020 2020 2020 2020 6966 2064 6174  ..        if dat
-00002130: 6173 6f75 7263 655f 6c61 7965 7220 6973  asource_layer is
-00002140: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-00002150: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-00002160: 7272 6f72 2866 224c 6179 6572 207b 6c61  rror(f"Layer {la
-00002170: 7965 727d 206e 6f74 2066 6f75 6e64 2069  yer} not found i
-00002180: 6e20 6669 6c65 3a20 7b70 6174 687d 2229  n file: {path}")
-00002190: 0d0a 0d0a 2020 2020 2020 2020 2320 4765  ....        # Ge
-000021a0: 7420 636f 6c75 6d6e 2069 6e66 6f0d 0a20  t column info.. 
-000021b0: 2020 2020 2020 2063 6f6c 756d 6e73 203d         columns =
-000021c0: 207b 7d0d 0a20 2020 2020 2020 2065 7272   {}..        err
-000021d0: 6f72 7320 3d20 5b5d 0d0a 2020 2020 2020  ors = []..      
-000021e0: 2020 6765 6f66 696c 6574 7970 6520 3d20    geofiletype = 
-000021f0: 4765 6f66 696c 6554 7970 6528 7061 7468  GeofileType(path
-00002200: 290d 0a20 2020 2020 2020 206c 6179 6572  )..        layer
-00002210: 5f64 6566 6e20 3d20 6461 7461 736f 7572  _defn = datasour
-00002220: 6365 5f6c 6179 6572 2e47 6574 4c61 7965  ce_layer.GetLaye
-00002230: 7244 6566 6e28 290d 0a20 2020 2020 2020  rDefn()..       
-00002240: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
-00002250: 6c61 7965 725f 6465 666e 2e47 6574 4669  layer_defn.GetFi
-00002260: 656c 6443 6f75 6e74 2829 293a 0d0a 2020  eldCount()):..  
-00002270: 2020 2020 2020 2020 2020 6e61 6d65 203d            name =
-00002280: 206c 6179 6572 5f64 6566 6e2e 4765 7446   layer_defn.GetF
-00002290: 6965 6c64 4465 666e 2869 292e 4765 744e  ieldDefn(i).GetN
-000022a0: 616d 6528 290d 0a20 2020 2020 2020 2020  ame()..         
-000022b0: 2020 2023 2054 4f44 4f3a 2074 6869 6e6b     # TODO: think
-000022c0: 2077 6865 7468 6572 2074 6865 2074 7970   whether the typ
-000022d0: 6520 6e61 6d65 2073 686f 756c 6420 6265  e name should be
-000022e0: 2063 6f6e 7665 7274 6564 2074 6f20 6f74   converted to ot
-000022f0: 6865 7220 6e61 6d65 730d 0a20 2020 2020  her names..     
-00002300: 2020 2020 2020 2067 6461 6c5f 7479 7065         gdal_type
-00002310: 203d 206c 6179 6572 5f64 6566 6e2e 4765   = layer_defn.Ge
-00002320: 7446 6965 6c64 4465 666e 2869 292e 4765  tFieldDefn(i).Ge
-00002330: 7454 7970 654e 616d 6528 290d 0a20 2020  tTypeName()..   
-00002340: 2020 2020 2020 2020 2077 6964 7468 203d           width =
-00002350: 206c 6179 6572 5f64 6566 6e2e 4765 7446   layer_defn.GetF
-00002360: 6965 6c64 4465 666e 2869 292e 4765 7457  ieldDefn(i).GetW
-00002370: 6964 7468 2829 0d0a 2020 2020 2020 2020  idth()..        
-00002380: 2020 2020 7769 6474 6820 3d20 7769 6474      width = widt
-00002390: 6820 6966 2077 6964 7468 203e 2030 2065  h if width > 0 e
-000023a0: 6c73 6520 4e6f 6e65 0d0a 2020 2020 2020  lse None..      
-000023b0: 2020 2020 2020 7072 6563 6973 696f 6e20        precision 
-000023c0: 3d20 6c61 7965 725f 6465 666e 2e47 6574  = layer_defn.Get
-000023d0: 4669 656c 6444 6566 6e28 6929 2e47 6574  FieldDefn(i).Get
-000023e0: 5072 6563 6973 696f 6e28 290d 0a20 2020  Precision()..   
-000023f0: 2020 2020 2020 2020 2070 7265 6369 7369           precisi
-00002400: 6f6e 203d 2070 7265 6369 7369 6f6e 2069  on = precision i
-00002410: 6620 7072 6563 6973 696f 6e20 3e20 3020  f precision > 0 
-00002420: 656c 7365 204e 6f6e 650d 0a20 2020 2020  else None..     
-00002430: 2020 2020 2020 2069 6c6c 6567 616c 5f63         illegal_c
-00002440: 6f6c 756d 6e5f 6368 6172 7320 3d20 5b27  olumn_chars = ['
-00002450: 2227 5d0d 0a20 2020 2020 2020 2020 2020  "']..           
-00002460: 2066 6f72 2069 6c6c 6567 616c 5f63 6861   for illegal_cha
-00002470: 7220 696e 2069 6c6c 6567 616c 5f63 6f6c  r in illegal_col
-00002480: 756d 6e5f 6368 6172 733a 0d0a 2020 2020  umn_chars:..    
-00002490: 2020 2020 2020 2020 2020 2020 6966 2069              if i
-000024a0: 6c6c 6567 616c 5f63 6861 7220 696e 206e  llegal_char in n
-000024b0: 616d 653a 0d0a 2020 2020 2020 2020 2020  ame:..          
-000024c0: 2020 2020 2020 2020 2020 6572 726f 7273            errors
-000024d0: 2e61 7070 656e 6428 0d0a 2020 2020 2020  .append(..      
-000024e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000024f0: 2020 6622 436f 6c75 6d6e 206e 616d 6520    f"Column name 
-00002500: 7b6e 616d 657d 2063 6f6e 7461 696e 7320  {name} contains 
-00002510: 696c 6c65 6761 6c20 6368 6172 3a20 7b69  illegal char: {i
-00002520: 6c6c 6567 616c 5f63 6861 727d 2022 0d0a  llegal_char} "..
-00002530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002540: 2020 2020 2020 2020 6622 696e 2066 696c          f"in fil
-00002550: 6520 7b70 6174 687d 2c20 6c61 7965 7220  e {path}, layer 
-00002560: 7b6c 6179 6572 7d22 0d0a 2020 2020 2020  {layer}"..      
-00002570: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-00002580: 0a20 2020 2020 2020 2020 2020 2063 6f6c  .            col
-00002590: 756d 6e5f 696e 666f 203d 2043 6f6c 756d  umn_info = Colum
-000025a0: 6e49 6e66 6f28 0d0a 2020 2020 2020 2020  nInfo(..        
-000025b0: 2020 2020 2020 2020 6e61 6d65 3d6e 616d          name=nam
-000025c0: 652c 2067 6461 6c5f 7479 7065 3d67 6461  e, gdal_type=gda
-000025d0: 6c5f 7479 7065 2c20 7769 6474 683d 7769  l_type, width=wi
-000025e0: 6474 682c 2070 7265 6369 7369 6f6e 3d70  dth, precision=p
-000025f0: 7265 6369 7369 6f6e 0d0a 2020 2020 2020  recision..      
-00002600: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-00002610: 2020 2020 2063 6f6c 756d 6e73 5b6e 616d       columns[nam
-00002620: 655d 203d 2063 6f6c 756d 6e5f 696e 666f  e] = column_info
-00002630: 0d0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-00002640: 2067 656f 6669 6c65 7479 7065 203d 3d20   geofiletype == 
-00002650: 4765 6f66 696c 6554 7970 652e 4553 5249  GeofileType.ESRI
-00002660: 5368 6170 6566 696c 653a 0d0a 2020 2020  Shapefile:..    
-00002670: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-00002680: 616d 652e 6361 7365 666f 6c64 2829 203d  ame.casefold() =
-00002690: 3d20 2267 656f 6d65 7472 7922 3a0d 0a20  = "geometry":.. 
-000026a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000026b0: 2020 2065 7272 6f72 732e 6170 7065 6e64     errors.append
-000026c0: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-000026d0: 2020 2020 2020 2020 2020 2022 416e 2061             "An a
-000026e0: 7474 7269 6275 7465 2063 6f6c 756d 6e20  ttribute column 
-000026f0: 2767 656f 6d65 7472 7927 2069 7320 6e6f  'geometry' is no
-00002700: 7420 7375 7070 6f72 7465 6420 696e 2061  t supported in a
-00002710: 2073 6861 7065 6669 6c65 220d 0a20 2020   shapefile"..   
-00002720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002730: 2029 0d0a 0d0a 2020 2020 2020 2020 2320   )....        # 
-00002740: 4765 7420 6765 6f6d 6574 7279 2063 6f6c  Get geometry col
-00002750: 756d 6e20 696e 666f 2e2e 2e0d 0a20 2020  umn info.....   
-00002760: 2020 2020 2067 656f 6d65 7472 7974 7970       geometrytyp
-00002770: 656e 616d 6520 3d20 6764 616c 2e6f 6772  ename = gdal.ogr
-00002780: 2e47 656f 6d65 7472 7954 7970 6554 6f4e  .GeometryTypeToN
-00002790: 616d 6528 6461 7461 736f 7572 6365 5f6c  ame(datasource_l
-000027a0: 6179 6572 2e47 6574 4765 6f6d 5479 7065  ayer.GetGeomType
-000027b0: 2829 290d 0a20 2020 2020 2020 2067 656f  ())..        geo
-000027c0: 6d65 7472 7974 7970 656e 616d 6520 3d20  metrytypename = 
-000027d0: 6765 6f6d 6574 7279 7479 7065 6e61 6d65  geometrytypename
-000027e0: 2e72 6570 6c61 6365 2822 2022 2c20 2222  .replace(" ", ""
-000027f0: 292e 7570 7065 7228 290d 0a0d 0a20 2020  ).upper()....   
-00002800: 2020 2020 2023 2046 6f72 2073 6861 7065       # For shape
-00002810: 2066 696c 6573 2c20 7468 6520 6469 6666   files, the diff
-00002820: 6572 656e 6365 2062 6574 7765 656e 2074  erence between t
-00002830: 6865 2027 4d55 4c54 4927 2076 6172 6961  he 'MULTI' varia
-00002840: 6e74 2061 6e64 2074 6865 0d0a 2020 2020  nt and the..    
-00002850: 2020 2020 2320 7369 6e67 6c65 206f 6e65      # single one
-00002860: 2064 6f65 736e 2774 2065 7869 7374 732e   doesn't exists.
-00002870: 2e2e 2073 6f20 616c 7761 7973 2072 6570  .. so always rep
-00002880: 6f72 7420 4d55 4c54 4920 7661 7269 616e  ort MULTI varian
-00002890: 7420 6279 2063 6f6e 7665 6e74 696f 6e2e  t by convention.
-000028a0: 0d0a 2020 2020 2020 2020 6966 2047 656f  ..        if Geo
-000028b0: 6669 6c65 5479 7065 2870 6174 6829 203d  fileType(path) =
-000028c0: 3d20 4765 6f66 696c 6554 7970 652e 4553  = GeofileType.ES
-000028d0: 5249 5368 6170 6566 696c 653a 0d0a 2020  RIShapefile:..  
-000028e0: 2020 2020 2020 2020 2020 6966 2028 0d0a            if (..
-000028f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002900: 6765 6f6d 6574 7279 7479 7065 6e61 6d65  geometrytypename
-00002910: 2e73 7461 7274 7377 6974 6828 2250 4f4c  .startswith("POL
-00002920: 5947 4f4e 2229 0d0a 2020 2020 2020 2020  YGON")..        
-00002930: 2020 2020 2020 2020 6f72 2067 656f 6d65          or geome
-00002940: 7472 7974 7970 656e 616d 652e 7374 6172  trytypename.star
-00002950: 7473 7769 7468 2822 4c49 4e45 5354 5249  tswith("LINESTRI
-00002960: 4e47 2229 0d0a 2020 2020 2020 2020 2020  NG")..          
-00002970: 2020 2020 2020 6f72 2067 656f 6d65 7472        or geometr
-00002980: 7974 7970 656e 616d 652e 7374 6172 7473  ytypename.starts
-00002990: 7769 7468 2822 504f 494e 5422 290d 0a20  with("POINT").. 
-000029a0: 2020 2020 2020 2020 2020 2029 3a0d 0a20             ):.. 
-000029b0: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-000029c0: 656f 6d65 7472 7974 7970 656e 616d 6520  eometrytypename 
-000029d0: 3d20 6622 4d55 4c54 497b 6765 6f6d 6574  = f"MULTI{geomet
-000029e0: 7279 7479 7065 6e61 6d65 7d22 0d0a 2020  rytypename}"..  
-000029f0: 2020 2020 2020 6966 2067 656f 6d65 7472        if geometr
-00002a00: 7974 7970 656e 616d 6520 3d3d 2022 554e  ytypename == "UN
-00002a10: 4b4e 4f57 4e28 414e 5929 223a 0d0a 2020  KNOWN(ANY)":..  
-00002a20: 2020 2020 2020 2020 2020 6765 6f6d 6574            geomet
-00002a30: 7279 7479 7065 6e61 6d65 203d 2022 4745  rytypename = "GE
-00002a40: 4f4d 4554 5259 220d 0a0d 0a20 2020 2020  OMETRY"....     
-00002a50: 2020 2023 2047 656f 6d65 7472 7974 7970     # Geometrytyp
-00002a60: 650d 0a20 2020 2020 2020 2069 6620 6765  e..        if ge
-00002a70: 6f6d 6574 7279 7479 7065 6e61 6d65 2021  ometrytypename !
-00002a80: 3d20 224e 4f4e 4522 3a0d 0a20 2020 2020  = "NONE":..     
-00002a90: 2020 2020 2020 2067 656f 6d65 7472 7974         geometryt
-00002aa0: 7970 6520 3d20 4765 6f6d 6574 7279 5479  ype = GeometryTy
-00002ab0: 7065 5b67 656f 6d65 7472 7974 7970 656e  pe[geometrytypen
-00002ac0: 616d 655d 0d0a 2020 2020 2020 2020 656c  ame]..        el
-00002ad0: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-00002ae0: 2067 656f 6d65 7472 7974 7970 6520 3d20   geometrytype = 
-00002af0: 4e6f 6e65 0d0a 0d0a 2020 2020 2020 2020  None....        
-00002b00: 2320 4966 2074 6865 2067 656f 6d65 7472  # If the geometr
-00002b10: 7920 7479 7065 2069 7320 6e6f 7420 4e6f  y type is not No
-00002b20: 6e65 2c20 6669 6c6c 206f 7574 2074 6865  ne, fill out the
-00002b30: 2065 7874 7261 2070 726f 7065 7274 6965   extra propertie
-00002b40: 730d 0a20 2020 2020 2020 2067 656f 6d65  s..        geome
-00002b50: 7472 7963 6f6c 756d 6e20 3d20 4e6f 6e65  trycolumn = None
-00002b60: 0d0a 2020 2020 2020 2020 6578 7465 6e74  ..        extent
-00002b70: 203d 204e 6f6e 650d 0a20 2020 2020 2020   = None..       
-00002b80: 2063 7273 203d 204e 6f6e 650d 0a20 2020   crs = None..   
-00002b90: 2020 2020 2074 6f74 616c 5f62 6f75 6e64       total_bound
-00002ba0: 7320 3d20 4e6f 6e65 0d0a 2020 2020 2020  s = None..      
-00002bb0: 2020 6966 2067 656f 6d65 7472 7974 7970    if geometrytyp
-00002bc0: 6520 6973 206e 6f74 204e 6f6e 653a 0d0a  e is not None:..
-00002bd0: 2020 2020 2020 2020 2020 2020 2320 4765              # Ge
-00002be0: 6f6d 6574 7279 2063 6f6c 756d 6e20 6e61  ometry column na
-00002bf0: 6d65 0d0a 2020 2020 2020 2020 2020 2020  me..            
-00002c00: 6765 6f6d 6574 7279 636f 6c75 6d6e 203d  geometrycolumn =
-00002c10: 2064 6174 6173 6f75 7263 655f 6c61 7965   datasource_laye
-00002c20: 722e 4765 7447 656f 6d65 7472 7943 6f6c  r.GetGeometryCol
-00002c30: 756d 6e28 290d 0a20 2020 2020 2020 2020  umn()..         
-00002c40: 2020 2069 6620 6765 6f6d 6574 7279 636f     if geometryco
-00002c50: 6c75 6d6e 203d 3d20 2222 3a0d 0a20 2020  lumn == "":..   
-00002c60: 2020 2020 2020 2020 2020 2020 2067 656f               geo
-00002c70: 6d65 7472 7963 6f6c 756d 6e20 3d20 2267  metrycolumn = "g
-00002c80: 656f 6d65 7472 7922 0d0a 2020 2020 2020  eometry"..      
-00002c90: 2020 2020 2020 2320 436f 6e76 6572 7420        # Convert 
-00002ca0: 6578 7465 6e74 2028 786d 696e 2c20 786d  extent (xmin, xm
-00002cb0: 6178 2c20 796d 696e 2c20 796d 6178 2920  ax, ymin, ymax) 
-00002cc0: 746f 2062 6f75 6e64 7320 2878 6d69 6e2c  to bounds (xmin,
-00002cd0: 2079 6d69 6e2c 2078 6d61 782c 2079 6d61   ymin, xmax, yma
-00002ce0: 7829 0d0a 2020 2020 2020 2020 2020 2020  x)..            
-00002cf0: 6578 7465 6e74 203d 2064 6174 6173 6f75  extent = datasou
-00002d00: 7263 655f 6c61 7965 722e 4765 7445 7874  rce_layer.GetExt
-00002d10: 656e 7428 290d 0a20 2020 2020 2020 2020  ent()..         
-00002d20: 2020 2074 6f74 616c 5f62 6f75 6e64 7320     total_bounds 
-00002d30: 3d20 2865 7874 656e 745b 305d 2c20 6578  = (extent[0], ex
-00002d40: 7465 6e74 5b32 5d2c 2065 7874 656e 745b  tent[2], extent[
-00002d50: 315d 2c20 6578 7465 6e74 5b33 5d29 0d0a  1], extent[3])..
-00002d60: 2020 2020 2020 2020 2020 2020 2320 4352              # CR
-00002d70: 530d 0a20 2020 2020 2020 2020 2020 2073  S..            s
-00002d80: 7061 7469 616c 7265 6620 3d20 6461 7461  patialref = data
-00002d90: 736f 7572 6365 5f6c 6179 6572 2e47 6574  source_layer.Get
-00002da0: 5370 6174 6961 6c52 6566 2829 0d0a 2020  SpatialRef()..  
-00002db0: 2020 2020 2020 2020 2020 6966 2073 7061            if spa
-00002dc0: 7469 616c 7265 6620 6973 206e 6f74 204e  tialref is not N
-00002dd0: 6f6e 653a 0d0a 2020 2020 2020 2020 2020  one:..          
-00002de0: 2020 2020 2020 6372 7320 3d20 7079 7072        crs = pypr
-00002df0: 6f6a 2e43 5253 2873 7061 7469 616c 7265  oj.CRS(spatialre
-00002e00: 662e 4578 706f 7274 546f 576b 7428 2929  f.ExportToWkt())
-00002e10: 0d0a 0d0a 2020 2020 2020 2020 2020 2020  ....            
-00002e20: 2020 2020 2320 4966 2073 7061 7469 616c      # If spatial
-00002e30: 2072 6566 2068 6173 206e 6f20 6570 7367   ref has no epsg
-00002e40: 2c20 7472 7920 746f 2066 696e 6420 636f  , try to find co
-00002e50: 7272 6573 706f 6e64 696e 6720 6f6e 650d  rresponding one.
-00002e60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002e70: 2063 7273 5f65 7073 6720 3d20 6372 732e   crs_epsg = crs.
-00002e80: 746f 5f65 7073 6728 290d 0a20 2020 2020  to_epsg()..     
-00002e90: 2020 2020 2020 2020 2020 2069 6620 6372             if cr
-00002ea0: 735f 6570 7367 2069 7320 4e6f 6e65 3a0d  s_epsg is None:.
-00002eb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002ec0: 2020 2020 2069 6620 6372 732e 6e61 6d65       if crs.name
-00002ed0: 2069 6e20 5b0d 0a20 2020 2020 2020 2020   in [..         
-00002ee0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00002ef0: 4265 6c67 6520 3139 3732 202f 2042 656c  Belge 1972 / Bel
-00002f00: 6769 616e 204c 616d 6265 7274 2037 3222  gian Lambert 72"
-00002f10: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00002f20: 2020 2020 2020 2020 2020 2022 4265 6c67             "Belg
-00002f30: 655f 3139 3732 5f42 656c 6769 616e 5f4c  e_1972_Belgian_L
-00002f40: 616d 6265 7274 5f37 3222 2c0d 0a20 2020  ambert_72",..   
-00002f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002f60: 2020 2020 2022 4265 6c67 655f 4c61 6d62       "Belge_Lamb
-00002f70: 6572 745f 3139 3732 222c 0d0a 2020 2020  ert_1972",..    
-00002f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002f90: 2020 2020 2242 4437 3220 2f20 4265 6c67      "BD72 / Belg
-00002fa0: 6961 6e20 4c61 6d62 6572 7420 3732 222c  ian Lambert 72",
-00002fb0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00002fc0: 2020 2020 2020 5d3a 0d0a 2020 2020 2020        ]:..      
-00002fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002fe0: 2020 2320 4265 6c67 6961 6e20 4c61 6d62    # Belgian Lamb
-00002ff0: 6572 7420 696e 206e 616d 652c 2073 6f20  ert in name, so 
-00003000: 6173 7375 6d65 2033 3133 3730 0d0a 2020  assume 31370..  
-00003010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003020: 2020 2020 2020 6372 7320 3d20 7079 7072        crs = pypr
-00003030: 6f6a 2e43 5253 2e66 726f 6d5f 6570 7367  oj.CRS.from_epsg
-00003040: 2833 3133 3730 290d 0a0d 0a20 2020 2020  (31370)....     
-00003050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003060: 2020 2023 2049 6620 7368 6170 6566 696c     # If shapefil
-00003070: 652c 2061 6464 2063 6f72 7265 6374 2033  e, add correct 3
-00003080: 3133 3730 202e 7072 6a20 6669 6c65 0d0a  1370 .prj file..
-00003090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000030a0: 2020 2020 2020 2020 6966 2047 656f 6669          if Geofi
-000030b0: 6c65 5479 7065 2870 6174 6829 203d 3d20  leType(path) == 
-000030c0: 4765 6f66 696c 6554 7970 652e 4553 5249  GeofileType.ESRI
-000030d0: 5368 6170 6566 696c 653a 0d0a 2020 2020  Shapefile:..    
-000030e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000030f0: 2020 2020 2020 2020 7072 6a5f 7061 7468          prj_path
-00003100: 203d 2070 6174 682e 7061 7265 6e74 202f   = path.parent /
-00003110: 2066 227b 7061 7468 2e73 7465 6d7d 2e70   f"{path.stem}.p
-00003120: 726a 220d 0a20 2020 2020 2020 2020 2020  rj"..           
-00003130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003140: 2069 6620 7072 6a5f 7061 7468 2e65 7869   if prj_path.exi
-00003150: 7374 7328 293a 0d0a 2020 2020 2020 2020  sts():..        
-00003160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003170: 2020 2020 2020 2020 7072 6a5f 7265 6e61          prj_rena
-00003180: 6d65 5f70 6174 6820 3d20 7061 7468 2e70  me_path = path.p
-00003190: 6172 656e 7420 2f20 6622 7b70 6174 682e  arent / f"{path.
-000031a0: 7374 656d 7d5f 6f72 6967 2e70 726a 220d  stem}_orig.prj".
-000031b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000031c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000031d0: 2069 6620 6e6f 7420 7072 6a5f 7265 6e61   if not prj_rena
-000031e0: 6d65 5f70 6174 682e 6578 6973 7473 2829  me_path.exists()
-000031f0: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00003200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003210: 2020 2020 2020 2070 726a 5f70 6174 682e         prj_path.
-00003220: 7265 6e61 6d65 2870 726a 5f72 656e 616d  rename(prj_renam
-00003230: 655f 7061 7468 290d 0a20 2020 2020 2020  e_path)..       
-00003240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003250: 2020 2020 2020 2020 2065 6c73 653a 0d0a           else:..
-00003260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003280: 2020 2020 7072 6a5f 7061 7468 2e75 6e6c      prj_path.unl
-00003290: 696e 6b28 290d 0a20 2020 2020 2020 2020  ink()..         
-000032a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000032b0: 2020 2020 2020 2070 726a 5f70 6174 682e         prj_path.
-000032c0: 7772 6974 655f 7465 7874 2850 524a 5f45  write_text(PRJ_E
-000032d0: 5053 475f 3331 3337 3029 0d0a 0d0a 2020  PSG_31370)....  
-000032e0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-000032f0: 204c 6179 6572 496e 666f 280d 0a20 2020   LayerInfo(..   
-00003300: 2020 2020 2020 2020 2020 2020 206e 616d               nam
-00003310: 653d 6461 7461 736f 7572 6365 5f6c 6179  e=datasource_lay
-00003320: 6572 2e47 6574 4e61 6d65 2829 2c0d 0a20  er.GetName(),.. 
-00003330: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00003340: 6561 7475 7265 636f 756e 743d 6461 7461  eaturecount=data
-00003350: 736f 7572 6365 5f6c 6179 6572 2e47 6574  source_layer.Get
-00003360: 4665 6174 7572 6543 6f75 6e74 2829 2c0d  FeatureCount(),.
-00003370: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003380: 2074 6f74 616c 5f62 6f75 6e64 733d 746f   total_bounds=to
-00003390: 7461 6c5f 626f 756e 6473 2c0d 0a20 2020  tal_bounds,..   
-000033a0: 2020 2020 2020 2020 2020 2020 2067 656f               geo
-000033b0: 6d65 7472 7963 6f6c 756d 6e3d 6765 6f6d  metrycolumn=geom
-000033c0: 6574 7279 636f 6c75 6d6e 2c0d 0a20 2020  etrycolumn,..   
-000033d0: 2020 2020 2020 2020 2020 2020 2067 656f               geo
-000033e0: 6d65 7472 7974 7970 656e 616d 653d 6765  metrytypename=ge
-000033f0: 6f6d 6574 7279 7479 7065 6e61 6d65 2c0d  ometrytypename,.
-00003400: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003410: 2067 656f 6d65 7472 7974 7970 653d 6765   geometrytype=ge
-00003420: 6f6d 6574 7279 7479 7065 2c0d 0a20 2020  ometrytype,..   
-00003430: 2020 2020 2020 2020 2020 2020 2063 6f6c               col
-00003440: 756d 6e73 3d63 6f6c 756d 6e73 2c0d 0a20  umns=columns,.. 
-00003450: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00003460: 6964 5f63 6f6c 756d 6e3d 6461 7461 736f  id_column=dataso
-00003470: 7572 6365 5f6c 6179 6572 2e47 6574 4649  urce_layer.GetFI
-00003480: 4443 6f6c 756d 6e28 292c 0d0a 2020 2020  DColumn(),..    
-00003490: 2020 2020 2020 2020 2020 2020 6372 733d              crs=
-000034a0: 6372 732c 0d0a 2020 2020 2020 2020 2020  crs,..          
-000034b0: 2020 2020 2020 6572 726f 7273 3d65 7272        errors=err
-000034c0: 6f72 732c 0d0a 2020 2020 2020 2020 2020  ors,..          
-000034d0: 2020 290d 0a20 2020 2020 2020 2065 6c73    )..        els
-000034e0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-000034f0: 6572 726f 7273 2e61 7070 656e 6428 224c  errors.append("L
-00003500: 6179 6572 2064 6f65 736e 2774 2068 6176  ayer doesn't hav
-00003510: 6520 6120 6765 6f6d 6574 7279 2063 6f6c  e a geometry col
-00003520: 756d 6e21 2229 0d0a 0d0a 2020 2020 6669  umn!")....    fi
-00003530: 6e61 6c6c 793a 0d0a 2020 2020 2020 2020  nally:..        
-00003540: 6966 2064 6174 6173 6f75 7263 6520 6973  if datasource is
-00003550: 206e 6f74 204e 6f6e 653a 0d0a 2020 2020   not None:..    
-00003560: 2020 2020 2020 2020 6465 6c20 6461 7461          del data
-00003570: 736f 7572 6365 0d0a 0d0a 2020 2020 2320  source....    # 
-00003580: 4966 2077 6520 6469 646e 2774 2072 6574  If we didn't ret
-00003590: 7572 6e20 6f72 2072 6169 7365 2079 6574  urn or raise yet
-000035a0: 2068 6572 652c 2074 6865 7265 206d 7573   here, there mus
-000035b0: 7420 6861 7665 2062 6565 6e20 6572 726f  t have been erro
-000035c0: 7273 0d0a 2020 2020 6572 726f 7273 5f73  rs..    errors_s
-000035d0: 7472 203d 2070 7072 696e 742e 7066 6f72  tr = pprint.pfor
-000035e0: 6d61 7428 6572 726f 7273 290d 0a20 2020  mat(errors)..   
-000035f0: 2072 6169 7365 2045 7863 6570 7469 6f6e   raise Exception
-00003600: 280d 0a20 2020 2020 2020 2066 2245 7272  (..        f"Err
-00003610: 6f72 7320 696e 206c 6179 6572 2064 6566  ors in layer def
-00003620: 696e 6974 696f 6e20 6f66 2066 696c 6520  inition of file 
-00003630: 7b70 6174 687d 2c20 6c61 7965 7220 7b6c  {path}, layer {l
-00003640: 6179 6572 7d3a 205c 6e7b 6572 726f 7273  ayer}: \n{errors
-00003650: 5f73 7472 7d22 0d0a 2020 2020 290d 0a0d  _str}"..    )...
-00003660: 0a0d 0a64 6566 2067 6574 5f6f 6e6c 795f  ...def get_only_
-00003670: 6c61 7965 7228 7061 7468 3a20 556e 696f  layer(path: Unio
-00003680: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
-00003690: 696b 655b 416e 795d 225d 2920 2d3e 2073  ike[Any]"]) -> s
-000036a0: 7472 3a0d 0a20 2020 2022 2222 0d0a 2020  tr:..    """..  
-000036b0: 2020 4765 7420 7468 6520 6c61 7965 726e    Get the layern
-000036c0: 616d 6520 666f 7220 6120 6669 6c65 2074  ame for a file t
-000036d0: 6861 7420 6f6e 6c79 2063 6f6e 7461 696e  hat only contain
-000036e0: 7320 6f6e 6520 6c61 7965 722e 0d0a 0d0a  s one layer.....
-000036f0: 2020 2020 4966 2074 6865 2066 696c 6520      If the file 
-00003700: 636f 6e74 6169 6e73 206d 756c 7469 706c  contains multipl
-00003710: 6520 6c61 7965 7273 2c20 616e 2065 7863  e layers, an exc
-00003720: 6570 7469 6f6e 2069 7320 7468 726f 776e  eption is thrown
-00003730: 2e0d 0a0d 0a20 2020 2041 7267 733a 0d0a  .....    Args:..
-00003740: 2020 2020 2020 2020 7061 7468 2028 5061          path (Pa
-00003750: 7468 4c69 6b65 293a 2074 6865 2066 696c  thLike): the fil
-00003760: 652e 0d0a 0d0a 2020 2020 5261 6973 6573  e.....    Raises
-00003770: 3a0d 0a20 2020 2020 2020 2056 616c 7565  :..        Value
-00003780: 4572 726f 723a 2061 6e20 696e 7661 6c69  Error: an invali
-00003790: 6420 7061 7261 6d65 7465 7220 7661 6c75  d parameter valu
-000037a0: 6520 7761 7320 7061 7373 6564 2e0d 0a0d  e was passed....
-000037b0: 0a20 2020 2052 6574 7572 6e73 3a0d 0a20  .    Returns:.. 
-000037c0: 2020 2020 2020 2073 7472 3a20 7468 6520         str: the 
-000037d0: 6c61 7965 7220 6e61 6d65 0d0a 2020 2020  layer name..    
-000037e0: 2222 220d 0a20 2020 2064 6174 6173 6f75  """..    datasou
-000037f0: 7263 6520 3d20 4e6f 6e65 0d0a 2020 2020  rce = None..    
-00003800: 7472 793a 0d0a 2020 2020 2020 2020 6461  try:..        da
-00003810: 7461 736f 7572 6365 5f6c 6179 6572 203d  tasource_layer =
-00003820: 204e 6f6e 650d 0a20 2020 2020 2020 2064   None..        d
-00003830: 6174 6173 6f75 7263 6520 3d20 6764 616c  atasource = gdal
-00003840: 2e4f 7065 6e45 7828 0d0a 2020 2020 2020  .OpenEx(..      
-00003850: 2020 2020 2020 7374 7228 7061 7468 292c        str(path),
-00003860: 206e 4f70 656e 466c 6167 733d 6764 616c   nOpenFlags=gdal
-00003870: 2e4f 465f 5645 4354 4f52 207c 2067 6461  .OF_VECTOR | gda
-00003880: 6c2e 4f46 5f52 4541 444f 4e4c 5920 7c20  l.OF_READONLY | 
-00003890: 6764 616c 2e4f 465f 5348 4152 4544 0d0a  gdal.OF_SHARED..
-000038a0: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-000038b0: 2020 206e 625f 6c61 7965 7273 203d 2064     nb_layers = d
-000038c0: 6174 6173 6f75 7263 652e 4765 744c 6179  atasource.GetLay
-000038d0: 6572 436f 756e 7428 290d 0a20 2020 2020  erCount()..     
-000038e0: 2020 2069 6620 6e62 5f6c 6179 6572 7320     if nb_layers 
-000038f0: 3d3d 2031 3a0d 0a20 2020 2020 2020 2020  == 1:..         
-00003900: 2020 2064 6174 6173 6f75 7263 655f 6c61     datasource_la
-00003910: 7965 7220 3d20 6461 7461 736f 7572 6365  yer = datasource
-00003920: 2e47 6574 4c61 7965 7242 7949 6e64 6578  .GetLayerByIndex
-00003930: 2830 290d 0a20 2020 2020 2020 2065 6c69  (0)..        eli
-00003940: 6620 6e62 5f6c 6179 6572 7320 3d3d 2030  f nb_layers == 0
-00003950: 3a0d 0a20 2020 2020 2020 2020 2020 2072  :..            r
-00003960: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-00003970: 6622 4572 726f 723a 204e 6f20 6c61 7965  f"Error: No laye
-00003980: 7273 2066 6f75 6e64 2069 6e20 7b70 6174  rs found in {pat
-00003990: 687d 2229 0d0a 2020 2020 2020 2020 656c  h}")..        el
-000039a0: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-000039b0: 2023 2043 6865 636b 2069 6620 7468 6572   # Check if ther
-000039c0: 6520 6973 206f 6e6c 7920 6f6e 6520 7370  e is only one sp
-000039d0: 6174 6961 6c20 6c61 7965 720d 0a20 2020  atial layer..   
-000039e0: 2020 2020 2020 2020 206c 6179 6572 7320           layers 
-000039f0: 3d20 6c69 7374 6c61 7965 7273 2870 6174  = listlayers(pat
-00003a00: 682c 206f 6e6c 795f 7370 6174 6961 6c5f  h, only_spatial_
-00003a10: 6c61 7965 7273 3d54 7275 6529 0d0a 2020  layers=True)..  
-00003a20: 2020 2020 2020 2020 2020 6966 206c 656e            if len
-00003a30: 286c 6179 6572 7329 203d 3d20 313a 0d0a  (layers) == 1:..
-00003a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003a50: 6461 7461 736f 7572 6365 5f6c 6179 6572  datasource_layer
-00003a60: 203d 2064 6174 6173 6f75 7263 652e 4765   = datasource.Ge
-00003a70: 744c 6179 6572 286c 6179 6572 735b 305d  tLayer(layers[0]
-00003a80: 290d 0a20 2020 2020 2020 2020 2020 2065  )..            e
-00003a90: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-00003aa0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00003ab0: 6545 7272 6f72 2866 224c 6179 6572 2068  eError(f"Layer h
-00003ac0: 6173 203e 2031 206c 6179 6572 3a20 7b70  as > 1 layer: {p
-00003ad0: 6174 687d 3a20 7b6c 6179 6572 737d 2229  ath}: {layers}")
-00003ae0: 0d0a 0d0a 2020 2020 2020 2020 7265 7475  ....        retu
-00003af0: 726e 2064 6174 6173 6f75 7263 655f 6c61  rn datasource_la
-00003b00: 7965 722e 4765 744e 616d 6528 290d 0a0d  yer.GetName()...
-00003b10: 0a20 2020 2066 696e 616c 6c79 3a0d 0a20  .    finally:.. 
-00003b20: 2020 2020 2020 2069 6620 6461 7461 736f         if dataso
-00003b30: 7572 6365 2069 7320 6e6f 7420 4e6f 6e65  urce is not None
-00003b40: 3a0d 0a20 2020 2020 2020 2020 2020 2064  :..            d
-00003b50: 656c 2064 6174 6173 6f75 7263 650d 0a0d  el datasource...
-00003b60: 0a0d 0a64 6566 2067 6574 5f64 6566 6175  ...def get_defau
-00003b70: 6c74 5f6c 6179 6572 2870 6174 683a 2055  lt_layer(path: U
-00003b80: 6e69 6f6e 5b73 7472 2c20 226f 732e 5061  nion[str, "os.Pa
-00003b90: 7468 4c69 6b65 5b41 6e79 5d22 5d29 202d  thLike[Any]"]) -
-00003ba0: 3e20 7374 723a 0d0a 2020 2020 2222 220d  > str:..    """.
-00003bb0: 0a20 2020 2047 6574 2074 6865 2064 6566  .    Get the def
-00003bc0: 6175 6c74 206c 6179 6572 206e 616d 6520  ault layer name 
-00003bd0: 746f 2062 6520 7573 6564 2066 6f72 2061  to be used for a
-00003be0: 206c 6179 6572 2069 6e20 7468 6973 2066   layer in this f
-00003bf0: 696c 652e 0d0a 0d0a 2020 2020 5468 6973  ile.....    This
-00003c00: 2069 7320 7468 6520 7374 656d 206f 6620   is the stem of 
-00003c10: 7468 6520 6669 6c65 7061 7468 2e0d 0a0d  the filepath....
-00003c20: 0a20 2020 2041 7267 733a 0d0a 2020 2020  .    Args:..    
-00003c30: 2020 2020 7061 7468 2028 556e 696f 6e5b      path (Union[
-00003c40: 7374 722c 293a 2054 6865 2070 6174 6820  str,): The path 
-00003c50: 746f 2074 6865 2066 696c 652e 0d0a 0d0a  to the file.....
-00003c60: 2020 2020 5265 7475 726e 733a 0d0a 2020      Returns:..  
-00003c70: 2020 2020 2020 7374 723a 2054 6865 2064        str: The d
-00003c80: 6566 6175 6c74 206c 6179 6572 206e 616d  efault layer nam
-00003c90: 652e 0d0a 2020 2020 2222 220d 0a20 2020  e...    """..   
-00003ca0: 2072 6574 7572 6e20 5061 7468 2870 6174   return Path(pat
-00003cb0: 6829 2e73 7465 6d0d 0a0d 0a0d 0a64 6566  h).stem......def
-00003cc0: 2065 7865 6375 7465 5f73 716c 280d 0a20   execute_sql(.. 
-00003cd0: 2020 2070 6174 683a 2055 6e69 6f6e 5b73     path: Union[s
-00003ce0: 7472 2c20 226f 732e 5061 7468 4c69 6b65  tr, "os.PathLike
-00003cf0: 5b41 6e79 5d22 5d2c 0d0a 2020 2020 7371  [Any]"],..    sq
-00003d00: 6c5f 7374 6d74 3a20 7374 722c 0d0a 2020  l_stmt: str,..  
-00003d10: 2020 7371 6c5f 6469 616c 6563 743a 204f    sql_dialect: O
-00003d20: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
-00003d30: 6f6e 652c 0d0a 293a 0d0a 2020 2020 2222  one,..):..    ""
-00003d40: 220d 0a20 2020 2045 7865 6375 7465 2061  "..    Execute a
-00003d50: 2073 716c 2073 7461 7465 6d65 6e74 2028   sql statement (
-00003d60: 444d 4c20 6f72 2044 444c 2920 6f6e 2074  DML or DDL) on t
-00003d70: 6865 2066 696c 652e 0d0a 0d0a 2020 2020  he file.....    
-00003d80: 546f 2072 756e 2053 454c 4543 5420 7371  To run SELECT sq
-00003d90: 6c20 7374 6174 656d 656e 7473 206f 6e20  l statements on 
-00003da0: 6120 6669 6c65 2c20 7573 6520 3a6d 6574  a file, use :met
-00003db0: 683a 607e 7265 6164 5f66 696c 6560 2e0d  h:`~read_file`..
-00003dc0: 0a0d 0a20 2020 2041 7267 733a 0d0a 2020  ...    Args:..  
-00003dd0: 2020 2020 2020 7061 7468 2028 5061 7468        path (Path
-00003de0: 4c69 6b65 293a 2054 6865 2070 6174 6820  Like): The path 
-00003df0: 746f 2074 6865 2066 696c 652e 0d0a 2020  to the file...  
-00003e00: 2020 2020 2020 7371 6c5f 7374 6d74 2028        sql_stmt (
-00003e10: 7374 7229 3a20 5468 6520 7371 6c20 7374  str): The sql st
-00003e20: 6174 656d 656e 7420 746f 2065 7865 6375  atement to execu
-00003e30: 7465 2e0d 0a20 2020 2020 2020 2073 716c  te...        sql
-00003e40: 5f64 6961 6c65 6374 2028 7374 7229 3a20  _dialect (str): 
-00003e50: 5468 6520 7371 6c20 6469 616c 6563 7420  The sql dialect 
-00003e60: 746f 2075 7365 3a0d 0a20 2020 2020 2020  to use:..       
-00003e70: 2020 2020 202a 204e 6f6e 653a 2075 7365       * None: use
-00003e80: 2074 6865 206e 6174 6976 6520 5351 4c20   the native SQL 
-00003e90: 6469 616c 6563 7420 6f66 2074 6865 2067  dialect of the g
-00003ea0: 656f 6669 6c65 2e0d 0a20 2020 2020 2020  eofile...       
-00003eb0: 2020 2020 202a 2027 4f47 5253 514c 273a       * 'OGRSQL':
-00003ec0: 2066 6f72 6365 2074 6865 2075 7365 206f   force the use o
-00003ed0: 6620 7468 6520 4f47 5220 5351 4c20 6469  f the OGR SQL di
-00003ee0: 616c 6563 742e 0d0a 2020 2020 2020 2020  alect...        
-00003ef0: 2020 2020 2a20 2753 514c 4954 4527 3a20      * 'SQLITE': 
-00003f00: 666f 7263 6520 7468 6520 7573 6520 6f66  force the use of
-00003f10: 2074 6865 2053 514c 4954 4520 6469 616c   the SQLITE dial
-00003f20: 6563 742e 0d0a 2020 2020 2020 2020 2020  ect...          
-00003f30: 2020 4465 6661 756c 7473 2074 6f20 4e6f    Defaults to No
-00003f40: 6e65 2e0d 0a20 2020 2022 2222 0d0a 2020  ne...    """..  
-00003f50: 2020 6461 7461 736f 7572 6365 203d 204e    datasource = N
-00003f60: 6f6e 650d 0a20 2020 2074 7279 3a0d 0a20  one..    try:.. 
-00003f70: 2020 2020 2020 2064 6174 6173 6f75 7263         datasourc
-00003f80: 6520 3d20 6764 616c 2e4f 7065 6e45 7828  e = gdal.OpenEx(
-00003f90: 7374 7228 7061 7468 292c 206e 4f70 656e  str(path), nOpen
-00003fa0: 466c 6167 733d 6764 616c 2e4f 465f 5550  Flags=gdal.OF_UP
-00003fb0: 4441 5445 290d 0a20 2020 2020 2020 2072  DATE)..        r
-00003fc0: 6573 756c 7420 3d20 6461 7461 736f 7572  esult = datasour
-00003fd0: 6365 2e45 7865 6375 7465 5351 4c28 7371  ce.ExecuteSQL(sq
-00003fe0: 6c5f 7374 6d74 2c20 6469 616c 6563 743d  l_stmt, dialect=
-00003ff0: 7371 6c5f 6469 616c 6563 7429 0d0a 2020  sql_dialect)..  
-00004000: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
-00004010: 2e52 656c 6561 7365 5265 7375 6c74 5365  .ReleaseResultSe
-00004020: 7428 7265 7375 6c74 290d 0a20 2020 2066  t(result)..    f
-00004030: 696e 616c 6c79 3a0d 0a20 2020 2020 2020  inally:..       
-00004040: 2069 6620 6461 7461 736f 7572 6365 2069   if datasource i
-00004050: 7320 6e6f 7420 4e6f 6e65 3a0d 0a20 2020  s not None:..   
-00004060: 2020 2020 2020 2020 2064 656c 2064 6174           del dat
-00004070: 6173 6f75 7263 650d 0a0d 0a0d 0a64 6566  asource......def
-00004080: 2063 7265 6174 655f 7370 6174 6961 6c5f   create_spatial_
-00004090: 696e 6465 7828 0d0a 2020 2020 7061 7468  index(..    path
-000040a0: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
-000040b0: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
-000040c0: 2c0d 0a20 2020 206c 6179 6572 3a20 4f70  ,..    layer: Op
-000040d0: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
-000040e0: 6e65 2c0d 0a20 2020 2063 6163 6865 5f73  ne,..    cache_s
-000040f0: 697a 655f 6d62 3a20 696e 7420 3d20 3132  ize_mb: int = 12
-00004100: 382c 0d0a 2020 2020 6578 6973 745f 6f6b  8,..    exist_ok
-00004110: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-00004120: 0a20 2020 2066 6f72 6365 5f72 6562 7569  .    force_rebui
-00004130: 6c64 3a20 626f 6f6c 203d 2046 616c 7365  ld: bool = False
-00004140: 2c0d 0a29 3a0d 0a20 2020 2022 2222 0d0a  ,..):..    """..
-00004150: 2020 2020 4372 6561 7465 2061 2073 7061      Create a spa
-00004160: 7469 616c 2069 6e64 6578 206f 6e20 7468  tial index on th
-00004170: 6520 6c61 7965 7220 7370 6563 6966 6965  e layer specifie
-00004180: 642e 0d0a 0d0a 2020 2020 4172 6773 3a0d  d.....    Args:.
-00004190: 0a20 2020 2020 2020 2070 6174 6820 2850  .        path (P
-000041a0: 6174 684c 696b 6529 3a20 5468 6520 6669  athLike): The fi
-000041b0: 6c65 2070 6174 682e 0d0a 2020 2020 2020  le path...      
-000041c0: 2020 6c61 7965 7220 2873 7472 2c20 6f70    layer (str, op
-000041d0: 7469 6f6e 616c 293a 2054 6865 206c 6179  tional): The lay
-000041e0: 6572 2e20 4966 206e 6f74 2073 7065 6369  er. If not speci
-000041f0: 6669 6564 2c20 616e 6420 7468 6572 6520  fied, and there 
-00004200: 6973 206f 6e6c 790d 0a20 2020 2020 2020  is only..       
-00004210: 2020 2020 206f 6e65 206c 6179 6572 2069       one layer i
-00004220: 6e20 7468 6520 6669 6c65 2c20 7468 6973  n the file, this
-00004230: 206c 6179 6572 2069 7320 7573 6564 2e20   layer is used. 
-00004240: 4f74 6865 7277 6973 6520 6578 6365 7074  Otherwise except
-00004250: 696f 6e2e 0d0a 2020 2020 2020 2020 6361  ion...        ca
-00004260: 6368 655f 7369 7a65 5f6d 6220 2869 6e74  che_size_mb (int
-00004270: 2c20 6f70 7469 6f6e 616c 293a 206d 656d  , optional): mem
-00004280: 6f72 7920 696e 204d 4220 7468 6174 2063  ory in MB that c
-00004290: 616e 2062 6520 7573 6564 2077 6869 6c65  an be used while
-000042a0: 0d0a 2020 2020 2020 2020 2020 2020 6372  ..            cr
-000042b0: 6561 7469 6e67 2073 7061 7469 616c 2069  eating spatial i
-000042c0: 6e64 6578 2066 6f72 2073 7061 7469 616c  ndex for spatial
-000042d0: 6974 6520 6669 6c65 7320 282e 6770 6b67  ite files (.gpkg
-000042e0: 206f 7220 2e73 716c 6974 6529 2e0d 0a20   or .sqlite)... 
-000042f0: 2020 2020 2020 2020 2020 2044 6566 6175             Defau
-00004300: 6c74 7320 746f 2031 3238 2e0d 0a20 2020  lts to 128...   
-00004310: 2020 2020 2065 7869 7374 5f6f 6b20 2862       exist_ok (b
-00004320: 6f6f 6c2c 206f 7074 696f 6e73 293a 2049  ool, options): I
-00004330: 6620 5472 7565 2061 6e64 2074 6865 2069  f True and the i
-00004340: 6e64 6578 2065 7869 7374 7320 616c 7265  ndex exists alre
-00004350: 6164 792c 2064 6f6e 2774 0d0a 2020 2020  ady, don't..    
-00004360: 2020 2020 2020 2020 7468 726f 7720 616e          throw an
-00004370: 2065 7272 6f72 2e0d 0a20 2020 2020 2020   error...       
-00004380: 2066 6f72 6365 5f72 6562 7569 6c64 2028   force_rebuild (
-00004390: 626f 6f6c 2c20 6f70 7469 6f6e 7329 3a20  bool, options): 
-000043a0: 5472 7565 2074 6f20 666f 7263 6520 7265  True to force re
-000043b0: 6275 696c 6420 6576 656e 2069 6620 696e  build even if in
-000043c0: 6465 780d 0a20 2020 2020 2020 2020 2020  dex..           
-000043d0: 2065 7869 7374 7320 616c 7265 6164 792e   exists already.
-000043e0: 2044 6566 6175 6c74 7320 746f 2046 616c   Defaults to Fal
-000043f0: 7365 2e0d 0a20 2020 2022 2222 0d0a 2020  se...    """..  
-00004400: 2020 2320 496e 6974 0d0a 2020 2020 7061    # Init..    pa
-00004410: 7468 203d 2050 6174 6828 7061 7468 290d  th = Path(path).
-00004420: 0a20 2020 2069 6620 6c61 7965 7220 6973  .    if layer is
-00004430: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-00004440: 6c61 7965 7220 3d20 6765 745f 6f6e 6c79  layer = get_only
-00004450: 5f6c 6179 6572 2870 6174 6829 0d0a 0d0a  _layer(path)....
-00004460: 2020 2020 2320 4966 2069 6e64 6578 2061      # If index a
-00004470: 6c72 6561 6479 2065 7869 7374 732c 2072  lready exists, r
-00004480: 656d 6f76 6520 696e 6465 7820 6f72 2072  emove index or r
-00004490: 6574 7572 6e0d 0a20 2020 2069 6620 6861  eturn..    if ha
-000044a0: 735f 7370 6174 6961 6c5f 696e 6465 7828  s_spatial_index(
-000044b0: 7061 7468 2c20 6c61 7965 7229 3a0d 0a20  path, layer):.. 
-000044c0: 2020 2020 2020 2069 6620 666f 7263 655f         if force_
-000044d0: 7265 6275 696c 643a 0d0a 2020 2020 2020  rebuild:..      
-000044e0: 2020 2020 2020 7265 6d6f 7665 5f73 7061        remove_spa
-000044f0: 7469 616c 5f69 6e64 6578 2870 6174 682c  tial_index(path,
-00004500: 206c 6179 6572 290d 0a20 2020 2020 2020   layer)..       
-00004510: 2065 6c69 6620 6578 6973 745f 6f6b 3a0d   elif exist_ok:.
-00004520: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00004530: 7572 6e0d 0a20 2020 2020 2020 2065 6c73  urn..        els
-00004540: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-00004550: 7261 6973 6520 4578 6365 7074 696f 6e28  raise Exception(
-00004560: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00004570: 2020 6622 4572 726f 7220 6164 6469 6e67    f"Error adding
-00004580: 2073 7061 7469 616c 2069 6e64 6578 2074   spatial index t
-00004590: 6f20 7b70 6174 687d 2e7b 6c61 7965 727d  o {path}.{layer}
-000045a0: 2c20 6974 2065 7869 7374 7320 616c 7265  , it exists alre
-000045b0: 6164 7922 0d0a 2020 2020 2020 2020 2020  ady"..          
-000045c0: 2020 290d 0a0d 0a20 2020 2023 204e 6f77    )....    # Now
-000045d0: 2072 6561 6c6c 7920 6164 6420 696e 6465   really add inde
-000045e0: 780d 0a20 2020 2064 6174 6173 6f75 7263  x..    datasourc
-000045f0: 6520 3d20 4e6f 6e65 0d0a 2020 2020 7472  e = None..    tr
-00004600: 793a 0d0a 2020 2020 2020 2020 6765 6f66  y:..        geof
-00004610: 696c 6574 7970 6520 3d20 4765 6f66 696c  iletype = Geofil
-00004620: 6554 7970 6528 7061 7468 290d 0a20 2020  eType(path)..   
-00004630: 2020 2020 2069 6620 6765 6f66 696c 6574       if geofilet
-00004640: 7970 652e 6973 5f73 7061 7469 616c 6974  ype.is_spatialit
-00004650: 655f 6261 7365 643a 0d0a 2020 2020 2020  e_based:..      
-00004660: 2020 2020 2020 2320 5468 6520 636f 6e66        # The conf
-00004670: 6967 206f 7074 696f 6e73 206e 6565 6420  ig options need 
-00004680: 746f 2062 6520 7365 7420 6265 666f 7265  to be set before
-00004690: 206f 7065 6e69 6e67 2074 6865 2066 696c   opening the fil
-000046a0: 6521 0d0a 2020 2020 2020 2020 2020 2020  e!..            
-000046b0: 6c61 7965 7269 6e66 6f20 3d20 6765 745f  layerinfo = get_
-000046c0: 6c61 7965 7269 6e66 6f28 7061 7468 2c20  layerinfo(path, 
-000046d0: 6c61 7965 7229 0d0a 2020 2020 2020 2020  layer)..        
-000046e0: 2020 2020 7769 7468 205f 6f67 725f 7574      with _ogr_ut
-000046f0: 696c 2e73 6574 5f63 6f6e 6669 675f 6f70  il.set_config_op
-00004700: 7469 6f6e 7328 7b22 4f47 525f 5351 4c49  tions({"OGR_SQLI
-00004710: 5445 5f43 4143 4845 223a 2063 6163 6865  TE_CACHE": cache
-00004720: 5f73 697a 655f 6d62 7d29 3a0d 0a20 2020  _size_mb}):..   
-00004730: 2020 2020 2020 2020 2020 2020 2064 6174               dat
-00004740: 6173 6f75 7263 6520 3d20 6764 616c 2e4f  asource = gdal.O
-00004750: 7065 6e45 7828 7374 7228 7061 7468 292c  penEx(str(path),
-00004760: 206e 4f70 656e 466c 6167 733d 6764 616c   nOpenFlags=gdal
-00004770: 2e4f 465f 5550 4441 5445 290d 0a20 2020  .OF_UPDATE)..   
-00004780: 2020 2020 2020 2020 2020 2020 2067 656f               geo
-00004790: 6d65 7472 7963 6f6c 756d 6e20 3d20 6c61  metrycolumn = la
-000047a0: 7965 7269 6e66 6f2e 6765 6f6d 6574 7279  yerinfo.geometry
-000047b0: 636f 6c75 6d6e 0d0a 2020 2020 2020 2020  column..        
-000047c0: 2020 2020 2020 2020 7371 6c20 3d20 6622          sql = f"
-000047d0: 5345 4c45 4354 2043 7265 6174 6553 7061  SELECT CreateSpa
-000047e0: 7469 616c 496e 6465 7828 277b 6c61 7965  tialIndex('{laye
-000047f0: 727d 272c 2027 7b67 656f 6d65 7472 7963  r}', '{geometryc
-00004800: 6f6c 756d 6e7d 2729 220d 0a20 2020 2020  olumn}')"..     
-00004810: 2020 2020 2020 2020 2020 2072 6573 756c             resul
-00004820: 7420 3d20 6461 7461 736f 7572 6365 2e45  t = datasource.E
-00004830: 7865 6375 7465 5351 4c28 7371 6c2c 2064  xecuteSQL(sql, d
-00004840: 6961 6c65 6374 3d22 5351 4c49 5445 2229  ialect="SQLITE")
-00004850: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00004860: 2020 6461 7461 736f 7572 6365 2e52 656c    datasource.Rel
-00004870: 6561 7365 5265 7375 6c74 5365 7428 7265  easeResultSet(re
-00004880: 7375 6c74 290d 0a0d 0a20 2020 2020 2020  sult)....       
-00004890: 2020 2020 2020 2020 2023 2056 6572 6966           # Verif
-000048a0: 7920 6966 2074 6865 2069 6e64 6578 2077  y if the index w
-000048b0: 6173 2063 7265 6174 6564 0d0a 2020 2020  as created..    
-000048c0: 2020 2020 2020 2020 2020 2020 7371 6c20              sql 
-000048d0: 3d20 6622 5345 4c45 4354 2048 6173 5370  = f"SELECT HasSp
-000048e0: 6174 6961 6c49 6e64 6578 2827 7b6c 6179  atialIndex('{lay
-000048f0: 6572 696e 666f 2e6e 616d 657d 272c 2027  erinfo.name}', '
-00004900: 7b67 656f 6d65 7472 7963 6f6c 756d 6e7d  {geometrycolumn}
-00004910: 2729 220d 0a20 2020 2020 2020 2020 2020  ')"..           
-00004920: 2020 2020 2072 6573 756c 7420 3d20 6461       result = da
-00004930: 7461 736f 7572 6365 2e45 7865 6375 7465  tasource.Execute
-00004940: 5351 4c28 7371 6c2c 2064 6961 6c65 6374  SQL(sql, dialect
-00004950: 3d22 5351 4c49 5445 2229 0d0a 2020 2020  ="SQLITE")..    
-00004960: 2020 2020 2020 2020 2020 2020 6861 735f              has_
-00004970: 7370 6174 6961 6c5f 6964 7820 3d20 7265  spatial_idx = re
-00004980: 7375 6c74 2e47 6574 4e65 7874 4665 6174  sult.GetNextFeat
-00004990: 7572 6528 292e 4765 7446 6965 6c64 2830  ure().GetField(0
-000049a0: 2920 3d3d 2031 0d0a 2020 2020 2020 2020  ) == 1..        
-000049b0: 2020 2020 2020 2020 6461 7461 736f 7572          datasour
-000049c0: 6365 2e52 656c 6561 7365 5265 7375 6c74  ce.ReleaseResult
-000049d0: 5365 7428 7265 7375 6c74 290d 0a0d 0a20  Set(result).... 
-000049e0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-000049f0: 2041 7070 6172 656e 746c 7920 6661 696c   Apparently fail
-00004a00: 6564 2c20 6966 2067 706b 672c 2074 7279  ed, if gpkg, try
-00004a10: 2061 6761 696e 2077 6974 6820 6f74 6865   again with othe
-00004a20: 7220 6675 6e63 7469 6f6e 0d0a 2020 2020  r function..    
-00004a30: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-00004a40: 6f74 2068 6173 5f73 7061 7469 616c 5f69  ot has_spatial_i
-00004a50: 6478 2061 6e64 2067 656f 6669 6c65 7479  dx and geofilety
-00004a60: 7065 203d 3d20 4765 6f66 696c 6554 7970  pe == GeofileTyp
-00004a70: 652e 4750 4b47 3a0d 0a20 2020 2020 2020  e.GPKG:..       
-00004a80: 2020 2020 2020 2020 2020 2020 2073 716c               sql
-00004a90: 203d 2066 2253 454c 4543 5420 6770 6b67   = f"SELECT gpkg
-00004aa0: 4164 6453 7061 7469 616c 496e 6465 7828  AddSpatialIndex(
-00004ab0: 277b 6c61 7965 727d 272c 2027 7b67 656f  '{layer}', '{geo
-00004ac0: 6d65 7472 7963 6f6c 756d 6e7d 2729 220d  metrycolumn}')".
-00004ad0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004ae0: 2020 2020 2072 6573 756c 7420 3d20 6461       result = da
-00004af0: 7461 736f 7572 6365 2e45 7865 6375 7465  tasource.Execute
-00004b00: 5351 4c28 7371 6c2c 2064 6961 6c65 6374  SQL(sql, dialect
-00004b10: 3d22 5351 4c49 5445 2229 0d0a 2020 2020  ="SQLITE")..    
-00004b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004b30: 6461 7461 736f 7572 6365 2e52 656c 6561  datasource.Relea
-00004b40: 7365 5265 7375 6c74 5365 7428 7265 7375  seResultSet(resu
-00004b50: 6c74 290d 0a0d 0a20 2020 2020 2020 2065  lt)....        e
-00004b60: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-00004b70: 2020 6461 7461 736f 7572 6365 203d 2067    datasource = g
-00004b80: 6461 6c2e 4f70 656e 4578 2873 7472 2870  dal.OpenEx(str(p
-00004b90: 6174 6829 2c20 6e4f 7065 6e46 6c61 6773  ath), nOpenFlags
-00004ba0: 3d67 6461 6c2e 4f46 5f55 5044 4154 4529  =gdal.OF_UPDATE)
-00004bb0: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-00004bc0: 7375 6c74 203d 2064 6174 6173 6f75 7263  sult = datasourc
-00004bd0: 652e 4578 6563 7574 6553 514c 2866 2743  e.ExecuteSQL(f'C
-00004be0: 5245 4154 4520 5350 4154 4941 4c20 494e  REATE SPATIAL IN
-00004bf0: 4445 5820 4f4e 2022 7b6c 6179 6572 7d22  DEX ON "{layer}"
-00004c00: 2729 0d0a 2020 2020 2020 2020 2020 2020  ')..            
-00004c10: 6461 7461 736f 7572 6365 2e52 656c 6561  datasource.Relea
-00004c20: 7365 5265 7375 6c74 5365 7428 7265 7375  seResultSet(resu
-00004c30: 6c74 290d 0a20 2020 2065 7863 6570 7420  lt)..    except 
-00004c40: 4578 6365 7074 696f 6e20 6173 2065 783a  Exception as ex:
-00004c50: 0d0a 2020 2020 2020 2020 7261 6973 6520  ..        raise 
-00004c60: 4578 6365 7074 696f 6e28 6622 4572 726f  Exception(f"Erro
-00004c70: 7220 6164 6469 6e67 2073 7061 7469 616c  r adding spatial
-00004c80: 2069 6e64 6578 2074 6f20 7b70 6174 687d   index to {path}
-00004c90: 2e7b 6c61 7965 727d 2229 2066 726f 6d20  .{layer}") from 
-00004ca0: 6578 0d0a 2020 2020 6669 6e61 6c6c 793a  ex..    finally:
-00004cb0: 0d0a 2020 2020 2020 2020 6966 2064 6174  ..        if dat
-00004cc0: 6173 6f75 7263 6520 6973 206e 6f74 204e  asource is not N
-00004cd0: 6f6e 653a 0d0a 2020 2020 2020 2020 2020  one:..          
-00004ce0: 2020 6465 6c20 6461 7461 736f 7572 6365    del datasource
-00004cf0: 0d0a 0d0a 2020 2020 6966 206e 6f74 2068  ....    if not h
-00004d00: 6173 5f73 7061 7469 616c 5f69 6e64 6578  as_spatial_index
-00004d10: 2870 6174 682c 206c 6179 6572 293a 0d0a  (path, layer):..
-00004d20: 2020 2020 2020 2020 7261 6973 6520 5275          raise Ru
-00004d30: 6e74 696d 6545 7272 6f72 2866 2263 7265  ntimeError(f"cre
-00004d40: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
-00004d50: 7820 6661 696c 6564 206f 6e20 7b70 6174  x failed on {pat
-00004d60: 687d 2c20 6c61 7965 723a 207b 6c61 7965  h}, layer: {laye
-00004d70: 727d 2229 0d0a 0d0a 0d0a 6465 6620 6861  r}")......def ha
-00004d80: 735f 7370 6174 6961 6c5f 696e 6465 7828  s_spatial_index(
-00004d90: 0d0a 2020 2020 7061 7468 3a20 556e 696f  ..    path: Unio
-00004da0: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
-00004db0: 696b 655b 416e 795d 225d 2c20 6c61 7965  ike[Any]"], laye
-00004dc0: 723a 204f 7074 696f 6e61 6c5b 7374 725d  r: Optional[str]
-00004dd0: 203d 204e 6f6e 650d 0a29 202d 3e20 626f   = None..) -> bo
-00004de0: 6f6c 3a0d 0a20 2020 2022 2222 0d0a 2020  ol:..    """..  
-00004df0: 2020 4368 6563 6b20 6966 2074 6865 206c    Check if the l
-00004e00: 6179 6572 2f63 6f6c 756d 6e20 6861 7320  ayer/column has 
-00004e10: 6120 7370 6174 6961 6c20 696e 6465 782e  a spatial index.
-00004e20: 0d0a 0d0a 2020 2020 4172 6773 3a0d 0a20  ....    Args:.. 
-00004e30: 2020 2020 2020 2070 6174 6820 2850 6174         path (Pat
-00004e40: 684c 696b 6529 3a20 5468 6520 6669 6c65  hLike): The file
-00004e50: 2070 6174 682e 0d0a 2020 2020 2020 2020   path...        
-00004e60: 6c61 7965 7220 2873 7472 2c20 6f70 7469  layer (str, opti
-00004e70: 6f6e 616c 293a 2054 6865 206c 6179 6572  onal): The layer
-00004e80: 2e20 4465 6661 756c 7473 2074 6f20 4e6f  . Defaults to No
-00004e90: 6e65 2e0d 0a0d 0a20 2020 2052 6169 7365  ne.....    Raise
-00004ea0: 733a 0d0a 2020 2020 2020 2020 5661 6c75  s:..        Valu
-00004eb0: 6545 7272 6f72 3a20 616e 2069 6e76 616c  eError: an inval
-00004ec0: 6964 2070 6172 616d 6574 6572 2076 616c  id parameter val
-00004ed0: 7565 2077 6173 2070 6173 7365 642e 0d0a  ue was passed...
-00004ee0: 0d0a 2020 2020 5265 7475 726e 733a 0d0a  ..    Returns:..
-00004ef0: 2020 2020 2020 2020 626f 6f6c 3a20 5472          bool: Tr
-00004f00: 7565 2069 6620 7468 6520 7370 6174 6961  ue if the spatia
-00004f10: 6c20 636f 6c75 6d6e 2065 7869 7374 732e  l column exists.
-00004f20: 0d0a 2020 2020 2222 220d 0a20 2020 2023  ..    """..    #
-00004f30: 2049 6e69 740d 0a20 2020 2070 6174 6820   Init..    path 
-00004f40: 3d20 5061 7468 2870 6174 6829 0d0a 0d0a  = Path(path)....
-00004f50: 2020 2020 2320 4e6f 7720 6368 6563 6b20      # Now check 
-00004f60: 7468 6520 696e 6465 780d 0a20 2020 2064  the index..    d
-00004f70: 6174 6173 6f75 7263 6520 3d20 4e6f 6e65  atasource = None
-00004f80: 0d0a 2020 2020 6765 6f66 696c 6574 7970  ..    geofiletyp
-00004f90: 6520 3d20 4765 6f66 696c 6554 7970 6528  e = GeofileType(
-00004fa0: 7061 7468 290d 0a20 2020 2074 7279 3a0d  path)..    try:.
-00004fb0: 0a20 2020 2020 2020 2069 6620 6765 6f66  .        if geof
-00004fc0: 696c 6574 7970 652e 6973 5f73 7061 7469  iletype.is_spati
-00004fd0: 616c 6974 655f 6261 7365 643a 0d0a 2020  alite_based:..  
-00004fe0: 2020 2020 2020 2020 2020 6c61 7965 7269            layeri
-00004ff0: 6e66 6f20 3d20 6765 745f 6c61 7965 7269  nfo = get_layeri
-00005000: 6e66 6f28 7061 7468 2c20 6c61 7965 7229  nfo(path, layer)
-00005010: 0d0a 2020 2020 2020 2020 2020 2020 6461  ..            da
-00005020: 7461 736f 7572 6365 203d 2067 6461 6c2e  tasource = gdal.
-00005030: 4f70 656e 4578 2873 7472 2870 6174 6829  OpenEx(str(path)
-00005040: 2c20 6e4f 7065 6e46 6c61 6773 3d67 6461  , nOpenFlags=gda
-00005050: 6c2e 4f46 5f52 4541 444f 4e4c 5929 0d0a  l.OF_READONLY)..
-00005060: 2020 2020 2020 2020 2020 2020 7371 6c20              sql 
-00005070: 3d20 6622 2222 0d0a 2020 2020 2020 2020  = f"""..        
-00005080: 2020 2020 2020 2020 5345 4c45 4354 2048          SELECT H
-00005090: 6173 5370 6174 6961 6c49 6e64 6578 2827  asSpatialIndex('
-000050a0: 7b6c 6179 6572 696e 666f 2e6e 616d 657d  {layerinfo.name}
-000050b0: 272c 0d0a 2020 2020 2020 2020 2020 2020  ',..            
-000050c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000050d0: 2020 2020 2020 2020 2020 2027 7b6c 6179             '{lay
-000050e0: 6572 696e 666f 2e67 656f 6d65 7472 7963  erinfo.geometryc
-000050f0: 6f6c 756d 6e7d 2729 0d0a 2020 2020 2020  olumn}')..      
-00005100: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-00005110: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
-00005120: 6461 7461 736f 7572 6365 2e45 7865 6375  datasource.Execu
-00005130: 7465 5351 4c28 7371 6c2c 2064 6961 6c65  teSQL(sql, diale
-00005140: 6374 3d22 5351 4c49 5445 2229 0d0a 2020  ct="SQLITE")..  
-00005150: 2020 2020 2020 2020 2020 6861 735f 7370            has_sp
-00005160: 6174 6961 6c5f 696e 6465 7820 3d20 7265  atial_index = re
-00005170: 7375 6c74 2e47 6574 4e65 7874 4665 6174  sult.GetNextFeat
-00005180: 7572 6528 292e 4765 7446 6965 6c64 2830  ure().GetField(0
-00005190: 2920 3d3d 2031 0d0a 2020 2020 2020 2020  ) == 1..        
-000051a0: 2020 2020 6461 7461 736f 7572 6365 2e52      datasource.R
-000051b0: 656c 6561 7365 5265 7375 6c74 5365 7428  eleaseResultSet(
-000051c0: 7265 7375 6c74 290d 0a20 2020 2020 2020  result)..       
-000051d0: 2020 2020 2072 6574 7572 6e20 6861 735f       return has_
-000051e0: 7370 6174 6961 6c5f 696e 6465 780d 0a20  spatial_index.. 
-000051f0: 2020 2020 2020 2065 6c69 6620 6765 6f66         elif geof
-00005200: 696c 6574 7970 6520 3d3d 2047 656f 6669  iletype == Geofi
-00005210: 6c65 5479 7065 2e45 5352 4953 6861 7065  leType.ESRIShape
-00005220: 6669 6c65 3a0d 0a20 2020 2020 2020 2020  file:..         
-00005230: 2020 2069 6e64 6578 5f70 6174 6820 3d20     index_path = 
-00005240: 7061 7468 2e70 6172 656e 7420 2f20 6622  path.parent / f"
-00005250: 7b70 6174 682e 7374 656d 7d2e 7169 7822  {path.stem}.qix"
-00005260: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-00005270: 7475 726e 2069 6e64 6578 5f70 6174 682e  turn index_path.
-00005280: 6578 6973 7473 2829 0d0a 2020 2020 2020  exists()..      
-00005290: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-000052a0: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-000052b0: 4572 726f 7228 6622 6861 735f 7370 6174  Error(f"has_spat
-000052c0: 6961 6c5f 696e 6465 7820 6e6f 7420 7375  ial_index not su
-000052d0: 7070 6f72 7465 6420 666f 7220 7b70 6174  pported for {pat
-000052e0: 687d 2229 0d0a 2020 2020 6669 6e61 6c6c  h}")..    finall
-000052f0: 793a 0d0a 2020 2020 2020 2020 6966 2064  y:..        if d
-00005300: 6174 6173 6f75 7263 6520 6973 206e 6f74  atasource is not
-00005310: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-00005320: 2020 2020 6461 7461 736f 7572 6365 203d      datasource =
-00005330: 204e 6f6e 650d 0a0d 0a0d 0a64 6566 2072   None......def r
-00005340: 656d 6f76 655f 7370 6174 6961 6c5f 696e  emove_spatial_in
-00005350: 6465 7828 0d0a 2020 2020 7061 7468 3a20  dex(..    path: 
-00005360: 556e 696f 6e5b 7374 722c 2022 6f73 2e50  Union[str, "os.P
-00005370: 6174 684c 696b 655b 416e 795d 225d 2c20  athLike[Any]"], 
-00005380: 6c61 7965 723a 204f 7074 696f 6e61 6c5b  layer: Optional[
-00005390: 7374 725d 203d 204e 6f6e 650d 0a29 3a0d  str] = None..):.
-000053a0: 0a20 2020 2022 2222 0d0a 2020 2020 5265  .    """..    Re
-000053b0: 6d6f 7665 2074 6865 2073 7061 7469 616c  move the spatial
-000053c0: 2069 6e64 6578 2066 726f 6d20 7468 6520   index from the 
-000053d0: 6c61 7965 7220 7370 6563 6966 6965 642e  layer specified.
-000053e0: 0d0a 0d0a 2020 2020 4172 6773 3a0d 0a20  ....    Args:.. 
-000053f0: 2020 2020 2020 2070 6174 6820 2850 6174         path (Pat
-00005400: 684c 696b 6529 3a20 5468 6520 6669 6c65  hLike): The file
-00005410: 2070 6174 682e 0d0a 2020 2020 2020 2020   path...        
-00005420: 6c61 7965 7220 2873 7472 2c20 6f70 7469  layer (str, opti
-00005430: 6f6e 616c 293a 2054 6865 206c 6179 6572  onal): The layer
-00005440: 2e20 4966 206e 6f74 2073 7065 6369 6669  . If not specifi
-00005450: 6564 2c20 616e 6420 7468 6572 6520 6973  ed, and there is
-00005460: 206f 6e6c 790d 0a20 2020 2020 2020 2020   only..         
-00005470: 2020 206f 6e65 206c 6179 6572 2069 6e20     one layer in 
-00005480: 7468 6520 6669 6c65 2c20 7468 6973 206c  the file, this l
-00005490: 6179 6572 2069 7320 7573 6564 2e20 4f74  ayer is used. Ot
-000054a0: 6865 7277 6973 6520 6578 6365 7074 696f  herwise exceptio
-000054b0: 6e2e 0d0a 2020 2020 2222 220d 0a20 2020  n...    """..   
-000054c0: 2023 2049 6e69 740d 0a20 2020 2070 6174   # Init..    pat
-000054d0: 6820 3d20 5061 7468 2870 6174 6829 0d0a  h = Path(path)..
-000054e0: 0d0a 2020 2020 2320 4e6f 7720 7265 616c  ..    # Now real
-000054f0: 6c79 2072 656d 6f76 6520 696e 6465 780d  ly remove index.
-00005500: 0a20 2020 2064 6174 6173 6f75 7263 6520  .    datasource 
-00005510: 3d20 4e6f 6e65 0d0a 2020 2020 6765 6f66  = None..    geof
-00005520: 696c 6574 7970 6520 3d20 4765 6f66 696c  iletype = Geofil
-00005530: 6554 7970 6528 7061 7468 290d 0a20 2020  eType(path)..   
-00005540: 206c 6179 6572 696e 666f 203d 2067 6574   layerinfo = get
-00005550: 5f6c 6179 6572 696e 666f 2870 6174 682c  _layerinfo(path,
-00005560: 206c 6179 6572 290d 0a20 2020 2074 7279   layer)..    try
-00005570: 3a0d 0a20 2020 2020 2020 2069 6620 6765  :..        if ge
-00005580: 6f66 696c 6574 7970 652e 6973 5f73 7061  ofiletype.is_spa
-00005590: 7469 616c 6974 655f 6261 7365 643a 0d0a  tialite_based:..
-000055a0: 2020 2020 2020 2020 2020 2020 6461 7461              data
-000055b0: 736f 7572 6365 203d 2067 6461 6c2e 4f70  source = gdal.Op
-000055c0: 656e 4578 2873 7472 2870 6174 6829 2c20  enEx(str(path), 
-000055d0: 6e4f 7065 6e46 6c61 6773 3d67 6461 6c2e  nOpenFlags=gdal.
-000055e0: 4f46 5f55 5044 4154 4529 0d0a 2020 2020  OF_UPDATE)..    
-000055f0: 2020 2020 2020 2020 7265 7375 6c74 203d          result =
-00005600: 2064 6174 6173 6f75 7263 652e 4578 6563   datasource.Exec
-00005610: 7574 6553 514c 280d 0a20 2020 2020 2020  uteSQL(..       
-00005620: 2020 2020 2020 2020 2066 2253 454c 4543           f"SELEC
-00005630: 5420 4469 7361 626c 6553 7061 7469 616c  T DisableSpatial
-00005640: 496e 6465 7828 277b 6c61 7965 7269 6e66  Index('{layerinf
-00005650: 6f2e 6e61 6d65 7d27 2c20 277b 6c61 7965  o.name}', '{laye
-00005660: 7269 6e66 6f2e 6765 6f6d 6574 7279 636f  rinfo.geometryco
-00005670: 6c75 6d6e 7d27 2922 2c20 2023 206e 6f71  lumn}')",  # noq
-00005680: 613a 2045 3530 310d 0a20 2020 2020 2020  a: E501..       
-00005690: 2020 2020 2020 2020 2064 6961 6c65 6374           dialect
-000056a0: 3d22 5351 4c49 5445 222c 0d0a 2020 2020  ="SQLITE",..    
-000056b0: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-000056c0: 2020 2020 2020 2064 6174 6173 6f75 7263         datasourc
-000056d0: 652e 5265 6c65 6173 6552 6573 756c 7453  e.ReleaseResultS
-000056e0: 6574 2872 6573 756c 7429 0d0a 2020 2020  et(result)..    
-000056f0: 2020 2020 656c 6966 2067 656f 6669 6c65      elif geofile
-00005700: 7479 7065 203d 3d20 4765 6f66 696c 6554  type == GeofileT
-00005710: 7970 652e 4553 5249 5368 6170 6566 696c  ype.ESRIShapefil
-00005720: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-00005730: 2320 4452 4f50 2053 5041 5449 414c 2049  # DROP SPATIAL I
-00005740: 4e44 4558 204f 4e20 2e2e 2e20 636f 6d6d  NDEX ON ... comm
-00005750: 616e 6420 6769 7665 7320 616e 2065 7272  and gives an err
-00005760: 6f72 2c20 736f 206a 7573 7420 7265 6d6f  or, so just remo
-00005770: 7665 202e 7169 780d 0a20 2020 2020 2020  ve .qix..       
-00005780: 2020 2020 2069 6e64 6578 5f70 6174 6820       index_path 
-00005790: 3d20 7061 7468 2e70 6172 656e 7420 2f20  = path.parent / 
-000057a0: 6622 7b70 6174 682e 7374 656d 7d2e 7169  f"{path.stem}.qi
-000057b0: 7822 0d0a 2020 2020 2020 2020 2020 2020  x"..            
-000057c0: 696e 6465 785f 7061 7468 2e75 6e6c 696e  index_path.unlin
-000057d0: 6b28 290d 0a20 2020 2020 2020 2065 6c73  k()..        els
-000057e0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-000057f0: 7261 6973 6520 4578 6365 7074 696f 6e28  raise Exception(
-00005800: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00005810: 2020 6622 7265 6d6f 7665 5f73 7061 7469    f"remove_spati
-00005820: 616c 5f69 6e64 6578 2069 7320 6e6f 7420  al_index is not 
-00005830: 7375 7070 6f72 7465 6420 666f 7220 7b70  supported for {p
-00005840: 6174 682e 7375 6666 6978 7d20 6669 6c65  ath.suffix} file
-00005850: 220d 0a20 2020 2020 2020 2020 2020 2029  "..            )
-00005860: 0d0a 2020 2020 6669 6e61 6c6c 793a 0d0a  ..    finally:..
-00005870: 2020 2020 2020 2020 6966 2064 6174 6173          if datas
-00005880: 6f75 7263 6520 6973 206e 6f74 204e 6f6e  ource is not Non
-00005890: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-000058a0: 6465 6c20 6461 7461 736f 7572 6365 0d0a  del datasource..
-000058b0: 0d0a 0d0a 6465 6620 7265 6e61 6d65 5f6c  ....def rename_l
-000058c0: 6179 6572 280d 0a20 2020 2070 6174 683a  ayer(..    path:
-000058d0: 2055 6e69 6f6e 5b73 7472 2c20 226f 732e   Union[str, "os.
-000058e0: 5061 7468 4c69 6b65 5b41 6e79 5d22 5d2c  PathLike[Any]"],
-000058f0: 206e 6577 5f6c 6179 6572 3a20 7374 722c   new_layer: str,
-00005900: 206c 6179 6572 3a20 4f70 7469 6f6e 616c   layer: Optional
-00005910: 5b73 7472 5d20 3d20 4e6f 6e65 0d0a 293a  [str] = None..):
-00005920: 0d0a 2020 2020 2222 220d 0a20 2020 2052  ..    """..    R
-00005930: 656e 616d 6520 7468 6520 6c61 7965 7220  ename the layer 
-00005940: 7370 6563 6966 6965 642e 0d0a 0d0a 2020  specified.....  
-00005950: 2020 4172 6773 3a0d 0a20 2020 2020 2020    Args:..       
-00005960: 2070 6174 6820 2850 6174 684c 696b 6529   path (PathLike)
-00005970: 3a20 5468 6520 6669 6c65 2070 6174 682e  : The file path.
-00005980: 0d0a 2020 2020 2020 2020 6c61 7965 7220  ..        layer 
-00005990: 284f 7074 696f 6e61 6c5b 7374 725d 293a  (Optional[str]):
-000059a0: 2054 6865 206c 6179 6572 206e 616d 652e   The layer name.
-000059b0: 2049 6620 6e6f 7420 7370 6563 6966 6965   If not specifie
-000059c0: 642c 2061 6e64 2074 6865 7265 2069 7320  d, and there is 
-000059d0: 6f6e 6c79 0d0a 2020 2020 2020 2020 2020  only..          
-000059e0: 2020 6f6e 6520 6c61 7965 7220 696e 2074    one layer in t
-000059f0: 6865 2066 696c 652c 2074 6869 7320 6c61  he file, this la
-00005a00: 7965 7220 6973 2075 7365 642e 204f 7468  yer is used. Oth
-00005a10: 6572 7769 7365 2065 7863 6570 7469 6f6e  erwise exception
-00005a20: 2e0d 0a20 2020 2020 2020 206e 6577 5f6c  ...        new_l
-00005a30: 6179 6572 2028 7374 7229 3a20 5468 6520  ayer (str): The 
-00005a40: 6e65 7720 6c61 7965 7220 6e61 6d65 2e20  new layer name. 
-00005a50: 4966 206e 6f74 2073 7065 6369 6669 6564  If not specified
-00005a60: 2c20 616e 6420 7468 6572 6520 6973 206f  , and there is o
-00005a70: 6e6c 790d 0a20 2020 2020 2020 2020 2020  nly..           
-00005a80: 206f 6e65 206c 6179 6572 2069 6e20 7468   one layer in th
-00005a90: 6520 6669 6c65 2c20 7468 6973 206c 6179  e file, this lay
-00005aa0: 6572 2069 7320 7573 6564 2e20 4f74 6865  er is used. Othe
-00005ab0: 7277 6973 6520 6578 6365 7074 696f 6e2e  rwise exception.
-00005ac0: 0d0a 2020 2020 2222 220d 0a20 2020 2023  ..    """..    #
-00005ad0: 2043 6865 636b 2069 6e70 7574 2070 6172   Check input par
-00005ae0: 616d 6574 6572 730d 0a20 2020 2070 6174  ameters..    pat
-00005af0: 6820 3d20 5061 7468 2870 6174 6829 0d0a  h = Path(path)..
-00005b00: 2020 2020 6966 206c 6179 6572 2069 7320      if layer is 
-00005b10: 4e6f 6e65 3a0d 0a20 2020 2020 2020 206c  None:..        l
-00005b20: 6179 6572 203d 2067 6574 5f6f 6e6c 795f  ayer = get_only_
-00005b30: 6c61 7965 7228 7061 7468 290d 0a0d 0a20  layer(path).... 
-00005b40: 2020 2023 204e 6f77 2072 6561 6c6c 7920     # Now really 
-00005b50: 7265 6e61 6d65 0d0a 2020 2020 6461 7461  rename..    data
-00005b60: 736f 7572 6365 203d 204e 6f6e 650d 0a20  source = None.. 
-00005b70: 2020 2067 656f 6669 6c65 7479 7065 203d     geofiletype =
-00005b80: 2047 656f 6669 6c65 5479 7065 2870 6174   GeofileType(pat
-00005b90: 6829 0d0a 2020 2020 7472 793a 0d0a 2020  h)..    try:..  
-00005ba0: 2020 2020 2020 6966 2067 656f 6669 6c65        if geofile
-00005bb0: 7479 7065 2e69 735f 7370 6174 6961 6c69  type.is_spatiali
-00005bc0: 7465 5f62 6173 6564 3a0d 0a20 2020 2020  te_based:..     
-00005bd0: 2020 2020 2020 2064 6174 6173 6f75 7263         datasourc
-00005be0: 6520 3d20 6764 616c 2e4f 7065 6e45 7828  e = gdal.OpenEx(
-00005bf0: 7374 7228 7061 7468 292c 206e 4f70 656e  str(path), nOpen
-00005c00: 466c 6167 733d 6764 616c 2e4f 465f 5550  Flags=gdal.OF_UP
-00005c10: 4441 5445 290d 0a20 2020 2020 2020 2020  DATE)..         
-00005c20: 2020 2073 716c 5f73 746d 7420 3d20 6627     sql_stmt = f'
-00005c30: 414c 5445 5220 5441 424c 4520 227b 6c61  ALTER TABLE "{la
-00005c40: 7965 727d 2220 5245 4e41 4d45 2054 4f20  yer}" RENAME TO 
-00005c50: 227b 6e65 775f 6c61 7965 727d 2227 0d0a  "{new_layer}"'..
-00005c60: 2020 2020 2020 2020 2020 2020 7265 7375              resu
-00005c70: 6c74 203d 2064 6174 6173 6f75 7263 652e  lt = datasource.
-00005c80: 4578 6563 7574 6553 514c 2873 716c 5f73  ExecuteSQL(sql_s
-00005c90: 746d 7429 0d0a 2020 2020 2020 2020 2020  tmt)..          
-00005ca0: 2020 6461 7461 736f 7572 6365 2e52 656c    datasource.Rel
-00005cb0: 6561 7365 5265 7375 6c74 5365 7428 7265  easeResultSet(re
-00005cc0: 7375 6c74 290d 0a20 2020 2020 2020 2065  sult)..        e
-00005cd0: 6c69 6620 6765 6f66 696c 6574 7970 6520  lif geofiletype 
-00005ce0: 3d3d 2047 656f 6669 6c65 5479 7065 2e45  == GeofileType.E
-00005cf0: 5352 4953 6861 7065 6669 6c65 3a0d 0a20  SRIShapefile:.. 
-00005d00: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-00005d10: 2056 616c 7565 4572 726f 7228 6622 7265   ValueError(f"re
-00005d20: 6e61 6d65 5f6c 6179 6572 2069 7320 6e6f  name_layer is no
-00005d30: 7420 706f 7373 6962 6c65 2066 6f72 207b  t possible for {
-00005d40: 6765 6f66 696c 6574 7970 657d 2066 696c  geofiletype} fil
-00005d50: 6522 290d 0a20 2020 2020 2020 2065 6c73  e")..        els
-00005d60: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-00005d70: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00005d80: 2866 2272 656e 616d 655f 6c61 7965 7220  (f"rename_layer 
-00005d90: 6973 206e 6f74 2069 6d70 6c65 6d65 6e74  is not implement
-00005da0: 6564 2066 6f72 207b 7061 7468 2e73 7566  ed for {path.suf
-00005db0: 6669 787d 2066 696c 6522 290d 0a20 2020  fix} file")..   
-00005dc0: 2066 696e 616c 6c79 3a0d 0a20 2020 2020   finally:..     
-00005dd0: 2020 2069 6620 6461 7461 736f 7572 6365     if datasource
-00005de0: 2069 7320 6e6f 7420 4e6f 6e65 3a0d 0a20   is not None:.. 
-00005df0: 2020 2020 2020 2020 2020 2064 656c 2064             del d
-00005e00: 6174 6173 6f75 7263 650d 0a0d 0a0d 0a64  atasource......d
-00005e10: 6566 2072 656e 616d 655f 636f 6c75 6d6e  ef rename_column
-00005e20: 280d 0a20 2020 2070 6174 683a 2055 6e69  (..    path: Uni
-00005e30: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
-00005e40: 4c69 6b65 5b41 6e79 5d22 5d2c 0d0a 2020  Like[Any]"],..  
-00005e50: 2020 636f 6c75 6d6e 5f6e 616d 653a 2073    column_name: s
-00005e60: 7472 2c0d 0a20 2020 206e 6577 5f63 6f6c  tr,..    new_col
-00005e70: 756d 6e5f 6e61 6d65 3a20 7374 722c 0d0a  umn_name: str,..
-00005e80: 2020 2020 6c61 7965 723a 204f 7074 696f      layer: Optio
-00005e90: 6e61 6c5b 7374 725d 203d 204e 6f6e 652c  nal[str] = None,
-00005ea0: 0d0a 293a 0d0a 2020 2020 2222 220d 0a20  ..):..    """.. 
-00005eb0: 2020 2052 656e 616d 6520 7468 6520 636f     Rename the co
-00005ec0: 6c75 6d6e 2073 7065 6369 6669 6564 2e0d  lumn specified..
-00005ed0: 0a0d 0a20 2020 2041 7267 733a 0d0a 2020  ...    Args:..  
-00005ee0: 2020 2020 2020 7061 7468 2028 5061 7468        path (Path
-00005ef0: 4c69 6b65 293a 2054 6865 2066 696c 6520  Like): The file 
-00005f00: 7061 7468 2e0d 0a20 2020 2020 2020 2063  path...        c
-00005f10: 6f6c 756d 6e5f 6e61 6d65 2028 7374 7229  olumn_name (str)
-00005f20: 3a20 7468 6520 6375 7272 656e 7420 636f  : the current co
-00005f30: 6c75 6d6e 206e 616d 652e 0d0a 2020 2020  lumn name...    
-00005f40: 2020 2020 6e65 775f 636f 6c75 6d6e 5f6e      new_column_n
-00005f50: 616d 6520 2873 7472 293a 2074 6865 206e  ame (str): the n
-00005f60: 6577 2063 6f6c 756d 6e20 6e61 6d65 2e0d  ew column name..
-00005f70: 0a20 2020 2020 2020 206c 6179 6572 2028  .        layer (
-00005f80: 4f70 7469 6f6e 616c 5b73 7472 5d29 3a20  Optional[str]): 
-00005f90: 5468 6520 6c61 7965 7220 6e61 6d65 2e20  The layer name. 
-00005fa0: 4966 206e 6f74 2073 7065 6369 6669 6564  If not specified
-00005fb0: 2c20 616e 6420 7468 6572 6520 6973 206f  , and there is o
-00005fc0: 6e6c 790d 0a20 2020 2020 2020 2020 2020  nly..           
-00005fd0: 206f 6e65 206c 6179 6572 2069 6e20 7468   one layer in th
-00005fe0: 6520 6669 6c65 2c20 7468 6973 206c 6179  e file, this lay
-00005ff0: 6572 2069 7320 7573 6564 2e20 4f74 6865  er is used. Othe
-00006000: 7277 6973 6520 6578 6365 7074 696f 6e2e  rwise exception.
-00006010: 0d0a 2020 2020 2222 220d 0a20 2020 2023  ..    """..    #
-00006020: 2043 6865 636b 2069 6e70 7574 2070 6172   Check input par
-00006030: 616d 6574 6572 730d 0a20 2020 2070 6174  ameters..    pat
-00006040: 6820 3d20 5061 7468 2870 6174 6829 0d0a  h = Path(path)..
-00006050: 2020 2020 6966 206c 6179 6572 2069 7320      if layer is 
-00006060: 4e6f 6e65 3a0d 0a20 2020 2020 2020 206c  None:..        l
-00006070: 6179 6572 203d 2067 6574 5f6f 6e6c 795f  ayer = get_only_
-00006080: 6c61 7965 7228 7061 7468 290d 0a20 2020  layer(path)..   
-00006090: 2069 6e66 6f20 3d20 6765 745f 6c61 7965   info = get_laye
-000060a0: 7269 6e66 6f28 7061 7468 290d 0a20 2020  rinfo(path)..   
-000060b0: 2069 6620 636f 6c75 6d6e 5f6e 616d 6520   if column_name 
-000060c0: 6e6f 7420 696e 2069 6e66 6f2e 636f 6c75  not in info.colu
-000060d0: 6d6e 7320 616e 6420 6e65 775f 636f 6c75  mns and new_colu
-000060e0: 6d6e 5f6e 616d 6520 696e 2069 6e66 6f2e  mn_name in info.
-000060f0: 636f 6c75 6d6e 733a 0d0a 2020 2020 2020  columns:..      
-00006100: 2020 6c6f 6767 6572 2e69 6e66 6f28 0d0a    logger.info(..
-00006110: 2020 2020 2020 2020 2020 2020 6622 436f              f"Co
-00006120: 6c75 6d6e 207b 636f 6c75 6d6e 5f6e 616d  lumn {column_nam
-00006130: 657d 2073 6565 6d73 2074 6f20 6265 2072  e} seems to be r
-00006140: 656e 616d 6564 2061 6c72 6561 6479 2074  enamed already t
-00006150: 6f20 7b6e 6577 5f63 6f6c 756d 6e5f 6e61  o {new_column_na
-00006160: 6d65 7d22 0d0a 2020 2020 2020 2020 290d  me}"..        ).
-00006170: 0a20 2020 2020 2020 2072 6574 7572 6e0d  .        return.
-00006180: 0a0d 0a20 2020 2023 204e 6f77 2072 6561  ...    # Now rea
-00006190: 6c6c 7920 7265 6e61 6d65 0d0a 2020 2020  lly rename..    
-000061a0: 6461 7461 736f 7572 6365 203d 204e 6f6e  datasource = Non
-000061b0: 650d 0a20 2020 2067 656f 6669 6c65 7479  e..    geofilety
-000061c0: 7065 203d 2047 656f 6669 6c65 5479 7065  pe = GeofileType
-000061d0: 2870 6174 6829 0d0a 2020 2020 7472 793a  (path)..    try:
-000061e0: 0d0a 2020 2020 2020 2020 6966 2067 656f  ..        if geo
-000061f0: 6669 6c65 7479 7065 2e69 735f 7370 6174  filetype.is_spat
-00006200: 6961 6c69 7465 5f62 6173 6564 3a0d 0a20  ialite_based:.. 
-00006210: 2020 2020 2020 2020 2020 2064 6174 6173             datas
-00006220: 6f75 7263 6520 3d20 6764 616c 2e4f 7065  ource = gdal.Ope
-00006230: 6e45 7828 7374 7228 7061 7468 292c 206e  nEx(str(path), n
-00006240: 4f70 656e 466c 6167 733d 6764 616c 2e4f  OpenFlags=gdal.O
-00006250: 465f 5550 4441 5445 290d 0a20 2020 2020  F_UPDATE)..     
-00006260: 2020 2020 2020 2073 716c 5f73 746d 7420         sql_stmt 
-00006270: 3d20 280d 0a20 2020 2020 2020 2020 2020  = (..           
-00006280: 2020 2020 2066 2741 4c54 4552 2054 4142       f'ALTER TAB
-00006290: 4c45 2022 7b6c 6179 6572 7d22 2027 0d0a  LE "{layer}" '..
-000062a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000062b0: 6627 5245 4e41 4d45 2043 4f4c 554d 4e20  f'RENAME COLUMN 
-000062c0: 227b 636f 6c75 6d6e 5f6e 616d 657d 2220  "{column_name}" 
-000062d0: 544f 2022 7b6e 6577 5f63 6f6c 756d 6e5f  TO "{new_column_
-000062e0: 6e61 6d65 7d22 270d 0a20 2020 2020 2020  name}"'..       
-000062f0: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-00006300: 2020 2020 7265 7375 6c74 203d 2064 6174      result = dat
-00006310: 6173 6f75 7263 652e 4578 6563 7574 6553  asource.ExecuteS
-00006320: 514c 2873 716c 5f73 746d 7429 0d0a 2020  QL(sql_stmt)..  
-00006330: 2020 2020 2020 2020 2020 6461 7461 736f            dataso
-00006340: 7572 6365 2e52 656c 6561 7365 5265 7375  urce.ReleaseResu
-00006350: 6c74 5365 7428 7265 7375 6c74 290d 0a20  ltSet(result).. 
-00006360: 2020 2020 2020 2065 6c69 6620 6765 6f66         elif geof
-00006370: 696c 6574 7970 6520 3d3d 2047 656f 6669  iletype == Geofi
-00006380: 6c65 5479 7065 2e45 5352 4953 6861 7065  leType.ESRIShape
-00006390: 6669 6c65 3a0d 0a20 2020 2020 2020 2020  file:..         
-000063a0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-000063b0: 726f 7228 6622 7265 6e61 6d65 5f63 6f6c  ror(f"rename_col
-000063c0: 756d 6e20 6973 206e 6f74 2070 6f73 7369  umn is not possi
-000063d0: 626c 6520 666f 7220 7b67 656f 6669 6c65  ble for {geofile
-000063e0: 7479 7065 7d20 6669 6c65 2229 0d0a 2020  type} file")..  
-000063f0: 2020 2020 2020 656c 7365 3a0d 0a20 2020        else:..   
-00006400: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-00006410: 616c 7565 4572 726f 7228 6622 7265 6e61  alueError(f"rena
-00006420: 6d65 5f63 6f6c 756d 6e20 6973 206e 6f74  me_column is not
-00006430: 2069 6d70 6c65 6d65 6e74 6564 2066 6f72   implemented for
-00006440: 207b 7061 7468 2e73 7566 6669 787d 2066   {path.suffix} f
-00006450: 696c 6522 290d 0a20 2020 2066 696e 616c  ile")..    final
-00006460: 6c79 3a0d 0a20 2020 2020 2020 2069 6620  ly:..        if 
-00006470: 6461 7461 736f 7572 6365 2069 7320 6e6f  datasource is no
-00006480: 7420 4e6f 6e65 3a0d 0a20 2020 2020 2020  t None:..       
-00006490: 2020 2020 2064 656c 2064 6174 6173 6f75       del datasou
-000064a0: 7263 650d 0a0d 0a0d 0a63 6c61 7373 2044  rce......class D
-000064b0: 6174 6154 7970 6528 656e 756d 2e45 6e75  ataType(enum.Enu
-000064c0: 6d29 3a0d 0a20 2020 2022 2222 0d0a 2020  m):..    """..  
-000064d0: 2020 5468 6973 2065 6e75 6d20 6465 6669    This enum defi
-000064e0: 6e65 7320 7468 6520 7374 616e 6461 7264  nes the standard
-000064f0: 2064 6174 6120 7479 7065 7320 7468 6174   data types that
-00006500: 2063 616e 2062 6520 7573 6564 2066 6f72   can be used for
-00006510: 2063 6f6c 756d 6e73 2e0d 0a20 2020 2022   columns...    "
-00006520: 2222 0d0a 0d0a 2020 2020 5445 5854 203d  ""....    TEXT =
-00006530: 2022 5445 5854 220d 0a20 2020 2022 2222   "TEXT"..    """
-00006540: 436f 6c75 6d6e 2077 6974 6820 7465 7874  Column with text
-00006550: 2064 6174 613a 207e 2073 7472 696e 672c   data: ~ string,
-00006560: 2063 6861 722c 2076 6172 6368 6172 2c20   char, varchar, 
-00006570: 636c 6f62 2e22 2222 0d0a 2020 2020 494e  clob."""..    IN
-00006580: 5445 4745 5220 3d20 2249 4e54 4547 4552  TEGER = "INTEGER
-00006590: 220d 0a20 2020 2022 2222 436f 6c75 6d6e  "..    """Column
-000065a0: 2077 6974 6820 696e 7465 6765 7220 6461   with integer da
-000065b0: 7461 2e22 2222 0d0a 2020 2020 5245 414c  ta."""..    REAL
-000065c0: 203d 2022 5245 414c 220d 0a20 2020 2022   = "REAL"..    "
-000065d0: 2222 436f 6c75 6d6e 2077 6974 6820 666c  ""Column with fl
-000065e0: 6f61 7469 6e67 2070 6f69 6e74 2064 6174  oating point dat
-000065f0: 613a 207e 2066 6c6f 6174 2c20 646f 7562  a: ~ float, doub
-00006600: 6c65 2e22 2222 0d0a 2020 2020 4441 5445  le."""..    DATE
-00006610: 203d 2022 4441 5445 220d 0a20 2020 2022   = "DATE"..    "
-00006620: 2222 436f 6c75 6d6e 2077 6974 6820 6461  ""Column with da
-00006630: 7465 2064 6174 612e 2222 220d 0a20 2020  te data."""..   
-00006640: 2054 494d 4553 5441 4d50 203d 2022 5449   TIMESTAMP = "TI
-00006650: 4d45 5354 414d 5022 0d0a 2020 2020 2222  MESTAMP"..    ""
-00006660: 2243 6f6c 756d 6e20 7769 7468 2074 696d  "Column with tim
-00006670: 6573 7461 6d70 2064 6174 613a 207e 2064  estamp data: ~ d
-00006680: 6174 6574 696d 652e 2222 220d 0a20 2020  atetime."""..   
-00006690: 2042 4f4f 4c45 414e 203d 2022 424f 4f4c   BOOLEAN = "BOOL
-000066a0: 4541 4e22 0d0a 2020 2020 2222 2243 6f6c  EAN"..    """Col
-000066b0: 756d 6e20 7769 7468 2062 6f6f 6c65 616e  umn with boolean
-000066c0: 2064 6174 612e 2222 220d 0a20 2020 2042   data."""..    B
-000066d0: 4c4f 4220 3d20 2242 4c4f 4222 0d0a 2020  LOB = "BLOB"..  
-000066e0: 2020 2222 2243 6f6c 756d 6e20 7769 7468    """Column with
-000066f0: 2062 696e 6172 7920 6461 7461 2e22 2222   binary data."""
-00006700: 0d0a 2020 2020 4e55 4d45 5249 4320 3d20  ..    NUMERIC = 
-00006710: 224e 554d 4552 4943 220d 0a20 2020 2022  "NUMERIC"..    "
-00006720: 2222 436f 6c75 6d6e 2077 6974 6820 6e75  ""Column with nu
-00006730: 6d65 7269 6320 6461 7461 3a20 6578 6163  meric data: exac
-00006740: 7420 6465 6369 6d61 6c20 6461 7461 2e22  t decimal data."
-00006750: 2222 0d0a 0d0a 0d0a 6465 6620 6164 645f  ""......def add_
-00006760: 636f 6c75 6d6e 280d 0a20 2020 2070 6174  column(..    pat
-00006770: 683a 2055 6e69 6f6e 5b73 7472 2c20 226f  h: Union[str, "o
-00006780: 732e 5061 7468 4c69 6b65 5b41 6e79 5d22  s.PathLike[Any]"
-00006790: 5d2c 0d0a 2020 2020 6e61 6d65 3a20 7374  ],..    name: st
-000067a0: 722c 0d0a 2020 2020 7479 7065 3a20 556e  r,..    type: Un
-000067b0: 696f 6e5b 4461 7461 5479 7065 2c20 7374  ion[DataType, st
-000067c0: 725d 2c0d 0a20 2020 2065 7870 7265 7373  r],..    express
-000067d0: 696f 6e3a 2055 6e69 6f6e 5b73 7472 2c20  ion: Union[str, 
-000067e0: 696e 742c 2066 6c6f 6174 2c20 4e6f 6e65  int, float, None
-000067f0: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2065  ] = None,..    e
-00006800: 7870 7265 7373 696f 6e5f 6469 616c 6563  xpression_dialec
-00006810: 743a 204f 7074 696f 6e61 6c5b 7374 725d  t: Optional[str]
-00006820: 203d 204e 6f6e 652c 0d0a 2020 2020 6c61   = None,..    la
-00006830: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
-00006840: 725d 203d 204e 6f6e 652c 0d0a 2020 2020  r] = None,..    
-00006850: 666f 7263 655f 7570 6461 7465 3a20 626f  force_update: bo
-00006860: 6f6c 203d 2046 616c 7365 2c0d 0a20 2020  ol = False,..   
-00006870: 2077 6964 7468 3a20 4f70 7469 6f6e 616c   width: Optional
-00006880: 5b69 6e74 5d20 3d20 4e6f 6e65 2c0d 0a29  [int] = None,..)
-00006890: 3a0d 0a20 2020 2022 2222 0d0a 2020 2020  :..    """..    
-000068a0: 4164 6420 6120 636f 6c75 6d6e 2074 6f20  Add a column to 
-000068b0: 6120 6c61 7965 7220 6f66 2074 6865 2067  a layer of the g
-000068c0: 656f 6669 6c65 2e0d 0a0d 0a20 2020 2041  eofile.....    A
-000068d0: 7267 733a 0d0a 2020 2020 2020 2020 7061  rgs:..        pa
-000068e0: 7468 2028 5061 7468 4c69 6b65 293a 2050  th (PathLike): P
-000068f0: 6174 6820 746f 2074 6865 2067 656f 6669  ath to the geofi
-00006900: 6c65 2e0d 0a20 2020 2020 2020 206e 616d  le...        nam
-00006910: 6520 2873 7472 293a 204e 616d 6520 666f  e (str): Name fo
-00006920: 7220 7468 6520 6e65 7720 636f 6c75 6d6e  r the new column
-00006930: 2e0d 0a20 2020 2020 2020 2074 7970 6520  ...        type 
-00006940: 2873 7472 293a 2043 6f6c 756d 6e20 7479  (str): Column ty
-00006950: 7065 206f 6620 7468 6520 6e65 7720 636f  pe of the new co
-00006960: 6c75 6d6e 2e0d 0a20 2020 2020 2020 2065  lumn...        e
-00006970: 7870 7265 7373 696f 6e20 2873 7472 2c20  xpression (str, 
-00006980: 6f70 7469 6f6e 616c 293a 2053 514c 6974  optional): SQLit
-00006990: 6520 6578 7072 6573 7369 6f6e 2074 6f20  e expression to 
-000069a0: 7573 6520 746f 2075 7064 6174 650d 0a20  use to update.. 
-000069b0: 2020 2020 2020 2020 2020 2074 6865 2076             the v
-000069c0: 616c 7565 2e20 4465 6661 756c 7473 2074  alue. Defaults t
-000069d0: 6f20 4e6f 6e65 2e0d 0a20 2020 2020 2020  o None...       
-000069e0: 2065 7870 7265 7373 696f 6e5f 6469 616c   expression_dial
-000069f0: 6563 7420 2873 7472 2c20 6f70 7469 6f6e  ect (str, option
-00006a00: 616c 293a 2053 514c 2064 6961 6c65 6374  al): SQL dialect
-00006a10: 2075 7365 6420 666f 7220 7468 6520 6578   used for the ex
-00006a20: 7072 6573 7369 6f6e 2e0d 0a20 2020 2020  pression...     
-00006a30: 2020 206c 6179 6572 2028 7374 722c 206f     layer (str, o
-00006a40: 7074 696f 6e61 6c29 3a20 5468 6520 6c61  ptional): The la
-00006a50: 7965 7220 6e61 6d65 2e20 4966 204e 6f6e  yer name. If Non
-00006a60: 6520 616e 6420 7468 6520 6765 6f66 696c  e and the geofil
-00006a70: 650d 0a20 2020 2020 2020 2020 2020 2068  e..            h
-00006a80: 6173 206f 6e6c 7920 6f6e 6520 6c61 7965  as only one laye
-00006a90: 722c 2074 6861 7420 6c61 7965 7220 6973  r, that layer is
-00006aa0: 2075 7365 642e 2044 6566 6175 6c74 7320   used. Defaults 
-00006ab0: 746f 204e 6f6e 652e 0d0a 2020 2020 2020  to None...      
-00006ac0: 2020 666f 7263 655f 7570 6461 7465 2028    force_update (
-00006ad0: 626f 6f6c 2c20 6f70 7469 6f6e 616c 293a  bool, optional):
-00006ae0: 2049 6620 7468 6520 636f 6c75 6d6e 2061   If the column a
-00006af0: 6c72 6561 6479 2065 7869 7374 732c 2065  lready exists, e
-00006b00: 7865 6375 7465 0d0a 2020 2020 2020 2020  xecute..        
-00006b10: 2020 2020 7468 6520 7570 6461 7465 2061      the update a
-00006b20: 6e79 7761 792e 2044 6566 6175 6c74 7320  nyway. Defaults 
-00006b30: 746f 2046 616c 7365 2e0d 0a20 2020 2020  to False...     
-00006b40: 2020 2077 6964 7468 2028 696e 742c 206f     width (int, o
-00006b50: 7074 696f 6e61 6c29 3a20 7468 6520 7769  ptional): the wi
-00006b60: 6474 6820 6f66 2074 6865 2066 6965 6c64  dth of the field
-00006b70: 2e0d 0a0d 0a20 2020 2052 6169 7365 733a  .....    Raises:
-00006b80: 0d0a 2020 2020 2020 2020 6578 3a20 5b64  ..        ex: [d
-00006b90: 6573 6372 6970 7469 6f6e 5d0d 0a20 2020  escription]..   
-00006ba0: 2022 2222 0d0a 2020 2020 2320 496e 6974   """..    # Init
-00006bb0: 0d0a 2020 2020 6966 2069 7369 6e73 7461  ..    if isinsta
-00006bc0: 6e63 6528 7479 7065 2c20 4461 7461 5479  nce(type, DataTy
-00006bd0: 7065 293a 0d0a 2020 2020 2020 2020 7479  pe):..        ty
-00006be0: 7065 5f73 7472 203d 2074 7970 652e 7661  pe_str = type.va
-00006bf0: 6c75 650d 0a20 2020 2065 6c73 653a 0d0a  lue..    else:..
-00006c00: 2020 2020 2020 2020 7479 7065 5f6c 6f77          type_low
-00006c10: 6572 203d 2074 7970 652e 6c6f 7765 7228  er = type.lower(
-00006c20: 290d 0a20 2020 2020 2020 2069 6620 7479  )..        if ty
-00006c30: 7065 5f6c 6f77 6572 203d 3d20 2273 7472  pe_lower == "str
-00006c40: 696e 6722 3a0d 0a20 2020 2020 2020 2020  ing":..         
-00006c50: 2020 2023 2054 4f44 4f3a 2074 6869 6e6b     # TODO: think
-00006c60: 2077 6865 7468 6572 2062 6569 6e67 2066   whether being f
-00006c70: 6c65 7869 626c 6520 6865 7265 2069 7320  lexible here is 
-00006c80: 6120 676f 6f64 2069 6465 612e 2e2e 0d0a  a good idea.....
-00006c90: 2020 2020 2020 2020 2020 2020 7479 7065              type
-00006ca0: 5f73 7472 203d 2022 5445 5854 220d 0a20  _str = "TEXT".. 
-00006cb0: 2020 2020 2020 2065 6c69 6620 7479 7065         elif type
-00006cc0: 5f6c 6f77 6572 203d 3d20 2262 696e 6172  _lower == "binar
-00006cd0: 7922 3a0d 0a20 2020 2020 2020 2020 2020  y":..           
-00006ce0: 2074 7970 655f 7374 7220 3d20 2242 4c4f   type_str = "BLO
-00006cf0: 4222 0d0a 2020 2020 2020 2020 656c 6966  B"..        elif
-00006d00: 2074 7970 655f 6c6f 7765 7220 3d3d 2022   type_lower == "
-00006d10: 7469 6d65 223a 0d0a 2020 2020 2020 2020  time":..        
-00006d20: 2020 2020 7479 7065 5f73 7472 203d 2022      type_str = "
-00006d30: 4441 5445 5449 4d45 220d 0a20 2020 2020  DATETIME"..     
-00006d40: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-00006d50: 2020 2020 2020 7479 7065 5f73 7472 203d        type_str =
-00006d60: 2074 7970 650d 0a20 2020 2070 6174 6820   type..    path 
-00006d70: 3d20 5061 7468 2870 6174 6829 0d0a 2020  = Path(path)..  
-00006d80: 2020 6966 206c 6179 6572 2069 7320 4e6f    if layer is No
-00006d90: 6e65 3a0d 0a20 2020 2020 2020 206c 6179  ne:..        lay
-00006da0: 6572 203d 2067 6574 5f6f 6e6c 795f 6c61  er = get_only_la
-00006db0: 7965 7228 7061 7468 290d 0a20 2020 206c  yer(path)..    l
-00006dc0: 6179 6572 696e 666f 5f6f 7269 6720 3d20  ayerinfo_orig = 
-00006dd0: 6765 745f 6c61 7965 7269 6e66 6f28 7061  get_layerinfo(pa
-00006de0: 7468 2c20 6c61 7965 7229 0d0a 0d0a 2020  th, layer)....  
-00006df0: 2020 2320 476f 210d 0a20 2020 2064 6174    # Go!..    dat
-00006e00: 6173 6f75 7263 6520 3d20 4e6f 6e65 0d0a  asource = None..
-00006e10: 2020 2020 7472 793a 0d0a 2020 2020 2020      try:..      
-00006e20: 2020 2320 4966 2063 6f6c 756d 6e20 646f    # If column do
-00006e30: 6573 6e27 7420 6578 6973 7420 7965 742c  esn't exist yet,
-00006e40: 2063 7265 6174 6520 6974 0d0a 2020 2020   create it..    
-00006e50: 2020 2020 636f 6c75 6d6e 735f 7570 7065      columns_uppe
-00006e60: 7220 3d20 5b63 6f6c 756d 6e2e 7570 7065  r = [column.uppe
-00006e70: 7228 2920 666f 7220 636f 6c75 6d6e 2069  r() for column i
-00006e80: 6e20 6c61 7965 7269 6e66 6f5f 6f72 6967  n layerinfo_orig
-00006e90: 2e63 6f6c 756d 6e73 5d0d 0a20 2020 2020  .columns]..     
-00006ea0: 2020 2069 6620 6e61 6d65 2e75 7070 6572     if name.upper
-00006eb0: 2829 206e 6f74 2069 6e20 636f 6c75 6d6e  () not in column
-00006ec0: 735f 7570 7065 723a 0d0a 2020 2020 2020  s_upper:..      
-00006ed0: 2020 2020 2020 7769 6474 685f 7374 7220        width_str 
-00006ee0: 3d20 6622 287b 7769 6474 687d 2922 2069  = f"({width})" i
-00006ef0: 6620 7769 6474 6820 6973 206e 6f74 204e  f width is not N
-00006f00: 6f6e 6520 656c 7365 2022 220d 0a20 2020  one else ""..   
-00006f10: 2020 2020 2020 2020 2073 716c 5f73 746d           sql_stm
-00006f20: 7420 3d20 280d 0a20 2020 2020 2020 2020  t = (..         
-00006f30: 2020 2020 2020 2066 2741 4c54 4552 2054         f'ALTER T
-00006f40: 4142 4c45 2022 7b6c 6179 6572 7d22 2041  ABLE "{layer}" A
-00006f50: 4444 2043 4f4c 554d 4e20 227b 6e61 6d65  DD COLUMN "{name
-00006f60: 7d22 207b 7479 7065 5f73 7472 7d7b 7769  }" {type_str}{wi
-00006f70: 6474 685f 7374 727d 270d 0a20 2020 2020  dth_str}'..     
-00006f80: 2020 2020 2020 2029 0d0a 2020 2020 2020         )..      
-00006f90: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
-00006fa0: 203d 2067 6461 6c2e 4f70 656e 4578 2873   = gdal.OpenEx(s
-00006fb0: 7472 2870 6174 6829 2c20 6e4f 7065 6e46  tr(path), nOpenF
-00006fc0: 6c61 6773 3d67 6461 6c2e 4f46 5f55 5044  lags=gdal.OF_UPD
-00006fd0: 4154 4529 0d0a 2020 2020 2020 2020 2020  ATE)..          
-00006fe0: 2020 7265 7375 6c74 203d 2064 6174 6173    result = datas
-00006ff0: 6f75 7263 652e 4578 6563 7574 6553 514c  ource.ExecuteSQL
-00007000: 2873 716c 5f73 746d 7429 0d0a 2020 2020  (sql_stmt)..    
-00007010: 2020 2020 2020 2020 6461 7461 736f 7572          datasour
-00007020: 6365 2e52 656c 6561 7365 5265 7375 6c74  ce.ReleaseResult
-00007030: 5365 7428 7265 7375 6c74 290d 0a20 2020  Set(result)..   
-00007040: 2020 2020 2065 6c73 653a 0d0a 2020 2020       else:..    
-00007050: 2020 2020 2020 2020 6c6f 6767 6572 2e77          logger.w
-00007060: 6172 6e69 6e67 2866 2243 6f6c 756d 6e20  arning(f"Column 
-00007070: 7b6e 616d 657d 2065 7869 7374 6564 2061  {name} existed a
-00007080: 6c72 6561 6479 2069 6e20 7b70 6174 687d  lready in {path}
-00007090: 2c20 6c61 7965 7220 7b6c 6179 6572 7d22  , layer {layer}"
-000070a0: 290d 0a0d 0a20 2020 2020 2020 2023 2049  )....        # I
-000070b0: 6620 616e 2065 7870 7265 7373 696f 6e20  f an expression 
-000070c0: 7761 7320 7072 6f76 6964 6564 2061 6e64  was provided and
-000070d0: 2075 7064 6174 6520 6361 6e20 6265 2064   update can be d
-000070e0: 6f6e 652c 2067 6f20 666f 7220 6974 2e2e  one, go for it..
-000070f0: 2e0d 0a20 2020 2020 2020 2069 6620 6578  ...        if ex
-00007100: 7072 6573 7369 6f6e 2069 7320 6e6f 7420  pression is not 
-00007110: 4e6f 6e65 2061 6e64 2028 0d0a 2020 2020  None and (..    
-00007120: 2020 2020 2020 2020 6e61 6d65 206e 6f74          name not
-00007130: 2069 6e20 6c61 7965 7269 6e66 6f5f 6f72   in layerinfo_or
-00007140: 6967 2e63 6f6c 756d 6e73 206f 7220 666f  ig.columns or fo
-00007150: 7263 655f 7570 6461 7465 2069 7320 5472  rce_update is Tr
-00007160: 7565 0d0a 2020 2020 2020 2020 293a 0d0a  ue..        ):..
-00007170: 2020 2020 2020 2020 2020 2020 6966 2064              if d
-00007180: 6174 6173 6f75 7263 6520 6973 204e 6f6e  atasource is Non
-00007190: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-000071a0: 2020 2020 6461 7461 736f 7572 6365 203d      datasource =
-000071b0: 2067 6461 6c2e 4f70 656e 4578 2873 7472   gdal.OpenEx(str
-000071c0: 2870 6174 6829 2c20 6e4f 7065 6e46 6c61  (path), nOpenFla
-000071d0: 6773 3d67 6461 6c2e 4f46 5f55 5044 4154  gs=gdal.OF_UPDAT
-000071e0: 4529 0d0a 2020 2020 2020 2020 2020 2020  E)..            
-000071f0: 7371 6c5f 7374 6d74 203d 2066 2755 5044  sql_stmt = f'UPD
-00007200: 4154 4520 227b 6c61 7965 727d 2220 5345  ATE "{layer}" SE
-00007210: 5420 227b 6e61 6d65 7d22 203d 207b 6578  T "{name}" = {ex
-00007220: 7072 6573 7369 6f6e 7d27 0d0a 2020 2020  pression}'..    
-00007230: 2020 2020 2020 2020 7265 7375 6c74 203d          result =
-00007240: 2064 6174 6173 6f75 7263 652e 4578 6563   datasource.Exec
-00007250: 7574 6553 514c 2873 716c 5f73 746d 742c  uteSQL(sql_stmt,
-00007260: 2064 6961 6c65 6374 3d65 7870 7265 7373   dialect=express
-00007270: 696f 6e5f 6469 616c 6563 7429 0d0a 2020  ion_dialect)..  
-00007280: 2020 2020 2020 2020 2020 6461 7461 736f            dataso
-00007290: 7572 6365 2e52 656c 6561 7365 5265 7375  urce.ReleaseResu
-000072a0: 6c74 5365 7428 7265 7375 6c74 290d 0a20  ltSet(result).. 
-000072b0: 2020 2066 696e 616c 6c79 3a0d 0a20 2020     finally:..   
-000072c0: 2020 2020 2069 6620 6461 7461 736f 7572       if datasour
-000072d0: 6365 2069 7320 6e6f 7420 4e6f 6e65 3a0d  ce is not None:.
-000072e0: 0a20 2020 2020 2020 2020 2020 2064 656c  .            del
-000072f0: 2064 6174 6173 6f75 7263 650d 0a0d 0a0d   datasource.....
-00007300: 0a64 6566 2064 726f 705f 636f 6c75 6d6e  .def drop_column
-00007310: 280d 0a20 2020 2070 6174 683a 2055 6e69  (..    path: Uni
-00007320: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
-00007330: 4c69 6b65 5b41 6e79 5d22 5d2c 2063 6f6c  Like[Any]"], col
-00007340: 756d 6e5f 6e61 6d65 3a20 7374 722c 206c  umn_name: str, l
-00007350: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
-00007360: 7472 5d20 3d20 4e6f 6e65 0d0a 293a 0d0a  tr] = None..):..
-00007370: 2020 2020 2222 220d 0a20 2020 2044 726f      """..    Dro
-00007380: 7020 7468 6520 636f 6c75 6d6e 2073 7065  p the column spe
-00007390: 6369 6669 6564 2e0d 0a0d 0a20 2020 2041  cified.....    A
-000073a0: 7267 733a 0d0a 2020 2020 2020 2020 7061  rgs:..        pa
-000073b0: 7468 2028 5061 7468 4c69 6b65 293a 2054  th (PathLike): T
-000073c0: 6865 2066 696c 6520 7061 7468 2e0d 0a20  he file path... 
-000073d0: 2020 2020 2020 2063 6f6c 756d 6e5f 6e61         column_na
-000073e0: 6d65 2028 7374 7229 3a20 7468 6520 636f  me (str): the co
-000073f0: 6c75 6d6e 206e 616d 652e 0d0a 2020 2020  lumn name...    
-00007400: 2020 2020 6c61 7965 7220 284f 7074 696f      layer (Optio
-00007410: 6e61 6c5b 7374 725d 293a 2054 6865 206c  nal[str]): The l
-00007420: 6179 6572 206e 616d 652e 2049 6620 6e6f  ayer name. If no
-00007430: 7420 7370 6563 6966 6965 642c 2061 6e64  t specified, and
-00007440: 2074 6865 7265 2069 7320 6f6e 6c79 0d0a   there is only..
-00007450: 2020 2020 2020 2020 2020 2020 6f6e 6520              one 
-00007460: 6c61 7965 7220 696e 2074 6865 2066 696c  layer in the fil
-00007470: 652c 2074 6869 7320 6c61 7965 7220 6973  e, this layer is
-00007480: 2075 7365 642e 204f 7468 6572 7769 7365   used. Otherwise
-00007490: 2061 2056 616c 7565 4572 726f 7220 6973   a ValueError is
-000074a0: 0d0a 2020 2020 2020 2020 2020 2020 7261  ..            ra
-000074b0: 6973 6564 2e0d 0a20 2020 2022 2222 0d0a  ised...    """..
-000074c0: 2020 2020 2320 4368 6563 6b20 696e 7075      # Check inpu
-000074d0: 7420 7061 7261 6d65 7465 7273 0d0a 2020  t parameters..  
-000074e0: 2020 7061 7468 203d 2050 6174 6828 7061    path = Path(pa
-000074f0: 7468 290d 0a20 2020 2069 6620 6c61 7965  th)..    if laye
-00007500: 7220 6973 204e 6f6e 653a 0d0a 2020 2020  r is None:..    
-00007510: 2020 2020 6c61 7965 7220 3d20 6765 745f      layer = get_
-00007520: 6f6e 6c79 5f6c 6179 6572 2870 6174 6829  only_layer(path)
-00007530: 0d0a 2020 2020 696e 666f 203d 2067 6574  ..    info = get
-00007540: 5f6c 6179 6572 696e 666f 2870 6174 682c  _layerinfo(path,
-00007550: 206c 6179 6572 290d 0a20 2020 2069 6620   layer)..    if 
-00007560: 636f 6c75 6d6e 5f6e 616d 6520 6e6f 7420  column_name not 
-00007570: 696e 2069 6e66 6f2e 636f 6c75 6d6e 733a  in info.columns:
-00007580: 0d0a 2020 2020 2020 2020 6c6f 6767 6572  ..        logger
-00007590: 2e69 6e66 6f28 6622 436f 6c75 6d6e 207b  .info(f"Column {
-000075a0: 636f 6c75 6d6e 5f6e 616d 657d 206e 6f74  column_name} not
-000075b0: 2070 7265 7365 6e74 2073 6f20 6361 6e6e   present so cann
-000075c0: 6f74 2062 6520 6472 6f70 7065 642e 2229  ot be dropped.")
-000075d0: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-000075e0: 0d0a 0d0a 2020 2020 2320 4e6f 7720 7265  ....    # Now re
-000075f0: 616c 6c79 2072 656e 616d 650d 0a20 2020  ally rename..   
-00007600: 2064 6174 6173 6f75 7263 6520 3d20 4e6f   datasource = No
-00007610: 6e65 0d0a 2020 2020 7472 793a 0d0a 2020  ne..    try:..  
-00007620: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
-00007630: 203d 2067 6461 6c2e 4f70 656e 4578 2873   = gdal.OpenEx(s
-00007640: 7472 2870 6174 6829 2c20 6e4f 7065 6e46  tr(path), nOpenF
-00007650: 6c61 6773 3d67 6461 6c2e 4f46 5f55 5044  lags=gdal.OF_UPD
-00007660: 4154 4529 0d0a 2020 2020 2020 2020 7371  ATE)..        sq
-00007670: 6c5f 7374 6d74 203d 2066 2741 4c54 4552  l_stmt = f'ALTER
-00007680: 2054 4142 4c45 2022 7b6c 6179 6572 7d22   TABLE "{layer}"
-00007690: 2044 524f 5020 434f 4c55 4d4e 2022 7b63   DROP COLUMN "{c
-000076a0: 6f6c 756d 6e5f 6e61 6d65 7d22 270d 0a20  olumn_name}"'.. 
-000076b0: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
-000076c0: 6461 7461 736f 7572 6365 2e45 7865 6375  datasource.Execu
-000076d0: 7465 5351 4c28 7371 6c5f 7374 6d74 290d  teSQL(sql_stmt).
-000076e0: 0a20 2020 2020 2020 2064 6174 6173 6f75  .        datasou
-000076f0: 7263 652e 5265 6c65 6173 6552 6573 756c  rce.ReleaseResul
-00007700: 7453 6574 2872 6573 756c 7429 0d0a 2020  tSet(result)..  
-00007710: 2020 6669 6e61 6c6c 793a 0d0a 2020 2020    finally:..    
-00007720: 2020 2020 6966 2064 6174 6173 6f75 7263      if datasourc
-00007730: 6520 6973 206e 6f74 204e 6f6e 653a 0d0a  e is not None:..
-00007740: 2020 2020 2020 2020 2020 2020 6465 6c20              del 
-00007750: 6461 7461 736f 7572 6365 0d0a 0d0a 0d0a  datasource......
-00007760: 6465 6620 7570 6461 7465 5f63 6f6c 756d  def update_colum
-00007770: 6e28 0d0a 2020 2020 7061 7468 3a20 556e  n(..    path: Un
+00000a10: 2323 2323 2323 2323 2323 0a0a 0a64 6566  ##########...def
+00000a20: 206c 6973 746c 6179 6572 7328 0a20 2020   listlayers(.   
+00000a30: 2070 6174 683a 2055 6e69 6f6e 5b73 7472   path: Union[str
+00000a40: 2c20 226f 732e 5061 7468 4c69 6b65 5b41  , "os.PathLike[A
+00000a50: 6e79 5d22 5d2c 0a20 2020 206f 6e6c 795f  ny]"],.    only_
+00000a60: 7370 6174 6961 6c5f 6c61 7965 7273 3a20  spatial_layers: 
+00000a70: 626f 6f6c 203d 2054 7275 652c 0a29 202d  bool = True,.) -
+00000a80: 3e20 4c69 7374 5b73 7472 5d3a 0a20 2020  > List[str]:.   
+00000a90: 2022 2222 0a20 2020 2047 6574 2074 6865   """.    Get the
+00000aa0: 206c 6973 7420 6f66 206c 6179 6572 7320   list of layers 
+00000ab0: 696e 2061 2067 656f 6669 6c65 2e0a 0a20  in a geofile... 
+00000ac0: 2020 2041 7267 733a 0a20 2020 2020 2020     Args:.       
+00000ad0: 2070 6174 6820 2850 6174 684c 696b 6529   path (PathLike)
+00000ae0: 3a20 7061 7468 2074 6f20 7468 6520 6669  : path to the fi
+00000af0: 6c65 2074 6f20 6765 7420 696e 666f 2061  le to get info a
+00000b00: 626f 7574 0a20 2020 2020 2020 206f 6e6c  bout.        onl
+00000b10: 795f 7370 6174 6961 6c5f 6c61 7965 7273  y_spatial_layers
+00000b20: 2028 626f 6f6c 2c20 6f70 7469 6f6e 616c   (bool, optional
+00000b30: 293a 2054 7275 6520 746f 206f 6e6c 7920  ): True to only 
+00000b40: 6c69 7374 2073 7061 7469 616c 206c 6179  list spatial lay
+00000b50: 6572 732e 0a20 2020 2020 2020 2020 2020  ers..           
+00000b60: 2046 616c 7365 2074 6f20 6c69 7374 2061   False to list a
+00000b70: 6c6c 2074 6162 6c65 732e 0a0a 2020 2020  ll tables...    
+00000b80: 5265 7475 726e 733a 0a20 2020 2020 2020  Returns:.       
+00000b90: 204c 6973 745b 7374 725d 3a20 7468 6520   List[str]: the 
+00000ba0: 6c69 7374 206f 6620 6c61 7965 7273 0a20  list of layers. 
+00000bb0: 2020 2022 2222 0a20 2020 2070 6174 6820     """.    path 
+00000bc0: 3d20 5061 7468 2870 6174 6829 0a20 2020  = Path(path).   
+00000bd0: 2069 6620 7061 7468 2e73 7566 6669 782e   if path.suffix.
+00000be0: 6c6f 7765 7228 2920 3d3d 2022 2e73 6870  lower() == ".shp
+00000bf0: 223a 0a20 2020 2020 2020 2072 6574 7572  ":.        retur
+00000c00: 6e20 5b70 6174 682e 7374 656d 5d0a 0a20  n [path.stem].. 
+00000c10: 2020 2064 6174 6173 6f75 7263 6520 3d20     datasource = 
+00000c20: 4e6f 6e65 0a20 2020 206c 6179 6572 7320  None.    layers 
+00000c30: 3d20 5b5d 0a20 2020 2074 7279 3a0a 2020  = [].    try:.  
+00000c40: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
+00000c50: 203d 2067 6461 6c2e 4f70 656e 4578 2873   = gdal.OpenEx(s
+00000c60: 7472 2870 6174 6829 290a 2020 2020 2020  tr(path)).      
+00000c70: 2020 6e62 5f6c 6179 6572 7320 3d20 6461    nb_layers = da
+00000c80: 7461 736f 7572 6365 2e47 6574 4c61 7965  tasource.GetLaye
+00000c90: 7243 6f75 6e74 2829 0a20 2020 2020 2020  rCount().       
+00000ca0: 2066 6f72 206c 6179 6572 5f69 6420 696e   for layer_id in
+00000cb0: 2072 616e 6765 286e 625f 6c61 7965 7273   range(nb_layers
+00000cc0: 293a 0a20 2020 2020 2020 2020 2020 2064  ):.            d
+00000cd0: 6174 6173 6f75 7263 655f 6c61 7965 7220  atasource_layer 
+00000ce0: 3d20 6461 7461 736f 7572 6365 2e47 6574  = datasource.Get
+00000cf0: 4c61 7965 7242 7949 6e64 6578 286c 6179  LayerByIndex(lay
+00000d00: 6572 5f69 6429 0a20 2020 2020 2020 2020  er_id).         
+00000d10: 2020 2069 6620 280a 2020 2020 2020 2020     if (.        
+00000d20: 2020 2020 2020 2020 6f6e 6c79 5f73 7061          only_spa
+00000d30: 7469 616c 5f6c 6179 6572 7320 6973 2046  tial_layers is F
+00000d40: 616c 7365 0a20 2020 2020 2020 2020 2020  alse.           
+00000d50: 2020 2020 206f 7220 6461 7461 736f 7572       or datasour
+00000d60: 6365 5f6c 6179 6572 2e47 6574 4765 6f6d  ce_layer.GetGeom
+00000d70: 6574 7279 436f 6c75 6d6e 2829 2021 3d20  etryColumn() != 
+00000d80: 2222 0a20 2020 2020 2020 2020 2020 2029  "".            )
+00000d90: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00000da0: 2020 6c61 7965 7273 2e61 7070 656e 6428    layers.append(
+00000db0: 6461 7461 736f 7572 6365 5f6c 6179 6572  datasource_layer
+00000dc0: 2e47 6574 4e61 6d65 2829 290a 2020 2020  .GetName()).    
+00000dd0: 6669 6e61 6c6c 793a 0a20 2020 2020 2020  finally:.       
+00000de0: 2069 6620 6461 7461 736f 7572 6365 2069   if datasource i
+00000df0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00000e00: 2020 2020 2020 2020 6465 6c20 6461 7461          del data
+00000e10: 736f 7572 6365 0a0a 2020 2020 7265 7475  source..    retu
+00000e20: 726e 206c 6179 6572 730a 0a0a 636c 6173  rn layers...clas
+00000e30: 7320 436f 6c75 6d6e 496e 666f 3a0a 2020  s ColumnInfo:.  
+00000e40: 2020 2222 220a 2020 2020 4120 6461 7461    """.    A data
+00000e50: 206f 626a 6563 7420 636f 6e74 6169 6e69   object containi
+00000e60: 6e67 206d 6574 612d 696e 666f 726d 6174  ng meta-informat
+00000e70: 696f 6e20 6162 6f75 7420 6120 636f 6c75  ion about a colu
+00000e80: 6d6e 2e0a 0a20 2020 2041 7474 7269 6275  mn...    Attribu
+00000e90: 7465 733a 0a20 2020 2020 2020 206e 616d  tes:.        nam
+00000ea0: 6520 2873 7472 293a 2074 6865 206e 616d  e (str): the nam
+00000eb0: 6520 6f66 2074 6865 2063 6f6c 756d 6e2e  e of the column.
+00000ec0: 0a20 2020 2020 2020 2067 6461 6c5f 7479  .        gdal_ty
+00000ed0: 7065 2028 7374 7229 3a20 7468 6520 7479  pe (str): the ty
+00000ee0: 7065 206f 6620 7468 6520 636f 6c75 6d6e  pe of the column
+00000ef0: 2061 6363 6f72 6469 6e67 2074 6f20 6764   according to gd
+00000f00: 616c 2e0a 2020 2020 2020 2020 7769 6474  al..        widt
+00000f10: 6820 2869 6e74 293a 2074 6865 2077 6964  h (int): the wid
+00000f20: 7468 206f 6620 7468 6520 636f 6c75 6d6e  th of the column
+00000f30: 2c20 6966 2073 7065 6369 6669 6564 2e0a  , if specified..
+00000f40: 2020 2020 2222 220a 0a20 2020 2064 6566      """..    def
+00000f50: 205f 5f69 6e69 745f 5f28 0a20 2020 2020   __init__(.     
+00000f60: 2020 2073 656c 662c 0a20 2020 2020 2020     self,.       
+00000f70: 206e 616d 653a 2073 7472 2c0a 2020 2020   name: str,.    
+00000f80: 2020 2020 6764 616c 5f74 7970 653a 2073      gdal_type: s
+00000f90: 7472 2c0a 2020 2020 2020 2020 7769 6474  tr,.        widt
+00000fa0: 683a 204f 7074 696f 6e61 6c5b 696e 745d  h: Optional[int]
+00000fb0: 2c0a 2020 2020 2020 2020 7072 6563 6973  ,.        precis
+00000fc0: 696f 6e3a 204f 7074 696f 6e61 6c5b 696e  ion: Optional[in
+00000fd0: 745d 2c0a 2020 2020 293a 0a20 2020 2020  t],.    ):.     
+00000fe0: 2020 2073 656c 662e 6e61 6d65 203d 206e     self.name = n
+00000ff0: 616d 650a 2020 2020 2020 2020 7365 6c66  ame.        self
+00001000: 2e67 6461 6c5f 7479 7065 203d 2067 6461  .gdal_type = gda
+00001010: 6c5f 7479 7065 0a20 2020 2020 2020 2073  l_type.        s
+00001020: 656c 662e 7769 6474 6820 3d20 7769 6474  elf.width = widt
+00001030: 680a 2020 2020 2020 2020 7365 6c66 2e70  h.        self.p
+00001040: 7265 6369 7369 6f6e 203d 2070 7265 6369  recision = preci
+00001050: 7369 6f6e 0a0a 2020 2020 6465 6620 5f5f  sion..    def __
+00001060: 7265 7072 5f5f 2873 656c 6629 3a0a 2020  repr__(self):.  
+00001070: 2020 2020 2020 7265 7475 726e 2066 227b        return f"{
+00001080: 7365 6c66 2e5f 5f63 6c61 7373 5f5f 7d28  self.__class__}(
+00001090: 7b73 656c 662e 5f5f 6469 6374 5f5f 7d29  {self.__dict__})
+000010a0: 220a 0a0a 636c 6173 7320 4c61 7965 7249  "...class LayerI
+000010b0: 6e66 6f3a 0a20 2020 2022 2222 0a20 2020  nfo:.    """.   
+000010c0: 2041 2064 6174 6120 6f62 6a65 6374 2063   A data object c
+000010d0: 6f6e 7461 696e 696e 6720 6d65 7461 2d69  ontaining meta-i
+000010e0: 6e66 6f72 6d61 7469 6f6e 2061 626f 7574  nformation about
+000010f0: 2061 206c 6179 6572 2e0a 0a20 2020 2041   a layer...    A
+00001100: 7474 7269 6275 7465 733a 0a20 2020 2020  ttributes:.     
+00001110: 2020 206e 616d 6520 2873 7472 293a 2074     name (str): t
+00001120: 6865 206e 616d 6520 6f66 2074 6865 206c  he name of the l
+00001130: 6179 6572 2e0a 2020 2020 2020 2020 6665  ayer..        fe
+00001140: 6174 7572 6563 6f75 6e74 2028 696e 7429  aturecount (int)
+00001150: 3a20 7468 6520 6e75 6d62 6572 206f 6620  : the number of 
+00001160: 6665 6174 7572 6573 2028 726f 7773 2920  features (rows) 
+00001170: 696e 2074 6865 206c 6179 6572 2e0a 2020  in the layer..  
+00001180: 2020 2020 2020 746f 7461 6c5f 626f 756e        total_boun
+00001190: 6473 2028 5475 706c 655b 666c 6f61 742c  ds (Tuple[float,
+000011a0: 2066 6c6f 6174 2c20 666c 6f61 742c 2066   float, float, f
+000011b0: 6c6f 6174 5d29 3a20 7468 6520 626f 756e  loat]): the boun
+000011c0: 6469 6e67 2062 6f78 206f 660a 2020 2020  ding box of.    
+000011d0: 2020 2020 2020 2020 7468 6520 6c61 7965          the laye
+000011e0: 722e 0a20 2020 2020 2020 2067 656f 6d65  r..        geome
+000011f0: 7472 7963 6f6c 756d 6e20 2873 7472 293a  trycolumn (str):
+00001200: 206e 616d 6520 6f66 2074 6865 2063 6f6c   name of the col
+00001210: 756d 6e20 7468 6174 2063 6f6e 7461 696e  umn that contain
+00001220: 7320 7468 650a 2020 2020 2020 2020 2020  s the.          
+00001230: 2020 7072 696d 6172 7920 6765 6f6d 6574    primary geomet
+00001240: 7279 2e0a 2020 2020 2020 2020 6765 6f6d  ry..        geom
+00001250: 6574 7279 7479 7065 6e61 6d65 2028 7374  etrytypename (st
+00001260: 7229 3a20 7468 6520 6765 6f6d 6574 7279  r): the geometry
+00001270: 2074 7970 6520 6e61 6d65 206f 6620 7468   type name of th
+00001280: 6520 6765 6f6d 6574 7279 636f 6c75 6d6e  e geometrycolumn
+00001290: 2e0a 2020 2020 2020 2020 2020 2020 5468  ..            Th
+000012a0: 6520 7479 7065 206e 616d 6520 7265 7475  e type name retu
+000012b0: 726e 6564 2069 7320 6f6e 6520 6f66 2074  rned is one of t
+000012c0: 6865 2066 6f6c 6c6f 7769 6e67 3a20 504f  he following: PO
+000012d0: 494e 542c 204d 554c 5449 504f 494e 542c  INT, MULTIPOINT,
+000012e0: 0a20 2020 2020 2020 2020 2020 204c 494e  .            LIN
+000012f0: 4553 5452 494e 472c 204d 554c 5449 4c49  ESTRING, MULTILI
+00001300: 4e45 5354 5249 4e47 2c20 504f 4c59 474f  NESTRING, POLYGO
+00001310: 4e2c 204d 554c 5449 504f 4c59 474f 4e2c  N, MULTIPOLYGON,
+00001320: 2043 4f4c 4c45 4354 494f 4e2e 0a20 2020   COLLECTION..   
+00001330: 2020 2020 2067 656f 6d65 7472 7974 7970       geometrytyp
+00001340: 6520 2847 656f 6d65 7472 7954 7970 6529  e (GeometryType)
+00001350: 3a20 7468 6520 6765 6f6d 6574 7279 2074  : the geometry t
+00001360: 7970 6520 6f66 2074 6865 2067 656f 6d65  ype of the geome
+00001370: 7472 7963 6f6c 756d 6e2e 0a20 2020 2020  trycolumn..     
+00001380: 2020 2063 6f6c 756d 6e73 2028 6469 6374     columns (dict
+00001390: 293a 2074 6865 2063 6f6c 756d 6e73 2028  ): the columns (
+000013a0: 6f74 6865 7220 7468 616e 2074 6865 2067  other than the g
+000013b0: 656f 6d65 7472 7920 636f 6c75 6d6e 2920  eometry column) 
+000013c0: 7468 6174 0a20 2020 2020 2020 2020 2020  that.           
+000013d0: 2061 7265 2061 7661 696c 6162 6c65 206f   are available o
+000013e0: 6e20 7468 6520 6c61 7965 7220 7769 7468  n the layer with
+000013f0: 2074 6865 6972 2070 726f 7065 7274 6965   their propertie
+00001400: 7320 6173 2061 2064 6963 742e 0a20 2020  s as a dict..   
+00001410: 2020 2020 2066 6964 5f63 6f6c 756d 6e20       fid_column 
+00001420: 2873 7472 293a 2063 6f6c 756d 6e20 6e61  (str): column na
+00001430: 6d65 206f 6620 7468 6520 4649 4420 636f  me of the FID co
+00001440: 6c75 6d6e 2e20 4973 2022 2220 666f 7220  lumn. Is "" for 
+00001450: 6669 6c65 2074 7970 6573 2074 6861 7420  file types that 
+00001460: 646f 6e27 740a 2020 2020 2020 2020 2020  don't.          
+00001470: 2020 6578 706c 6963 6974 6c79 2073 746f    explicitly sto
+00001480: 7265 2061 6e20 4649 442c 206c 696b 6520  re an FID, like 
+00001490: 7368 6170 6566 696c 652e 0a20 2020 2020  shapefile..     
+000014a0: 2020 2063 7273 2028 7079 7072 6f6a 2e43     crs (pyproj.C
+000014b0: 5253 293a 2074 6865 2073 7061 7469 616c  RS): the spatial
+000014c0: 2072 6566 6572 656e 6365 206f 6620 7468   reference of th
+000014d0: 6520 6c61 7965 722e 0a20 2020 2020 2020  e layer..       
+000014e0: 2065 7272 6f72 7320 284c 6973 745b 7374   errors (List[st
+000014f0: 725d 293a 206c 6973 7420 6f66 2065 7272  r]): list of err
+00001500: 6f72 7320 696e 2074 6865 206c 6179 6572  ors in the layer
+00001510: 2c20 6567 2e20 696e 7661 6c69 6420 636f  , eg. invalid co
+00001520: 6c75 6d6e 0a20 2020 2020 2020 2020 2020  lumn.           
+00001530: 206e 616d 6573 2c2e 2e2e 0a20 2020 2022   names,....    "
+00001540: 2222 0a0a 2020 2020 6465 6620 5f5f 696e  ""..    def __in
+00001550: 6974 5f5f 280a 2020 2020 2020 2020 7365  it__(.        se
+00001560: 6c66 2c0a 2020 2020 2020 2020 6e61 6d65  lf,.        name
+00001570: 3a20 7374 722c 0a20 2020 2020 2020 2066  : str,.        f
+00001580: 6561 7475 7265 636f 756e 743a 2069 6e74  eaturecount: int
+00001590: 2c0a 2020 2020 2020 2020 746f 7461 6c5f  ,.        total_
+000015a0: 626f 756e 6473 3a20 5475 706c 655b 666c  bounds: Tuple[fl
+000015b0: 6f61 742c 2066 6c6f 6174 2c20 666c 6f61  oat, float, floa
+000015c0: 742c 2066 6c6f 6174 5d2c 0a20 2020 2020  t, float],.     
+000015d0: 2020 2067 656f 6d65 7472 7963 6f6c 756d     geometrycolum
+000015e0: 6e3a 2073 7472 2c0a 2020 2020 2020 2020  n: str,.        
+000015f0: 6765 6f6d 6574 7279 7479 7065 6e61 6d65  geometrytypename
+00001600: 3a20 7374 722c 0a20 2020 2020 2020 2067  : str,.        g
+00001610: 656f 6d65 7472 7974 7970 653a 2047 656f  eometrytype: Geo
+00001620: 6d65 7472 7954 7970 652c 0a20 2020 2020  metryType,.     
+00001630: 2020 2063 6f6c 756d 6e73 3a20 4469 6374     columns: Dict
+00001640: 5b73 7472 2c20 436f 6c75 6d6e 496e 666f  [str, ColumnInfo
+00001650: 5d2c 0a20 2020 2020 2020 2066 6964 5f63  ],.        fid_c
+00001660: 6f6c 756d 6e3a 2073 7472 2c0a 2020 2020  olumn: str,.    
+00001670: 2020 2020 6372 733a 204f 7074 696f 6e61      crs: Optiona
+00001680: 6c5b 7079 7072 6f6a 2e43 5253 5d2c 0a20  l[pyproj.CRS],. 
+00001690: 2020 2020 2020 2065 7272 6f72 733a 204c         errors: L
+000016a0: 6973 745b 7374 725d 2c0a 2020 2020 293a  ist[str],.    ):
+000016b0: 0a20 2020 2020 2020 2073 656c 662e 6e61  .        self.na
+000016c0: 6d65 203d 206e 616d 650a 2020 2020 2020  me = name.      
+000016d0: 2020 7365 6c66 2e66 6561 7475 7265 636f    self.featureco
+000016e0: 756e 7420 3d20 6665 6174 7572 6563 6f75  unt = featurecou
+000016f0: 6e74 0a20 2020 2020 2020 2073 656c 662e  nt.        self.
+00001700: 746f 7461 6c5f 626f 756e 6473 203d 2074  total_bounds = t
+00001710: 6f74 616c 5f62 6f75 6e64 730a 2020 2020  otal_bounds.    
+00001720: 2020 2020 7365 6c66 2e67 656f 6d65 7472      self.geometr
+00001730: 7963 6f6c 756d 6e20 3d20 6765 6f6d 6574  ycolumn = geomet
+00001740: 7279 636f 6c75 6d6e 0a20 2020 2020 2020  rycolumn.       
+00001750: 2073 656c 662e 6765 6f6d 6574 7279 7479   self.geometryty
+00001760: 7065 6e61 6d65 203d 2067 656f 6d65 7472  pename = geometr
+00001770: 7974 7970 656e 616d 650a 2020 2020 2020  ytypename.      
+00001780: 2020 7365 6c66 2e67 656f 6d65 7472 7974    self.geometryt
+00001790: 7970 6520 3d20 6765 6f6d 6574 7279 7479  ype = geometryty
+000017a0: 7065 0a20 2020 2020 2020 2073 656c 662e  pe.        self.
+000017b0: 636f 6c75 6d6e 7320 3d20 636f 6c75 6d6e  columns = column
+000017c0: 730a 2020 2020 2020 2020 7365 6c66 2e66  s.        self.f
+000017d0: 6964 5f63 6f6c 756d 6e20 3d20 6669 645f  id_column = fid_
+000017e0: 636f 6c75 6d6e 0a20 2020 2020 2020 2073  column.        s
+000017f0: 656c 662e 6372 7320 3d20 6372 730a 2020  elf.crs = crs.  
+00001800: 2020 2020 2020 7365 6c66 2e65 7272 6f72        self.error
+00001810: 7320 3d20 6572 726f 7273 0a0a 2020 2020  s = errors..    
+00001820: 6465 6620 5f5f 7265 7072 5f5f 2873 656c  def __repr__(sel
+00001830: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+00001840: 726e 2066 227b 7365 6c66 2e5f 5f63 6c61  rn f"{self.__cla
+00001850: 7373 5f5f 7d28 7b73 656c 662e 5f5f 6469  ss__}({self.__di
+00001860: 6374 5f5f 7d29 220a 0a0a 6465 6620 6765  ct__})"...def ge
+00001870: 745f 6c61 7965 725f 6765 6f6d 6574 7279  t_layer_geometry
+00001880: 7479 7065 7328 0a20 2020 2070 6174 683a  types(.    path:
+00001890: 2055 6e69 6f6e 5b73 7472 2c20 226f 732e   Union[str, "os.
+000018a0: 5061 7468 4c69 6b65 5b41 6e79 5d22 5d2c  PathLike[Any]"],
+000018b0: 206c 6179 6572 3a20 4f70 7469 6f6e 616c   layer: Optional
+000018c0: 5b73 7472 5d20 3d20 4e6f 6e65 0a29 202d  [str] = None.) -
+000018d0: 3e20 4c69 7374 5b73 7472 5d3a 0a20 2020  > List[str]:.   
+000018e0: 2022 2222 0a20 2020 2047 6574 2074 6865   """.    Get the
+000018f0: 2067 656f 6d65 7472 7920 7479 7065 7320   geometry types 
+00001900: 696e 2074 6865 206c 6179 6572 2062 7920  in the layer by 
+00001910: 6578 616d 696e 696e 6720 6561 6368 2067  examining each g
+00001920: 656f 6d65 7472 7920 696e 2074 6865 206c  eometry in the l
+00001930: 6179 6572 2e0a 0a20 2020 2054 6865 2067  ayer...    The g
+00001940: 656e 6572 616c 2067 656f 6d65 7472 7920  eneral geometry 
+00001950: 7479 7065 206f 6620 7468 6520 6c61 7965  type of the laye
+00001960: 7220 6361 6e20 6265 2064 6574 6572 6d69  r can be determi
+00001970: 6e65 6420 7573 696e 670a 2020 2020 3a6d  ned using.    :m
+00001980: 6574 683a 607e 6765 745f 6c61 7965 7269  eth:`~get_layeri
+00001990: 6e66 6f60 2e0a 0a20 2020 2041 7267 733a  nfo`...    Args:
+000019a0: 0a20 2020 2020 2020 2070 6174 6820 2850  .        path (P
+000019b0: 6174 684c 696b 6529 3a20 7061 7468 2074  athLike): path t
+000019c0: 6f20 7468 6520 6669 6c65 2074 6f20 6765  o the file to ge
+000019d0: 7420 696e 666f 2061 626f 7574 0a20 2020  t info about.   
+000019e0: 2020 2020 206c 6179 6572 2028 7374 7229       layer (str)
+000019f0: 3a20 7468 6520 6c61 7965 7220 796f 7520  : the layer you 
+00001a00: 7761 6e74 2069 6e66 6f20 6162 6f75 742e  want info about.
+00001a10: 2044 6f65 736e 2774 206e 6565 6420 746f   Doesn't need to
+00001a20: 2062 650a 2020 2020 2020 2020 2020 2020   be.            
+00001a30: 7370 6563 6966 6965 6420 6966 2074 6865  specified if the
+00001a40: 7265 2069 7320 6f6e 6c79 206f 6e65 206c  re is only one l
+00001a50: 6179 6572 2069 6e20 7468 6520 6765 6f66  ayer in the geof
+00001a60: 696c 652e 0a0a 2020 2020 5265 7475 726e  ile...    Return
+00001a70: 733a 0a20 2020 2020 2020 204c 6973 745b  s:.        List[
+00001a80: 7374 725d 3a20 7468 6520 6765 6f6d 6574  str]: the geomet
+00001a90: 7279 2074 7970 6573 2069 6e20 7468 6520  ry types in the 
+00001aa0: 6c61 7965 722e 0a20 2020 2022 2222 0a20  layer..    """. 
+00001ab0: 2020 2073 716c 5f73 746d 7420 3d20 2222     sql_stmt = ""
+00001ac0: 220a 2020 2020 2020 2020 5345 4c45 4354  ".        SELECT
+00001ad0: 2044 4953 5449 4e43 540a 2020 2020 2020   DISTINCT.      
+00001ae0: 2020 2020 2020 2020 2043 4153 450a 2020           CASE.  
+00001af0: 2020 2020 2020 2020 2020 2020 2020 2057                 W
+00001b00: 4845 4e20 4361 7374 546f 5369 6e67 6c65  HEN CastToSingle
+00001b10: 287b 6765 6f6d 6574 7279 636f 6c75 6d6e  ({geometrycolumn
+00001b20: 7d29 2049 5320 4e4f 5420 4e55 4c4c 2054  }) IS NOT NULL T
+00001b30: 4845 4e0a 2020 2020 2020 2020 2020 2020  HEN.            
+00001b40: 2020 2020 2020 2020 2053 545f 4765 6f6d           ST_Geom
+00001b50: 6574 7279 5479 7065 2843 6173 7454 6f53  etryType(CastToS
+00001b60: 696e 676c 6528 7b67 656f 6d65 7472 7963  ingle({geometryc
+00001b70: 6f6c 756d 6e7d 2929 0a20 2020 2020 2020  olumn})).       
+00001b80: 2020 2020 2020 2020 2020 454c 5345 2053            ELSE S
+00001b90: 545f 4765 6f6d 6574 7279 5479 7065 287b  T_GeometryType({
+00001ba0: 6765 6f6d 6574 7279 636f 6c75 6d6e 7d29  geometrycolumn})
+00001bb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001bc0: 454e 4420 4153 2067 656f 6d5f 7479 7065  END AS geom_type
+00001bd0: 0a20 2020 2020 2020 2020 2046 524f 4d20  .          FROM 
+00001be0: 227b 696e 7075 745f 6c61 7965 727d 2220  "{input_layer}" 
+00001bf0: 6c61 7965 720a 2020 2020 2222 220a 2020  layer.    """.  
+00001c00: 2020 7265 7375 6c74 5f64 6620 3d20 7265    result_df = re
+00001c10: 6164 5f66 696c 6528 7061 7468 2c20 7371  ad_file(path, sq
+00001c20: 6c5f 7374 6d74 3d73 716c 5f73 746d 742c  l_stmt=sql_stmt,
+00001c30: 2073 716c 5f64 6961 6c65 6374 3d22 5351   sql_dialect="SQ
+00001c40: 4c49 5445 2229 0a20 2020 2072 6574 7572  LITE").    retur
+00001c50: 6e20 7265 7375 6c74 5f64 665b 2267 656f  n result_df["geo
+00001c60: 6d5f 7479 7065 225d 2e74 6f5f 6c69 7374  m_type"].to_list
+00001c70: 2829 2020 2320 7479 7065 3a20 6967 6e6f  ()  # type: igno
+00001c80: 7265 0a0a 0a64 6566 2067 6574 5f6c 6179  re...def get_lay
+00001c90: 6572 696e 666f 280a 2020 2020 7061 7468  erinfo(.    path
+00001ca0: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
+00001cb0: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
+00001cc0: 2c20 6c61 7965 723a 204f 7074 696f 6e61  , layer: Optiona
+00001cd0: 6c5b 7374 725d 203d 204e 6f6e 650a 2920  l[str] = None.) 
+00001ce0: 2d3e 204c 6179 6572 496e 666f 3a0a 2020  -> LayerInfo:.  
+00001cf0: 2020 2222 220a 2020 2020 4765 7420 696e    """.    Get in
+00001d00: 666f 726d 6174 696f 6e20 6162 6f75 7420  formation about 
+00001d10: 6120 6c61 7965 7220 696e 2074 6865 2067  a layer in the g
+00001d20: 656f 6669 6c65 2e0a 0a20 2020 2052 6169  eofile...    Rai
+00001d30: 7365 7320 616e 2065 7863 6570 7469 6f6e  ses an exception
+00001d40: 2069 6620 7468 6520 6c61 7965 7220 6465   if the layer de
+00001d50: 6669 6e69 7469 6f6e 2068 6173 2065 7272  finition has err
+00001d60: 6f72 7320 6c69 6b65 2069 6e76 616c 6964  ors like invalid
+00001d70: 2063 6f6c 756d 6e0a 2020 2020 6e61 6d65   column.    name
+00001d80: 732c 2e2e 2e0a 0a20 2020 2041 7267 733a  s,.....    Args:
+00001d90: 0a20 2020 2020 2020 2070 6174 6820 2850  .        path (P
+00001da0: 6174 684c 696b 6529 3a20 7061 7468 2074  athLike): path t
+00001db0: 6f20 7468 6520 6669 6c65 2074 6f20 6765  o the file to ge
+00001dc0: 7420 696e 666f 2061 626f 7574 0a20 2020  t info about.   
+00001dd0: 2020 2020 206c 6179 6572 2028 7374 7229       layer (str)
+00001de0: 3a20 7468 6520 6c61 7965 7220 796f 7520  : the layer you 
+00001df0: 7761 6e74 2069 6e66 6f20 6162 6f75 742e  want info about.
+00001e00: 2044 6f65 736e 2774 206e 6565 6420 746f   Doesn't need to
+00001e10: 2062 650a 2020 2020 2020 2020 2020 2020   be.            
+00001e20: 7370 6563 6966 6965 6420 6966 2074 6865  specified if the
+00001e30: 7265 2069 7320 6f6e 6c79 206f 6e65 206c  re is only one l
+00001e40: 6179 6572 2069 6e20 7468 6520 6765 6f66  ayer in the geof
+00001e50: 696c 652e 0a0a 2020 2020 5265 7475 726e  ile...    Return
+00001e60: 733a 0a20 2020 2020 2020 204c 6179 6572  s:.        Layer
+00001e70: 496e 666f 3a20 7468 6520 696e 666f 726d  Info: the inform
+00001e80: 6174 696f 6e20 6162 6f75 7420 7468 6520  ation about the 
+00001e90: 6c61 7965 722e 0a20 2020 2022 2222 0a20  layer..    """. 
+00001ea0: 2020 2023 2049 6e69 740a 2020 2020 7061     # Init.    pa
+00001eb0: 7468 203d 2050 6174 6828 7061 7468 290a  th = Path(path).
+00001ec0: 2020 2020 6966 206e 6f74 2070 6174 682e      if not path.
+00001ed0: 6578 6973 7473 2829 3a0a 2020 2020 2020  exists():.      
+00001ee0: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+00001ef0: 6f72 2866 2269 6e70 7574 5f70 6174 6820  or(f"input_path 
+00001f00: 646f 6573 6e27 7420 6578 6973 743a 207b  doesn't exist: {
+00001f10: 7061 7468 7d22 290a 0a20 2020 2069 6620  path}")..    if 
+00001f20: 6c61 7965 7220 6973 204e 6f6e 653a 0a20  layer is None:. 
+00001f30: 2020 2020 2020 206c 6179 6572 203d 2067         layer = g
+00001f40: 6574 5f6f 6e6c 795f 6c61 7965 7228 7061  et_only_layer(pa
+00001f50: 7468 290a 0a20 2020 2064 6174 6173 6f75  th)..    datasou
+00001f60: 7263 6520 3d20 4e6f 6e65 0a20 2020 2074  rce = None.    t
+00001f70: 7279 3a0a 2020 2020 2020 2020 6461 7461  ry:.        data
+00001f80: 736f 7572 6365 203d 2067 6461 6c2e 4f70  source = gdal.Op
+00001f90: 656e 4578 2873 7472 2870 6174 6829 290a  enEx(str(path)).
+00001fa0: 2020 2020 2020 2020 6461 7461 736f 7572          datasour
+00001fb0: 6365 5f6c 6179 6572 203d 2064 6174 6173  ce_layer = datas
+00001fc0: 6f75 7263 652e 4765 744c 6179 6572 286c  ource.GetLayer(l
+00001fd0: 6179 6572 290a 0a20 2020 2020 2020 2023  ayer)..        #
+00001fe0: 2049 6620 7468 6520 6c61 7965 7220 646f   If the layer do
+00001ff0: 6573 6e27 7420 6578 6973 742c 2072 6574  esn't exist, ret
+00002000: 7572 6e0a 2020 2020 2020 2020 6966 2064  urn.        if d
+00002010: 6174 6173 6f75 7263 655f 6c61 7965 7220  atasource_layer 
+00002020: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+00002030: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00002040: 4572 726f 7228 6622 4c61 7965 7220 7b6c  Error(f"Layer {l
+00002050: 6179 6572 7d20 6e6f 7420 666f 756e 6420  ayer} not found 
+00002060: 696e 2066 696c 653a 207b 7061 7468 7d22  in file: {path}"
+00002070: 290a 0a20 2020 2020 2020 2023 2047 6574  )..        # Get
+00002080: 2063 6f6c 756d 6e20 696e 666f 0a20 2020   column info.   
+00002090: 2020 2020 2063 6f6c 756d 6e73 203d 207b       columns = {
+000020a0: 7d0a 2020 2020 2020 2020 6572 726f 7273  }.        errors
+000020b0: 203d 205b 5d0a 2020 2020 2020 2020 6765   = [].        ge
+000020c0: 6f66 696c 6574 7970 6520 3d20 4765 6f66  ofiletype = Geof
+000020d0: 696c 6554 7970 6528 7061 7468 290a 2020  ileType(path).  
+000020e0: 2020 2020 2020 6c61 7965 725f 6465 666e        layer_defn
+000020f0: 203d 2064 6174 6173 6f75 7263 655f 6c61   = datasource_la
+00002100: 7965 722e 4765 744c 6179 6572 4465 666e  yer.GetLayerDefn
+00002110: 2829 0a20 2020 2020 2020 2066 6f72 2069  ().        for i
+00002120: 2069 6e20 7261 6e67 6528 6c61 7965 725f   in range(layer_
+00002130: 6465 666e 2e47 6574 4669 656c 6443 6f75  defn.GetFieldCou
+00002140: 6e74 2829 293a 0a20 2020 2020 2020 2020  nt()):.         
+00002150: 2020 206e 616d 6520 3d20 6c61 7965 725f     name = layer_
+00002160: 6465 666e 2e47 6574 4669 656c 6444 6566  defn.GetFieldDef
+00002170: 6e28 6929 2e47 6574 4e61 6d65 2829 0a20  n(i).GetName(). 
+00002180: 2020 2020 2020 2020 2020 2023 2054 4f44             # TOD
+00002190: 4f3a 2074 6869 6e6b 2077 6865 7468 6572  O: think whether
+000021a0: 2074 6865 2074 7970 6520 6e61 6d65 2073   the type name s
+000021b0: 686f 756c 6420 6265 2063 6f6e 7665 7274  hould be convert
+000021c0: 6564 2074 6f20 6f74 6865 7220 6e61 6d65  ed to other name
+000021d0: 730a 2020 2020 2020 2020 2020 2020 6764  s.            gd
+000021e0: 616c 5f74 7970 6520 3d20 6c61 7965 725f  al_type = layer_
+000021f0: 6465 666e 2e47 6574 4669 656c 6444 6566  defn.GetFieldDef
+00002200: 6e28 6929 2e47 6574 5479 7065 4e61 6d65  n(i).GetTypeName
+00002210: 2829 0a20 2020 2020 2020 2020 2020 2077  ().            w
+00002220: 6964 7468 203d 206c 6179 6572 5f64 6566  idth = layer_def
+00002230: 6e2e 4765 7446 6965 6c64 4465 666e 2869  n.GetFieldDefn(i
+00002240: 292e 4765 7457 6964 7468 2829 0a20 2020  ).GetWidth().   
+00002250: 2020 2020 2020 2020 2077 6964 7468 203d           width =
+00002260: 2077 6964 7468 2069 6620 7769 6474 6820   width if width 
+00002270: 3e20 3020 656c 7365 204e 6f6e 650a 2020  > 0 else None.  
+00002280: 2020 2020 2020 2020 2020 7072 6563 6973            precis
+00002290: 696f 6e20 3d20 6c61 7965 725f 6465 666e  ion = layer_defn
+000022a0: 2e47 6574 4669 656c 6444 6566 6e28 6929  .GetFieldDefn(i)
+000022b0: 2e47 6574 5072 6563 6973 696f 6e28 290a  .GetPrecision().
+000022c0: 2020 2020 2020 2020 2020 2020 7072 6563              prec
+000022d0: 6973 696f 6e20 3d20 7072 6563 6973 696f  ision = precisio
+000022e0: 6e20 6966 2070 7265 6369 7369 6f6e 203e  n if precision >
+000022f0: 2030 2065 6c73 6520 4e6f 6e65 0a20 2020   0 else None.   
+00002300: 2020 2020 2020 2020 2069 6c6c 6567 616c           illegal
+00002310: 5f63 6f6c 756d 6e5f 6368 6172 7320 3d20  _column_chars = 
+00002320: 5b27 2227 5d0a 2020 2020 2020 2020 2020  ['"'].          
+00002330: 2020 666f 7220 696c 6c65 6761 6c5f 6368    for illegal_ch
+00002340: 6172 2069 6e20 696c 6c65 6761 6c5f 636f  ar in illegal_co
+00002350: 6c75 6d6e 5f63 6861 7273 3a0a 2020 2020  lumn_chars:.    
+00002360: 2020 2020 2020 2020 2020 2020 6966 2069              if i
+00002370: 6c6c 6567 616c 5f63 6861 7220 696e 206e  llegal_char in n
+00002380: 616d 653a 0a20 2020 2020 2020 2020 2020  ame:.           
+00002390: 2020 2020 2020 2020 2065 7272 6f72 732e           errors.
+000023a0: 6170 7065 6e64 280a 2020 2020 2020 2020  append(.        
+000023b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000023c0: 6622 436f 6c75 6d6e 206e 616d 6520 7b6e  f"Column name {n
+000023d0: 616d 657d 2063 6f6e 7461 696e 7320 696c  ame} contains il
+000023e0: 6c65 6761 6c20 6368 6172 3a20 7b69 6c6c  legal char: {ill
+000023f0: 6567 616c 5f63 6861 727d 2022 0a20 2020  egal_char} ".   
+00002400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002410: 2020 2020 2066 2269 6e20 6669 6c65 207b       f"in file {
+00002420: 7061 7468 7d2c 206c 6179 6572 207b 6c61  path}, layer {la
+00002430: 7965 727d 220a 2020 2020 2020 2020 2020  yer}".          
+00002440: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00002450: 2020 2020 2020 2020 636f 6c75 6d6e 5f69          column_i
+00002460: 6e66 6f20 3d20 436f 6c75 6d6e 496e 666f  nfo = ColumnInfo
+00002470: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00002480: 2020 6e61 6d65 3d6e 616d 652c 2067 6461    name=name, gda
+00002490: 6c5f 7479 7065 3d67 6461 6c5f 7479 7065  l_type=gdal_type
+000024a0: 2c20 7769 6474 683d 7769 6474 682c 2070  , width=width, p
+000024b0: 7265 6369 7369 6f6e 3d70 7265 6369 7369  recision=precisi
+000024c0: 6f6e 0a20 2020 2020 2020 2020 2020 2029  on.            )
+000024d0: 0a20 2020 2020 2020 2020 2020 2063 6f6c  .            col
+000024e0: 756d 6e73 5b6e 616d 655d 203d 2063 6f6c  umns[name] = col
+000024f0: 756d 6e5f 696e 666f 0a20 2020 2020 2020  umn_info.       
+00002500: 2020 2020 2069 6620 6765 6f66 696c 6574       if geofilet
+00002510: 7970 6520 3d3d 2047 656f 6669 6c65 5479  ype == GeofileTy
+00002520: 7065 2e45 5352 4953 6861 7065 6669 6c65  pe.ESRIShapefile
+00002530: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00002540: 2020 6966 206e 616d 652e 6361 7365 666f    if name.casefo
+00002550: 6c64 2829 203d 3d20 2267 656f 6d65 7472  ld() == "geometr
+00002560: 7922 3a0a 2020 2020 2020 2020 2020 2020  y":.            
+00002570: 2020 2020 2020 2020 6572 726f 7273 2e61          errors.a
+00002580: 7070 656e 6428 0a20 2020 2020 2020 2020  ppend(.         
+00002590: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+000025a0: 416e 2061 7474 7269 6275 7465 2063 6f6c  An attribute col
+000025b0: 756d 6e20 2767 656f 6d65 7472 7927 2069  umn 'geometry' i
+000025c0: 7320 6e6f 7420 7375 7070 6f72 7465 6420  s not supported 
+000025d0: 696e 2061 2073 6861 7065 6669 6c65 220a  in a shapefile".
+000025e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000025f0: 2020 2020 290a 0a20 2020 2020 2020 2023      )..        #
+00002600: 2047 6574 2067 656f 6d65 7472 7920 636f   Get geometry co
+00002610: 6c75 6d6e 2069 6e66 6f2e 2e2e 0a20 2020  lumn info....   
+00002620: 2020 2020 2067 656f 6d65 7472 7974 7970       geometrytyp
+00002630: 656e 616d 6520 3d20 6764 616c 2e6f 6772  ename = gdal.ogr
+00002640: 2e47 656f 6d65 7472 7954 7970 6554 6f4e  .GeometryTypeToN
+00002650: 616d 6528 6461 7461 736f 7572 6365 5f6c  ame(datasource_l
+00002660: 6179 6572 2e47 6574 4765 6f6d 5479 7065  ayer.GetGeomType
+00002670: 2829 290a 2020 2020 2020 2020 6765 6f6d  ()).        geom
+00002680: 6574 7279 7479 7065 6e61 6d65 203d 2067  etrytypename = g
+00002690: 656f 6d65 7472 7974 7970 656e 616d 652e  eometrytypename.
+000026a0: 7265 706c 6163 6528 2220 222c 2022 2229  replace(" ", "")
+000026b0: 2e75 7070 6572 2829 0a0a 2020 2020 2020  .upper()..      
+000026c0: 2020 2320 466f 7220 7368 6170 6520 6669    # For shape fi
+000026d0: 6c65 732c 2074 6865 2064 6966 6665 7265  les, the differe
+000026e0: 6e63 6520 6265 7477 6565 6e20 7468 6520  nce between the 
+000026f0: 274d 554c 5449 2720 7661 7269 616e 7420  'MULTI' variant 
+00002700: 616e 6420 7468 650a 2020 2020 2020 2020  and the.        
+00002710: 2320 7369 6e67 6c65 206f 6e65 2064 6f65  # single one doe
+00002720: 736e 2774 2065 7869 7374 732e 2e2e 2073  sn't exists... s
+00002730: 6f20 616c 7761 7973 2072 6570 6f72 7420  o always report 
+00002740: 4d55 4c54 4920 7661 7269 616e 7420 6279  MULTI variant by
+00002750: 2063 6f6e 7665 6e74 696f 6e2e 0a20 2020   convention..   
+00002760: 2020 2020 2069 6620 4765 6f66 696c 6554       if GeofileT
+00002770: 7970 6528 7061 7468 2920 3d3d 2047 656f  ype(path) == Geo
+00002780: 6669 6c65 5479 7065 2e45 5352 4953 6861  fileType.ESRISha
+00002790: 7065 6669 6c65 3a0a 2020 2020 2020 2020  pefile:.        
+000027a0: 2020 2020 6966 2028 0a20 2020 2020 2020      if (.       
+000027b0: 2020 2020 2020 2020 2067 656f 6d65 7472           geometr
+000027c0: 7974 7970 656e 616d 652e 7374 6172 7473  ytypename.starts
+000027d0: 7769 7468 2822 504f 4c59 474f 4e22 290a  with("POLYGON").
+000027e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000027f0: 6f72 2067 656f 6d65 7472 7974 7970 656e  or geometrytypen
+00002800: 616d 652e 7374 6172 7473 7769 7468 2822  ame.startswith("
+00002810: 4c49 4e45 5354 5249 4e47 2229 0a20 2020  LINESTRING").   
+00002820: 2020 2020 2020 2020 2020 2020 206f 7220               or 
+00002830: 6765 6f6d 6574 7279 7479 7065 6e61 6d65  geometrytypename
+00002840: 2e73 7461 7274 7377 6974 6828 2250 4f49  .startswith("POI
+00002850: 4e54 2229 0a20 2020 2020 2020 2020 2020  NT").           
+00002860: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
+00002870: 2020 2020 6765 6f6d 6574 7279 7479 7065      geometrytype
+00002880: 6e61 6d65 203d 2066 224d 554c 5449 7b67  name = f"MULTI{g
+00002890: 656f 6d65 7472 7974 7970 656e 616d 657d  eometrytypename}
+000028a0: 220a 2020 2020 2020 2020 6966 2067 656f  ".        if geo
+000028b0: 6d65 7472 7974 7970 656e 616d 6520 3d3d  metrytypename ==
+000028c0: 2022 554e 4b4e 4f57 4e28 414e 5929 223a   "UNKNOWN(ANY)":
+000028d0: 0a20 2020 2020 2020 2020 2020 2067 656f  .            geo
+000028e0: 6d65 7472 7974 7970 656e 616d 6520 3d20  metrytypename = 
+000028f0: 2247 454f 4d45 5452 5922 0a0a 2020 2020  "GEOMETRY"..    
+00002900: 2020 2020 2320 4765 6f6d 6574 7279 7479      # Geometryty
+00002910: 7065 0a20 2020 2020 2020 2069 6620 6765  pe.        if ge
+00002920: 6f6d 6574 7279 7479 7065 6e61 6d65 2021  ometrytypename !
+00002930: 3d20 224e 4f4e 4522 3a0a 2020 2020 2020  = "NONE":.      
+00002940: 2020 2020 2020 6765 6f6d 6574 7279 7479        geometryty
+00002950: 7065 203d 2047 656f 6d65 7472 7954 7970  pe = GeometryTyp
+00002960: 655b 6765 6f6d 6574 7279 7479 7065 6e61  e[geometrytypena
+00002970: 6d65 5d0a 2020 2020 2020 2020 656c 7365  me].        else
+00002980: 3a0a 2020 2020 2020 2020 2020 2020 6765  :.            ge
+00002990: 6f6d 6574 7279 7479 7065 203d 204e 6f6e  ometrytype = Non
+000029a0: 650a 0a20 2020 2020 2020 2023 2049 6620  e..        # If 
+000029b0: 7468 6520 6765 6f6d 6574 7279 2074 7970  the geometry typ
+000029c0: 6520 6973 206e 6f74 204e 6f6e 652c 2066  e is not None, f
+000029d0: 696c 6c20 6f75 7420 7468 6520 6578 7472  ill out the extr
+000029e0: 6120 7072 6f70 6572 7469 6573 0a20 2020  a properties.   
+000029f0: 2020 2020 2067 656f 6d65 7472 7963 6f6c       geometrycol
+00002a00: 756d 6e20 3d20 4e6f 6e65 0a20 2020 2020  umn = None.     
+00002a10: 2020 2065 7874 656e 7420 3d20 4e6f 6e65     extent = None
+00002a20: 0a20 2020 2020 2020 2063 7273 203d 204e  .        crs = N
+00002a30: 6f6e 650a 2020 2020 2020 2020 746f 7461  one.        tota
+00002a40: 6c5f 626f 756e 6473 203d 204e 6f6e 650a  l_bounds = None.
+00002a50: 2020 2020 2020 2020 6966 2067 656f 6d65          if geome
+00002a60: 7472 7974 7970 6520 6973 206e 6f74 204e  trytype is not N
+00002a70: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00002a80: 2023 2047 656f 6d65 7472 7920 636f 6c75   # Geometry colu
+00002a90: 6d6e 206e 616d 650a 2020 2020 2020 2020  mn name.        
+00002aa0: 2020 2020 6765 6f6d 6574 7279 636f 6c75      geometrycolu
+00002ab0: 6d6e 203d 2064 6174 6173 6f75 7263 655f  mn = datasource_
+00002ac0: 6c61 7965 722e 4765 7447 656f 6d65 7472  layer.GetGeometr
+00002ad0: 7943 6f6c 756d 6e28 290a 2020 2020 2020  yColumn().      
+00002ae0: 2020 2020 2020 6966 2067 656f 6d65 7472        if geometr
+00002af0: 7963 6f6c 756d 6e20 3d3d 2022 223a 0a20  ycolumn == "":. 
+00002b00: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+00002b10: 656f 6d65 7472 7963 6f6c 756d 6e20 3d20  eometrycolumn = 
+00002b20: 2267 656f 6d65 7472 7922 0a20 2020 2020  "geometry".     
+00002b30: 2020 2020 2020 2023 2043 6f6e 7665 7274         # Convert
+00002b40: 2065 7874 656e 7420 2878 6d69 6e2c 2078   extent (xmin, x
+00002b50: 6d61 782c 2079 6d69 6e2c 2079 6d61 7829  max, ymin, ymax)
+00002b60: 2074 6f20 626f 756e 6473 2028 786d 696e   to bounds (xmin
+00002b70: 2c20 796d 696e 2c20 786d 6178 2c20 796d  , ymin, xmax, ym
+00002b80: 6178 290a 2020 2020 2020 2020 2020 2020  ax).            
+00002b90: 6578 7465 6e74 203d 2064 6174 6173 6f75  extent = datasou
+00002ba0: 7263 655f 6c61 7965 722e 4765 7445 7874  rce_layer.GetExt
+00002bb0: 656e 7428 290a 2020 2020 2020 2020 2020  ent().          
+00002bc0: 2020 746f 7461 6c5f 626f 756e 6473 203d    total_bounds =
+00002bd0: 2028 6578 7465 6e74 5b30 5d2c 2065 7874   (extent[0], ext
+00002be0: 656e 745b 325d 2c20 6578 7465 6e74 5b31  ent[2], extent[1
+00002bf0: 5d2c 2065 7874 656e 745b 335d 290a 2020  ], extent[3]).  
+00002c00: 2020 2020 2020 2020 2020 2320 4352 530a            # CRS.
+00002c10: 2020 2020 2020 2020 2020 2020 7370 6174              spat
+00002c20: 6961 6c72 6566 203d 2064 6174 6173 6f75  ialref = datasou
+00002c30: 7263 655f 6c61 7965 722e 4765 7453 7061  rce_layer.GetSpa
+00002c40: 7469 616c 5265 6628 290a 2020 2020 2020  tialRef().      
+00002c50: 2020 2020 2020 6966 2073 7061 7469 616c        if spatial
+00002c60: 7265 6620 6973 206e 6f74 204e 6f6e 653a  ref is not None:
+00002c70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002c80: 2063 7273 203d 2070 7970 726f 6a2e 4352   crs = pyproj.CR
+00002c90: 5328 7370 6174 6961 6c72 6566 2e45 7870  S(spatialref.Exp
+00002ca0: 6f72 7454 6f57 6b74 2829 290a 0a20 2020  ortToWkt())..   
+00002cb0: 2020 2020 2020 2020 2020 2020 2023 2049               # I
+00002cc0: 6620 7370 6174 6961 6c20 7265 6620 6861  f spatial ref ha
+00002cd0: 7320 6e6f 2065 7073 672c 2074 7279 2074  s no epsg, try t
+00002ce0: 6f20 6669 6e64 2063 6f72 7265 7370 6f6e  o find correspon
+00002cf0: 6469 6e67 206f 6e65 0a20 2020 2020 2020  ding one.       
+00002d00: 2020 2020 2020 2020 2063 7273 5f65 7073           crs_eps
+00002d10: 6720 3d20 6372 732e 746f 5f65 7073 6728  g = crs.to_epsg(
+00002d20: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00002d30: 2020 6966 2063 7273 5f65 7073 6720 6973    if crs_epsg is
+00002d40: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00002d50: 2020 2020 2020 2020 2020 2069 6620 6372             if cr
+00002d60: 732e 6e61 6d65 2069 6e20 5b0a 2020 2020  s.name in [.    
+00002d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002d80: 2020 2020 2242 656c 6765 2031 3937 3220      "Belge 1972 
+00002d90: 2f20 4265 6c67 6961 6e20 4c61 6d62 6572  / Belgian Lamber
+00002da0: 7420 3732 222c 0a20 2020 2020 2020 2020  t 72",.         
+00002db0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+00002dc0: 4265 6c67 655f 3139 3732 5f42 656c 6769  Belge_1972_Belgi
+00002dd0: 616e 5f4c 616d 6265 7274 5f37 3222 2c0a  an_Lambert_72",.
+00002de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002df0: 2020 2020 2020 2020 2242 656c 6765 5f4c          "Belge_L
+00002e00: 616d 6265 7274 5f31 3937 3222 2c0a 2020  ambert_1972",.  
+00002e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002e20: 2020 2020 2020 2242 4437 3220 2f20 4265        "BD72 / Be
+00002e30: 6c67 6961 6e20 4c61 6d62 6572 7420 3732  lgian Lambert 72
+00002e40: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00002e50: 2020 2020 2020 205d 3a0a 2020 2020 2020         ]:.      
+00002e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002e70: 2020 2320 4265 6c67 6961 6e20 4c61 6d62    # Belgian Lamb
+00002e80: 6572 7420 696e 206e 616d 652c 2073 6f20  ert in name, so 
+00002e90: 6173 7375 6d65 2033 3133 3730 0a20 2020  assume 31370.   
+00002ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002eb0: 2020 2020 2063 7273 203d 2070 7970 726f       crs = pypro
+00002ec0: 6a2e 4352 532e 6672 6f6d 5f65 7073 6728  j.CRS.from_epsg(
+00002ed0: 3331 3337 3029 0a0a 2020 2020 2020 2020  31370)..        
+00002ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002ef0: 2320 4966 2073 6861 7065 6669 6c65 2c20  # If shapefile, 
+00002f00: 6164 6420 636f 7272 6563 7420 3331 3337  add correct 3137
+00002f10: 3020 2e70 726a 2066 696c 650a 2020 2020  0 .prj file.    
+00002f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002f30: 2020 2020 6966 2047 656f 6669 6c65 5479      if GeofileTy
+00002f40: 7065 2870 6174 6829 203d 3d20 4765 6f66  pe(path) == Geof
+00002f50: 696c 6554 7970 652e 4553 5249 5368 6170  ileType.ESRIShap
+00002f60: 6566 696c 653a 0a20 2020 2020 2020 2020  efile:.         
+00002f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002f80: 2020 2070 726a 5f70 6174 6820 3d20 7061     prj_path = pa
+00002f90: 7468 2e70 6172 656e 7420 2f20 6622 7b70  th.parent / f"{p
+00002fa0: 6174 682e 7374 656d 7d2e 7072 6a22 0a20  ath.stem}.prj". 
+00002fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002fc0: 2020 2020 2020 2020 2020 2069 6620 7072             if pr
+00002fd0: 6a5f 7061 7468 2e65 7869 7374 7328 293a  j_path.exists():
+00002fe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003000: 2070 726a 5f72 656e 616d 655f 7061 7468   prj_rename_path
+00003010: 203d 2070 6174 682e 7061 7265 6e74 202f   = path.parent /
+00003020: 2066 227b 7061 7468 2e73 7465 6d7d 5f6f   f"{path.stem}_o
+00003030: 7269 672e 7072 6a22 0a20 2020 2020 2020  rig.prj".       
+00003040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003050: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
+00003060: 7072 6a5f 7265 6e61 6d65 5f70 6174 682e  prj_rename_path.
+00003070: 6578 6973 7473 2829 3a0a 2020 2020 2020  exists():.      
+00003080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003090: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+000030a0: 6a5f 7061 7468 2e72 656e 616d 6528 7072  j_path.rename(pr
+000030b0: 6a5f 7265 6e61 6d65 5f70 6174 6829 0a20  j_rename_path). 
+000030c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000030d0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+000030e0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000030f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003100: 2020 2020 2020 2020 2070 726a 5f70 6174           prj_pat
+00003110: 682e 756e 6c69 6e6b 2829 0a20 2020 2020  h.unlink().     
+00003120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003130: 2020 2020 2020 2020 2020 2070 726a 5f70             prj_p
+00003140: 6174 682e 7772 6974 655f 7465 7874 2850  ath.write_text(P
+00003150: 524a 5f45 5053 475f 3331 3337 3029 0a0a  RJ_EPSG_31370)..
+00003160: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00003170: 726e 204c 6179 6572 496e 666f 280a 2020  rn LayerInfo(.  
+00003180: 2020 2020 2020 2020 2020 2020 2020 6e61                na
+00003190: 6d65 3d64 6174 6173 6f75 7263 655f 6c61  me=datasource_la
+000031a0: 7965 722e 4765 744e 616d 6528 292c 0a20  yer.GetName(),. 
+000031b0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+000031c0: 6561 7475 7265 636f 756e 743d 6461 7461  eaturecount=data
+000031d0: 736f 7572 6365 5f6c 6179 6572 2e47 6574  source_layer.Get
+000031e0: 4665 6174 7572 6543 6f75 6e74 2829 2c0a  FeatureCount(),.
+000031f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003200: 746f 7461 6c5f 626f 756e 6473 3d74 6f74  total_bounds=tot
+00003210: 616c 5f62 6f75 6e64 732c 0a20 2020 2020  al_bounds,.     
+00003220: 2020 2020 2020 2020 2020 2067 656f 6d65             geome
+00003230: 7472 7963 6f6c 756d 6e3d 6765 6f6d 6574  trycolumn=geomet
+00003240: 7279 636f 6c75 6d6e 2c0a 2020 2020 2020  rycolumn,.      
+00003250: 2020 2020 2020 2020 2020 6765 6f6d 6574            geomet
+00003260: 7279 7479 7065 6e61 6d65 3d67 656f 6d65  rytypename=geome
+00003270: 7472 7974 7970 656e 616d 652c 0a20 2020  trytypename,.   
+00003280: 2020 2020 2020 2020 2020 2020 2067 656f               geo
+00003290: 6d65 7472 7974 7970 653d 6765 6f6d 6574  metrytype=geomet
+000032a0: 7279 7479 7065 2c0a 2020 2020 2020 2020  rytype,.        
+000032b0: 2020 2020 2020 2020 636f 6c75 6d6e 733d          columns=
+000032c0: 636f 6c75 6d6e 732c 0a20 2020 2020 2020  columns,.       
+000032d0: 2020 2020 2020 2020 2066 6964 5f63 6f6c           fid_col
+000032e0: 756d 6e3d 6461 7461 736f 7572 6365 5f6c  umn=datasource_l
+000032f0: 6179 6572 2e47 6574 4649 4443 6f6c 756d  ayer.GetFIDColum
+00003300: 6e28 292c 0a20 2020 2020 2020 2020 2020  n(),.           
+00003310: 2020 2020 2063 7273 3d63 7273 2c0a 2020       crs=crs,.  
+00003320: 2020 2020 2020 2020 2020 2020 2020 6572                er
+00003330: 726f 7273 3d65 7272 6f72 732c 0a20 2020  rors=errors,.   
+00003340: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00003350: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00003360: 2020 2020 2065 7272 6f72 732e 6170 7065       errors.appe
+00003370: 6e64 2822 4c61 7965 7220 646f 6573 6e27  nd("Layer doesn'
+00003380: 7420 6861 7665 2061 2067 656f 6d65 7472  t have a geometr
+00003390: 7920 636f 6c75 6d6e 2122 290a 0a20 2020  y column!")..   
+000033a0: 2066 696e 616c 6c79 3a0a 2020 2020 2020   finally:.      
+000033b0: 2020 6966 2064 6174 6173 6f75 7263 6520    if datasource 
+000033c0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+000033d0: 2020 2020 2020 2020 2064 656c 2064 6174           del dat
+000033e0: 6173 6f75 7263 650a 0a20 2020 2023 2049  asource..    # I
+000033f0: 6620 7765 2064 6964 6e27 7420 7265 7475  f we didn't retu
+00003400: 726e 206f 7220 7261 6973 6520 7965 7420  rn or raise yet 
+00003410: 6865 7265 2c20 7468 6572 6520 6d75 7374  here, there must
+00003420: 2068 6176 6520 6265 656e 2065 7272 6f72   have been error
+00003430: 730a 2020 2020 6572 726f 7273 5f73 7472  s.    errors_str
+00003440: 203d 2070 7072 696e 742e 7066 6f72 6d61   = pprint.pforma
+00003450: 7428 6572 726f 7273 290a 2020 2020 7261  t(errors).    ra
+00003460: 6973 6520 4578 6365 7074 696f 6e28 0a20  ise Exception(. 
+00003470: 2020 2020 2020 2066 2245 7272 6f72 7320         f"Errors 
+00003480: 696e 206c 6179 6572 2064 6566 696e 6974  in layer definit
+00003490: 696f 6e20 6f66 2066 696c 6520 7b70 6174  ion of file {pat
+000034a0: 687d 2c20 6c61 7965 7220 7b6c 6179 6572  h}, layer {layer
+000034b0: 7d3a 205c 6e7b 6572 726f 7273 5f73 7472  }: \n{errors_str
+000034c0: 7d22 0a20 2020 2029 0a0a 0a64 6566 2067  }".    )...def g
+000034d0: 6574 5f6f 6e6c 795f 6c61 7965 7228 7061  et_only_layer(pa
+000034e0: 7468 3a20 556e 696f 6e5b 7374 722c 2022  th: Union[str, "
+000034f0: 6f73 2e50 6174 684c 696b 655b 416e 795d  os.PathLike[Any]
+00003500: 225d 2920 2d3e 2073 7472 3a0a 2020 2020  "]) -> str:.    
+00003510: 2222 220a 2020 2020 4765 7420 7468 6520  """.    Get the 
+00003520: 6c61 7965 726e 616d 6520 666f 7220 6120  layername for a 
+00003530: 6669 6c65 2074 6861 7420 6f6e 6c79 2063  file that only c
+00003540: 6f6e 7461 696e 7320 6f6e 6520 6c61 7965  ontains one laye
+00003550: 722e 0a0a 2020 2020 4966 2074 6865 2066  r...    If the f
+00003560: 696c 6520 636f 6e74 6169 6e73 206d 756c  ile contains mul
+00003570: 7469 706c 6520 6c61 7965 7273 2c20 616e  tiple layers, an
+00003580: 2065 7863 6570 7469 6f6e 2069 7320 7468   exception is th
+00003590: 726f 776e 2e0a 0a20 2020 2041 7267 733a  rown...    Args:
+000035a0: 0a20 2020 2020 2020 2070 6174 6820 2850  .        path (P
+000035b0: 6174 684c 696b 6529 3a20 7468 6520 6669  athLike): the fi
+000035c0: 6c65 2e0a 0a20 2020 2052 6169 7365 733a  le...    Raises:
+000035d0: 0a20 2020 2020 2020 2056 616c 7565 4572  .        ValueEr
+000035e0: 726f 723a 2061 6e20 696e 7661 6c69 6420  ror: an invalid 
+000035f0: 7061 7261 6d65 7465 7220 7661 6c75 6520  parameter value 
+00003600: 7761 7320 7061 7373 6564 2e0a 0a20 2020  was passed...   
+00003610: 2052 6574 7572 6e73 3a0a 2020 2020 2020   Returns:.      
+00003620: 2020 7374 723a 2074 6865 206c 6179 6572    str: the layer
+00003630: 206e 616d 650a 2020 2020 2222 220a 2020   name.    """.  
+00003640: 2020 6461 7461 736f 7572 6365 203d 204e    datasource = N
+00003650: 6f6e 650a 2020 2020 7472 793a 0a20 2020  one.    try:.   
+00003660: 2020 2020 2064 6174 6173 6f75 7263 655f       datasource_
+00003670: 6c61 7965 7220 3d20 4e6f 6e65 0a20 2020  layer = None.   
+00003680: 2020 2020 2064 6174 6173 6f75 7263 6520       datasource 
+00003690: 3d20 6764 616c 2e4f 7065 6e45 7828 0a20  = gdal.OpenEx(. 
+000036a0: 2020 2020 2020 2020 2020 2073 7472 2870             str(p
+000036b0: 6174 6829 2c20 6e4f 7065 6e46 6c61 6773  ath), nOpenFlags
+000036c0: 3d67 6461 6c2e 4f46 5f56 4543 544f 5220  =gdal.OF_VECTOR 
+000036d0: 7c20 6764 616c 2e4f 465f 5245 4144 4f4e  | gdal.OF_READON
+000036e0: 4c59 207c 2067 6461 6c2e 4f46 5f53 4841  LY | gdal.OF_SHA
+000036f0: 5245 440a 2020 2020 2020 2020 290a 2020  RED.        ).  
+00003700: 2020 2020 2020 6e62 5f6c 6179 6572 7320        nb_layers 
+00003710: 3d20 6461 7461 736f 7572 6365 2e47 6574  = datasource.Get
+00003720: 4c61 7965 7243 6f75 6e74 2829 0a20 2020  LayerCount().   
+00003730: 2020 2020 2069 6620 6e62 5f6c 6179 6572       if nb_layer
+00003740: 7320 3d3d 2031 3a0a 2020 2020 2020 2020  s == 1:.        
+00003750: 2020 2020 6461 7461 736f 7572 6365 5f6c      datasource_l
+00003760: 6179 6572 203d 2064 6174 6173 6f75 7263  ayer = datasourc
+00003770: 652e 4765 744c 6179 6572 4279 496e 6465  e.GetLayerByInde
+00003780: 7828 3029 0a20 2020 2020 2020 2065 6c69  x(0).        eli
+00003790: 6620 6e62 5f6c 6179 6572 7320 3d3d 2030  f nb_layers == 0
+000037a0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+000037b0: 6973 6520 5661 6c75 6545 7272 6f72 2866  ise ValueError(f
+000037c0: 2245 7272 6f72 3a20 4e6f 206c 6179 6572  "Error: No layer
+000037d0: 7320 666f 756e 6420 696e 207b 7061 7468  s found in {path
+000037e0: 7d22 290a 2020 2020 2020 2020 656c 7365  }").        else
+000037f0: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+00003800: 4368 6563 6b20 6966 2074 6865 7265 2069  Check if there i
+00003810: 7320 6f6e 6c79 206f 6e65 2073 7061 7469  s only one spati
+00003820: 616c 206c 6179 6572 0a20 2020 2020 2020  al layer.       
+00003830: 2020 2020 206c 6179 6572 7320 3d20 6c69       layers = li
+00003840: 7374 6c61 7965 7273 2870 6174 682c 206f  stlayers(path, o
+00003850: 6e6c 795f 7370 6174 6961 6c5f 6c61 7965  nly_spatial_laye
+00003860: 7273 3d54 7275 6529 0a20 2020 2020 2020  rs=True).       
+00003870: 2020 2020 2069 6620 6c65 6e28 6c61 7965       if len(laye
+00003880: 7273 2920 3d3d 2031 3a0a 2020 2020 2020  rs) == 1:.      
+00003890: 2020 2020 2020 2020 2020 6461 7461 736f            dataso
+000038a0: 7572 6365 5f6c 6179 6572 203d 2064 6174  urce_layer = dat
+000038b0: 6173 6f75 7263 652e 4765 744c 6179 6572  asource.GetLayer
+000038c0: 286c 6179 6572 735b 305d 290a 2020 2020  (layers[0]).    
+000038d0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+000038e0: 2020 2020 2020 2020 2020 2020 2020 7261                ra
+000038f0: 6973 6520 5661 6c75 6545 7272 6f72 2866  ise ValueError(f
+00003900: 224c 6179 6572 2068 6173 203e 2031 206c  "Layer has > 1 l
+00003910: 6179 6572 3a20 7b70 6174 687d 3a20 7b6c  ayer: {path}: {l
+00003920: 6179 6572 737d 2229 0a0a 2020 2020 2020  ayers}")..      
+00003930: 2020 7265 7475 726e 2064 6174 6173 6f75    return datasou
+00003940: 7263 655f 6c61 7965 722e 4765 744e 616d  rce_layer.GetNam
+00003950: 6528 290a 0a20 2020 2066 696e 616c 6c79  e()..    finally
+00003960: 3a0a 2020 2020 2020 2020 6966 2064 6174  :.        if dat
+00003970: 6173 6f75 7263 6520 6973 206e 6f74 204e  asource is not N
+00003980: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00003990: 2064 656c 2064 6174 6173 6f75 7263 650a   del datasource.
+000039a0: 0a0a 6465 6620 6765 745f 6465 6661 756c  ..def get_defaul
+000039b0: 745f 6c61 7965 7228 7061 7468 3a20 556e  t_layer(path: Un
+000039c0: 696f 6e5b 7374 722c 2022 6f73 2e50 6174  ion[str, "os.Pat
+000039d0: 684c 696b 655b 416e 795d 225d 2920 2d3e  hLike[Any]"]) ->
+000039e0: 2073 7472 3a0a 2020 2020 2222 220a 2020   str:.    """.  
+000039f0: 2020 4765 7420 7468 6520 6465 6661 756c    Get the defaul
+00003a00: 7420 6c61 7965 7220 6e61 6d65 2074 6f20  t layer name to 
+00003a10: 6265 2075 7365 6420 666f 7220 6120 6c61  be used for a la
+00003a20: 7965 7220 696e 2074 6869 7320 6669 6c65  yer in this file
+00003a30: 2e0a 0a20 2020 2054 6869 7320 6973 2074  ...    This is t
+00003a40: 6865 2073 7465 6d20 6f66 2074 6865 2066  he stem of the f
+00003a50: 696c 6570 6174 682e 0a0a 2020 2020 4172  ilepath...    Ar
+00003a60: 6773 3a0a 2020 2020 2020 2020 7061 7468  gs:.        path
+00003a70: 2028 556e 696f 6e5b 7374 722c 293a 2054   (Union[str,): T
+00003a80: 6865 2070 6174 6820 746f 2074 6865 2066  he path to the f
+00003a90: 696c 652e 0a0a 2020 2020 5265 7475 726e  ile...    Return
+00003aa0: 733a 0a20 2020 2020 2020 2073 7472 3a20  s:.        str: 
+00003ab0: 5468 6520 6465 6661 756c 7420 6c61 7965  The default laye
+00003ac0: 7220 6e61 6d65 2e0a 2020 2020 2222 220a  r name..    """.
+00003ad0: 2020 2020 7265 7475 726e 2050 6174 6828      return Path(
+00003ae0: 7061 7468 292e 7374 656d 0a0a 0a64 6566  path).stem...def
+00003af0: 2065 7865 6375 7465 5f73 716c 280a 2020   execute_sql(.  
+00003b00: 2020 7061 7468 3a20 556e 696f 6e5b 7374    path: Union[st
+00003b10: 722c 2022 6f73 2e50 6174 684c 696b 655b  r, "os.PathLike[
+00003b20: 416e 795d 225d 2c0a 2020 2020 7371 6c5f  Any]"],.    sql_
+00003b30: 7374 6d74 3a20 7374 722c 0a20 2020 2073  stmt: str,.    s
+00003b40: 716c 5f64 6961 6c65 6374 3a20 4f70 7469  ql_dialect: Opti
+00003b50: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
+00003b60: 2c0a 293a 0a20 2020 2022 2222 0a20 2020  ,.):.    """.   
+00003b70: 2045 7865 6375 7465 2061 2073 716c 2073   Execute a sql s
+00003b80: 7461 7465 6d65 6e74 2028 444d 4c20 6f72  tatement (DML or
+00003b90: 2044 444c 2920 6f6e 2074 6865 2066 696c   DDL) on the fil
+00003ba0: 652e 0a0a 2020 2020 546f 2072 756e 2053  e...    To run S
+00003bb0: 454c 4543 5420 7371 6c20 7374 6174 656d  ELECT sql statem
+00003bc0: 656e 7473 206f 6e20 6120 6669 6c65 2c20  ents on a file, 
+00003bd0: 7573 6520 3a6d 6574 683a 607e 7265 6164  use :meth:`~read
+00003be0: 5f66 696c 6560 2e0a 0a20 2020 2041 7267  _file`...    Arg
+00003bf0: 733a 0a20 2020 2020 2020 2070 6174 6820  s:.        path 
+00003c00: 2850 6174 684c 696b 6529 3a20 5468 6520  (PathLike): The 
+00003c10: 7061 7468 2074 6f20 7468 6520 6669 6c65  path to the file
+00003c20: 2e0a 2020 2020 2020 2020 7371 6c5f 7374  ..        sql_st
+00003c30: 6d74 2028 7374 7229 3a20 5468 6520 7371  mt (str): The sq
+00003c40: 6c20 7374 6174 656d 656e 7420 746f 2065  l statement to e
+00003c50: 7865 6375 7465 2e0a 2020 2020 2020 2020  xecute..        
+00003c60: 7371 6c5f 6469 616c 6563 7420 2873 7472  sql_dialect (str
+00003c70: 293a 2054 6865 2073 716c 2064 6961 6c65  ): The sql diale
+00003c80: 6374 2074 6f20 7573 653a 0a20 2020 2020  ct to use:.     
+00003c90: 2020 2020 2020 202a 204e 6f6e 653a 2075         * None: u
+00003ca0: 7365 2074 6865 206e 6174 6976 6520 5351  se the native SQ
+00003cb0: 4c20 6469 616c 6563 7420 6f66 2074 6865  L dialect of the
+00003cc0: 2067 656f 6669 6c65 2e0a 2020 2020 2020   geofile..      
+00003cd0: 2020 2020 2020 2a20 274f 4752 5351 4c27        * 'OGRSQL'
+00003ce0: 3a20 666f 7263 6520 7468 6520 7573 6520  : force the use 
+00003cf0: 6f66 2074 6865 204f 4752 2053 514c 2064  of the OGR SQL d
+00003d00: 6961 6c65 6374 2e0a 2020 2020 2020 2020  ialect..        
+00003d10: 2020 2020 2a20 2753 514c 4954 4527 3a20      * 'SQLITE': 
+00003d20: 666f 7263 6520 7468 6520 7573 6520 6f66  force the use of
+00003d30: 2074 6865 2053 514c 4954 4520 6469 616c   the SQLITE dial
+00003d40: 6563 742e 0a20 2020 2020 2020 2020 2020  ect..           
+00003d50: 2044 6566 6175 6c74 7320 746f 204e 6f6e   Defaults to Non
+00003d60: 652e 0a20 2020 2022 2222 0a20 2020 2064  e..    """.    d
+00003d70: 6174 6173 6f75 7263 6520 3d20 4e6f 6e65  atasource = None
+00003d80: 0a20 2020 2074 7279 3a0a 2020 2020 2020  .    try:.      
+00003d90: 2020 6461 7461 736f 7572 6365 203d 2067    datasource = g
+00003da0: 6461 6c2e 4f70 656e 4578 2873 7472 2870  dal.OpenEx(str(p
+00003db0: 6174 6829 2c20 6e4f 7065 6e46 6c61 6773  ath), nOpenFlags
+00003dc0: 3d67 6461 6c2e 4f46 5f55 5044 4154 4529  =gdal.OF_UPDATE)
+00003dd0: 0a20 2020 2020 2020 2072 6573 756c 7420  .        result 
+00003de0: 3d20 6461 7461 736f 7572 6365 2e45 7865  = datasource.Exe
+00003df0: 6375 7465 5351 4c28 7371 6c5f 7374 6d74  cuteSQL(sql_stmt
+00003e00: 2c20 6469 616c 6563 743d 7371 6c5f 6469  , dialect=sql_di
+00003e10: 616c 6563 7429 0a20 2020 2020 2020 2064  alect).        d
+00003e20: 6174 6173 6f75 7263 652e 5265 6c65 6173  atasource.Releas
+00003e30: 6552 6573 756c 7453 6574 2872 6573 756c  eResultSet(resul
+00003e40: 7429 0a20 2020 2066 696e 616c 6c79 3a0a  t).    finally:.
+00003e50: 2020 2020 2020 2020 6966 2064 6174 6173          if datas
+00003e60: 6f75 7263 6520 6973 206e 6f74 204e 6f6e  ource is not Non
+00003e70: 653a 0a20 2020 2020 2020 2020 2020 2064  e:.            d
+00003e80: 656c 2064 6174 6173 6f75 7263 650a 0a0a  el datasource...
+00003e90: 6465 6620 6372 6561 7465 5f73 7061 7469  def create_spati
+00003ea0: 616c 5f69 6e64 6578 280a 2020 2020 7061  al_index(.    pa
+00003eb0: 7468 3a20 556e 696f 6e5b 7374 722c 2022  th: Union[str, "
+00003ec0: 6f73 2e50 6174 684c 696b 655b 416e 795d  os.PathLike[Any]
+00003ed0: 225d 2c0a 2020 2020 6c61 7965 723a 204f  "],.    layer: O
+00003ee0: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
+00003ef0: 6f6e 652c 0a20 2020 2063 6163 6865 5f73  one,.    cache_s
+00003f00: 697a 655f 6d62 3a20 696e 7420 3d20 3132  ize_mb: int = 12
+00003f10: 382c 0a20 2020 2065 7869 7374 5f6f 6b3a  8,.    exist_ok:
+00003f20: 2062 6f6f 6c20 3d20 4661 6c73 652c 0a20   bool = False,. 
+00003f30: 2020 2066 6f72 6365 5f72 6562 7569 6c64     force_rebuild
+00003f40: 3a20 626f 6f6c 203d 2046 616c 7365 2c0a  : bool = False,.
+00003f50: 293a 0a20 2020 2022 2222 0a20 2020 2043  ):.    """.    C
+00003f60: 7265 6174 6520 6120 7370 6174 6961 6c20  reate a spatial 
+00003f70: 696e 6465 7820 6f6e 2074 6865 206c 6179  index on the lay
+00003f80: 6572 2073 7065 6369 6669 6564 2e0a 0a20  er specified... 
+00003f90: 2020 2041 7267 733a 0a20 2020 2020 2020     Args:.       
+00003fa0: 2070 6174 6820 2850 6174 684c 696b 6529   path (PathLike)
+00003fb0: 3a20 5468 6520 6669 6c65 2070 6174 682e  : The file path.
+00003fc0: 0a20 2020 2020 2020 206c 6179 6572 2028  .        layer (
+00003fd0: 7374 722c 206f 7074 696f 6e61 6c29 3a20  str, optional): 
+00003fe0: 5468 6520 6c61 7965 722e 2049 6620 6e6f  The layer. If no
+00003ff0: 7420 7370 6563 6966 6965 642c 2061 6e64  t specified, and
+00004000: 2074 6865 7265 2069 7320 6f6e 6c79 0a20   there is only. 
+00004010: 2020 2020 2020 2020 2020 206f 6e65 206c             one l
+00004020: 6179 6572 2069 6e20 7468 6520 6669 6c65  ayer in the file
+00004030: 2c20 7468 6973 206c 6179 6572 2069 7320  , this layer is 
+00004040: 7573 6564 2e20 4f74 6865 7277 6973 6520  used. Otherwise 
+00004050: 6578 6365 7074 696f 6e2e 0a20 2020 2020  exception..     
+00004060: 2020 2063 6163 6865 5f73 697a 655f 6d62     cache_size_mb
+00004070: 2028 696e 742c 206f 7074 696f 6e61 6c29   (int, optional)
+00004080: 3a20 6d65 6d6f 7279 2069 6e20 4d42 2074  : memory in MB t
+00004090: 6861 7420 6361 6e20 6265 2075 7365 6420  hat can be used 
+000040a0: 7768 696c 650a 2020 2020 2020 2020 2020  while.          
+000040b0: 2020 6372 6561 7469 6e67 2073 7061 7469    creating spati
+000040c0: 616c 2069 6e64 6578 2066 6f72 2073 7061  al index for spa
+000040d0: 7469 616c 6974 6520 6669 6c65 7320 282e  tialite files (.
+000040e0: 6770 6b67 206f 7220 2e73 716c 6974 6529  gpkg or .sqlite)
+000040f0: 2e0a 2020 2020 2020 2020 2020 2020 4465  ..            De
+00004100: 6661 756c 7473 2074 6f20 3132 382e 0a20  faults to 128.. 
+00004110: 2020 2020 2020 2065 7869 7374 5f6f 6b20         exist_ok 
+00004120: 2862 6f6f 6c2c 206f 7074 696f 6e73 293a  (bool, options):
+00004130: 2049 6620 5472 7565 2061 6e64 2074 6865   If True and the
+00004140: 2069 6e64 6578 2065 7869 7374 7320 616c   index exists al
+00004150: 7265 6164 792c 2064 6f6e 2774 0a20 2020  ready, don't.   
+00004160: 2020 2020 2020 2020 2074 6872 6f77 2061           throw a
+00004170: 6e20 6572 726f 722e 0a20 2020 2020 2020  n error..       
+00004180: 2066 6f72 6365 5f72 6562 7569 6c64 2028   force_rebuild (
+00004190: 626f 6f6c 2c20 6f70 7469 6f6e 7329 3a20  bool, options): 
+000041a0: 5472 7565 2074 6f20 666f 7263 6520 7265  True to force re
+000041b0: 6275 696c 6420 6576 656e 2069 6620 696e  build even if in
+000041c0: 6465 780a 2020 2020 2020 2020 2020 2020  dex.            
+000041d0: 6578 6973 7473 2061 6c72 6561 6479 2e20  exists already. 
+000041e0: 4465 6661 756c 7473 2074 6f20 4661 6c73  Defaults to Fals
+000041f0: 652e 0a20 2020 2022 2222 0a20 2020 2023  e..    """.    #
+00004200: 2049 6e69 740a 2020 2020 7061 7468 203d   Init.    path =
+00004210: 2050 6174 6828 7061 7468 290a 2020 2020   Path(path).    
+00004220: 6966 206c 6179 6572 2069 7320 4e6f 6e65  if layer is None
+00004230: 3a0a 2020 2020 2020 2020 6c61 7965 7220  :.        layer 
+00004240: 3d20 6765 745f 6f6e 6c79 5f6c 6179 6572  = get_only_layer
+00004250: 2870 6174 6829 0a0a 2020 2020 2320 4966  (path)..    # If
+00004260: 2069 6e64 6578 2061 6c72 6561 6479 2065   index already e
+00004270: 7869 7374 732c 2072 656d 6f76 6520 696e  xists, remove in
+00004280: 6465 7820 6f72 2072 6574 7572 6e0a 2020  dex or return.  
+00004290: 2020 6966 2068 6173 5f73 7061 7469 616c    if has_spatial
+000042a0: 5f69 6e64 6578 2870 6174 682c 206c 6179  _index(path, lay
+000042b0: 6572 293a 0a20 2020 2020 2020 2069 6620  er):.        if 
+000042c0: 666f 7263 655f 7265 6275 696c 643a 0a20  force_rebuild:. 
+000042d0: 2020 2020 2020 2020 2020 2072 656d 6f76             remov
+000042e0: 655f 7370 6174 6961 6c5f 696e 6465 7828  e_spatial_index(
+000042f0: 7061 7468 2c20 6c61 7965 7229 0a20 2020  path, layer).   
+00004300: 2020 2020 2065 6c69 6620 6578 6973 745f       elif exist_
+00004310: 6f6b 3a0a 2020 2020 2020 2020 2020 2020  ok:.            
+00004320: 7265 7475 726e 0a20 2020 2020 2020 2065  return.        e
+00004330: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00004340: 2072 6169 7365 2045 7863 6570 7469 6f6e   raise Exception
+00004350: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00004360: 2020 6622 4572 726f 7220 6164 6469 6e67    f"Error adding
+00004370: 2073 7061 7469 616c 2069 6e64 6578 2074   spatial index t
+00004380: 6f20 7b70 6174 687d 2e7b 6c61 7965 727d  o {path}.{layer}
+00004390: 2c20 6974 2065 7869 7374 7320 616c 7265  , it exists alre
+000043a0: 6164 7922 0a20 2020 2020 2020 2020 2020  ady".           
+000043b0: 2029 0a0a 2020 2020 2320 4e6f 7720 7265   )..    # Now re
+000043c0: 616c 6c79 2061 6464 2069 6e64 6578 0a20  ally add index. 
+000043d0: 2020 2064 6174 6173 6f75 7263 6520 3d20     datasource = 
+000043e0: 4e6f 6e65 0a20 2020 2074 7279 3a0a 2020  None.    try:.  
+000043f0: 2020 2020 2020 6765 6f66 696c 6574 7970        geofiletyp
+00004400: 6520 3d20 4765 6f66 696c 6554 7970 6528  e = GeofileType(
+00004410: 7061 7468 290a 2020 2020 2020 2020 6966  path).        if
+00004420: 2067 656f 6669 6c65 7479 7065 2e69 735f   geofiletype.is_
+00004430: 7370 6174 6961 6c69 7465 5f62 6173 6564  spatialite_based
+00004440: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+00004450: 5468 6520 636f 6e66 6967 206f 7074 696f  The config optio
+00004460: 6e73 206e 6565 6420 746f 2062 6520 7365  ns need to be se
+00004470: 7420 6265 666f 7265 206f 7065 6e69 6e67  t before opening
+00004480: 2074 6865 2066 696c 6521 0a20 2020 2020   the file!.     
+00004490: 2020 2020 2020 206c 6179 6572 696e 666f         layerinfo
+000044a0: 203d 2067 6574 5f6c 6179 6572 696e 666f   = get_layerinfo
+000044b0: 2870 6174 682c 206c 6179 6572 290a 2020  (path, layer).  
+000044c0: 2020 2020 2020 2020 2020 7769 7468 205f            with _
+000044d0: 6f67 725f 7574 696c 2e73 6574 5f63 6f6e  ogr_util.set_con
+000044e0: 6669 675f 6f70 7469 6f6e 7328 7b22 4f47  fig_options({"OG
+000044f0: 525f 5351 4c49 5445 5f43 4143 4845 223a  R_SQLITE_CACHE":
+00004500: 2063 6163 6865 5f73 697a 655f 6d62 7d29   cache_size_mb})
+00004510: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00004520: 2020 6461 7461 736f 7572 6365 203d 2067    datasource = g
+00004530: 6461 6c2e 4f70 656e 4578 2873 7472 2870  dal.OpenEx(str(p
+00004540: 6174 6829 2c20 6e4f 7065 6e46 6c61 6773  ath), nOpenFlags
+00004550: 3d67 6461 6c2e 4f46 5f55 5044 4154 4529  =gdal.OF_UPDATE)
+00004560: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004570: 2067 656f 6d65 7472 7963 6f6c 756d 6e20   geometrycolumn 
+00004580: 3d20 6c61 7965 7269 6e66 6f2e 6765 6f6d  = layerinfo.geom
+00004590: 6574 7279 636f 6c75 6d6e 0a20 2020 2020  etrycolumn.     
+000045a0: 2020 2020 2020 2020 2020 2073 716c 203d             sql =
+000045b0: 2066 2253 454c 4543 5420 4372 6561 7465   f"SELECT Create
+000045c0: 5370 6174 6961 6c49 6e64 6578 2827 7b6c  SpatialIndex('{l
+000045d0: 6179 6572 7d27 2c20 277b 6765 6f6d 6574  ayer}', '{geomet
+000045e0: 7279 636f 6c75 6d6e 7d27 2922 0a20 2020  rycolumn}')".   
+000045f0: 2020 2020 2020 2020 2020 2020 2072 6573               res
+00004600: 756c 7420 3d20 6461 7461 736f 7572 6365  ult = datasource
+00004610: 2e45 7865 6375 7465 5351 4c28 7371 6c2c  .ExecuteSQL(sql,
+00004620: 2064 6961 6c65 6374 3d22 5351 4c49 5445   dialect="SQLITE
+00004630: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
+00004640: 2020 2064 6174 6173 6f75 7263 652e 5265     datasource.Re
+00004650: 6c65 6173 6552 6573 756c 7453 6574 2872  leaseResultSet(r
+00004660: 6573 756c 7429 0a20 2020 2020 2020 2065  esult).        e
+00004670: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00004680: 2064 6174 6173 6f75 7263 6520 3d20 6764   datasource = gd
+00004690: 616c 2e4f 7065 6e45 7828 7374 7228 7061  al.OpenEx(str(pa
+000046a0: 7468 292c 206e 4f70 656e 466c 6167 733d  th), nOpenFlags=
+000046b0: 6764 616c 2e4f 465f 5550 4441 5445 290a  gdal.OF_UPDATE).
+000046c0: 2020 2020 2020 2020 2020 2020 7265 7375              resu
+000046d0: 6c74 203d 2064 6174 6173 6f75 7263 652e  lt = datasource.
+000046e0: 4578 6563 7574 6553 514c 2866 2743 5245  ExecuteSQL(f'CRE
+000046f0: 4154 4520 5350 4154 4941 4c20 494e 4445  ATE SPATIAL INDE
+00004700: 5820 4f4e 2022 7b6c 6179 6572 7d22 2729  X ON "{layer}"')
+00004710: 0a20 2020 2020 2020 2020 2020 2064 6174  .            dat
+00004720: 6173 6f75 7263 652e 5265 6c65 6173 6552  asource.ReleaseR
+00004730: 6573 756c 7453 6574 2872 6573 756c 7429  esultSet(result)
+00004740: 0a20 2020 2065 7863 6570 7420 4578 6365  .    except Exce
+00004750: 7074 696f 6e20 6173 2065 783a 0a20 2020  ption as ex:.   
+00004760: 2020 2020 2072 6169 7365 2045 7863 6570       raise Excep
+00004770: 7469 6f6e 2866 2245 7272 6f72 2061 6464  tion(f"Error add
+00004780: 696e 6720 7370 6174 6961 6c20 696e 6465  ing spatial inde
+00004790: 7820 746f 207b 7061 7468 7d2e 7b6c 6179  x to {path}.{lay
+000047a0: 6572 7d22 2920 6672 6f6d 2065 780a 2020  er}") from ex.  
+000047b0: 2020 6669 6e61 6c6c 793a 0a20 2020 2020    finally:.     
+000047c0: 2020 2069 6620 6461 7461 736f 7572 6365     if datasource
+000047d0: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+000047e0: 2020 2020 2020 2020 2020 6465 6c20 6461            del da
+000047f0: 7461 736f 7572 6365 0a0a 2020 2020 6966  tasource..    if
+00004800: 206e 6f74 2068 6173 5f73 7061 7469 616c   not has_spatial
+00004810: 5f69 6e64 6578 2870 6174 682c 206c 6179  _index(path, lay
+00004820: 6572 293a 0a20 2020 2020 2020 2072 6169  er):.        rai
+00004830: 7365 2052 756e 7469 6d65 4572 726f 7228  se RuntimeError(
+00004840: 6622 6372 6561 7465 5f73 7061 7469 616c  f"create_spatial
+00004850: 5f69 6e64 6578 2066 6169 6c65 6420 6f6e  _index failed on
+00004860: 207b 7061 7468 7d2c 206c 6179 6572 3a20   {path}, layer: 
+00004870: 7b6c 6179 6572 7d22 290a 0a0a 6465 6620  {layer}")...def 
+00004880: 6861 735f 7370 6174 6961 6c5f 696e 6465  has_spatial_inde
+00004890: 7828 0a20 2020 2070 6174 683a 2055 6e69  x(.    path: Uni
+000048a0: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
+000048b0: 4c69 6b65 5b41 6e79 5d22 5d2c 206c 6179  Like[Any]"], lay
+000048c0: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
+000048d0: 5d20 3d20 4e6f 6e65 0a29 202d 3e20 626f  ] = None.) -> bo
+000048e0: 6f6c 3a0a 2020 2020 2222 220a 2020 2020  ol:.    """.    
+000048f0: 4368 6563 6b20 6966 2074 6865 206c 6179  Check if the lay
+00004900: 6572 2f63 6f6c 756d 6e20 6861 7320 6120  er/column has a 
+00004910: 7370 6174 6961 6c20 696e 6465 782e 0a0a  spatial index...
+00004920: 2020 2020 4172 6773 3a0a 2020 2020 2020      Args:.      
+00004930: 2020 7061 7468 2028 5061 7468 4c69 6b65    path (PathLike
+00004940: 293a 2054 6865 2066 696c 6520 7061 7468  ): The file path
+00004950: 2e0a 2020 2020 2020 2020 6c61 7965 7220  ..        layer 
+00004960: 2873 7472 2c20 6f70 7469 6f6e 616c 293a  (str, optional):
+00004970: 2054 6865 206c 6179 6572 2e20 4465 6661   The layer. Defa
+00004980: 756c 7473 2074 6f20 4e6f 6e65 2e0a 0a20  ults to None... 
+00004990: 2020 2052 6169 7365 733a 0a20 2020 2020     Raises:.     
+000049a0: 2020 2056 616c 7565 4572 726f 723a 2061     ValueError: a
+000049b0: 6e20 696e 7661 6c69 6420 7061 7261 6d65  n invalid parame
+000049c0: 7465 7220 7661 6c75 6520 7761 7320 7061  ter value was pa
+000049d0: 7373 6564 2e0a 0a20 2020 2052 6574 7572  ssed...    Retur
+000049e0: 6e73 3a0a 2020 2020 2020 2020 626f 6f6c  ns:.        bool
+000049f0: 3a20 5472 7565 2069 6620 7468 6520 7370  : True if the sp
+00004a00: 6174 6961 6c20 636f 6c75 6d6e 2065 7869  atial column exi
+00004a10: 7374 732e 0a20 2020 2022 2222 0a20 2020  sts..    """.   
+00004a20: 2023 2049 6e69 740a 2020 2020 7061 7468   # Init.    path
+00004a30: 203d 2050 6174 6828 7061 7468 290a 0a20   = Path(path).. 
+00004a40: 2020 2023 204e 6f77 2063 6865 636b 2074     # Now check t
+00004a50: 6865 2069 6e64 6578 0a20 2020 2064 6174  he index.    dat
+00004a60: 6173 6f75 7263 6520 3d20 4e6f 6e65 0a20  asource = None. 
+00004a70: 2020 2067 656f 6669 6c65 7479 7065 203d     geofiletype =
+00004a80: 2047 656f 6669 6c65 5479 7065 2870 6174   GeofileType(pat
+00004a90: 6829 0a20 2020 2074 7279 3a0a 2020 2020  h).    try:.    
+00004aa0: 2020 2020 6966 2067 656f 6669 6c65 7479      if geofilety
+00004ab0: 7065 2e69 735f 7370 6174 6961 6c69 7465  pe.is_spatialite
+00004ac0: 5f62 6173 6564 3a0a 2020 2020 2020 2020  _based:.        
+00004ad0: 2020 2020 6c61 7965 7269 6e66 6f20 3d20      layerinfo = 
+00004ae0: 6765 745f 6c61 7965 7269 6e66 6f28 7061  get_layerinfo(pa
+00004af0: 7468 2c20 6c61 7965 7229 0a20 2020 2020  th, layer).     
+00004b00: 2020 2020 2020 2064 6174 6173 6f75 7263         datasourc
+00004b10: 6520 3d20 6764 616c 2e4f 7065 6e45 7828  e = gdal.OpenEx(
+00004b20: 7374 7228 7061 7468 292c 206e 4f70 656e  str(path), nOpen
+00004b30: 466c 6167 733d 6764 616c 2e4f 465f 5245  Flags=gdal.OF_RE
+00004b40: 4144 4f4e 4c59 290a 2020 2020 2020 2020  ADONLY).        
+00004b50: 2020 2020 7371 6c20 3d20 6622 2222 0a20      sql = f""". 
+00004b60: 2020 2020 2020 2020 2020 2020 2020 2053                 S
+00004b70: 454c 4543 5420 4861 7353 7061 7469 616c  ELECT HasSpatial
+00004b80: 496e 6465 7828 277b 6c61 7965 7269 6e66  Index('{layerinf
+00004b90: 6f2e 6e61 6d65 7d27 2c0a 2020 2020 2020  o.name}',.      
+00004ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004bc0: 2027 7b6c 6179 6572 696e 666f 2e67 656f   '{layerinfo.geo
+00004bd0: 6d65 7472 7963 6f6c 756d 6e7d 2729 0a20  metrycolumn}'). 
+00004be0: 2020 2020 2020 2020 2020 2022 2222 0a20             """. 
+00004bf0: 2020 2020 2020 2020 2020 2072 6573 756c             resul
+00004c00: 7420 3d20 6461 7461 736f 7572 6365 2e45  t = datasource.E
+00004c10: 7865 6375 7465 5351 4c28 7371 6c2c 2064  xecuteSQL(sql, d
+00004c20: 6961 6c65 6374 3d22 5351 4c49 5445 2229  ialect="SQLITE")
+00004c30: 0a20 2020 2020 2020 2020 2020 2068 6173  .            has
+00004c40: 5f73 7061 7469 616c 5f69 6e64 6578 203d  _spatial_index =
+00004c50: 2072 6573 756c 742e 4765 744e 6578 7446   result.GetNextF
+00004c60: 6561 7475 7265 2829 2e47 6574 4669 656c  eature().GetFiel
+00004c70: 6428 3029 203d 3d20 310a 2020 2020 2020  d(0) == 1.      
+00004c80: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
+00004c90: 2e52 656c 6561 7365 5265 7375 6c74 5365  .ReleaseResultSe
+00004ca0: 7428 7265 7375 6c74 290a 2020 2020 2020  t(result).      
+00004cb0: 2020 2020 2020 7265 7475 726e 2068 6173        return has
+00004cc0: 5f73 7061 7469 616c 5f69 6e64 6578 0a20  _spatial_index. 
+00004cd0: 2020 2020 2020 2065 6c69 6620 6765 6f66         elif geof
+00004ce0: 696c 6574 7970 6520 3d3d 2047 656f 6669  iletype == Geofi
+00004cf0: 6c65 5479 7065 2e45 5352 4953 6861 7065  leType.ESRIShape
+00004d00: 6669 6c65 3a0a 2020 2020 2020 2020 2020  file:.          
+00004d10: 2020 696e 6465 785f 7061 7468 203d 2070    index_path = p
+00004d20: 6174 682e 7061 7265 6e74 202f 2066 227b  ath.parent / f"{
+00004d30: 7061 7468 2e73 7465 6d7d 2e71 6978 220a  path.stem}.qix".
+00004d40: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00004d50: 726e 2069 6e64 6578 5f70 6174 682e 6578  rn index_path.ex
+00004d60: 6973 7473 2829 0a20 2020 2020 2020 2065  ists().        e
+00004d70: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00004d80: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
+00004d90: 7228 6622 6861 735f 7370 6174 6961 6c5f  r(f"has_spatial_
+00004da0: 696e 6465 7820 6e6f 7420 7375 7070 6f72  index not suppor
+00004db0: 7465 6420 666f 7220 7b70 6174 687d 2229  ted for {path}")
+00004dc0: 0a20 2020 2066 696e 616c 6c79 3a0a 2020  .    finally:.  
+00004dd0: 2020 2020 2020 6966 2064 6174 6173 6f75        if datasou
+00004de0: 7263 6520 6973 206e 6f74 204e 6f6e 653a  rce is not None:
+00004df0: 0a20 2020 2020 2020 2020 2020 2064 6174  .            dat
+00004e00: 6173 6f75 7263 6520 3d20 4e6f 6e65 0a0a  asource = None..
+00004e10: 0a64 6566 2072 656d 6f76 655f 7370 6174  .def remove_spat
+00004e20: 6961 6c5f 696e 6465 7828 0a20 2020 2070  ial_index(.    p
+00004e30: 6174 683a 2055 6e69 6f6e 5b73 7472 2c20  ath: Union[str, 
+00004e40: 226f 732e 5061 7468 4c69 6b65 5b41 6e79  "os.PathLike[Any
+00004e50: 5d22 5d2c 206c 6179 6572 3a20 4f70 7469  ]"], layer: Opti
+00004e60: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
+00004e70: 0a29 3a0a 2020 2020 2222 220a 2020 2020  .):.    """.    
+00004e80: 5265 6d6f 7665 2074 6865 2073 7061 7469  Remove the spati
+00004e90: 616c 2069 6e64 6578 2066 726f 6d20 7468  al index from th
+00004ea0: 6520 6c61 7965 7220 7370 6563 6966 6965  e layer specifie
+00004eb0: 642e 0a0a 2020 2020 4172 6773 3a0a 2020  d...    Args:.  
+00004ec0: 2020 2020 2020 7061 7468 2028 5061 7468        path (Path
+00004ed0: 4c69 6b65 293a 2054 6865 2066 696c 6520  Like): The file 
+00004ee0: 7061 7468 2e0a 2020 2020 2020 2020 6c61  path..        la
+00004ef0: 7965 7220 2873 7472 2c20 6f70 7469 6f6e  yer (str, option
+00004f00: 616c 293a 2054 6865 206c 6179 6572 2e20  al): The layer. 
+00004f10: 4966 206e 6f74 2073 7065 6369 6669 6564  If not specified
+00004f20: 2c20 616e 6420 7468 6572 6520 6973 206f  , and there is o
+00004f30: 6e6c 790a 2020 2020 2020 2020 2020 2020  nly.            
+00004f40: 6f6e 6520 6c61 7965 7220 696e 2074 6865  one layer in the
+00004f50: 2066 696c 652c 2074 6869 7320 6c61 7965   file, this laye
+00004f60: 7220 6973 2075 7365 642e 204f 7468 6572  r is used. Other
+00004f70: 7769 7365 2065 7863 6570 7469 6f6e 2e0a  wise exception..
+00004f80: 2020 2020 2222 220a 2020 2020 2320 496e      """.    # In
+00004f90: 6974 0a20 2020 2070 6174 6820 3d20 5061  it.    path = Pa
+00004fa0: 7468 2870 6174 6829 0a0a 2020 2020 2320  th(path)..    # 
+00004fb0: 4e6f 7720 7265 616c 6c79 2072 656d 6f76  Now really remov
+00004fc0: 6520 696e 6465 780a 2020 2020 6461 7461  e index.    data
+00004fd0: 736f 7572 6365 203d 204e 6f6e 650a 2020  source = None.  
+00004fe0: 2020 6765 6f66 696c 6574 7970 6520 3d20    geofiletype = 
+00004ff0: 4765 6f66 696c 6554 7970 6528 7061 7468  GeofileType(path
+00005000: 290a 2020 2020 6c61 7965 7269 6e66 6f20  ).    layerinfo 
+00005010: 3d20 6765 745f 6c61 7965 7269 6e66 6f28  = get_layerinfo(
+00005020: 7061 7468 2c20 6c61 7965 7229 0a20 2020  path, layer).   
+00005030: 2074 7279 3a0a 2020 2020 2020 2020 6966   try:.        if
+00005040: 2067 656f 6669 6c65 7479 7065 2e69 735f   geofiletype.is_
+00005050: 7370 6174 6961 6c69 7465 5f62 6173 6564  spatialite_based
+00005060: 3a0a 2020 2020 2020 2020 2020 2020 6461  :.            da
+00005070: 7461 736f 7572 6365 203d 2067 6461 6c2e  tasource = gdal.
+00005080: 4f70 656e 4578 2873 7472 2870 6174 6829  OpenEx(str(path)
+00005090: 2c20 6e4f 7065 6e46 6c61 6773 3d67 6461  , nOpenFlags=gda
+000050a0: 6c2e 4f46 5f55 5044 4154 4529 0a20 2020  l.OF_UPDATE).   
+000050b0: 2020 2020 2020 2020 2072 6573 756c 7420           result 
+000050c0: 3d20 6461 7461 736f 7572 6365 2e45 7865  = datasource.Exe
+000050d0: 6375 7465 5351 4c28 0a20 2020 2020 2020  cuteSQL(.       
+000050e0: 2020 2020 2020 2020 2066 2253 454c 4543           f"SELEC
+000050f0: 5420 4469 7361 626c 6553 7061 7469 616c  T DisableSpatial
+00005100: 496e 6465 7828 277b 6c61 7965 7269 6e66  Index('{layerinf
+00005110: 6f2e 6e61 6d65 7d27 2c20 277b 6c61 7965  o.name}', '{laye
+00005120: 7269 6e66 6f2e 6765 6f6d 6574 7279 636f  rinfo.geometryco
+00005130: 6c75 6d6e 7d27 2922 2c20 2023 206e 6f71  lumn}')",  # noq
+00005140: 613a 2045 3530 310a 2020 2020 2020 2020  a: E501.        
+00005150: 2020 2020 2020 2020 6469 616c 6563 743d          dialect=
+00005160: 2253 514c 4954 4522 2c0a 2020 2020 2020  "SQLITE",.      
+00005170: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00005180: 2020 2020 6461 7461 736f 7572 6365 2e52      datasource.R
+00005190: 656c 6561 7365 5265 7375 6c74 5365 7428  eleaseResultSet(
+000051a0: 7265 7375 6c74 290a 2020 2020 2020 2020  result).        
+000051b0: 656c 6966 2067 656f 6669 6c65 7479 7065  elif geofiletype
+000051c0: 203d 3d20 4765 6f66 696c 6554 7970 652e   == GeofileType.
+000051d0: 4553 5249 5368 6170 6566 696c 653a 0a20  ESRIShapefile:. 
+000051e0: 2020 2020 2020 2020 2020 2023 2044 524f             # DRO
+000051f0: 5020 5350 4154 4941 4c20 494e 4445 5820  P SPATIAL INDEX 
+00005200: 4f4e 202e 2e2e 2063 6f6d 6d61 6e64 2067  ON ... command g
+00005210: 6976 6573 2061 6e20 6572 726f 722c 2073  ives an error, s
+00005220: 6f20 6a75 7374 2072 656d 6f76 6520 2e71  o just remove .q
+00005230: 6978 0a20 2020 2020 2020 2020 2020 2069  ix.            i
+00005240: 6e64 6578 5f70 6174 6820 3d20 7061 7468  ndex_path = path
+00005250: 2e70 6172 656e 7420 2f20 6622 7b70 6174  .parent / f"{pat
+00005260: 682e 7374 656d 7d2e 7169 7822 0a20 2020  h.stem}.qix".   
+00005270: 2020 2020 2020 2020 2069 6e64 6578 5f70           index_p
+00005280: 6174 682e 756e 6c69 6e6b 2829 0a20 2020  ath.unlink().   
+00005290: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000052a0: 2020 2020 2020 2072 6169 7365 2045 7863         raise Exc
+000052b0: 6570 7469 6f6e 280a 2020 2020 2020 2020  eption(.        
+000052c0: 2020 2020 2020 2020 6622 7265 6d6f 7665          f"remove
+000052d0: 5f73 7061 7469 616c 5f69 6e64 6578 2069  _spatial_index i
+000052e0: 7320 6e6f 7420 7375 7070 6f72 7465 6420  s not supported 
+000052f0: 666f 7220 7b70 6174 682e 7375 6666 6978  for {path.suffix
+00005300: 7d20 6669 6c65 220a 2020 2020 2020 2020  } file".        
+00005310: 2020 2020 290a 2020 2020 6669 6e61 6c6c      ).    finall
+00005320: 793a 0a20 2020 2020 2020 2069 6620 6461  y:.        if da
+00005330: 7461 736f 7572 6365 2069 7320 6e6f 7420  tasource is not 
+00005340: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00005350: 2020 6465 6c20 6461 7461 736f 7572 6365    del datasource
+00005360: 0a0a 0a64 6566 2072 656e 616d 655f 6c61  ...def rename_la
+00005370: 7965 7228 0a20 2020 2070 6174 683a 2055  yer(.    path: U
+00005380: 6e69 6f6e 5b73 7472 2c20 226f 732e 5061  nion[str, "os.Pa
+00005390: 7468 4c69 6b65 5b41 6e79 5d22 5d2c 206e  thLike[Any]"], n
+000053a0: 6577 5f6c 6179 6572 3a20 7374 722c 206c  ew_layer: str, l
+000053b0: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
+000053c0: 7472 5d20 3d20 4e6f 6e65 0a29 3a0a 2020  tr] = None.):.  
+000053d0: 2020 2222 220a 2020 2020 5265 6e61 6d65    """.    Rename
+000053e0: 2074 6865 206c 6179 6572 2073 7065 6369   the layer speci
+000053f0: 6669 6564 2e0a 0a20 2020 2041 7267 733a  fied...    Args:
+00005400: 0a20 2020 2020 2020 2070 6174 6820 2850  .        path (P
+00005410: 6174 684c 696b 6529 3a20 5468 6520 6669  athLike): The fi
+00005420: 6c65 2070 6174 682e 0a20 2020 2020 2020  le path..       
+00005430: 206c 6179 6572 2028 4f70 7469 6f6e 616c   layer (Optional
+00005440: 5b73 7472 5d29 3a20 5468 6520 6c61 7965  [str]): The laye
+00005450: 7220 6e61 6d65 2e20 4966 206e 6f74 2073  r name. If not s
+00005460: 7065 6369 6669 6564 2c20 616e 6420 7468  pecified, and th
+00005470: 6572 6520 6973 206f 6e6c 790a 2020 2020  ere is only.    
+00005480: 2020 2020 2020 2020 6f6e 6520 6c61 7965          one laye
+00005490: 7220 696e 2074 6865 2066 696c 652c 2074  r in the file, t
+000054a0: 6869 7320 6c61 7965 7220 6973 2075 7365  his layer is use
+000054b0: 642e 204f 7468 6572 7769 7365 2065 7863  d. Otherwise exc
+000054c0: 6570 7469 6f6e 2e0a 2020 2020 2020 2020  eption..        
+000054d0: 6e65 775f 6c61 7965 7220 2873 7472 293a  new_layer (str):
+000054e0: 2054 6865 206e 6577 206c 6179 6572 206e   The new layer n
+000054f0: 616d 652e 2049 6620 6e6f 7420 7370 6563  ame. If not spec
+00005500: 6966 6965 642c 2061 6e64 2074 6865 7265  ified, and there
+00005510: 2069 7320 6f6e 6c79 0a20 2020 2020 2020   is only.       
+00005520: 2020 2020 206f 6e65 206c 6179 6572 2069       one layer i
+00005530: 6e20 7468 6520 6669 6c65 2c20 7468 6973  n the file, this
+00005540: 206c 6179 6572 2069 7320 7573 6564 2e20   layer is used. 
+00005550: 4f74 6865 7277 6973 6520 6578 6365 7074  Otherwise except
+00005560: 696f 6e2e 0a20 2020 2022 2222 0a20 2020  ion..    """.   
+00005570: 2023 2043 6865 636b 2069 6e70 7574 2070   # Check input p
+00005580: 6172 616d 6574 6572 730a 2020 2020 7061  arameters.    pa
+00005590: 7468 203d 2050 6174 6828 7061 7468 290a  th = Path(path).
+000055a0: 2020 2020 6966 206c 6179 6572 2069 7320      if layer is 
+000055b0: 4e6f 6e65 3a0a 2020 2020 2020 2020 6c61  None:.        la
+000055c0: 7965 7220 3d20 6765 745f 6f6e 6c79 5f6c  yer = get_only_l
+000055d0: 6179 6572 2870 6174 6829 0a0a 2020 2020  ayer(path)..    
+000055e0: 2320 4e6f 7720 7265 616c 6c79 2072 656e  # Now really ren
+000055f0: 616d 650a 2020 2020 6461 7461 736f 7572  ame.    datasour
+00005600: 6365 203d 204e 6f6e 650a 2020 2020 6765  ce = None.    ge
+00005610: 6f66 696c 6574 7970 6520 3d20 4765 6f66  ofiletype = Geof
+00005620: 696c 6554 7970 6528 7061 7468 290a 2020  ileType(path).  
+00005630: 2020 7472 793a 0a20 2020 2020 2020 2069    try:.        i
+00005640: 6620 6765 6f66 696c 6574 7970 652e 6973  f geofiletype.is
+00005650: 5f73 7061 7469 616c 6974 655f 6261 7365  _spatialite_base
+00005660: 643a 0a20 2020 2020 2020 2020 2020 2064  d:.            d
+00005670: 6174 6173 6f75 7263 6520 3d20 6764 616c  atasource = gdal
+00005680: 2e4f 7065 6e45 7828 7374 7228 7061 7468  .OpenEx(str(path
+00005690: 292c 206e 4f70 656e 466c 6167 733d 6764  ), nOpenFlags=gd
+000056a0: 616c 2e4f 465f 5550 4441 5445 290a 2020  al.OF_UPDATE).  
+000056b0: 2020 2020 2020 2020 2020 7371 6c5f 7374            sql_st
+000056c0: 6d74 203d 2066 2741 4c54 4552 2054 4142  mt = f'ALTER TAB
+000056d0: 4c45 2022 7b6c 6179 6572 7d22 2052 454e  LE "{layer}" REN
+000056e0: 414d 4520 544f 2022 7b6e 6577 5f6c 6179  AME TO "{new_lay
+000056f0: 6572 7d22 270a 2020 2020 2020 2020 2020  er}"'.          
+00005700: 2020 7265 7375 6c74 203d 2064 6174 6173    result = datas
+00005710: 6f75 7263 652e 4578 6563 7574 6553 514c  ource.ExecuteSQL
+00005720: 2873 716c 5f73 746d 7429 0a20 2020 2020  (sql_stmt).     
+00005730: 2020 2020 2020 2064 6174 6173 6f75 7263         datasourc
+00005740: 652e 5265 6c65 6173 6552 6573 756c 7453  e.ReleaseResultS
+00005750: 6574 2872 6573 756c 7429 0a20 2020 2020  et(result).     
+00005760: 2020 2065 6c69 6620 6765 6f66 696c 6574     elif geofilet
+00005770: 7970 6520 3d3d 2047 656f 6669 6c65 5479  ype == GeofileTy
+00005780: 7065 2e45 5352 4953 6861 7065 6669 6c65  pe.ESRIShapefile
+00005790: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+000057a0: 6973 6520 5661 6c75 6545 7272 6f72 2866  ise ValueError(f
+000057b0: 2272 656e 616d 655f 6c61 7965 7220 6973  "rename_layer is
+000057c0: 206e 6f74 2070 6f73 7369 626c 6520 666f   not possible fo
+000057d0: 7220 7b67 656f 6669 6c65 7479 7065 7d20  r {geofiletype} 
+000057e0: 6669 6c65 2229 0a20 2020 2020 2020 2065  file").        e
+000057f0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00005800: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
+00005810: 7228 6622 7265 6e61 6d65 5f6c 6179 6572  r(f"rename_layer
+00005820: 2069 7320 6e6f 7420 696d 706c 656d 656e   is not implemen
+00005830: 7465 6420 666f 7220 7b70 6174 682e 7375  ted for {path.su
+00005840: 6666 6978 7d20 6669 6c65 2229 0a20 2020  ffix} file").   
+00005850: 2066 696e 616c 6c79 3a0a 2020 2020 2020   finally:.      
+00005860: 2020 6966 2064 6174 6173 6f75 7263 6520    if datasource 
+00005870: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+00005880: 2020 2020 2020 2020 2064 656c 2064 6174           del dat
+00005890: 6173 6f75 7263 650a 0a0a 6465 6620 7265  asource...def re
+000058a0: 6e61 6d65 5f63 6f6c 756d 6e28 0a20 2020  name_column(.   
+000058b0: 2070 6174 683a 2055 6e69 6f6e 5b73 7472   path: Union[str
+000058c0: 2c20 226f 732e 5061 7468 4c69 6b65 5b41  , "os.PathLike[A
+000058d0: 6e79 5d22 5d2c 0a20 2020 2063 6f6c 756d  ny]"],.    colum
+000058e0: 6e5f 6e61 6d65 3a20 7374 722c 0a20 2020  n_name: str,.   
+000058f0: 206e 6577 5f63 6f6c 756d 6e5f 6e61 6d65   new_column_name
+00005900: 3a20 7374 722c 0a20 2020 206c 6179 6572  : str,.    layer
+00005910: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
+00005920: 3d20 4e6f 6e65 2c0a 293a 0a20 2020 2022  = None,.):.    "
+00005930: 2222 0a20 2020 2052 656e 616d 6520 7468  "".    Rename th
+00005940: 6520 636f 6c75 6d6e 2073 7065 6369 6669  e column specifi
+00005950: 6564 2e0a 0a20 2020 2041 7267 733a 0a20  ed...    Args:. 
+00005960: 2020 2020 2020 2070 6174 6820 2850 6174         path (Pat
+00005970: 684c 696b 6529 3a20 5468 6520 6669 6c65  hLike): The file
+00005980: 2070 6174 682e 0a20 2020 2020 2020 2063   path..        c
+00005990: 6f6c 756d 6e5f 6e61 6d65 2028 7374 7229  olumn_name (str)
+000059a0: 3a20 7468 6520 6375 7272 656e 7420 636f  : the current co
+000059b0: 6c75 6d6e 206e 616d 652e 0a20 2020 2020  lumn name..     
+000059c0: 2020 206e 6577 5f63 6f6c 756d 6e5f 6e61     new_column_na
+000059d0: 6d65 2028 7374 7229 3a20 7468 6520 6e65  me (str): the ne
+000059e0: 7720 636f 6c75 6d6e 206e 616d 652e 0a20  w column name.. 
+000059f0: 2020 2020 2020 206c 6179 6572 2028 4f70         layer (Op
+00005a00: 7469 6f6e 616c 5b73 7472 5d29 3a20 5468  tional[str]): Th
+00005a10: 6520 6c61 7965 7220 6e61 6d65 2e20 4966  e layer name. If
+00005a20: 206e 6f74 2073 7065 6369 6669 6564 2c20   not specified, 
+00005a30: 616e 6420 7468 6572 6520 6973 206f 6e6c  and there is onl
+00005a40: 790a 2020 2020 2020 2020 2020 2020 6f6e  y.            on
+00005a50: 6520 6c61 7965 7220 696e 2074 6865 2066  e layer in the f
+00005a60: 696c 652c 2074 6869 7320 6c61 7965 7220  ile, this layer 
+00005a70: 6973 2075 7365 642e 204f 7468 6572 7769  is used. Otherwi
+00005a80: 7365 2065 7863 6570 7469 6f6e 2e0a 2020  se exception..  
+00005a90: 2020 2222 220a 2020 2020 2320 4368 6563    """.    # Chec
+00005aa0: 6b20 696e 7075 7420 7061 7261 6d65 7465  k input paramete
+00005ab0: 7273 0a20 2020 2070 6174 6820 3d20 5061  rs.    path = Pa
+00005ac0: 7468 2870 6174 6829 0a20 2020 2069 6620  th(path).    if 
+00005ad0: 6c61 7965 7220 6973 204e 6f6e 653a 0a20  layer is None:. 
+00005ae0: 2020 2020 2020 206c 6179 6572 203d 2067         layer = g
+00005af0: 6574 5f6f 6e6c 795f 6c61 7965 7228 7061  et_only_layer(pa
+00005b00: 7468 290a 2020 2020 696e 666f 203d 2067  th).    info = g
+00005b10: 6574 5f6c 6179 6572 696e 666f 2870 6174  et_layerinfo(pat
+00005b20: 6829 0a20 2020 2069 6620 636f 6c75 6d6e  h).    if column
+00005b30: 5f6e 616d 6520 6e6f 7420 696e 2069 6e66  _name not in inf
+00005b40: 6f2e 636f 6c75 6d6e 7320 616e 6420 6e65  o.columns and ne
+00005b50: 775f 636f 6c75 6d6e 5f6e 616d 6520 696e  w_column_name in
+00005b60: 2069 6e66 6f2e 636f 6c75 6d6e 733a 0a20   info.columns:. 
+00005b70: 2020 2020 2020 206c 6f67 6765 722e 696e         logger.in
+00005b80: 666f 280a 2020 2020 2020 2020 2020 2020  fo(.            
+00005b90: 6622 436f 6c75 6d6e 207b 636f 6c75 6d6e  f"Column {column
+00005ba0: 5f6e 616d 657d 2073 6565 6d73 2074 6f20  _name} seems to 
+00005bb0: 6265 2072 656e 616d 6564 2061 6c72 6561  be renamed alrea
+00005bc0: 6479 2074 6f20 7b6e 6577 5f63 6f6c 756d  dy to {new_colum
+00005bd0: 6e5f 6e61 6d65 7d22 0a20 2020 2020 2020  n_name}".       
+00005be0: 2029 0a20 2020 2020 2020 2072 6574 7572   ).        retur
+00005bf0: 6e0a 0a20 2020 2023 204e 6f77 2072 6561  n..    # Now rea
+00005c00: 6c6c 7920 7265 6e61 6d65 0a20 2020 2064  lly rename.    d
+00005c10: 6174 6173 6f75 7263 6520 3d20 4e6f 6e65  atasource = None
+00005c20: 0a20 2020 2067 656f 6669 6c65 7479 7065  .    geofiletype
+00005c30: 203d 2047 656f 6669 6c65 5479 7065 2870   = GeofileType(p
+00005c40: 6174 6829 0a20 2020 2074 7279 3a0a 2020  ath).    try:.  
+00005c50: 2020 2020 2020 6966 2067 656f 6669 6c65        if geofile
+00005c60: 7479 7065 2e69 735f 7370 6174 6961 6c69  type.is_spatiali
+00005c70: 7465 5f62 6173 6564 3a0a 2020 2020 2020  te_based:.      
+00005c80: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
+00005c90: 203d 2067 6461 6c2e 4f70 656e 4578 2873   = gdal.OpenEx(s
+00005ca0: 7472 2870 6174 6829 2c20 6e4f 7065 6e46  tr(path), nOpenF
+00005cb0: 6c61 6773 3d67 6461 6c2e 4f46 5f55 5044  lags=gdal.OF_UPD
+00005cc0: 4154 4529 0a20 2020 2020 2020 2020 2020  ATE).           
+00005cd0: 2073 716c 5f73 746d 7420 3d20 280a 2020   sql_stmt = (.  
+00005ce0: 2020 2020 2020 2020 2020 2020 2020 6627                f'
+00005cf0: 414c 5445 5220 5441 424c 4520 227b 6c61  ALTER TABLE "{la
+00005d00: 7965 727d 2220 270a 2020 2020 2020 2020  yer}" '.        
+00005d10: 2020 2020 2020 2020 6627 5245 4e41 4d45          f'RENAME
+00005d20: 2043 4f4c 554d 4e20 227b 636f 6c75 6d6e   COLUMN "{column
+00005d30: 5f6e 616d 657d 2220 544f 2022 7b6e 6577  _name}" TO "{new
+00005d40: 5f63 6f6c 756d 6e5f 6e61 6d65 7d22 270a  _column_name}"'.
+00005d50: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00005d60: 2020 2020 2020 2020 2020 7265 7375 6c74            result
+00005d70: 203d 2064 6174 6173 6f75 7263 652e 4578   = datasource.Ex
+00005d80: 6563 7574 6553 514c 2873 716c 5f73 746d  ecuteSQL(sql_stm
+00005d90: 7429 0a20 2020 2020 2020 2020 2020 2064  t).            d
+00005da0: 6174 6173 6f75 7263 652e 5265 6c65 6173  atasource.Releas
+00005db0: 6552 6573 756c 7453 6574 2872 6573 756c  eResultSet(resul
+00005dc0: 7429 0a20 2020 2020 2020 2065 6c69 6620  t).        elif 
+00005dd0: 6765 6f66 696c 6574 7970 6520 3d3d 2047  geofiletype == G
+00005de0: 656f 6669 6c65 5479 7065 2e45 5352 4953  eofileType.ESRIS
+00005df0: 6861 7065 6669 6c65 3a0a 2020 2020 2020  hapefile:.      
+00005e00: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00005e10: 6545 7272 6f72 2866 2272 656e 616d 655f  eError(f"rename_
+00005e20: 636f 6c75 6d6e 2069 7320 6e6f 7420 706f  column is not po
+00005e30: 7373 6962 6c65 2066 6f72 207b 6765 6f66  ssible for {geof
+00005e40: 696c 6574 7970 657d 2066 696c 6522 290a  iletype} file").
+00005e50: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00005e60: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00005e70: 5661 6c75 6545 7272 6f72 2866 2272 656e  ValueError(f"ren
+00005e80: 616d 655f 636f 6c75 6d6e 2069 7320 6e6f  ame_column is no
+00005e90: 7420 696d 706c 656d 656e 7465 6420 666f  t implemented fo
+00005ea0: 7220 7b70 6174 682e 7375 6666 6978 7d20  r {path.suffix} 
+00005eb0: 6669 6c65 2229 0a20 2020 2066 696e 616c  file").    final
+00005ec0: 6c79 3a0a 2020 2020 2020 2020 6966 2064  ly:.        if d
+00005ed0: 6174 6173 6f75 7263 6520 6973 206e 6f74  atasource is not
+00005ee0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00005ef0: 2020 2064 656c 2064 6174 6173 6f75 7263     del datasourc
+00005f00: 650a 0a0a 636c 6173 7320 4461 7461 5479  e...class DataTy
+00005f10: 7065 2865 6e75 6d2e 456e 756d 293a 0a20  pe(enum.Enum):. 
+00005f20: 2020 2022 2222 0a20 2020 2054 6869 7320     """.    This 
+00005f30: 656e 756d 2064 6566 696e 6573 2074 6865  enum defines the
+00005f40: 2073 7461 6e64 6172 6420 6461 7461 2074   standard data t
+00005f50: 7970 6573 2074 6861 7420 6361 6e20 6265  ypes that can be
+00005f60: 2075 7365 6420 666f 7220 636f 6c75 6d6e   used for column
+00005f70: 732e 0a20 2020 2022 2222 0a0a 2020 2020  s..    """..    
+00005f80: 5445 5854 203d 2022 5445 5854 220a 2020  TEXT = "TEXT".  
+00005f90: 2020 2222 2243 6f6c 756d 6e20 7769 7468    """Column with
+00005fa0: 2074 6578 7420 6461 7461 3a20 7e20 7374   text data: ~ st
+00005fb0: 7269 6e67 2c20 6368 6172 2c20 7661 7263  ring, char, varc
+00005fc0: 6861 722c 2063 6c6f 622e 2222 220a 2020  har, clob.""".  
+00005fd0: 2020 494e 5445 4745 5220 3d20 2249 4e54    INTEGER = "INT
+00005fe0: 4547 4552 220a 2020 2020 2222 2243 6f6c  EGER".    """Col
+00005ff0: 756d 6e20 7769 7468 2069 6e74 6567 6572  umn with integer
+00006000: 2064 6174 612e 2222 220a 2020 2020 5245   data.""".    RE
+00006010: 414c 203d 2022 5245 414c 220a 2020 2020  AL = "REAL".    
+00006020: 2222 2243 6f6c 756d 6e20 7769 7468 2066  """Column with f
+00006030: 6c6f 6174 696e 6720 706f 696e 7420 6461  loating point da
+00006040: 7461 3a20 7e20 666c 6f61 742c 2064 6f75  ta: ~ float, dou
+00006050: 626c 652e 2222 220a 2020 2020 4441 5445  ble.""".    DATE
+00006060: 203d 2022 4441 5445 220a 2020 2020 2222   = "DATE".    ""
+00006070: 2243 6f6c 756d 6e20 7769 7468 2064 6174  "Column with dat
+00006080: 6520 6461 7461 2e22 2222 0a20 2020 2054  e data.""".    T
+00006090: 494d 4553 5441 4d50 203d 2022 5449 4d45  IMESTAMP = "TIME
+000060a0: 5354 414d 5022 0a20 2020 2022 2222 436f  STAMP".    """Co
+000060b0: 6c75 6d6e 2077 6974 6820 7469 6d65 7374  lumn with timest
+000060c0: 616d 7020 6461 7461 3a20 7e20 6461 7465  amp data: ~ date
+000060d0: 7469 6d65 2e22 2222 0a20 2020 2042 4f4f  time.""".    BOO
+000060e0: 4c45 414e 203d 2022 424f 4f4c 4541 4e22  LEAN = "BOOLEAN"
+000060f0: 0a20 2020 2022 2222 436f 6c75 6d6e 2077  .    """Column w
+00006100: 6974 6820 626f 6f6c 6561 6e20 6461 7461  ith boolean data
+00006110: 2e22 2222 0a20 2020 2042 4c4f 4220 3d20  .""".    BLOB = 
+00006120: 2242 4c4f 4222 0a20 2020 2022 2222 436f  "BLOB".    """Co
+00006130: 6c75 6d6e 2077 6974 6820 6269 6e61 7279  lumn with binary
+00006140: 2064 6174 612e 2222 220a 2020 2020 4e55   data.""".    NU
+00006150: 4d45 5249 4320 3d20 224e 554d 4552 4943  MERIC = "NUMERIC
+00006160: 220a 2020 2020 2222 2243 6f6c 756d 6e20  ".    """Column 
+00006170: 7769 7468 206e 756d 6572 6963 2064 6174  with numeric dat
+00006180: 613a 2065 7861 6374 2064 6563 696d 616c  a: exact decimal
+00006190: 2064 6174 612e 2222 220a 0a0a 6465 6620   data."""...def 
+000061a0: 6164 645f 636f 6c75 6d6e 280a 2020 2020  add_column(.    
+000061b0: 7061 7468 3a20 556e 696f 6e5b 7374 722c  path: Union[str,
+000061c0: 2022 6f73 2e50 6174 684c 696b 655b 416e   "os.PathLike[An
+000061d0: 795d 225d 2c0a 2020 2020 6e61 6d65 3a20  y]"],.    name: 
+000061e0: 7374 722c 0a20 2020 2074 7970 653a 2055  str,.    type: U
+000061f0: 6e69 6f6e 5b44 6174 6154 7970 652c 2073  nion[DataType, s
+00006200: 7472 5d2c 0a20 2020 2065 7870 7265 7373  tr],.    express
+00006210: 696f 6e3a 2055 6e69 6f6e 5b73 7472 2c20  ion: Union[str, 
+00006220: 696e 742c 2066 6c6f 6174 2c20 4e6f 6e65  int, float, None
+00006230: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 6578  ] = None,.    ex
+00006240: 7072 6573 7369 6f6e 5f64 6961 6c65 6374  pression_dialect
+00006250: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
+00006260: 3d20 4e6f 6e65 2c0a 2020 2020 6c61 7965  = None,.    laye
+00006270: 723a 204f 7074 696f 6e61 6c5b 7374 725d  r: Optional[str]
+00006280: 203d 204e 6f6e 652c 0a20 2020 2066 6f72   = None,.    for
+00006290: 6365 5f75 7064 6174 653a 2062 6f6f 6c20  ce_update: bool 
+000062a0: 3d20 4661 6c73 652c 0a20 2020 2077 6964  = False,.    wid
+000062b0: 7468 3a20 4f70 7469 6f6e 616c 5b69 6e74  th: Optional[int
+000062c0: 5d20 3d20 4e6f 6e65 2c0a 293a 0a20 2020  ] = None,.):.   
+000062d0: 2022 2222 0a20 2020 2041 6464 2061 2063   """.    Add a c
+000062e0: 6f6c 756d 6e20 746f 2061 206c 6179 6572  olumn to a layer
+000062f0: 206f 6620 7468 6520 6765 6f66 696c 652e   of the geofile.
+00006300: 0a0a 2020 2020 4172 6773 3a0a 2020 2020  ..    Args:.    
+00006310: 2020 2020 7061 7468 2028 5061 7468 4c69      path (PathLi
+00006320: 6b65 293a 2050 6174 6820 746f 2074 6865  ke): Path to the
+00006330: 2067 656f 6669 6c65 2e0a 2020 2020 2020   geofile..      
+00006340: 2020 6e61 6d65 2028 7374 7229 3a20 4e61    name (str): Na
+00006350: 6d65 2066 6f72 2074 6865 206e 6577 2063  me for the new c
+00006360: 6f6c 756d 6e2e 0a20 2020 2020 2020 2074  olumn..        t
+00006370: 7970 6520 2873 7472 293a 2043 6f6c 756d  ype (str): Colum
+00006380: 6e20 7479 7065 206f 6620 7468 6520 6e65  n type of the ne
+00006390: 7720 636f 6c75 6d6e 2e0a 2020 2020 2020  w column..      
+000063a0: 2020 6578 7072 6573 7369 6f6e 2028 7374    expression (st
+000063b0: 722c 206f 7074 696f 6e61 6c29 3a20 5351  r, optional): SQ
+000063c0: 4c69 7465 2065 7870 7265 7373 696f 6e20  Lite expression 
+000063d0: 746f 2075 7365 2074 6f20 7570 6461 7465  to use to update
+000063e0: 0a20 2020 2020 2020 2020 2020 2074 6865  .            the
+000063f0: 2076 616c 7565 2e20 4465 6661 756c 7473   value. Defaults
+00006400: 2074 6f20 4e6f 6e65 2e0a 2020 2020 2020   to None..      
+00006410: 2020 6578 7072 6573 7369 6f6e 5f64 6961    expression_dia
+00006420: 6c65 6374 2028 7374 722c 206f 7074 696f  lect (str, optio
+00006430: 6e61 6c29 3a20 5351 4c20 6469 616c 6563  nal): SQL dialec
+00006440: 7420 7573 6564 2066 6f72 2074 6865 2065  t used for the e
+00006450: 7870 7265 7373 696f 6e2e 0a20 2020 2020  xpression..     
+00006460: 2020 206c 6179 6572 2028 7374 722c 206f     layer (str, o
+00006470: 7074 696f 6e61 6c29 3a20 5468 6520 6c61  ptional): The la
+00006480: 7965 7220 6e61 6d65 2e20 4966 204e 6f6e  yer name. If Non
+00006490: 6520 616e 6420 7468 6520 6765 6f66 696c  e and the geofil
+000064a0: 650a 2020 2020 2020 2020 2020 2020 6861  e.            ha
+000064b0: 7320 6f6e 6c79 206f 6e65 206c 6179 6572  s only one layer
+000064c0: 2c20 7468 6174 206c 6179 6572 2069 7320  , that layer is 
+000064d0: 7573 6564 2e20 4465 6661 756c 7473 2074  used. Defaults t
+000064e0: 6f20 4e6f 6e65 2e0a 2020 2020 2020 2020  o None..        
+000064f0: 666f 7263 655f 7570 6461 7465 2028 626f  force_update (bo
+00006500: 6f6c 2c20 6f70 7469 6f6e 616c 293a 2049  ol, optional): I
+00006510: 6620 7468 6520 636f 6c75 6d6e 2061 6c72  f the column alr
+00006520: 6561 6479 2065 7869 7374 732c 2065 7865  eady exists, exe
+00006530: 6375 7465 0a20 2020 2020 2020 2020 2020  cute.           
+00006540: 2074 6865 2075 7064 6174 6520 616e 7977   the update anyw
+00006550: 6179 2e20 4465 6661 756c 7473 2074 6f20  ay. Defaults to 
+00006560: 4661 6c73 652e 0a20 2020 2020 2020 2077  False..        w
+00006570: 6964 7468 2028 696e 742c 206f 7074 696f  idth (int, optio
+00006580: 6e61 6c29 3a20 7468 6520 7769 6474 6820  nal): the width 
+00006590: 6f66 2074 6865 2066 6965 6c64 2e0a 0a20  of the field... 
+000065a0: 2020 2052 6169 7365 733a 0a20 2020 2020     Raises:.     
+000065b0: 2020 2065 783a 205b 6465 7363 7269 7074     ex: [descript
+000065c0: 696f 6e5d 0a20 2020 2022 2222 0a20 2020  ion].    """.   
+000065d0: 2023 2049 6e69 740a 2020 2020 6966 2069   # Init.    if i
+000065e0: 7369 6e73 7461 6e63 6528 7479 7065 2c20  sinstance(type, 
+000065f0: 4461 7461 5479 7065 293a 0a20 2020 2020  DataType):.     
+00006600: 2020 2074 7970 655f 7374 7220 3d20 7479     type_str = ty
+00006610: 7065 2e76 616c 7565 0a20 2020 2065 6c73  pe.value.    els
+00006620: 653a 0a20 2020 2020 2020 2074 7970 655f  e:.        type_
+00006630: 6c6f 7765 7220 3d20 7479 7065 2e6c 6f77  lower = type.low
+00006640: 6572 2829 0a20 2020 2020 2020 2069 6620  er().        if 
+00006650: 7479 7065 5f6c 6f77 6572 203d 3d20 2273  type_lower == "s
+00006660: 7472 696e 6722 3a0a 2020 2020 2020 2020  tring":.        
+00006670: 2020 2020 2320 544f 444f 3a20 7468 696e      # TODO: thin
+00006680: 6b20 7768 6574 6865 7220 6265 696e 6720  k whether being 
+00006690: 666c 6578 6962 6c65 2068 6572 6520 6973  flexible here is
+000066a0: 2061 2067 6f6f 6420 6964 6561 2e2e 2e0a   a good idea....
+000066b0: 2020 2020 2020 2020 2020 2020 7479 7065              type
+000066c0: 5f73 7472 203d 2022 5445 5854 220a 2020  _str = "TEXT".  
+000066d0: 2020 2020 2020 656c 6966 2074 7970 655f        elif type_
+000066e0: 6c6f 7765 7220 3d3d 2022 6269 6e61 7279  lower == "binary
+000066f0: 223a 0a20 2020 2020 2020 2020 2020 2074  ":.            t
+00006700: 7970 655f 7374 7220 3d20 2242 4c4f 4222  ype_str = "BLOB"
+00006710: 0a20 2020 2020 2020 2065 6c69 6620 7479  .        elif ty
+00006720: 7065 5f6c 6f77 6572 203d 3d20 2274 696d  pe_lower == "tim
+00006730: 6522 3a0a 2020 2020 2020 2020 2020 2020  e":.            
+00006740: 7479 7065 5f73 7472 203d 2022 4441 5445  type_str = "DATE
+00006750: 5449 4d45 220a 2020 2020 2020 2020 656c  TIME".        el
+00006760: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00006770: 7479 7065 5f73 7472 203d 2074 7970 650a  type_str = type.
+00006780: 2020 2020 7061 7468 203d 2050 6174 6828      path = Path(
+00006790: 7061 7468 290a 2020 2020 6966 206c 6179  path).    if lay
+000067a0: 6572 2069 7320 4e6f 6e65 3a0a 2020 2020  er is None:.    
+000067b0: 2020 2020 6c61 7965 7220 3d20 6765 745f      layer = get_
+000067c0: 6f6e 6c79 5f6c 6179 6572 2870 6174 6829  only_layer(path)
+000067d0: 0a20 2020 206c 6179 6572 696e 666f 5f6f  .    layerinfo_o
+000067e0: 7269 6720 3d20 6765 745f 6c61 7965 7269  rig = get_layeri
+000067f0: 6e66 6f28 7061 7468 2c20 6c61 7965 7229  nfo(path, layer)
+00006800: 0a0a 2020 2020 2320 476f 210a 2020 2020  ..    # Go!.    
+00006810: 6461 7461 736f 7572 6365 203d 204e 6f6e  datasource = Non
+00006820: 650a 2020 2020 7472 793a 0a20 2020 2020  e.    try:.     
+00006830: 2020 2023 2049 6620 636f 6c75 6d6e 2064     # If column d
+00006840: 6f65 736e 2774 2065 7869 7374 2079 6574  oesn't exist yet
+00006850: 2c20 6372 6561 7465 2069 740a 2020 2020  , create it.    
+00006860: 2020 2020 636f 6c75 6d6e 735f 7570 7065      columns_uppe
+00006870: 7220 3d20 5b63 6f6c 756d 6e2e 7570 7065  r = [column.uppe
+00006880: 7228 2920 666f 7220 636f 6c75 6d6e 2069  r() for column i
+00006890: 6e20 6c61 7965 7269 6e66 6f5f 6f72 6967  n layerinfo_orig
+000068a0: 2e63 6f6c 756d 6e73 5d0a 2020 2020 2020  .columns].      
+000068b0: 2020 6966 206e 616d 652e 7570 7065 7228    if name.upper(
+000068c0: 2920 6e6f 7420 696e 2063 6f6c 756d 6e73  ) not in columns
+000068d0: 5f75 7070 6572 3a0a 2020 2020 2020 2020  _upper:.        
+000068e0: 2020 2020 7769 6474 685f 7374 7220 3d20      width_str = 
+000068f0: 6622 287b 7769 6474 687d 2922 2069 6620  f"({width})" if 
+00006900: 7769 6474 6820 6973 206e 6f74 204e 6f6e  width is not Non
+00006910: 6520 656c 7365 2022 220a 2020 2020 2020  e else "".      
+00006920: 2020 2020 2020 7371 6c5f 7374 6d74 203d        sql_stmt =
+00006930: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
+00006940: 2020 2066 2741 4c54 4552 2054 4142 4c45     f'ALTER TABLE
+00006950: 2022 7b6c 6179 6572 7d22 2041 4444 2043   "{layer}" ADD C
+00006960: 4f4c 554d 4e20 227b 6e61 6d65 7d22 207b  OLUMN "{name}" {
+00006970: 7479 7065 5f73 7472 7d7b 7769 6474 685f  type_str}{width_
+00006980: 7374 727d 270a 2020 2020 2020 2020 2020  str}'.          
+00006990: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+000069a0: 6461 7461 736f 7572 6365 203d 2067 6461  datasource = gda
+000069b0: 6c2e 4f70 656e 4578 2873 7472 2870 6174  l.OpenEx(str(pat
+000069c0: 6829 2c20 6e4f 7065 6e46 6c61 6773 3d67  h), nOpenFlags=g
+000069d0: 6461 6c2e 4f46 5f55 5044 4154 4529 0a20  dal.OF_UPDATE). 
+000069e0: 2020 2020 2020 2020 2020 2072 6573 756c             resul
+000069f0: 7420 3d20 6461 7461 736f 7572 6365 2e45  t = datasource.E
+00006a00: 7865 6375 7465 5351 4c28 7371 6c5f 7374  xecuteSQL(sql_st
+00006a10: 6d74 290a 2020 2020 2020 2020 2020 2020  mt).            
+00006a20: 6461 7461 736f 7572 6365 2e52 656c 6561  datasource.Relea
+00006a30: 7365 5265 7375 6c74 5365 7428 7265 7375  seResultSet(resu
+00006a40: 6c74 290a 2020 2020 2020 2020 656c 7365  lt).        else
+00006a50: 3a0a 2020 2020 2020 2020 2020 2020 6c6f  :.            lo
+00006a60: 6767 6572 2e77 6172 6e69 6e67 2866 2243  gger.warning(f"C
+00006a70: 6f6c 756d 6e20 7b6e 616d 657d 2065 7869  olumn {name} exi
+00006a80: 7374 6564 2061 6c72 6561 6479 2069 6e20  sted already in 
+00006a90: 7b70 6174 687d 2c20 6c61 7965 7220 7b6c  {path}, layer {l
+00006aa0: 6179 6572 7d22 290a 0a20 2020 2020 2020  ayer}")..       
+00006ab0: 2023 2049 6620 616e 2065 7870 7265 7373   # If an express
+00006ac0: 696f 6e20 7761 7320 7072 6f76 6964 6564  ion was provided
+00006ad0: 2061 6e64 2075 7064 6174 6520 6361 6e20   and update can 
+00006ae0: 6265 2064 6f6e 652c 2067 6f20 666f 7220  be done, go for 
+00006af0: 6974 2e2e 2e0a 2020 2020 2020 2020 6966  it....        if
+00006b00: 2065 7870 7265 7373 696f 6e20 6973 206e   expression is n
+00006b10: 6f74 204e 6f6e 6520 616e 6420 280a 2020  ot None and (.  
+00006b20: 2020 2020 2020 2020 2020 6e61 6d65 206e            name n
+00006b30: 6f74 2069 6e20 6c61 7965 7269 6e66 6f5f  ot in layerinfo_
+00006b40: 6f72 6967 2e63 6f6c 756d 6e73 206f 7220  orig.columns or 
+00006b50: 666f 7263 655f 7570 6461 7465 2069 7320  force_update is 
+00006b60: 5472 7565 0a20 2020 2020 2020 2029 3a0a  True.        ):.
+00006b70: 2020 2020 2020 2020 2020 2020 6966 2064              if d
+00006b80: 6174 6173 6f75 7263 6520 6973 204e 6f6e  atasource is Non
+00006b90: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00006ba0: 2020 2064 6174 6173 6f75 7263 6520 3d20     datasource = 
+00006bb0: 6764 616c 2e4f 7065 6e45 7828 7374 7228  gdal.OpenEx(str(
+00006bc0: 7061 7468 292c 206e 4f70 656e 466c 6167  path), nOpenFlag
+00006bd0: 733d 6764 616c 2e4f 465f 5550 4441 5445  s=gdal.OF_UPDATE
+00006be0: 290a 2020 2020 2020 2020 2020 2020 7371  ).            sq
+00006bf0: 6c5f 7374 6d74 203d 2066 2755 5044 4154  l_stmt = f'UPDAT
+00006c00: 4520 227b 6c61 7965 727d 2220 5345 5420  E "{layer}" SET 
+00006c10: 227b 6e61 6d65 7d22 203d 207b 6578 7072  "{name}" = {expr
+00006c20: 6573 7369 6f6e 7d27 0a20 2020 2020 2020  ession}'.       
+00006c30: 2020 2020 2072 6573 756c 7420 3d20 6461       result = da
+00006c40: 7461 736f 7572 6365 2e45 7865 6375 7465  tasource.Execute
+00006c50: 5351 4c28 7371 6c5f 7374 6d74 2c20 6469  SQL(sql_stmt, di
+00006c60: 616c 6563 743d 6578 7072 6573 7369 6f6e  alect=expression
+00006c70: 5f64 6961 6c65 6374 290a 2020 2020 2020  _dialect).      
+00006c80: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
+00006c90: 2e52 656c 6561 7365 5265 7375 6c74 5365  .ReleaseResultSe
+00006ca0: 7428 7265 7375 6c74 290a 2020 2020 6669  t(result).    fi
+00006cb0: 6e61 6c6c 793a 0a20 2020 2020 2020 2069  nally:.        i
+00006cc0: 6620 6461 7461 736f 7572 6365 2069 7320  f datasource is 
+00006cd0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+00006ce0: 2020 2020 2020 6465 6c20 6461 7461 736f        del dataso
+00006cf0: 7572 6365 0a0a 0a64 6566 2064 726f 705f  urce...def drop_
+00006d00: 636f 6c75 6d6e 280a 2020 2020 7061 7468  column(.    path
+00006d10: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
+00006d20: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
+00006d30: 2c20 636f 6c75 6d6e 5f6e 616d 653a 2073  , column_name: s
+00006d40: 7472 2c20 6c61 7965 723a 204f 7074 696f  tr, layer: Optio
+00006d50: 6e61 6c5b 7374 725d 203d 204e 6f6e 650a  nal[str] = None.
+00006d60: 293a 0a20 2020 2022 2222 0a20 2020 2044  ):.    """.    D
+00006d70: 726f 7020 7468 6520 636f 6c75 6d6e 2073  rop the column s
+00006d80: 7065 6369 6669 6564 2e0a 0a20 2020 2041  pecified...    A
+00006d90: 7267 733a 0a20 2020 2020 2020 2070 6174  rgs:.        pat
+00006da0: 6820 2850 6174 684c 696b 6529 3a20 5468  h (PathLike): Th
+00006db0: 6520 6669 6c65 2070 6174 682e 0a20 2020  e file path..   
+00006dc0: 2020 2020 2063 6f6c 756d 6e5f 6e61 6d65       column_name
+00006dd0: 2028 7374 7229 3a20 7468 6520 636f 6c75   (str): the colu
+00006de0: 6d6e 206e 616d 652e 0a20 2020 2020 2020  mn name..       
+00006df0: 206c 6179 6572 2028 4f70 7469 6f6e 616c   layer (Optional
+00006e00: 5b73 7472 5d29 3a20 5468 6520 6c61 7965  [str]): The laye
+00006e10: 7220 6e61 6d65 2e20 4966 206e 6f74 2073  r name. If not s
+00006e20: 7065 6369 6669 6564 2c20 616e 6420 7468  pecified, and th
+00006e30: 6572 6520 6973 206f 6e6c 790a 2020 2020  ere is only.    
+00006e40: 2020 2020 2020 2020 6f6e 6520 6c61 7965          one laye
+00006e50: 7220 696e 2074 6865 2066 696c 652c 2074  r in the file, t
+00006e60: 6869 7320 6c61 7965 7220 6973 2075 7365  his layer is use
+00006e70: 642e 204f 7468 6572 7769 7365 2061 2056  d. Otherwise a V
+00006e80: 616c 7565 4572 726f 7220 6973 0a20 2020  alueError is.   
+00006e90: 2020 2020 2020 2020 2072 6169 7365 642e           raised.
+00006ea0: 0a20 2020 2022 2222 0a20 2020 2023 2043  .    """.    # C
+00006eb0: 6865 636b 2069 6e70 7574 2070 6172 616d  heck input param
+00006ec0: 6574 6572 730a 2020 2020 7061 7468 203d  eters.    path =
+00006ed0: 2050 6174 6828 7061 7468 290a 2020 2020   Path(path).    
+00006ee0: 6966 206c 6179 6572 2069 7320 4e6f 6e65  if layer is None
+00006ef0: 3a0a 2020 2020 2020 2020 6c61 7965 7220  :.        layer 
+00006f00: 3d20 6765 745f 6f6e 6c79 5f6c 6179 6572  = get_only_layer
+00006f10: 2870 6174 6829 0a20 2020 2069 6e66 6f20  (path).    info 
+00006f20: 3d20 6765 745f 6c61 7965 7269 6e66 6f28  = get_layerinfo(
+00006f30: 7061 7468 2c20 6c61 7965 7229 0a20 2020  path, layer).   
+00006f40: 2069 6620 636f 6c75 6d6e 5f6e 616d 6520   if column_name 
+00006f50: 6e6f 7420 696e 2069 6e66 6f2e 636f 6c75  not in info.colu
+00006f60: 6d6e 733a 0a20 2020 2020 2020 206c 6f67  mns:.        log
+00006f70: 6765 722e 696e 666f 2866 2243 6f6c 756d  ger.info(f"Colum
+00006f80: 6e20 7b63 6f6c 756d 6e5f 6e61 6d65 7d20  n {column_name} 
+00006f90: 6e6f 7420 7072 6573 656e 7420 736f 2063  not present so c
+00006fa0: 616e 6e6f 7420 6265 2064 726f 7070 6564  annot be dropped
+00006fb0: 2e22 290a 2020 2020 2020 2020 7265 7475  .").        retu
+00006fc0: 726e 0a0a 2020 2020 2320 4e6f 7720 7265  rn..    # Now re
+00006fd0: 616c 6c79 2072 656e 616d 650a 2020 2020  ally rename.    
+00006fe0: 6461 7461 736f 7572 6365 203d 204e 6f6e  datasource = Non
+00006ff0: 650a 2020 2020 7472 793a 0a20 2020 2020  e.    try:.     
+00007000: 2020 2064 6174 6173 6f75 7263 6520 3d20     datasource = 
+00007010: 6764 616c 2e4f 7065 6e45 7828 7374 7228  gdal.OpenEx(str(
+00007020: 7061 7468 292c 206e 4f70 656e 466c 6167  path), nOpenFlag
+00007030: 733d 6764 616c 2e4f 465f 5550 4441 5445  s=gdal.OF_UPDATE
+00007040: 290a 2020 2020 2020 2020 7371 6c5f 7374  ).        sql_st
+00007050: 6d74 203d 2066 2741 4c54 4552 2054 4142  mt = f'ALTER TAB
+00007060: 4c45 2022 7b6c 6179 6572 7d22 2044 524f  LE "{layer}" DRO
+00007070: 5020 434f 4c55 4d4e 2022 7b63 6f6c 756d  P COLUMN "{colum
+00007080: 6e5f 6e61 6d65 7d22 270a 2020 2020 2020  n_name}"'.      
+00007090: 2020 7265 7375 6c74 203d 2064 6174 6173    result = datas
+000070a0: 6f75 7263 652e 4578 6563 7574 6553 514c  ource.ExecuteSQL
+000070b0: 2873 716c 5f73 746d 7429 0a20 2020 2020  (sql_stmt).     
+000070c0: 2020 2064 6174 6173 6f75 7263 652e 5265     datasource.Re
+000070d0: 6c65 6173 6552 6573 756c 7453 6574 2872  leaseResultSet(r
+000070e0: 6573 756c 7429 0a20 2020 2066 696e 616c  esult).    final
+000070f0: 6c79 3a0a 2020 2020 2020 2020 6966 2064  ly:.        if d
+00007100: 6174 6173 6f75 7263 6520 6973 206e 6f74  atasource is not
+00007110: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00007120: 2020 2064 656c 2064 6174 6173 6f75 7263     del datasourc
+00007130: 650a 0a0a 6465 6620 7570 6461 7465 5f63  e...def update_c
+00007140: 6f6c 756d 6e28 0a20 2020 2070 6174 683a  olumn(.    path:
+00007150: 2055 6e69 6f6e 5b73 7472 2c20 226f 732e   Union[str, "os.
+00007160: 5061 7468 4c69 6b65 5b41 6e79 5d22 5d2c  PathLike[Any]"],
+00007170: 0a20 2020 206e 616d 653a 2073 7472 2c0a  .    name: str,.
+00007180: 2020 2020 6578 7072 6573 7369 6f6e 3a20      expression: 
+00007190: 7374 722c 0a20 2020 206c 6179 6572 3a20  str,.    layer: 
+000071a0: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
+000071b0: 4e6f 6e65 2c0a 2020 2020 7768 6572 653a  None,.    where:
+000071c0: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
+000071d0: 204e 6f6e 652c 0a29 3a0a 2020 2020 2222   None,.):.    ""
+000071e0: 220a 2020 2020 5570 6461 7465 2061 2063  ".    Update a c
+000071f0: 6f6c 756d 6e20 6672 6f6d 2061 206c 6179  olumn from a lay
+00007200: 6572 206f 6620 7468 6520 6765 6f66 696c  er of the geofil
+00007210: 652e 0a0a 2020 2020 4172 6773 3a0a 2020  e...    Args:.  
+00007220: 2020 2020 2020 7061 7468 2028 5061 7468        path (Path
+00007230: 4c69 6b65 293a 2050 6174 6820 746f 2074  Like): Path to t
+00007240: 6865 2067 656f 6669 6c65 0a20 2020 2020  he geofile.     
+00007250: 2020 206e 616d 6520 2873 7472 293a 204e     name (str): N
+00007260: 616d 6520 666f 7220 7468 6520 6e65 7720  ame for the new 
+00007270: 636f 6c75 6d6e 0a20 2020 2020 2020 2065  column.        e
+00007280: 7870 7265 7373 696f 6e20 2873 7472 293a  xpression (str):
+00007290: 2053 514c 6974 6520 6578 7072 6573 7369   SQLite expressi
+000072a0: 6f6e 2074 6f20 7573 6520 746f 2075 7064  on to use to upd
+000072b0: 6174 650a 2020 2020 2020 2020 2020 2020  ate.            
+000072c0: 7468 6520 7661 6c75 652e 0a20 2020 2020  the value..     
+000072d0: 2020 206c 6179 6572 2028 7374 722c 206f     layer (str, o
+000072e0: 7074 696f 6e61 6c29 3a20 5468 6520 6c61  ptional): The la
+000072f0: 7965 7220 6e61 6d65 2e20 4966 204e 6f6e  yer name. If Non
+00007300: 6520 616e 6420 7468 6520 6765 6f66 696c  e and the geofil
+00007310: 650a 2020 2020 2020 2020 2020 2020 6861  e.            ha
+00007320: 7320 6f6e 6c79 206f 6e65 206c 6179 6572  s only one layer
+00007330: 2c20 7468 6174 206c 6179 6572 2069 7320  , that layer is 
+00007340: 7573 6564 2e20 4465 6661 756c 7473 2074  used. Defaults t
+00007350: 6f20 4e6f 6e65 2e0a 2020 2020 2020 2020  o None..        
+00007360: 6c61 7965 7220 2873 7472 2c20 6f70 7469  layer (str, opti
+00007370: 6f6e 616c 293a 2053 514c 2077 6865 7265  onal): SQL where
+00007380: 2063 6c61 7573 6520 746f 2072 6573 7472   clause to restr
+00007390: 6963 7420 7468 6520 726f 7773 2074 6861  ict the rows tha
+000073a0: 7420 7769 6c6c 0a20 2020 2020 2020 2020  t will.         
+000073b0: 2020 2062 6520 7570 6461 7465 642e 2044     be updated. D
+000073c0: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
+000073d0: 0a0a 2020 2020 5261 6973 6573 3a0a 2020  ..    Raises:.  
+000073e0: 2020 2020 2020 5661 6c75 6545 7272 6f72        ValueError
+000073f0: 3a20 616e 2069 6e76 616c 6964 2070 6172  : an invalid par
+00007400: 616d 6574 6572 2076 616c 7565 2077 6173  ameter value was
+00007410: 2070 6173 7365 642e 0a20 2020 2022 2222   passed..    """
+00007420: 0a0a 2020 2020 2320 496e 6974 0a20 2020  ..    # Init.   
+00007430: 2070 6174 6820 3d20 5061 7468 2870 6174   path = Path(pat
+00007440: 6829 0a20 2020 2069 6620 6c61 7965 7220  h).    if layer 
+00007450: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+00007460: 206c 6179 6572 203d 2067 6574 5f6f 6e6c   layer = get_onl
+00007470: 795f 6c61 7965 7228 7061 7468 290a 2020  y_layer(path).  
+00007480: 2020 6c61 7965 7269 6e66 6f5f 6f72 6967    layerinfo_orig
+00007490: 203d 2067 6574 5f6c 6179 6572 696e 666f   = get_layerinfo
+000074a0: 2870 6174 682c 206c 6179 6572 290a 2020  (path, layer).  
+000074b0: 2020 636f 6c75 6d6e 735f 7570 7065 7220    columns_upper 
+000074c0: 3d20 5b63 6f6c 756d 6e2e 7570 7065 7228  = [column.upper(
+000074d0: 2920 666f 7220 636f 6c75 6d6e 2069 6e20  ) for column in 
+000074e0: 6c61 7965 7269 6e66 6f5f 6f72 6967 2e63  layerinfo_orig.c
+000074f0: 6f6c 756d 6e73 5d0a 2020 2020 6966 206e  olumns].    if n
+00007500: 616d 652e 7570 7065 7228 2920 6e6f 7420  ame.upper() not 
+00007510: 696e 2063 6f6c 756d 6e73 5f75 7070 6572  in columns_upper
+00007520: 3a0a 2020 2020 2020 2020 2320 4966 2063  :.        # If c
+00007530: 6f6c 756d 6e20 646f 6573 6e27 7420 6578  olumn doesn't ex
+00007540: 6973 7420 7965 742c 2065 7272 6f72 210a  ist yet, error!.
+00007550: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+00007560: 6c75 6545 7272 6f72 2866 2243 6f6c 756d  lueError(f"Colum
+00007570: 6e20 7b6e 616d 657d 2064 6f65 736e 2774  n {name} doesn't
+00007580: 2065 7869 7374 2069 6e20 7b70 6174 687d   exist in {path}
+00007590: 2c20 6c61 7965 7220 7b6c 6179 6572 7d22  , layer {layer}"
+000075a0: 290a 0a20 2020 2023 2047 6f21 0a20 2020  )..    # Go!.   
+000075b0: 2064 6174 6173 6f75 7263 6520 3d20 4e6f   datasource = No
+000075c0: 6e65 0a20 2020 2074 7279 3a0a 2020 2020  ne.    try:.    
+000075d0: 2020 2020 6461 7461 736f 7572 6365 203d      datasource =
+000075e0: 2067 6461 6c2e 4f70 656e 4578 2873 7472   gdal.OpenEx(str
+000075f0: 2870 6174 6829 2c20 6e4f 7065 6e46 6c61  (path), nOpenFla
+00007600: 6773 3d67 6461 6c2e 4f46 5f55 5044 4154  gs=gdal.OF_UPDAT
+00007610: 4529 0a20 2020 2020 2020 2073 716c 6974  E).        sqlit
+00007620: 655f 7374 6d74 203d 2066 2755 5044 4154  e_stmt = f'UPDAT
+00007630: 4520 227b 6c61 7965 727d 2220 5345 5420  E "{layer}" SET 
+00007640: 227b 6e61 6d65 7d22 203d 207b 6578 7072  "{name}" = {expr
+00007650: 6573 7369 6f6e 7d27 0a20 2020 2020 2020  ession}'.       
+00007660: 2069 6620 7768 6572 6520 6973 206e 6f74   if where is not
+00007670: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00007680: 2020 2073 716c 6974 655f 7374 6d74 202b     sqlite_stmt +
+00007690: 3d20 6622 5c6e 2057 4845 5245 207b 7768  = f"\n WHERE {wh
+000076a0: 6572 657d 220a 2020 2020 2020 2020 7265  ere}".        re
+000076b0: 7375 6c74 203d 2064 6174 6173 6f75 7263  sult = datasourc
+000076c0: 652e 4578 6563 7574 6553 514c 2873 716c  e.ExecuteSQL(sql
+000076d0: 6974 655f 7374 6d74 2c20 6469 616c 6563  ite_stmt, dialec
+000076e0: 743d 2253 514c 4954 4522 290a 2020 2020  t="SQLITE").    
+000076f0: 2020 2020 6461 7461 736f 7572 6365 2e52      datasource.R
+00007700: 656c 6561 7365 5265 7375 6c74 5365 7428  eleaseResultSet(
+00007710: 7265 7375 6c74 290a 2020 2020 6669 6e61  result).    fina
+00007720: 6c6c 793a 0a20 2020 2020 2020 2069 6620  lly:.        if 
+00007730: 6461 7461 736f 7572 6365 2069 7320 6e6f  datasource is no
+00007740: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
+00007750: 2020 2020 6465 6c20 6461 7461 736f 7572      del datasour
+00007760: 6365 0a0a 0a64 6566 2072 6561 645f 6669  ce...def read_fi
+00007770: 6c65 280a 2020 2020 7061 7468 3a20 556e  le(.    path: Un
 00007780: 696f 6e5b 7374 722c 2022 6f73 2e50 6174  ion[str, "os.Pat
-00007790: 684c 696b 655b 416e 795d 225d 2c0d 0a20  hLike[Any]"],.. 
-000077a0: 2020 206e 616d 653a 2073 7472 2c0d 0a20     name: str,.. 
-000077b0: 2020 2065 7870 7265 7373 696f 6e3a 2073     expression: s
-000077c0: 7472 2c0d 0a20 2020 206c 6179 6572 3a20  tr,..    layer: 
-000077d0: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
-000077e0: 4e6f 6e65 2c0d 0a20 2020 2077 6865 7265  None,..    where
-000077f0: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
-00007800: 3d20 4e6f 6e65 2c0d 0a29 3a0d 0a20 2020  = None,..):..   
-00007810: 2022 2222 0d0a 2020 2020 5570 6461 7465   """..    Update
-00007820: 2061 2063 6f6c 756d 6e20 6672 6f6d 2061   a column from a
-00007830: 206c 6179 6572 206f 6620 7468 6520 6765   layer of the ge
-00007840: 6f66 696c 652e 0d0a 0d0a 2020 2020 4172  ofile.....    Ar
-00007850: 6773 3a0d 0a20 2020 2020 2020 2070 6174  gs:..        pat
-00007860: 6820 2850 6174 684c 696b 6529 3a20 5061  h (PathLike): Pa
-00007870: 7468 2074 6f20 7468 6520 6765 6f66 696c  th to the geofil
-00007880: 650d 0a20 2020 2020 2020 206e 616d 6520  e..        name 
-00007890: 2873 7472 293a 204e 616d 6520 666f 7220  (str): Name for 
-000078a0: 7468 6520 6e65 7720 636f 6c75 6d6e 0d0a  the new column..
-000078b0: 2020 2020 2020 2020 6578 7072 6573 7369          expressi
-000078c0: 6f6e 2028 7374 7229 3a20 5351 4c69 7465  on (str): SQLite
-000078d0: 2065 7870 7265 7373 696f 6e20 746f 2075   expression to u
-000078e0: 7365 2074 6f20 7570 6461 7465 0d0a 2020  se to update..  
-000078f0: 2020 2020 2020 2020 2020 7468 6520 7661            the va
-00007900: 6c75 652e 0d0a 2020 2020 2020 2020 6c61  lue...        la
-00007910: 7965 7220 2873 7472 2c20 6f70 7469 6f6e  yer (str, option
-00007920: 616c 293a 2054 6865 206c 6179 6572 206e  al): The layer n
-00007930: 616d 652e 2049 6620 4e6f 6e65 2061 6e64  ame. If None and
-00007940: 2074 6865 2067 656f 6669 6c65 0d0a 2020   the geofile..  
-00007950: 2020 2020 2020 2020 2020 6861 7320 6f6e            has on
-00007960: 6c79 206f 6e65 206c 6179 6572 2c20 7468  ly one layer, th
-00007970: 6174 206c 6179 6572 2069 7320 7573 6564  at layer is used
-00007980: 2e20 4465 6661 756c 7473 2074 6f20 4e6f  . Defaults to No
-00007990: 6e65 2e0d 0a20 2020 2020 2020 206c 6179  ne...        lay
-000079a0: 6572 2028 7374 722c 206f 7074 696f 6e61  er (str, optiona
-000079b0: 6c29 3a20 5351 4c20 7768 6572 6520 636c  l): SQL where cl
-000079c0: 6175 7365 2074 6f20 7265 7374 7269 6374  ause to restrict
-000079d0: 2074 6865 2072 6f77 7320 7468 6174 2077   the rows that w
-000079e0: 696c 6c0d 0a20 2020 2020 2020 2020 2020  ill..           
-000079f0: 2062 6520 7570 6461 7465 642e 2044 6566   be updated. Def
-00007a00: 6175 6c74 7320 746f 204e 6f6e 652e 0d0a  aults to None...
-00007a10: 0d0a 2020 2020 5261 6973 6573 3a0d 0a20  ..    Raises:.. 
-00007a20: 2020 2020 2020 2056 616c 7565 4572 726f         ValueErro
-00007a30: 723a 2061 6e20 696e 7661 6c69 6420 7061  r: an invalid pa
-00007a40: 7261 6d65 7465 7220 7661 6c75 6520 7761  rameter value wa
-00007a50: 7320 7061 7373 6564 2e0d 0a20 2020 2022  s passed...    "
-00007a60: 2222 0d0a 0d0a 2020 2020 2320 496e 6974  ""....    # Init
-00007a70: 0d0a 2020 2020 7061 7468 203d 2050 6174  ..    path = Pat
-00007a80: 6828 7061 7468 290d 0a20 2020 2069 6620  h(path)..    if 
-00007a90: 6c61 7965 7220 6973 204e 6f6e 653a 0d0a  layer is None:..
-00007aa0: 2020 2020 2020 2020 6c61 7965 7220 3d20          layer = 
-00007ab0: 6765 745f 6f6e 6c79 5f6c 6179 6572 2870  get_only_layer(p
-00007ac0: 6174 6829 0d0a 2020 2020 6c61 7965 7269  ath)..    layeri
-00007ad0: 6e66 6f5f 6f72 6967 203d 2067 6574 5f6c  nfo_orig = get_l
-00007ae0: 6179 6572 696e 666f 2870 6174 682c 206c  ayerinfo(path, l
-00007af0: 6179 6572 290d 0a20 2020 2063 6f6c 756d  ayer)..    colum
-00007b00: 6e73 5f75 7070 6572 203d 205b 636f 6c75  ns_upper = [colu
-00007b10: 6d6e 2e75 7070 6572 2829 2066 6f72 2063  mn.upper() for c
-00007b20: 6f6c 756d 6e20 696e 206c 6179 6572 696e  olumn in layerin
-00007b30: 666f 5f6f 7269 672e 636f 6c75 6d6e 735d  fo_orig.columns]
-00007b40: 0d0a 2020 2020 6966 206e 616d 652e 7570  ..    if name.up
-00007b50: 7065 7228 2920 6e6f 7420 696e 2063 6f6c  per() not in col
-00007b60: 756d 6e73 5f75 7070 6572 3a0d 0a20 2020  umns_upper:..   
-00007b70: 2020 2020 2023 2049 6620 636f 6c75 6d6e       # If column
-00007b80: 2064 6f65 736e 2774 2065 7869 7374 2079   doesn't exist y
-00007b90: 6574 2c20 6572 726f 7221 0d0a 2020 2020  et, error!..    
-00007ba0: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-00007bb0: 7272 6f72 2866 2243 6f6c 756d 6e20 7b6e  rror(f"Column {n
-00007bc0: 616d 657d 2064 6f65 736e 2774 2065 7869  ame} doesn't exi
-00007bd0: 7374 2069 6e20 7b70 6174 687d 2c20 6c61  st in {path}, la
-00007be0: 7965 7220 7b6c 6179 6572 7d22 290d 0a0d  yer {layer}")...
-00007bf0: 0a20 2020 2023 2047 6f21 0d0a 2020 2020  .    # Go!..    
-00007c00: 6461 7461 736f 7572 6365 203d 204e 6f6e  datasource = Non
-00007c10: 650d 0a20 2020 2074 7279 3a0d 0a20 2020  e..    try:..   
-00007c20: 2020 2020 2064 6174 6173 6f75 7263 6520       datasource 
-00007c30: 3d20 6764 616c 2e4f 7065 6e45 7828 7374  = gdal.OpenEx(st
-00007c40: 7228 7061 7468 292c 206e 4f70 656e 466c  r(path), nOpenFl
-00007c50: 6167 733d 6764 616c 2e4f 465f 5550 4441  ags=gdal.OF_UPDA
-00007c60: 5445 290d 0a20 2020 2020 2020 2073 716c  TE)..        sql
-00007c70: 6974 655f 7374 6d74 203d 2066 2755 5044  ite_stmt = f'UPD
-00007c80: 4154 4520 227b 6c61 7965 727d 2220 5345  ATE "{layer}" SE
-00007c90: 5420 227b 6e61 6d65 7d22 203d 207b 6578  T "{name}" = {ex
-00007ca0: 7072 6573 7369 6f6e 7d27 0d0a 2020 2020  pression}'..    
-00007cb0: 2020 2020 6966 2077 6865 7265 2069 7320      if where is 
-00007cc0: 6e6f 7420 4e6f 6e65 3a0d 0a20 2020 2020  not None:..     
-00007cd0: 2020 2020 2020 2073 716c 6974 655f 7374         sqlite_st
-00007ce0: 6d74 202b 3d20 6622 5c6e 2057 4845 5245  mt += f"\n WHERE
-00007cf0: 207b 7768 6572 657d 220d 0a20 2020 2020   {where}"..     
-00007d00: 2020 2072 6573 756c 7420 3d20 6461 7461     result = data
-00007d10: 736f 7572 6365 2e45 7865 6375 7465 5351  source.ExecuteSQ
-00007d20: 4c28 7371 6c69 7465 5f73 746d 742c 2064  L(sqlite_stmt, d
-00007d30: 6961 6c65 6374 3d22 5351 4c49 5445 2229  ialect="SQLITE")
-00007d40: 0d0a 2020 2020 2020 2020 6461 7461 736f  ..        dataso
-00007d50: 7572 6365 2e52 656c 6561 7365 5265 7375  urce.ReleaseResu
-00007d60: 6c74 5365 7428 7265 7375 6c74 290d 0a20  ltSet(result).. 
-00007d70: 2020 2066 696e 616c 6c79 3a0d 0a20 2020     finally:..   
-00007d80: 2020 2020 2069 6620 6461 7461 736f 7572       if datasour
-00007d90: 6365 2069 7320 6e6f 7420 4e6f 6e65 3a0d  ce is not None:.
-00007da0: 0a20 2020 2020 2020 2020 2020 2064 656c  .            del
-00007db0: 2064 6174 6173 6f75 7263 650d 0a0d 0a0d   datasource.....
-00007dc0: 0a64 6566 2072 6561 645f 6669 6c65 280d  .def read_file(.
-00007dd0: 0a20 2020 2070 6174 683a 2055 6e69 6f6e  .    path: Union
-00007de0: 5b73 7472 2c20 226f 732e 5061 7468 4c69  [str, "os.PathLi
-00007df0: 6b65 5b41 6e79 5d22 5d2c 0d0a 2020 2020  ke[Any]"],..    
-00007e00: 6c61 7965 723a 204f 7074 696f 6e61 6c5b  layer: Optional[
-00007e10: 7374 725d 203d 204e 6f6e 652c 0d0a 2020  str] = None,..  
-00007e20: 2020 636f 6c75 6d6e 733a 204f 7074 696f    columns: Optio
-00007e30: 6e61 6c5b 4974 6572 6162 6c65 5b73 7472  nal[Iterable[str
-00007e40: 5d5d 203d 204e 6f6e 652c 0d0a 2020 2020  ]] = None,..    
-00007e50: 6262 6f78 3d4e 6f6e 652c 0d0a 2020 2020  bbox=None,..    
-00007e60: 726f 7773 3d4e 6f6e 652c 0d0a 2020 2020  rows=None,..    
-00007e70: 7371 6c5f 7374 6d74 3a20 4f70 7469 6f6e  sql_stmt: Option
-00007e80: 616c 5b73 7472 5d20 3d20 4e6f 6e65 2c0d  al[str] = None,.
-00007e90: 0a20 2020 2073 716c 5f64 6961 6c65 6374  .    sql_dialect
-00007ea0: 3a20 4f70 7469 6f6e 616c 5b4c 6974 6572  : Optional[Liter
-00007eb0: 616c 5b22 5351 4c49 5445 222c 2022 4f47  al["SQLITE", "OG
-00007ec0: 5253 514c 225d 5d20 3d20 4e6f 6e65 2c0d  RSQL"]] = None,.
-00007ed0: 0a20 2020 2069 676e 6f72 655f 6765 6f6d  .    ignore_geom
-00007ee0: 6574 7279 3a20 626f 6f6c 203d 2046 616c  etry: bool = Fal
-00007ef0: 7365 2c0d 0a20 2020 2066 6964 5f61 735f  se,..    fid_as_
-00007f00: 696e 6465 783a 2062 6f6f 6c20 3d20 4661  index: bool = Fa
-00007f10: 6c73 652c 0d0a 2920 2d3e 2067 7064 2e47  lse,..) -> gpd.G
-00007f20: 656f 4461 7461 4672 616d 653a 0d0a 2020  eoDataFrame:..  
-00007f30: 2020 2222 220d 0a20 2020 2052 6561 6473    """..    Reads
-00007f40: 2061 2066 696c 6520 746f 2061 2067 656f   a file to a geo
-00007f50: 7061 6e64 6173 2047 656f 4461 7461 6672  pandas GeoDatafr
-00007f60: 616d 652e 0d0a 0d0a 2020 2020 5468 6520  ame.....    The 
-00007f70: 6669 6c65 2066 6f72 6d61 7420 6973 2064  file format is d
-00007f80: 6574 6563 7465 6420 6261 7365 6420 6f6e  etected based on
-00007f90: 2074 6865 2066 696c 6570 6174 6820 6578   the filepath ex
-00007fa0: 7465 6e73 696f 6e2e 0d0a 0d0a 2020 2020  tension.....    
-00007fb0: 4966 2061 6e20 7371 6c5f 7374 6d74 2069  If an sql_stmt i
-00007fc0: 7320 7370 6563 6966 6965 642c 2074 6865  s specified, the
-00007fd0: 2073 716c 6974 6520 7175 6572 7920 6361   sqlite query ca
-00007fe0: 6e20 636f 6e74 6169 6e20 666f 6c6c 6f77  n contain follow
-00007ff0: 696e 6720 706c 6163 6568 6f6c 6465 7273  ing placeholders
-00008000: 0d0a 2020 2020 7468 6174 2077 696c 6c20  ..    that will 
-00008010: 6265 2061 7574 6f6d 6174 6963 616c 6c79  be automatically
-00008020: 2072 6570 6c61 6365 6420 666f 7220 796f   replaced for yo
-00008030: 753a 0d0a 0d0a 2020 2020 2020 2a20 7b67  u:....      * {g
-00008040: 656f 6d65 7472 7963 6f6c 756d 6e7d 3a20  eometrycolumn}: 
-00008050: 7468 6520 636f 6c75 6d6e 2077 6865 7265  the column where
-00008060: 2074 6865 2070 7269 6d61 7279 2067 656f   the primary geo
-00008070: 6d65 7472 7920 6973 2073 746f 7265 642e  metry is stored.
-00008080: 0d0a 2020 2020 2020 2a20 7b63 6f6c 756d  ..      * {colum
-00008090: 6e73 5f74 6f5f 7365 6c65 6374 5f73 7472  ns_to_select_str
-000080a0: 7d3a 2069 6620 2763 6f6c 756d 6e73 2720  }: if 'columns' 
-000080b0: 6973 206e 6f74 204e 6f6e 652c 2074 686f  is not None, tho
-000080c0: 7365 2063 6f6c 756d 6e73 2c0d 0a20 2020  se columns,..   
-000080d0: 2020 2020 206f 7468 6572 7769 7365 2061       otherwise a
-000080e0: 6c6c 2063 6f6c 756d 6e73 206f 6620 7468  ll columns of th
-000080f0: 6520 6c61 7965 722e 0d0a 2020 2020 2020  e layer...      
-00008100: 2a20 7b69 6e70 7574 5f6c 6179 6572 7d3a  * {input_layer}:
-00008110: 2074 6865 206c 6179 6572 206e 616d 6520   the layer name 
-00008120: 6f66 2074 6865 2069 6e70 7574 206c 6179  of the input lay
-00008130: 6572 2e0d 0a0d 0a20 2020 2045 7861 6d70  er.....    Examp
-00008140: 6c65 2073 716c 2073 7461 7465 6d65 6e74  le sql statement
-00008150: 2077 6974 6820 706c 6163 6568 6f6c 6465   with placeholde
-00008160: 7273 3a0d 0a20 2020 203a 3a0d 0a0d 0a20  rs:..    ::.... 
-00008170: 2020 2020 2020 2053 454c 4543 5420 7b67         SELECT {g
-00008180: 656f 6d65 7472 7963 6f6c 756d 6e7d 0d0a  eometrycolumn}..
-00008190: 2020 2020 2020 2020 2020 2020 2020 7b63                {c
-000081a0: 6f6c 756d 6e73 5f74 6f5f 7365 6c65 6374  olumns_to_select
-000081b0: 5f73 7472 7d0d 0a20 2020 2020 2020 2020  _str}..         
-000081c0: 2046 524f 4d20 227b 696e 7075 745f 6c61   FROM "{input_la
-000081d0: 7965 727d 2220 6c61 7965 720d 0a0d 0a20  yer}" layer.... 
-000081e0: 2020 2054 6865 2075 6e64 6572 6c79 696e     The underlyin
-000081f0: 6720 6c69 6272 6172 7920 7573 6564 2074  g library used t
-00008200: 6f20 7265 6164 2074 6865 2066 696c 6520  o read the file 
-00008210: 6361 6e20 6265 2063 686f 6f73 656e 2075  can be choosen u
-00008220: 7369 6e67 2074 6865 0d0a 2020 2020 2247  sing the..    "G
-00008230: 464f 5f49 4f5f 454e 4749 4e45 2220 656e  FO_IO_ENGINE" en
-00008240: 7669 726f 6e6d 656e 7420 7661 7269 6162  vironment variab
-00008250: 6c65 2e20 506f 7373 6962 6c65 2076 616c  le. Possible val
-00008260: 7565 7320 6172 6520 2266 696f 6e61 2220  ues are "fiona" 
-00008270: 616e 6420 2270 796f 6772 696f 222e 0d0a  and "pyogrio"...
-00008280: 2020 2020 5468 6973 206f 7074 696f 6e20      This option 
-00008290: 6973 2063 7265 6174 6564 2061 7320 6120  is created as a 
-000082a0: 7465 6d70 6f72 6172 7920 6661 6c6c 6261  temporary fallba
-000082b0: 636b 2074 6f20 2266 696f 6e61 2220 666f  ck to "fiona" fo
-000082c0: 7220 6361 7365 7320 7768 6572 6520 2270  r cases where "p
-000082d0: 796f 6772 696f 220d 0a20 2020 2067 6976  yogrio"..    giv
-000082e0: 6573 2069 7373 7565 732c 2073 6f20 706c  es issues, so pl
-000082f0: 6561 7365 2072 6570 6f72 7420 6973 7375  ease report issu
-00008300: 6573 2069 6620 7468 6579 2061 7265 2065  es if they are e
-00008310: 6e63 6f75 6e74 6572 6564 2e20 496e 2074  ncountered. In t
-00008320: 6865 2066 7574 7572 6520 7375 7070 6f72  he future suppor
-00008330: 740d 0a20 2020 2066 6f72 2074 6865 2022  t..    for the "
-00008340: 6669 6f6e 6122 2065 6e67 696e 6520 6d6f  fiona" engine mo
-00008350: 7374 206c 696b 656c 7920 7769 6c6c 2062  st likely will b
-00008360: 6520 7265 6d6f 7665 642e 2044 6566 6175  e removed. Defau
-00008370: 6c74 2065 6e67 696e 6520 6973 2022 7079  lt engine is "py
-00008380: 6f67 7269 6f22 2e0d 0a0d 0a20 2020 2041  ogrio".....    A
-00008390: 7267 733a 0d0a 2020 2020 2020 2020 7061  rgs:..        pa
-000083a0: 7468 2028 6669 6c65 2070 6174 6829 3a20  th (file path): 
-000083b0: 7061 7468 2074 6f20 7468 6520 6669 6c65  path to the file
-000083c0: 2074 6f20 7265 6164 2066 726f 6d0d 0a20   to read from.. 
-000083d0: 2020 2020 2020 206c 6179 6572 2028 7374         layer (st
-000083e0: 722c 206f 7074 696f 6e61 6c29 3a20 5468  r, optional): Th
-000083f0: 6520 6c61 7965 7220 746f 2072 6561 642e  e layer to read.
-00008400: 2044 6566 6175 6c74 7320 746f 204e 6f6e   Defaults to Non
-00008410: 652c 0d0a 2020 2020 2020 2020 2020 2020  e,..            
-00008420: 7468 656e 2072 6561 6473 2074 6865 206f  then reads the o
-00008430: 6e6c 7920 6c61 7965 7220 696e 2074 6865  nly layer in the
-00008440: 2066 696c 6520 6f72 2074 6872 6f77 7320   file or throws 
-00008450: 6572 726f 722e 0d0a 2020 2020 2020 2020  error...        
-00008460: 636f 6c75 6d6e 7320 2849 7465 7261 626c  columns (Iterabl
-00008470: 655b 7374 725d 2c20 6f70 7469 6f6e 616c  e[str], optional
-00008480: 293a 2054 6865 2028 6e6f 6e2d 6765 6f6d  ): The (non-geom
-00008490: 6574 7279 2920 636f 6c75 6d6e 7320 746f  etry) columns to
-000084a0: 2072 6561 6420 7769 6c6c 0d0a 2020 2020   read will..    
-000084b0: 2020 2020 2020 2020 6265 2072 6574 7572          be retur
-000084c0: 6e65 6420 696e 2074 6865 206f 7264 6572  ned in the order
-000084d0: 2073 7065 6369 6669 6564 2e20 4966 204e   specified. If N
-000084e0: 6f6e 652c 2061 6c6c 2073 7461 6e64 6172  one, all standar
-000084f0: 6420 636f 6c75 6d6e 7320 6172 6520 7265  d columns are re
-00008500: 6164 2e0d 0a20 2020 2020 2020 2020 2020  ad...           
-00008510: 2049 6e20 6164 6469 7469 6f6e 2074 6f20   In addition to 
-00008520: 7374 616e 6461 7264 2063 6f6c 756d 6e73  standard columns
-00008530: 2c20 6974 2069 7320 616c 736f 2070 6f73  , it is also pos
-00008540: 7369 626c 650d 0a20 2020 2020 2020 2020  sible..         
-00008550: 2020 2074 6f20 7370 6563 6966 7920 2266     to specify "f
-00008560: 6964 222c 2061 2075 6e69 7175 6520 696e  id", a unique in
-00008570: 6465 7820 6176 6169 6c61 626c 6520 696e  dex available in
-00008580: 2061 6c6c 2069 6e70 7574 2066 696c 6573   all input files
-00008590: 2e20 4e6f 7465 2074 6861 7420 7468 650d  . Note that the.
-000085a0: 0a20 2020 2020 2020 2020 2020 2022 6669  .            "fi
-000085b0: 6422 2077 696c 6c20 6265 2061 6c69 6173  d" will be alias
-000085c0: 6564 2065 672e 2074 6f20 2266 6964 5f31  ed eg. to "fid_1
-000085d0: 222e 2044 6566 6175 6c74 7320 746f 204e  ". Defaults to N
-000085e0: 6f6e 652e 0d0a 2020 2020 2020 2020 6262  one...        bb
-000085f0: 6f78 2028 5b74 7970 655d 2c20 6f70 7469  ox ([type], opti
-00008600: 6f6e 616c 293a 2052 6561 6420 6f6e 6c79  onal): Read only
-00008610: 2067 656f 6d65 7472 6965 7320 696e 7465   geometries inte
-00008620: 7273 6563 7469 6e67 2074 6869 7320 6262  rsecting this bb
-00008630: 6f78 2e0d 0a20 2020 2020 2020 2020 2020  ox...           
-00008640: 2044 6566 6175 6c74 7320 746f 204e 6f6e   Defaults to Non
-00008650: 652c 2074 6865 6e20 616c 6c20 726f 7773  e, then all rows
-00008660: 2061 7265 2072 6561 642e 0d0a 2020 2020   are read...    
-00008670: 2020 2020 726f 7773 2028 5b74 7970 655d      rows ([type]
-00008680: 2c20 6f70 7469 6f6e 616c 293a 2052 6561  , optional): Rea
-00008690: 6420 6f6e 6c79 2074 6865 2072 6f77 7320  d only the rows 
-000086a0: 7370 6563 6966 6965 642e 0d0a 2020 2020  specified...    
-000086b0: 2020 2020 2020 2020 4465 6661 756c 7473          Defaults
-000086c0: 2074 6f20 4e6f 6e65 2c20 7468 656e 2061   to None, then a
-000086d0: 6c6c 2072 6f77 7320 6172 6520 7265 6164  ll rows are read
-000086e0: 2e0d 0a20 2020 2020 2020 2073 716c 5f73  ...        sql_s
-000086f0: 746d 7420 2873 7472 293a 2073 716c 2073  tmt (str): sql s
-00008700: 7461 7465 6d65 6e74 2074 6f20 7573 652e  tatement to use.
-00008710: 204f 6e6c 7920 7375 7070 6f72 7465 6420   Only supported 
-00008720: 7769 7468 2022 7079 6f67 7269 6f22 2065  with "pyogrio" e
-00008730: 6e67 696e 652e 0d0a 2020 2020 2020 2020  ngine...        
-00008740: 7371 6c5f 6469 616c 6563 7420 2873 7472  sql_dialect (str
-00008750: 2c20 6f70 7469 6f6e 616c 293a 2053 716c  , optional): Sql
-00008760: 2064 6961 6c65 6374 2075 7365 642e 2049   dialect used. I
-00008770: 6620 4e6f 6e65 2c20 666f 7220 6461 7461  f None, for data
-00008780: 2073 6f75 7263 6573 2077 6974 680d 0a20   sources with.. 
-00008790: 2020 2020 2020 2020 2020 2065 7870 6c69             expli
-000087a0: 6369 7420 5351 4c20 7375 7070 6f72 7420  cit SQL support 
-000087b0: 7468 6520 7374 6174 656d 656e 7420 6973  the statement is
-000087c0: 2070 726f 6365 7373 6564 2062 7920 7468   processed by th
-000087d0: 6520 6465 6661 756c 7420 5351 4c20 656e  e default SQL en
-000087e0: 6769 6e65 0d0a 2020 2020 2020 2020 2020  gine..          
-000087f0: 2020 2865 2e67 2e20 506f 7374 4749 532c    (e.g. PostGIS,
-00008800: 2047 656f 7061 636b 6167 652c 2053 7061   Geopackage, Spa
-00008810: 7469 616c 6974 652c 2e2e 2e29 2e20 466f  tialite,...). Fo
-00008820: 7220 6461 7461 2073 6f75 7263 6573 0d0a  r data sources..
-00008830: 2020 2020 2020 2020 2020 2020 7769 7468              with
-00008840: 6f75 7420 5351 4c20 7375 7070 6f72 742c  out SQL support,
-00008850: 2074 6865 2022 4f47 5253 514c 2220 6469   the "OGRSQL" di
-00008860: 616c 6563 7420 6973 2074 6865 2064 6566  alect is the def
-00008870: 6175 6c74 2e20 4465 6661 756c 7473 2074  ault. Defaults t
-00008880: 6f20 4e6f 6e65 2e0d 0a20 2020 2020 2020  o None...       
-00008890: 2069 676e 6f72 655f 6765 6f6d 6574 7279   ignore_geometry
-000088a0: 2028 626f 6f6c 2c20 6f70 7469 6f6e 616c   (bool, optional
-000088b0: 293a 2054 7275 6520 6e6f 7420 746f 2072  ): True not to r
-000088c0: 6561 642f 7265 7475 726e 2074 6865 2067  ead/return the g
-000088d0: 656f 6d65 7472 792e 0d0a 2020 2020 2020  eometry...      
-000088e0: 2020 2020 2020 4465 6661 756c 7473 2074        Defaults t
-000088f0: 6f20 4661 6c73 652e 0d0a 2020 2020 2020  o False...      
-00008900: 2020 6669 645f 6173 5f69 6e64 6578 2028    fid_as_index (
-00008910: 626f 6f6c 2c20 6f70 7469 6f6e 616c 293a  bool, optional):
-00008920: 2049 6620 5472 7565 2c20 7769 6c6c 2075   If True, will u
-00008930: 7365 2074 6865 2046 4944 7320 6f66 2074  se the FIDs of t
-00008940: 6865 2066 6561 7475 7265 7320 7468 6174  he features that
-00008950: 0d0a 2020 2020 2020 2020 2020 2020 7765  ..            we
-00008960: 7265 2072 6561 6420 6173 2074 6865 2069  re read as the i
-00008970: 6e64 6578 206f 6620 7468 6520 4765 6f44  ndex of the GeoD
-00008980: 6174 6146 7261 6d65 2e20 4d61 7920 7374  ataFrame. May st
-00008990: 6172 7420 6174 2030 206f 7220 3120 6465  art at 0 or 1 de
-000089a0: 7065 6e64 696e 6720 6f6e 0d0a 2020 2020  pending on..    
-000089b0: 2020 2020 2020 2020 7468 6520 6472 6976          the driv
-000089c0: 6572 2e20 4465 6661 756c 7473 2074 6f20  er. Defaults to 
-000089d0: 4661 6c73 652e 0d0a 0d0a 2020 2020 5261  False.....    Ra
-000089e0: 6973 6573 3a0d 0a20 2020 2020 2020 2056  ises:..        V
-000089f0: 616c 7565 4572 726f 723a 2061 6e20 696e  alueError: an in
-00008a00: 7661 6c69 6420 7061 7261 6d65 7465 7220  valid parameter 
-00008a10: 7661 6c75 6520 7761 7320 7061 7373 6564  value was passed
-00008a20: 2e0d 0a0d 0a20 2020 2052 6574 7572 6e73  .....    Returns
-00008a30: 3a0d 0a20 2020 2020 2020 2067 7064 2e47  :..        gpd.G
-00008a40: 656f 4461 7461 4672 616d 653a 2074 6865  eoDataFrame: the
-00008a50: 2064 6174 6120 7265 6164 2e0d 0a20 2020   data read...   
-00008a60: 2022 2222 0d0a 2020 2020 7265 7375 6c74   """..    result
-00008a70: 5f67 6466 203d 205f 7265 6164 5f66 696c  _gdf = _read_fil
-00008a80: 655f 6261 7365 280d 0a20 2020 2020 2020  e_base(..       
-00008a90: 2070 6174 683d 7061 7468 2c0d 0a20 2020   path=path,..   
-00008aa0: 2020 2020 206c 6179 6572 3d6c 6179 6572       layer=layer
-00008ab0: 2c0d 0a20 2020 2020 2020 2063 6f6c 756d  ,..        colum
-00008ac0: 6e73 3d63 6f6c 756d 6e73 2c0d 0a20 2020  ns=columns,..   
-00008ad0: 2020 2020 2062 626f 783d 6262 6f78 2c0d       bbox=bbox,.
-00008ae0: 0a20 2020 2020 2020 2072 6f77 733d 726f  .        rows=ro
-00008af0: 7773 2c0d 0a20 2020 2020 2020 2073 716c  ws,..        sql
-00008b00: 5f73 746d 743d 7371 6c5f 7374 6d74 2c0d  _stmt=sql_stmt,.
-00008b10: 0a20 2020 2020 2020 2073 716c 5f64 6961  .        sql_dia
-00008b20: 6c65 6374 3d73 716c 5f64 6961 6c65 6374  lect=sql_dialect
-00008b30: 2c0d 0a20 2020 2020 2020 2069 676e 6f72  ,..        ignor
-00008b40: 655f 6765 6f6d 6574 7279 3d69 676e 6f72  e_geometry=ignor
-00008b50: 655f 6765 6f6d 6574 7279 2c0d 0a20 2020  e_geometry,..   
-00008b60: 2020 2020 2066 6964 5f61 735f 696e 6465       fid_as_inde
-00008b70: 783d 6669 645f 6173 5f69 6e64 6578 2c0d  x=fid_as_index,.
-00008b80: 0a20 2020 2029 0d0a 0d0a 2020 2020 2320  .    )....    # 
-00008b90: 4e6f 2061 7373 6572 7420 746f 206b 6565  No assert to kee
-00008ba0: 7020 6261 636b 7761 7264 7320 636f 6d70  p backwards comp
-00008bb0: 6174 6962 696c 6974 790d 0a20 2020 2072  atibility..    r
-00008bc0: 6574 7572 6e20 7265 7375 6c74 5f67 6466  eturn result_gdf
-00008bd0: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
-00008be0: 0d0a 0d0a 0d0a 6465 6620 7265 6164 5f66  ......def read_f
-00008bf0: 696c 655f 6e6f 6765 6f6d 280d 0a20 2020  ile_nogeom(..   
-00008c00: 2070 6174 683a 2055 6e69 6f6e 5b73 7472   path: Union[str
-00008c10: 2c20 226f 732e 5061 7468 4c69 6b65 5b41  , "os.PathLike[A
-00008c20: 6e79 5d22 5d2c 0d0a 2020 2020 6c61 7965  ny]"],..    laye
-00008c30: 723a 204f 7074 696f 6e61 6c5b 7374 725d  r: Optional[str]
-00008c40: 203d 204e 6f6e 652c 0d0a 2020 2020 636f   = None,..    co
-00008c50: 6c75 6d6e 733a 204f 7074 696f 6e61 6c5b  lumns: Optional[
-00008c60: 4974 6572 6162 6c65 5b73 7472 5d5d 203d  Iterable[str]] =
-00008c70: 204e 6f6e 652c 0d0a 2020 2020 6262 6f78   None,..    bbox
-00008c80: 3d4e 6f6e 652c 0d0a 2020 2020 726f 7773  =None,..    rows
-00008c90: 3d4e 6f6e 652c 0d0a 2020 2020 7371 6c5f  =None,..    sql_
-00008ca0: 7374 6d74 3a20 4f70 7469 6f6e 616c 5b73  stmt: Optional[s
-00008cb0: 7472 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  tr] = None,..   
-00008cc0: 2073 716c 5f64 6961 6c65 6374 3a20 4f70   sql_dialect: Op
-00008cd0: 7469 6f6e 616c 5b4c 6974 6572 616c 5b22  tional[Literal["
-00008ce0: 5351 4c49 5445 222c 2022 4f47 5253 514c  SQLITE", "OGRSQL
-00008cf0: 225d 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  "]] = None,..   
-00008d00: 2066 6964 5f61 735f 696e 6465 783a 2062   fid_as_index: b
-00008d10: 6f6f 6c20 3d20 4661 6c73 652c 0d0a 2920  ool = False,..) 
-00008d20: 2d3e 2070 642e 4461 7461 4672 616d 653a  -> pd.DataFrame:
-00008d30: 0d0a 2020 2020 2222 220d 0a20 2020 2044  ..    """..    D
-00008d40: 4550 5245 4341 5445 443a 2070 6c65 6173  EPRECATED: pleas
-00008d50: 6520 7573 6520 7265 6164 5f66 696c 6520  e use read_file 
-00008d60: 7769 7468 206f 7074 696f 6e20 6967 6e6f  with option igno
-00008d70: 7265 5f67 656f 6d65 7472 793d 5472 7565  re_geometry=True
-00008d80: 2e0d 0a20 2020 2022 2222 0d0a 2020 2020  ...    """..    
-00008d90: 7761 726e 696e 6773 2e77 6172 6e28 0d0a  warnings.warn(..
-00008da0: 2020 2020 2020 2020 2272 6561 645f 6669          "read_fi
-00008db0: 6c65 5f6e 6f67 656f 6d20 6973 2064 6570  le_nogeom is dep
-00008dc0: 7265 6361 7465 643a 2075 7365 2072 6561  recated: use rea
-00008dd0: 645f 6669 6c65 2077 6974 6820 6967 6e6f  d_file with igno
-00008de0: 7265 5f67 656f 6d65 7472 793d 5472 7565  re_geometry=True
-00008df0: 222c 0d0a 2020 2020 2020 2020 4675 7475  ",..        Futu
-00008e00: 7265 5761 726e 696e 672c 0d0a 2020 2020  reWarning,..    
-00008e10: 290d 0a20 2020 2072 6573 756c 745f 6764  )..    result_gd
-00008e20: 6620 3d20 5f72 6561 645f 6669 6c65 5f62  f = _read_file_b
-00008e30: 6173 6528 0d0a 2020 2020 2020 2020 7061  ase(..        pa
-00008e40: 7468 3d70 6174 682c 0d0a 2020 2020 2020  th=path,..      
-00008e50: 2020 6c61 7965 723d 6c61 7965 722c 0d0a    layer=layer,..
-00008e60: 2020 2020 2020 2020 636f 6c75 6d6e 733d          columns=
-00008e70: 636f 6c75 6d6e 732c 0d0a 2020 2020 2020  columns,..      
-00008e80: 2020 6262 6f78 3d62 626f 782c 0d0a 2020    bbox=bbox,..  
-00008e90: 2020 2020 2020 726f 7773 3d72 6f77 732c        rows=rows,
-00008ea0: 0d0a 2020 2020 2020 2020 7371 6c5f 7374  ..        sql_st
-00008eb0: 6d74 3d73 716c 5f73 746d 742c 0d0a 2020  mt=sql_stmt,..  
-00008ec0: 2020 2020 2020 7371 6c5f 6469 616c 6563        sql_dialec
-00008ed0: 743d 7371 6c5f 6469 616c 6563 742c 0d0a  t=sql_dialect,..
-00008ee0: 2020 2020 2020 2020 6967 6e6f 7265 5f67          ignore_g
-00008ef0: 656f 6d65 7472 793d 5472 7565 2c0d 0a20  eometry=True,.. 
-00008f00: 2020 2020 2020 2066 6964 5f61 735f 696e         fid_as_in
-00008f10: 6465 783d 6669 645f 6173 5f69 6e64 6578  dex=fid_as_index
-00008f20: 2c0d 0a20 2020 2029 0d0a 2020 2020 6173  ,..    )..    as
-00008f30: 7365 7274 2069 7369 6e73 7461 6e63 6528  sert isinstance(
-00008f40: 7265 7375 6c74 5f67 6466 2c20 7064 2e44  result_gdf, pd.D
-00008f50: 6174 6146 7261 6d65 290d 0a20 2020 2072  ataFrame)..    r
-00008f60: 6574 7572 6e20 7265 7375 6c74 5f67 6466  eturn result_gdf
-00008f70: 0d0a 0d0a 0d0a 6465 6620 5f72 6561 645f  ......def _read_
-00008f80: 6669 6c65 5f62 6173 6528 0d0a 2020 2020  file_base(..    
-00008f90: 7061 7468 3a20 556e 696f 6e5b 7374 722c  path: Union[str,
-00008fa0: 2022 6f73 2e50 6174 684c 696b 655b 416e   "os.PathLike[An
-00008fb0: 795d 225d 2c0d 0a20 2020 206c 6179 6572  y]"],..    layer
-00008fc0: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
-00008fd0: 3d20 4e6f 6e65 2c0d 0a20 2020 2063 6f6c  = None,..    col
-00008fe0: 756d 6e73 3a20 4f70 7469 6f6e 616c 5b49  umns: Optional[I
-00008ff0: 7465 7261 626c 655b 7374 725d 5d20 3d20  terable[str]] = 
-00009000: 4e6f 6e65 2c0d 0a20 2020 2062 626f 783d  None,..    bbox=
-00009010: 4e6f 6e65 2c0d 0a20 2020 2072 6f77 733d  None,..    rows=
-00009020: 4e6f 6e65 2c0d 0a20 2020 2073 716c 5f73  None,..    sql_s
-00009030: 746d 743a 204f 7074 696f 6e61 6c5b 7374  tmt: Optional[st
-00009040: 725d 203d 204e 6f6e 652c 0d0a 2020 2020  r] = None,..    
-00009050: 7371 6c5f 6469 616c 6563 743a 204f 7074  sql_dialect: Opt
-00009060: 696f 6e61 6c5b 4c69 7465 7261 6c5b 2253  ional[Literal["S
-00009070: 514c 4954 4522 2c20 224f 4752 5351 4c22  QLITE", "OGRSQL"
-00009080: 5d5d 203d 204e 6f6e 652c 0d0a 2020 2020  ]] = None,..    
-00009090: 6967 6e6f 7265 5f67 656f 6d65 7472 793a  ignore_geometry:
-000090a0: 2062 6f6f 6c20 3d20 4661 6c73 652c 0d0a   bool = False,..
-000090b0: 2020 2020 6669 645f 6173 5f69 6e64 6578      fid_as_index
-000090c0: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-000090d0: 0a29 202d 3e20 556e 696f 6e5b 7064 2e44  .) -> Union[pd.D
-000090e0: 6174 6146 7261 6d65 2c20 6770 642e 4765  ataFrame, gpd.Ge
-000090f0: 6f44 6174 6146 7261 6d65 5d3a 0d0a 2020  oDataFrame]:..  
-00009100: 2020 2222 220d 0a20 2020 2052 6561 6473    """..    Reads
-00009110: 2061 2066 696c 6520 746f 2061 2070 616e   a file to a pan
-00009120: 6461 7320 4461 7461 6672 616d 652e 0d0a  das Dataframe...
-00009130: 2020 2020 2222 220d 0a20 2020 2023 2043      """..    # C
-00009140: 6865 636b 2069 6620 7468 6520 6669 6420  heck if the fid 
-00009150: 636f 6c75 6d6e 206e 6565 6473 2074 6f20  column needs to 
-00009160: 6265 2072 6561 6420 6173 2063 6f6c 756d  be read as colum
-00009170: 6e20 7669 6120 7468 6520 636f 6c75 6d6e  n via the column
-00009180: 7320 7061 7261 6d65 7465 720d 0a20 2020  s parameter..   
-00009190: 2066 6964 5f61 735f 636f 6c75 6d6e 203d   fid_as_column =
-000091a0: 2046 616c 7365 0d0a 2020 2020 6966 2063   False..    if c
-000091b0: 6f6c 756d 6e73 2069 7320 6e6f 7420 4e6f  olumns is not No
-000091c0: 6e65 3a0d 0a20 2020 2020 2020 2069 6620  ne:..        if 
-000091d0: 2266 6964 2220 696e 205b 636f 6c75 6d6e  "fid" in [column
-000091e0: 2e6c 6f77 6572 2829 2066 6f72 2063 6f6c  .lower() for col
-000091f0: 756d 6e20 696e 2063 6f6c 756d 6e73 5d3a  umn in columns]:
-00009200: 0d0a 2020 2020 2020 2020 2020 2020 6669  ..            fi
-00009210: 645f 6173 5f63 6f6c 756d 6e20 3d20 5472  d_as_column = Tr
-00009220: 7565 0d0a 0d0a 2020 2020 2320 5265 6164  ue....    # Read
-00009230: 2077 6974 6820 7468 6520 656e 6769 6e65   with the engine
-00009240: 2073 7065 6369 6669 6564 0d0a 2020 2020   specified..    
-00009250: 656e 6769 6e65 203d 205f 6765 745f 656e  engine = _get_en
-00009260: 6769 6e65 2829 0d0a 2020 2020 6966 2065  gine()..    if e
-00009270: 6e67 696e 6520 3d3d 2022 7079 6f67 7269  ngine == "pyogri
-00009280: 6f22 3a0d 0a20 2020 2020 2020 2067 6466  o":..        gdf
-00009290: 203d 205f 7265 6164 5f66 696c 655f 6261   = _read_file_ba
-000092a0: 7365 5f70 796f 6772 696f 280d 0a20 2020  se_pyogrio(..   
-000092b0: 2020 2020 2020 2020 2070 6174 683d 7061           path=pa
-000092c0: 7468 2c0d 0a20 2020 2020 2020 2020 2020  th,..           
-000092d0: 206c 6179 6572 3d6c 6179 6572 2c0d 0a20   layer=layer,.. 
-000092e0: 2020 2020 2020 2020 2020 2063 6f6c 756d             colum
-000092f0: 6e73 3d63 6f6c 756d 6e73 2c0d 0a20 2020  ns=columns,..   
-00009300: 2020 2020 2020 2020 2062 626f 783d 6262           bbox=bb
-00009310: 6f78 2c0d 0a20 2020 2020 2020 2020 2020  ox,..           
-00009320: 2072 6f77 733d 726f 7773 2c0d 0a20 2020   rows=rows,..   
-00009330: 2020 2020 2020 2020 2073 716c 5f73 746d           sql_stm
-00009340: 743d 7371 6c5f 7374 6d74 2c0d 0a20 2020  t=sql_stmt,..   
-00009350: 2020 2020 2020 2020 2073 716c 5f64 6961           sql_dia
-00009360: 6c65 6374 3d73 716c 5f64 6961 6c65 6374  lect=sql_dialect
-00009370: 2c0d 0a20 2020 2020 2020 2020 2020 2069  ,..            i
-00009380: 676e 6f72 655f 6765 6f6d 6574 7279 3d69  gnore_geometry=i
-00009390: 676e 6f72 655f 6765 6f6d 6574 7279 2c0d  gnore_geometry,.
-000093a0: 0a20 2020 2020 2020 2020 2020 2066 6964  .            fid
-000093b0: 5f61 735f 696e 6465 783d 6669 645f 6173  _as_index=fid_as
-000093c0: 5f69 6e64 6578 206f 7220 6669 645f 6173  _index or fid_as
-000093d0: 5f63 6f6c 756d 6e2c 0d0a 2020 2020 2020  _column,..      
-000093e0: 2020 290d 0a20 2020 2065 6c69 6620 656e    )..    elif en
-000093f0: 6769 6e65 203d 3d20 2266 696f 6e61 223a  gine == "fiona":
-00009400: 0d0a 2020 2020 2020 2020 6764 6620 3d20  ..        gdf = 
-00009410: 5f72 6561 645f 6669 6c65 5f62 6173 655f  _read_file_base_
-00009420: 6669 6f6e 6128 0d0a 2020 2020 2020 2020  fiona(..        
-00009430: 2020 2020 7061 7468 3d70 6174 682c 0d0a      path=path,..
-00009440: 2020 2020 2020 2020 2020 2020 6c61 7965              laye
-00009450: 723d 6c61 7965 722c 0d0a 2020 2020 2020  r=layer,..      
-00009460: 2020 2020 2020 636f 6c75 6d6e 733d 636f        columns=co
-00009470: 6c75 6d6e 732c 0d0a 2020 2020 2020 2020  lumns,..        
-00009480: 2020 2020 6262 6f78 3d62 626f 782c 0d0a      bbox=bbox,..
-00009490: 2020 2020 2020 2020 2020 2020 726f 7773              rows
-000094a0: 3d72 6f77 732c 0d0a 2020 2020 2020 2020  =rows,..        
-000094b0: 2020 2020 7371 6c5f 7374 6d74 3d73 716c      sql_stmt=sql
-000094c0: 5f73 746d 742c 0d0a 2020 2020 2020 2020  _stmt,..        
-000094d0: 2020 2020 7371 6c5f 6469 616c 6563 743d      sql_dialect=
-000094e0: 7371 6c5f 6469 616c 6563 742c 0d0a 2020  sql_dialect,..  
-000094f0: 2020 2020 2020 2020 2020 6967 6e6f 7265            ignore
-00009500: 5f67 656f 6d65 7472 793d 6967 6e6f 7265  _geometry=ignore
-00009510: 5f67 656f 6d65 7472 792c 0d0a 2020 2020  _geometry,..    
-00009520: 2020 2020 2020 2020 6669 645f 6173 5f69          fid_as_i
-00009530: 6e64 6578 3d66 6964 5f61 735f 696e 6465  ndex=fid_as_inde
-00009540: 7820 6f72 2066 6964 5f61 735f 636f 6c75  x or fid_as_colu
-00009550: 6d6e 2c0d 0a20 2020 2020 2020 2029 0d0a  mn,..        )..
-00009560: 2020 2020 656c 7365 3a0d 0a20 2020 2020      else:..     
-00009570: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00009580: 726f 7228 6622 556e 7375 7070 6f72 7465  ror(f"Unsupporte
-00009590: 6420 656e 6769 6e65 3a20 7b65 6e67 696e  d engine: {engin
-000095a0: 657d 2229 0d0a 0d0a 2020 2020 2320 436f  e}")....    # Co
-000095b0: 7079 2074 6865 2069 6e64 6578 2074 6f20  py the index to 
-000095c0: 6120 636f 6c75 6d6e 2069 6620 6e65 6564  a column if need
-000095d0: 6564 2e2e 2e0d 0a20 2020 2069 6620 6669  ed.....    if fi
-000095e0: 645f 6173 5f63 6f6c 756d 6e3a 0d0a 2020  d_as_column:..  
-000095f0: 2020 2020 2020 6764 665b 2266 6964 225d        gdf["fid"]
-00009600: 203d 2067 6466 2e69 6e64 6578 0d0a 2020   = gdf.index..  
-00009610: 2020 2020 2020 6966 206e 6f74 2066 6964        if not fid
-00009620: 5f61 735f 696e 6465 783a 0d0a 2020 2020  _as_index:..    
-00009630: 2020 2020 2020 2020 6764 6620 3d20 6764          gdf = gd
-00009640: 662e 7265 7365 745f 696e 6465 7828 6472  f.reset_index(dr
-00009650: 6f70 3d54 7275 6529 0d0a 0d0a 2020 2020  op=True)....    
-00009660: 7265 7475 726e 2067 6466 0d0a 0d0a 0d0a  return gdf......
-00009670: 6465 6620 5f72 6561 645f 6669 6c65 5f62  def _read_file_b
-00009680: 6173 655f 6669 6f6e 6128 0d0a 2020 2020  ase_fiona(..    
-00009690: 7061 7468 3a20 556e 696f 6e5b 7374 722c  path: Union[str,
-000096a0: 2022 6f73 2e50 6174 684c 696b 655b 416e   "os.PathLike[An
-000096b0: 795d 225d 2c0d 0a20 2020 206c 6179 6572  y]"],..    layer
-000096c0: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
-000096d0: 3d20 4e6f 6e65 2c0d 0a20 2020 2063 6f6c  = None,..    col
-000096e0: 756d 6e73 3a20 4f70 7469 6f6e 616c 5b49  umns: Optional[I
-000096f0: 7465 7261 626c 655b 7374 725d 5d20 3d20  terable[str]] = 
-00009700: 4e6f 6e65 2c0d 0a20 2020 2062 626f 783d  None,..    bbox=
-00009710: 4e6f 6e65 2c0d 0a20 2020 2072 6f77 733d  None,..    rows=
-00009720: 4e6f 6e65 2c0d 0a20 2020 2073 716c 5f73  None,..    sql_s
-00009730: 746d 743a 204f 7074 696f 6e61 6c5b 7374  tmt: Optional[st
-00009740: 725d 203d 204e 6f6e 652c 0d0a 2020 2020  r] = None,..    
-00009750: 7371 6c5f 6469 616c 6563 743a 204f 7074  sql_dialect: Opt
-00009760: 696f 6e61 6c5b 4c69 7465 7261 6c5b 2253  ional[Literal["S
-00009770: 514c 4954 4522 2c20 224f 4752 5351 4c22  QLITE", "OGRSQL"
-00009780: 5d5d 203d 204e 6f6e 652c 0d0a 2020 2020  ]] = None,..    
-00009790: 6967 6e6f 7265 5f67 656f 6d65 7472 793a  ignore_geometry:
-000097a0: 2062 6f6f 6c20 3d20 4661 6c73 652c 0d0a   bool = False,..
-000097b0: 2020 2020 6669 645f 6173 5f69 6e64 6578      fid_as_index
-000097c0: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-000097d0: 0a29 202d 3e20 556e 696f 6e5b 7064 2e44  .) -> Union[pd.D
-000097e0: 6174 6146 7261 6d65 2c20 6770 642e 4765  ataFrame, gpd.Ge
-000097f0: 6f44 6174 6146 7261 6d65 5d3a 0d0a 2020  oDataFrame]:..  
-00009800: 2020 2222 220d 0a20 2020 2052 6561 6473    """..    Reads
-00009810: 2061 2066 696c 6520 746f 2061 2070 616e   a file to a pan
-00009820: 6461 7320 4461 7461 6672 616d 6520 7573  das Dataframe us
-00009830: 696e 6720 6669 6f6e 612e 0d0a 2020 2020  ing fiona...    
-00009840: 2222 220d 0a20 2020 2069 6620 6967 6e6f  """..    if igno
-00009850: 7265 5f67 656f 6d65 7472 7920 616e 6420  re_geometry and 
-00009860: 636f 6c75 6d6e 7320 3d3d 205b 5d3a 0d0a  columns == []:..
-00009870: 2020 2020 2020 2020 7265 7475 726e 2070          return p
-00009880: 642e 4461 7461 4672 616d 6528 290d 0a20  d.DataFrame().. 
-00009890: 2020 2069 6620 7371 6c5f 7374 6d74 2069     if sql_stmt i
-000098a0: 7320 6e6f 7420 4e6f 6e65 3a0d 0a20 2020  s not None:..   
-000098b0: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-000098c0: 4572 726f 7228 2273 716c 5f73 746d 7420  Error("sql_stmt 
-000098d0: 6973 206e 6f74 2073 7570 706f 7274 6564  is not supported
-000098e0: 2077 6974 6820 6669 6f6e 6120 656e 6769   with fiona engi
-000098f0: 6e65 2229 0d0a 0d0a 2020 2020 2320 496e  ne")....    # In
-00009900: 6974 0d0a 2020 2020 7061 7468 203d 2050  it..    path = P
-00009910: 6174 6828 7061 7468 290d 0a20 2020 2069  ath(path)..    i
-00009920: 6620 7061 7468 2e65 7869 7374 7328 2920  f path.exists() 
-00009930: 6973 2046 616c 7365 3a0d 0a20 2020 2020  is False:..     
-00009940: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00009950: 726f 7228 6622 6669 6c65 2064 6f65 736e  ror(f"file doesn
-00009960: 2774 2065 7869 7374 3a20 7b70 6174 687d  't exist: {path}
-00009970: 2229 0d0a 0d0a 2020 2020 2320 4966 206e  ")....    # If n
-00009980: 6f20 6c61 7965 7220 6e61 6d65 2073 7065  o layer name spe
-00009990: 6369 6669 6564 2c20 6368 6563 6b20 6966  cified, check if
-000099a0: 2074 6865 7265 2069 7320 6f6e 6c79 206f   there is only o
-000099b0: 6e65 206c 6179 6572 2069 6e20 7468 6520  ne layer in the 
-000099c0: 6669 6c65 2e0d 0a20 2020 2069 6620 6c61  file...    if la
-000099d0: 7965 7220 6973 204e 6f6e 653a 0d0a 2020  yer is None:..  
-000099e0: 2020 2020 2020 6c61 7965 7220 3d20 6765        layer = ge
-000099f0: 745f 6f6e 6c79 5f6c 6179 6572 2870 6174  t_only_layer(pat
-00009a00: 6829 0d0a 0d0a 2020 2020 2320 5645 5259  h)....    # VERY
-00009a10: 2044 4952 5459 2068 6163 6b20 746f 2067   DIRTY hack to g
-00009a20: 6574 2074 6865 2066 6964 0d0a 2020 2020  et the fid..    
-00009a30: 6966 2066 6964 5f61 735f 696e 6465 783a  if fid_as_index:
-00009a40: 0d0a 2020 2020 2020 2020 2320 4d61 6b65  ..        # Make
-00009a50: 2061 2063 6f70 792f 636f 7079 2069 6e70   a copy/copy inp
-00009a60: 7574 2066 696c 6520 746f 2067 656f 7061  ut file to geopa
-00009a70: 636b 6167 652c 2061 7320 7765 2077 696c  ckage, as we wil
-00009a80: 6c20 6164 6420 616e 2066 6964 2f72 6f77  l add an fid/row
-00009a90: 6420 636f 6c75 6d6e 0d0a 2020 2020 2020  d column..      
-00009aa0: 2020 746d 705f 6669 645f 7061 7468 203d    tmp_fid_path =
-00009ab0: 2050 6174 6828 7465 6d70 6669 6c65 2e6d   Path(tempfile.m
-00009ac0: 6b64 7465 6d70 2829 2920 2f20 6622 7b70  kdtemp()) / f"{p
-00009ad0: 6174 682e 7374 656d 7d2e 6770 6b67 220d  ath.stem}.gpkg".
-00009ae0: 0a20 2020 2020 2020 2074 7279 3a0d 0a20  .        try:.. 
-00009af0: 2020 2020 2020 2020 2020 2069 6620 4765             if Ge
-00009b00: 6f66 696c 6554 7970 6528 7061 7468 2920  ofileType(path) 
-00009b10: 3d3d 2047 656f 6669 6c65 5479 7065 2e47  == GeofileType.G
-00009b20: 504b 473a 0d0a 2020 2020 2020 2020 2020  PKG:..          
-00009b30: 2020 2020 2020 636f 7079 2870 6174 682c        copy(path,
-00009b40: 2074 6d70 5f66 6964 5f70 6174 6829 0d0a   tmp_fid_path)..
-00009b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b60: 6164 645f 636f 6c75 6d6e 2874 6d70 5f66  add_column(tmp_f
-00009b70: 6964 5f70 6174 682c 2022 5f5f 544d 505f  id_path, "__TMP_
-00009b80: 4745 4f46 494c 454f 5053 5f46 4944 222c  GEOFILEOPS_FID",
-00009b90: 2022 494e 5445 4745 5222 2c20 2266 6964   "INTEGER", "fid
-00009ba0: 2229 0d0a 2020 2020 2020 2020 2020 2020  ")..            
-00009bb0: 656c 7365 3a0d 0a20 2020 2020 2020 2020  else:..         
-00009bc0: 2020 2020 2020 2063 6f6e 7665 7274 2870         convert(p
-00009bd0: 6174 682c 2074 6d70 5f66 6964 5f70 6174  ath, tmp_fid_pat
-00009be0: 6829 0d0a 2020 2020 2020 2020 2020 2020  h)..            
-00009bf0: 2020 2020 2320 6669 6420 696e 2073 6861      # fid in sha
-00009c00: 7065 6669 6c65 2069 7320 3020 6261 7365  pefile is 0 base
-00009c10: 642c 2073 6f20 6669 642d 310d 0a20 2020  d, so fid-1..   
-00009c20: 2020 2020 2020 2020 2020 2020 2061 6464               add
-00009c30: 5f63 6f6c 756d 6e28 746d 705f 6669 645f  _column(tmp_fid_
-00009c40: 7061 7468 2c20 225f 5f54 4d50 5f47 454f  path, "__TMP_GEO
-00009c50: 4649 4c45 4f50 535f 4649 4422 2c20 2249  FILEOPS_FID", "I
-00009c60: 4e54 4547 4552 222c 2022 6669 642d 3122  NTEGER", "fid-1"
-00009c70: 290d 0a0d 0a20 2020 2020 2020 2020 2020  )....           
-00009c80: 2070 6174 6820 3d20 746d 705f 6669 645f   path = tmp_fid_
-00009c90: 7061 7468 0d0a 2020 2020 2020 2020 6669  path..        fi
-00009ca0: 6e61 6c6c 793a 0d0a 2020 2020 2020 2020  nally:..        
-00009cb0: 2020 2020 6966 2074 6d70 5f66 6964 5f70      if tmp_fid_p
-00009cc0: 6174 682e 7061 7265 6e74 2e65 7869 7374  ath.parent.exist
-00009cd0: 7328 293a 0d0a 2020 2020 2020 2020 2020  s():..          
-00009ce0: 2020 2020 2020 7368 7574 696c 2e72 6d74        shutil.rmt
-00009cf0: 7265 6528 746d 705f 6669 645f 7061 7468  ree(tmp_fid_path
-00009d00: 2c20 6967 6e6f 7265 5f65 7272 6f72 733d  , ignore_errors=
-00009d10: 5472 7565 290d 0a0d 0a20 2020 2023 2043  True)....    # C
-00009d20: 6865 636b 696e 6720 6966 2066 6965 6c64  hecking if field
-00009d30: 2f63 6f6c 756d 6e20 6e61 6d65 7320 7368  /column names sh
-00009d40: 6f75 6c64 2062 6520 7265 6164 2069 7320  ould be read is 
-00009d50: 6361 7365 2073 656e 7369 7469 7665 2069  case sensitive i
-00009d60: 6e20 6669 6f6e 612c 2073 6f0d 0a20 2020  n fiona, so..   
-00009d70: 2023 206d 616b 6520 7375 7265 2074 6865   # make sure the
-00009d80: 2063 6f6c 756d 6e20 6e61 6d65 7320 7370   column names sp
-00009d90: 6563 6966 6965 6420 6861 7665 2074 6865  ecified have the
-00009da0: 2073 616d 6520 6361 7369 6e67 2e0d 0a20   same casing... 
-00009db0: 2020 2063 6f6c 756d 6e73 5f70 7265 7061     columns_prepa
-00009dc0: 7265 6420 3d20 4e6f 6e65 0d0a 2020 2020  red = None..    
-00009dd0: 6966 2063 6f6c 756d 6e73 2069 7320 6e6f  if columns is no
-00009de0: 7420 4e6f 6e65 3a0d 0a20 2020 2020 2020  t None:..       
-00009df0: 206c 6179 6572 696e 666f 203d 2067 6574   layerinfo = get
-00009e00: 5f6c 6179 6572 696e 666f 2870 6174 682c  _layerinfo(path,
-00009e10: 206c 6179 6572 3d6c 6179 6572 290d 0a20   layer=layer).. 
-00009e20: 2020 2020 2020 2063 6f6c 756d 6e73 5f75         columns_u
-00009e30: 7070 6572 5f6c 6f6f 6b75 7020 3d20 7b63  pper_lookup = {c
-00009e40: 6f6c 756d 6e2e 7570 7065 7228 293a 2063  olumn.upper(): c
-00009e50: 6f6c 756d 6e20 666f 7220 636f 6c75 6d6e  olumn for column
-00009e60: 2069 6e20 636f 6c75 6d6e 737d 0d0a 2020   in columns}..  
-00009e70: 2020 2020 2020 636f 6c75 6d6e 735f 7072        columns_pr
-00009e80: 6570 6172 6564 203d 207b 0d0a 2020 2020  epared = {..    
-00009e90: 2020 2020 2020 2020 636f 6c75 6d6e 3a20          column: 
-00009ea0: 636f 6c75 6d6e 735f 7570 7065 725f 6c6f  columns_upper_lo
-00009eb0: 6f6b 7570 5b63 6f6c 756d 6e2e 7570 7065  okup[column.uppe
-00009ec0: 7228 295d 0d0a 2020 2020 2020 2020 2020  r()]..          
-00009ed0: 2020 666f 7220 636f 6c75 6d6e 2069 6e20    for column in 
-00009ee0: 6c61 7965 7269 6e66 6f2e 636f 6c75 6d6e  layerinfo.column
-00009ef0: 730d 0a20 2020 2020 2020 2020 2020 2069  s..            i
-00009f00: 6620 636f 6c75 6d6e 2e75 7070 6572 2829  f column.upper()
-00009f10: 2069 6e20 636f 6c75 6d6e 735f 7570 7065   in columns_uppe
-00009f20: 725f 6c6f 6f6b 7570 0d0a 2020 2020 2020  r_lookup..      
-00009f30: 2020 7d0d 0a0d 0a20 2020 2023 2052 6561    }....    # Rea
-00009f40: 642e 2e2e 0d0a 2020 2020 636f 6c75 6d6e  d.....    column
-00009f50: 735f 6c69 7374 203d 204e 6f6e 6520 6966  s_list = None if
-00009f60: 2063 6f6c 756d 6e73 5f70 7265 7061 7265   columns_prepare
-00009f70: 6420 6973 204e 6f6e 6520 656c 7365 206c  d is None else l
-00009f80: 6973 7428 636f 6c75 6d6e 735f 7072 6570  ist(columns_prep
-00009f90: 6172 6564 290d 0a20 2020 2072 6573 756c  ared)..    resul
-00009fa0: 745f 6764 6620 3d20 6770 642e 7265 6164  t_gdf = gpd.read
-00009fb0: 5f66 696c 6528 0d0a 2020 2020 2020 2020  _file(..        
-00009fc0: 7374 7228 7061 7468 292c 0d0a 2020 2020  str(path),..    
-00009fd0: 2020 2020 6c61 7965 723d 6c61 7965 722c      layer=layer,
-00009fe0: 0d0a 2020 2020 2020 2020 6262 6f78 3d62  ..        bbox=b
-00009ff0: 626f 782c 0d0a 2020 2020 2020 2020 726f  box,..        ro
-0000a000: 7773 3d72 6f77 732c 0d0a 2020 2020 2020  ws=rows,..      
-0000a010: 2020 696e 636c 7564 655f 6669 656c 6473    include_fields
-0000a020: 3d63 6f6c 756d 6e73 5f6c 6973 742c 0d0a  =columns_list,..
-0000a030: 2020 2020 2020 2020 7371 6c3d 7371 6c5f          sql=sql_
-0000a040: 7374 6d74 2c0d 0a20 2020 2020 2020 2073  stmt,..        s
-0000a050: 716c 5f64 6961 6c65 6374 3d73 716c 5f64  ql_dialect=sql_d
-0000a060: 6961 6c65 6374 2c0d 0a20 2020 2020 2020  ialect,..       
-0000a070: 2069 676e 6f72 655f 6765 6f6d 6574 7279   ignore_geometry
-0000a080: 3d69 676e 6f72 655f 6765 6f6d 6574 7279  =ignore_geometry
-0000a090: 2c0d 0a20 2020 2029 0d0a 0d0a 2020 2020  ,..    )....    
-0000a0a0: 2320 5365 7420 7468 6520 696e 6465 7820  # Set the index 
-0000a0b0: 746f 2074 6865 2062 6163 6b65 642d 7570  to the backed-up
-0000a0c0: 2066 6964 0d0a 2020 2020 6966 2066 6964   fid..    if fid
-0000a0d0: 5f61 735f 696e 6465 783a 0d0a 2020 2020  _as_index:..    
-0000a0e0: 2020 2020 7265 7375 6c74 5f67 6466 203d      result_gdf =
-0000a0f0: 2072 6573 756c 745f 6764 662e 7365 745f   result_gdf.set_
-0000a100: 696e 6465 7828 225f 5f54 4d50 5f47 454f  index("__TMP_GEO
-0000a110: 4649 4c45 4f50 535f 4649 4422 290d 0a0d  FILEOPS_FID")...
-0000a120: 0a20 2020 2023 2052 656f 7264 6572 2063  .    # Reorder c
-0000a130: 6f6c 756d 6e73 202b 2063 6861 6e67 6520  olumns + change 
-0000a140: 6361 7369 6e67 2073 6f20 7468 6579 2061  casing so they a
-0000a150: 7265 2074 6865 2073 616d 6520 6173 2063  re the same as c
-0000a160: 6f6c 756d 6e73 2070 6172 616d 6574 6572  olumns parameter
-0000a170: 0d0a 2020 2020 6966 2063 6f6c 756d 6e73  ..    if columns
-0000a180: 5f70 7265 7061 7265 6420 6973 206e 6f74  _prepared is not
-0000a190: 204e 6f6e 6520 616e 6420 6c65 6e28 636f   None and len(co
-0000a1a0: 6c75 6d6e 735f 7072 6570 6172 6564 2920  lumns_prepared) 
-0000a1b0: 3e20 303a 0d0a 2020 2020 2020 2020 7265  > 0:..        re
-0000a1c0: 7375 6c74 5f67 6466 203d 2072 6573 756c  sult_gdf = resul
-0000a1d0: 745f 6764 665b 6c69 7374 2863 6f6c 756d  t_gdf[list(colum
-0000a1e0: 6e73 5f70 7265 7061 7265 6429 202b 205b  ns_prepared) + [
-0000a1f0: 2267 656f 6d65 7472 7922 5d5d 0d0a 2020  "geometry"]]..  
-0000a200: 2020 2020 2020 7265 7375 6c74 5f67 6466        result_gdf
-0000a210: 203d 2072 6573 756c 745f 6764 662e 7265   = result_gdf.re
-0000a220: 6e61 6d65 2863 6f6c 756d 6e73 3d63 6f6c  name(columns=col
-0000a230: 756d 6e73 5f70 7265 7061 7265 6429 2020  umns_prepared)  
-0000a240: 2320 7479 7065 3a20 6967 6e6f 7265 0d0a  # type: ignore..
-0000a250: 0d0a 2020 2020 2320 5374 6172 7469 6e67  ..    # Starting
-0000a260: 2066 726f 6d20 6669 6f6e 6120 312e 392c   from fiona 1.9,
-0000a270: 2073 7472 696e 6720 636f 6c75 6d6e 7320   string columns 
-0000a280: 7769 7468 2061 6c6c 204e 6f6e 6520 7661  with all None va
-0000a290: 6c75 6573 2061 7265 2072 6561 6420 6173  lues are read as
-0000a2a0: 2062 6569 6e67 0d0a 2020 2020 2320 666c   being..    # fl
-0000a2b0: 6f61 7420 636f 6c75 6d6e 732e 2043 6f6e  oat columns. Con
-0000a2c0: 7665 7274 2074 6865 6d20 746f 206f 626a  vert them to obj
-0000a2d0: 6563 7420 7479 7065 2e0d 0a20 2020 2066  ect type...    f
-0000a2e0: 6c6f 6174 5f63 6f6c 7320 3d20 6c69 7374  loat_cols = list
-0000a2f0: 2872 6573 756c 745f 6764 662e 7365 6c65  (result_gdf.sele
-0000a300: 6374 5f64 7479 7065 7328 5b22 666c 6f61  ct_dtypes(["floa
-0000a310: 7436 3422 5d29 2e63 6f6c 756d 6e73 290d  t64"]).columns).
-0000a320: 0a20 2020 2069 6620 6c65 6e28 666c 6f61  .    if len(floa
-0000a330: 745f 636f 6c73 2920 3e20 303a 0d0a 2020  t_cols) > 0:..  
-0000a340: 2020 2020 2020 2320 4368 6563 6b20 666f        # Check fo
-0000a350: 7220 616c 6c20 666c 6f61 7420 636f 6c75  r all float colu
-0000a360: 6d6e 7320 666f 756e 6420 6966 2074 6865  mns found if the
-0000a370: 7920 7368 6f75 6c64 2062 6520 6f62 6a65  y should be obje
-0000a380: 6374 2063 6f6c 756d 6e73 2069 6e73 7465  ct columns inste
-0000a390: 6164 0d0a 2020 2020 2020 2020 7769 7468  ad..        with
-0000a3a0: 2066 696f 6e61 2e6f 7065 6e28 7061 7468   fiona.open(path
-0000a3b0: 2c20 6c61 7965 723d 6c61 7965 7229 2061  , layer=layer) a
-0000a3c0: 7320 636f 6c6c 6563 7469 6f6e 3a0d 0a20  s collection:.. 
-0000a3d0: 2020 2020 2020 2020 2020 2061 7373 6572             asser
-0000a3e0: 7420 636f 6c6c 6563 7469 6f6e 2e73 6368  t collection.sch
-0000a3f0: 656d 6120 6973 206e 6f74 204e 6f6e 650d  ema is not None.
-0000a400: 0a20 2020 2020 2020 2020 2020 2070 726f  .            pro
-0000a410: 7065 7274 6965 7320 3d20 636f 6c6c 6563  perties = collec
-0000a420: 7469 6f6e 2e73 6368 656d 615b 2270 726f  tion.schema["pro
-0000a430: 7065 7274 6965 7322 5d0d 0a20 2020 2020  perties"]..     
-0000a440: 2020 2020 2020 2066 6f72 2063 6f6c 2069         for col i
-0000a450: 6e20 666c 6f61 745f 636f 6c73 3a0d 0a20  n float_cols:.. 
-0000a460: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000a470: 6620 636f 6c20 696e 2070 726f 7065 7274  f col in propert
-0000a480: 6965 7320 616e 6420 7072 6f70 6572 7469  ies and properti
-0000a490: 6573 5b63 6f6c 5d2e 7374 6172 7473 7769  es[col].startswi
-0000a4a0: 7468 2822 7374 7222 293a 0d0a 2020 2020  th("str"):..    
-0000a4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a4c0: 7265 7375 6c74 5f67 6466 5b63 6f6c 5d20  result_gdf[col] 
-0000a4d0: 3d20 280d 0a20 2020 2020 2020 2020 2020  = (..           
-0000a4e0: 2020 2020 2020 2020 2020 2020 2072 6573               res
-0000a4f0: 756c 745f 6764 665b 636f 6c5d 2020 2320  ult_gdf[col]  # 
-0000a500: 7479 7065 3a20 6967 6e6f 7265 0d0a 2020  type: ignore..  
-0000a510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a520: 2020 2020 2020 2e61 7374 7970 6528 6f62        .astype(ob
-0000a530: 6a65 6374 2920 2023 2074 7970 653a 2069  ject)  # type: i
-0000a540: 676e 6f72 650d 0a20 2020 2020 2020 2020  gnore..         
-0000a550: 2020 2020 2020 2020 2020 2020 2020 202e                 .
-0000a560: 7265 706c 6163 6528 6e70 2e6e 616e 2c20  replace(np.nan, 
-0000a570: 4e6f 6e65 290d 0a20 2020 2020 2020 2020  None)..         
-0000a580: 2020 2020 2020 2020 2020 2029 0d0a 0d0a             )....
-0000a590: 2020 2020 2320 6173 7365 7274 2074 6f20      # assert to 
-0000a5a0: 6576 6164 6520 7079 4c61 6e63 6520 7761  evade pyLance wa
-0000a5b0: 726e 696e 670d 0a20 2020 2061 7373 6572  rning..    asser
-0000a5c0: 7420 6973 696e 7374 616e 6365 2872 6573  t isinstance(res
-0000a5d0: 756c 745f 6764 662c 2070 642e 4461 7461  ult_gdf, pd.Data
-0000a5e0: 4672 616d 6529 206f 7220 6973 696e 7374  Frame) or isinst
-0000a5f0: 616e 6365 280d 0a20 2020 2020 2020 2072  ance(..        r
-0000a600: 6573 756c 745f 6764 662c 2067 7064 2e47  esult_gdf, gpd.G
-0000a610: 656f 4461 7461 4672 616d 650d 0a20 2020  eoDataFrame..   
-0000a620: 2029 0d0a 2020 2020 7265 7475 726e 2072   )..    return r
-0000a630: 6573 756c 745f 6764 660d 0a0d 0a0d 0a64  esult_gdf......d
-0000a640: 6566 205f 7265 6164 5f66 696c 655f 6261  ef _read_file_ba
-0000a650: 7365 5f70 796f 6772 696f 280d 0a20 2020  se_pyogrio(..   
-0000a660: 2070 6174 683a 2055 6e69 6f6e 5b73 7472   path: Union[str
-0000a670: 2c20 226f 732e 5061 7468 4c69 6b65 5b41  , "os.PathLike[A
-0000a680: 6e79 5d22 5d2c 0d0a 2020 2020 6c61 7965  ny]"],..    laye
-0000a690: 723a 204f 7074 696f 6e61 6c5b 7374 725d  r: Optional[str]
-0000a6a0: 203d 204e 6f6e 652c 0d0a 2020 2020 636f   = None,..    co
-0000a6b0: 6c75 6d6e 733a 204f 7074 696f 6e61 6c5b  lumns: Optional[
-0000a6c0: 4974 6572 6162 6c65 5b73 7472 5d5d 203d  Iterable[str]] =
-0000a6d0: 204e 6f6e 652c 0d0a 2020 2020 6262 6f78   None,..    bbox
-0000a6e0: 3d4e 6f6e 652c 0d0a 2020 2020 726f 7773  =None,..    rows
-0000a6f0: 3d4e 6f6e 652c 0d0a 2020 2020 7371 6c5f  =None,..    sql_
-0000a700: 7374 6d74 3a20 4f70 7469 6f6e 616c 5b73  stmt: Optional[s
-0000a710: 7472 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  tr] = None,..   
-0000a720: 2073 716c 5f64 6961 6c65 6374 3a20 4f70   sql_dialect: Op
-0000a730: 7469 6f6e 616c 5b4c 6974 6572 616c 5b22  tional[Literal["
-0000a740: 5351 4c49 5445 222c 2022 4f47 5253 514c  SQLITE", "OGRSQL
-0000a750: 225d 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  "]] = None,..   
-0000a760: 2069 676e 6f72 655f 6765 6f6d 6574 7279   ignore_geometry
-0000a770: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-0000a780: 0a20 2020 2066 6964 5f61 735f 696e 6465  .    fid_as_inde
-0000a790: 783a 2062 6f6f 6c20 3d20 4661 6c73 652c  x: bool = False,
-0000a7a0: 0d0a 2920 2d3e 2055 6e69 6f6e 5b70 642e  ..) -> Union[pd.
-0000a7b0: 4461 7461 4672 616d 652c 2067 7064 2e47  DataFrame, gpd.G
-0000a7c0: 656f 4461 7461 4672 616d 655d 3a0d 0a20  eoDataFrame]:.. 
-0000a7d0: 2020 2022 2222 0d0a 2020 2020 5265 6164     """..    Read
-0000a7e0: 7320 6120 6669 6c65 2074 6f20 6120 7061  s a file to a pa
-0000a7f0: 6e64 6173 2044 6174 6166 7261 6d65 2075  ndas Dataframe u
-0000a800: 7369 6e67 2070 796f 6772 696f 2e0d 0a20  sing pyogrio... 
-0000a810: 2020 2022 2222 0d0a 2020 2020 2320 496e     """..    # In
-0000a820: 6974 0d0a 2020 2020 7061 7468 203d 2050  it..    path = P
-0000a830: 6174 6828 7061 7468 290d 0a20 2020 2069  ath(path)..    i
-0000a840: 6620 7061 7468 2e65 7869 7374 7328 2920  f path.exists() 
-0000a850: 6973 2046 616c 7365 3a0d 0a20 2020 2020  is False:..     
-0000a860: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-0000a870: 726f 7228 6622 6669 6c65 2064 6f65 736e  ror(f"file doesn
-0000a880: 2774 2065 7869 7374 3a20 7b70 6174 687d  't exist: {path}
-0000a890: 2229 0d0a 0d0a 2020 2020 2320 436f 6e76  ")....    # Conv
-0000a8a0: 6572 7420 736c 6963 6520 6f62 6a65 6374  ert slice object
-0000a8b0: 2074 6f20 7079 6f67 7269 6f20 7061 7261   to pyogrio para
-0000a8c0: 6d65 7465 7273 0d0a 2020 2020 6966 2072  meters..    if r
-0000a8d0: 6f77 7320 6973 206e 6f74 204e 6f6e 653a  ows is not None:
-0000a8e0: 0d0a 2020 2020 2020 2020 736b 6970 5f66  ..        skip_f
-0000a8f0: 6561 7475 7265 7320 3d20 726f 7773 2e73  eatures = rows.s
-0000a900: 7461 7274 0d0a 2020 2020 2020 2020 6d61  tart..        ma
-0000a910: 785f 6665 6174 7572 6573 203d 2072 6f77  x_features = row
-0000a920: 732e 7374 6f70 202d 2072 6f77 732e 7374  s.stop - rows.st
-0000a930: 6172 740d 0a20 2020 2065 6c73 653a 0d0a  art..    else:..
-0000a940: 2020 2020 2020 2020 736b 6970 5f66 6561          skip_fea
-0000a950: 7475 7265 7320 3d20 300d 0a20 2020 2020  tures = 0..     
-0000a960: 2020 206d 6178 5f66 6561 7475 7265 7320     max_features 
-0000a970: 3d20 4e6f 6e65 0d0a 0d0a 2020 2020 2320  = None....    # 
-0000a980: 4966 206e 6f20 7371 6c5f 7374 6d74 2073  If no sql_stmt s
-0000a990: 7065 6369 6669 6564 0d0a 2020 2020 636f  pecified..    co
-0000a9a0: 6c75 6d6e 735f 7072 6570 6172 6564 203d  lumns_prepared =
-0000a9b0: 204e 6f6e 650d 0a20 2020 2069 6620 7371   None..    if sq
-0000a9c0: 6c5f 7374 6d74 2069 7320 4e6f 6e65 3a0d  l_stmt is None:.
-0000a9d0: 0a20 2020 2020 2020 2023 2049 6620 6e6f  .        # If no
-0000a9e0: 206c 6179 6572 2073 7065 6369 6669 6564   layer specified
-0000a9f0: 2c20 7468 6572 6520 7368 6f75 6c64 2062  , there should b
-0000aa00: 6520 6f6e 6c79 206f 6e65 206c 6179 6572  e only one layer
-0000aa10: 2069 6e20 7468 6520 6669 6c65 2e0d 0a20   in the file... 
-0000aa20: 2020 2020 2020 2069 6620 6c61 7965 7220         if layer 
-0000aa30: 6973 204e 6f6e 653a 0d0a 2020 2020 2020  is None:..      
-0000aa40: 2020 2020 2020 6c61 7965 7220 3d20 6765        layer = ge
-0000aa50: 745f 6f6e 6c79 5f6c 6179 6572 2870 6174  t_only_layer(pat
-0000aa60: 6829 0d0a 0d0a 2020 2020 2020 2020 2320  h)....        # 
-0000aa70: 4368 6563 6b69 6e67 2069 6620 636f 6c75  Checking if colu
-0000aa80: 6d6e 206e 616d 6573 2073 686f 756c 6420  mn names should 
-0000aa90: 6265 2072 6561 6420 6973 2063 6173 6520  be read is case 
-0000aaa0: 7365 6e73 6974 6976 6520 696e 2070 796f  sensitive in pyo
-0000aab0: 6772 696f 2c20 736f 0d0a 2020 2020 2020  grio, so..      
-0000aac0: 2020 2320 6d61 6b65 2073 7572 6520 7468    # make sure th
-0000aad0: 6520 636f 6c75 6d6e 206e 616d 6573 2073  e column names s
-0000aae0: 7065 6369 6669 6564 2068 6176 6520 7468  pecified have th
-0000aaf0: 6520 7361 6d65 2063 6173 696e 672e 0d0a  e same casing...
-0000ab00: 2020 2020 2020 2020 6966 2063 6f6c 756d          if colum
-0000ab10: 6e73 2069 7320 6e6f 7420 4e6f 6e65 3a0d  ns is not None:.
-0000ab20: 0a20 2020 2020 2020 2020 2020 206c 6179  .            lay
-0000ab30: 6572 696e 666f 203d 2067 6574 5f6c 6179  erinfo = get_lay
-0000ab40: 6572 696e 666f 2870 6174 682c 206c 6179  erinfo(path, lay
-0000ab50: 6572 3d6c 6179 6572 290d 0a20 2020 2020  er=layer)..     
-0000ab60: 2020 2020 2020 2063 6f6c 756d 6e73 5f75         columns_u
-0000ab70: 7070 6572 5f6c 6f6f 6b75 7020 3d20 7b63  pper_lookup = {c
-0000ab80: 6f6c 756d 6e2e 7570 7065 7228 293a 2063  olumn.upper(): c
-0000ab90: 6f6c 756d 6e20 666f 7220 636f 6c75 6d6e  olumn for column
-0000aba0: 2069 6e20 636f 6c75 6d6e 737d 0d0a 2020   in columns}..  
-0000abb0: 2020 2020 2020 2020 2020 636f 6c75 6d6e            column
-0000abc0: 735f 7072 6570 6172 6564 203d 207b 0d0a  s_prepared = {..
-0000abd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000abe0: 636f 6c75 6d6e 3a20 636f 6c75 6d6e 735f  column: columns_
-0000abf0: 7570 7065 725f 6c6f 6f6b 7570 5b63 6f6c  upper_lookup[col
-0000ac00: 756d 6e2e 7570 7065 7228 295d 0d0a 2020  umn.upper()]..  
-0000ac10: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-0000ac20: 7220 636f 6c75 6d6e 2069 6e20 6c61 7965  r column in laye
-0000ac30: 7269 6e66 6f2e 636f 6c75 6d6e 730d 0a20  rinfo.columns.. 
-0000ac40: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000ac50: 6620 636f 6c75 6d6e 2e75 7070 6572 2829  f column.upper()
-0000ac60: 2069 6e20 636f 6c75 6d6e 735f 7570 7065   in columns_uppe
-0000ac70: 725f 6c6f 6f6b 7570 0d0a 2020 2020 2020  r_lookup..      
-0000ac80: 2020 2020 2020 7d0d 0a20 2020 2065 6c73        }..    els
-0000ac90: 653a 0d0a 2020 2020 2020 2020 2320 4669  e:..        # Fi
-0000aca0: 6c6c 206f 7574 2070 6c61 6365 686f 6c64  ll out placehold
-0000acb0: 6572 732c 206b 6565 7020 636f 6c75 6d6e  ers, keep column
-0000acc0: 735f 7072 6570 6172 6564 204e 6f6e 6520  s_prepared None 
-0000acd0: 6265 6361 7573 6520 636f 6c75 6d6e 2066  because column f
-0000ace0: 696c 7465 7269 6e67 0d0a 2020 2020 2020  iltering..      
-0000acf0: 2020 2320 7368 6f75 6c64 2068 6170 7065    # should happe
-0000ad00: 6e20 696e 2073 716c 5f73 746d 742e 0d0a  n in sql_stmt...
-0000ad10: 2020 2020 2020 2020 7371 6c5f 7374 6d74          sql_stmt
-0000ad20: 203d 205f 6669 6c6c 5f6f 7574 5f73 716c   = _fill_out_sql
-0000ad30: 5f70 6c61 6365 686f 6c64 6572 7328 0d0a  _placeholders(..
-0000ad40: 2020 2020 2020 2020 2020 2020 7061 7468              path
-0000ad50: 3d70 6174 682c 206c 6179 6572 3d6c 6179  =path, layer=lay
-0000ad60: 6572 2c20 7371 6c5f 7374 6d74 3d73 716c  er, sql_stmt=sql
-0000ad70: 5f73 746d 742c 2063 6f6c 756d 6e73 3d63  _stmt, columns=c
-0000ad80: 6f6c 756d 6e73 0d0a 2020 2020 2020 2020  olumns..        
-0000ad90: 290d 0a0d 0a20 2020 2023 2052 6561 6421  )....    # Read!
-0000ada0: 0d0a 2020 2020 636f 6c75 6d6e 735f 6c69  ..    columns_li
-0000adb0: 7374 203d 204e 6f6e 6520 6966 2063 6f6c  st = None if col
-0000adc0: 756d 6e73 5f70 7265 7061 7265 6420 6973  umns_prepared is
-0000add0: 204e 6f6e 6520 656c 7365 206c 6973 7428   None else list(
-0000ade0: 636f 6c75 6d6e 735f 7072 6570 6172 6564  columns_prepared
-0000adf0: 290d 0a20 2020 2072 6573 756c 745f 6764  )..    result_gd
-0000ae00: 6620 3d20 7079 6f67 7269 6f2e 7265 6164  f = pyogrio.read
-0000ae10: 5f64 6174 6166 7261 6d65 280d 0a20 2020  _dataframe(..   
-0000ae20: 2020 2020 2070 6174 682c 0d0a 2020 2020       path,..    
-0000ae30: 2020 2020 6c61 7965 723d 6c61 7965 722c      layer=layer,
-0000ae40: 0d0a 2020 2020 2020 2020 636f 6c75 6d6e  ..        column
-0000ae50: 733d 636f 6c75 6d6e 735f 6c69 7374 2c0d  s=columns_list,.
-0000ae60: 0a20 2020 2020 2020 2062 626f 783d 6262  .        bbox=bb
-0000ae70: 6f78 2c0d 0a20 2020 2020 2020 2073 6b69  ox,..        ski
-0000ae80: 705f 6665 6174 7572 6573 3d73 6b69 705f  p_features=skip_
-0000ae90: 6665 6174 7572 6573 2c0d 0a20 2020 2020  features,..     
-0000aea0: 2020 206d 6178 5f66 6561 7475 7265 733d     max_features=
-0000aeb0: 6d61 785f 6665 6174 7572 6573 2c0d 0a20  max_features,.. 
-0000aec0: 2020 2020 2020 2073 716c 3d73 716c 5f73         sql=sql_s
-0000aed0: 746d 742c 0d0a 2020 2020 2020 2020 7371  tmt,..        sq
-0000aee0: 6c5f 6469 616c 6563 743d 7371 6c5f 6469  l_dialect=sql_di
-0000aef0: 616c 6563 742c 0d0a 2020 2020 2020 2020  alect,..        
-0000af00: 7265 6164 5f67 656f 6d65 7472 793d 6e6f  read_geometry=no
-0000af10: 7420 6967 6e6f 7265 5f67 656f 6d65 7472  t ignore_geometr
-0000af20: 792c 0d0a 2020 2020 2020 2020 6669 645f  y,..        fid_
-0000af30: 6173 5f69 6e64 6578 3d66 6964 5f61 735f  as_index=fid_as_
-0000af40: 696e 6465 782c 0d0a 2020 2020 290d 0a0d  index,..    )...
-0000af50: 0a20 2020 2023 2052 656f 7264 6572 2063  .    # Reorder c
-0000af60: 6f6c 756d 6e73 202b 2063 6861 6e67 6520  olumns + change 
-0000af70: 6361 7369 6e67 2073 6f20 7468 6579 2061  casing so they a
-0000af80: 7265 2074 6865 2073 616d 6520 6173 2063  re the same as c
-0000af90: 6f6c 756d 6e73 2070 6172 616d 6574 6572  olumns parameter
-0000afa0: 0d0a 2020 2020 6966 2063 6f6c 756d 6e73  ..    if columns
-0000afb0: 5f70 7265 7061 7265 6420 6973 206e 6f74  _prepared is not
-0000afc0: 204e 6f6e 6520 616e 6420 6c65 6e28 636f   None and len(co
-0000afd0: 6c75 6d6e 735f 7072 6570 6172 6564 2920  lumns_prepared) 
-0000afe0: 3e20 303a 0d0a 2020 2020 2020 2020 7265  > 0:..        re
-0000aff0: 7375 6c74 5f67 6466 203d 2072 6573 756c  sult_gdf = resul
-0000b000: 745f 6764 665b 6c69 7374 2863 6f6c 756d  t_gdf[list(colum
-0000b010: 6e73 5f70 7265 7061 7265 6429 202b 205b  ns_prepared) + [
-0000b020: 2267 656f 6d65 7472 7922 5d5d 0d0a 2020  "geometry"]]..  
-0000b030: 2020 2020 2020 7265 7375 6c74 5f67 6466        result_gdf
-0000b040: 203d 2072 6573 756c 745f 6764 662e 7265   = result_gdf.re
-0000b050: 6e61 6d65 2863 6f6c 756d 6e73 3d63 6f6c  name(columns=col
-0000b060: 756d 6e73 5f70 7265 7061 7265 6429 2020  umns_prepared)  
-0000b070: 2320 7479 7065 3a20 6967 6e6f 7265 0d0a  # type: ignore..
-0000b080: 0d0a 2020 2020 2320 6173 7365 7274 2074  ..    # assert t
-0000b090: 6f20 6576 6164 6520 7079 4c61 6e63 6520  o evade pyLance 
-0000b0a0: 7761 726e 696e 670d 0a20 2020 2061 7373  warning..    ass
-0000b0b0: 6572 7420 6973 696e 7374 616e 6365 2872  ert isinstance(r
-0000b0c0: 6573 756c 745f 6764 662c 2070 642e 4461  esult_gdf, pd.Da
-0000b0d0: 7461 4672 616d 6529 206f 7220 6973 696e  taFrame) or isin
-0000b0e0: 7374 616e 6365 280d 0a20 2020 2020 2020  stance(..       
-0000b0f0: 2072 6573 756c 745f 6764 662c 2067 7064   result_gdf, gpd
-0000b100: 2e47 656f 4461 7461 4672 616d 650d 0a20  .GeoDataFrame.. 
-0000b110: 2020 2029 0d0a 2020 2020 7265 7475 726e     )..    return
-0000b120: 2072 6573 756c 745f 6764 660d 0a0d 0a0d   result_gdf.....
-0000b130: 0a64 6566 205f 6669 6c6c 5f6f 7574 5f73  .def _fill_out_s
-0000b140: 716c 5f70 6c61 6365 686f 6c64 6572 7328  ql_placeholders(
-0000b150: 0d0a 2020 2020 7061 7468 3a20 5061 7468  ..    path: Path
-0000b160: 2c20 6c61 7965 723a 204f 7074 696f 6e61  , layer: Optiona
-0000b170: 6c5b 7374 725d 2c20 7371 6c5f 7374 6d74  l[str], sql_stmt
-0000b180: 3a20 7374 722c 2063 6f6c 756d 6e73 3a20  : str, columns: 
-0000b190: 4f70 7469 6f6e 616c 5b49 7465 7261 626c  Optional[Iterabl
-0000b1a0: 655b 7374 725d 5d0d 0a29 202d 3e20 7374  e[str]]..) -> st
-0000b1b0: 723a 0d0a 2020 2020 2320 4669 6c6c 206f  r:..    # Fill o
-0000b1c0: 7574 2070 6c61 6365 686f 6c64 6572 7320  ut placeholders 
-0000b1d0: 696e 2074 6865 2073 716c 5f73 746d 7420  in the sql_stmt 
-0000b1e0: 6966 206e 6565 6465 643a 0d0a 2020 2020  if needed:..    
-0000b1f0: 706c 6163 6568 6f6c 6465 7273 203d 205b  placeholders = [
-0000b200: 0d0a 2020 2020 2020 2020 6e61 6d65 2066  ..        name f
-0000b210: 6f72 205f 2c20 6e61 6d65 2c20 5f2c 205f  or _, name, _, _
-0000b220: 2069 6e20 7374 7269 6e67 2e46 6f72 6d61   in string.Forma
-0000b230: 7474 6572 2829 2e70 6172 7365 2873 716c  tter().parse(sql
-0000b240: 5f73 746d 7429 2069 6620 6e61 6d65 0d0a  _stmt) if name..
-0000b250: 2020 2020 5d0d 0a20 2020 206c 6179 6572      ]..    layer
-0000b260: 5f74 6d70 203d 206c 6179 6572 0d0a 2020  _tmp = layer..  
-0000b270: 2020 6c61 7965 7269 6e66 6f20 3d20 4e6f    layerinfo = No
-0000b280: 6e65 0d0a 2020 2020 666f 726d 6174 5f6b  ne..    format_k
-0000b290: 7761 7267 7320 3d20 7b7d 0d0a 2020 2020  wargs = {}..    
-0000b2a0: 666f 7220 706c 6163 6568 6f6c 6465 7220  for placeholder 
-0000b2b0: 696e 2070 6c61 6365 686f 6c64 6572 733a  in placeholders:
-0000b2c0: 0d0a 2020 2020 2020 2020 6966 206c 6179  ..        if lay
-0000b2d0: 6572 5f74 6d70 2069 7320 4e6f 6e65 3a0d  er_tmp is None:.
-0000b2e0: 0a20 2020 2020 2020 2020 2020 206c 6179  .            lay
-0000b2f0: 6572 5f74 6d70 203d 2067 6574 5f6f 6e6c  er_tmp = get_onl
-0000b300: 795f 6c61 7965 7228 7061 7468 290d 0a20  y_layer(path).. 
-0000b310: 2020 2020 2020 2069 6620 706c 6163 6568         if placeh
-0000b320: 6f6c 6465 7220 3d3d 2022 696e 7075 745f  older == "input_
-0000b330: 6c61 7965 7222 3a0d 0a20 2020 2020 2020  layer":..       
-0000b340: 2020 2020 2066 6f72 6d61 745f 6b77 6172       format_kwar
-0000b350: 6773 5b70 6c61 6365 686f 6c64 6572 5d20  gs[placeholder] 
-0000b360: 3d20 6c61 7965 725f 746d 700d 0a20 2020  = layer_tmp..   
-0000b370: 2020 2020 2065 6c69 6620 706c 6163 6568       elif placeh
-0000b380: 6f6c 6465 7220 3d3d 2022 6765 6f6d 6574  older == "geomet
-0000b390: 7279 636f 6c75 6d6e 223a 0d0a 2020 2020  rycolumn":..    
-0000b3a0: 2020 2020 2020 2020 6966 206c 6179 6572          if layer
-0000b3b0: 696e 666f 2069 7320 4e6f 6e65 3a0d 0a20  info is None:.. 
-0000b3c0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000b3d0: 6179 6572 696e 666f 203d 2067 6574 5f6c  ayerinfo = get_l
-0000b3e0: 6179 6572 696e 666f 2870 6174 682c 206c  ayerinfo(path, l
-0000b3f0: 6179 6572 5f74 6d70 290d 0a20 2020 2020  ayer_tmp)..     
-0000b400: 2020 2020 2020 2066 6f72 6d61 745f 6b77         format_kw
-0000b410: 6172 6773 5b70 6c61 6365 686f 6c64 6572  args[placeholder
-0000b420: 5d20 3d20 6c61 7965 7269 6e66 6f2e 6765  ] = layerinfo.ge
-0000b430: 6f6d 6574 7279 636f 6c75 6d6e 0d0a 2020  ometrycolumn..  
-0000b440: 2020 2020 2020 656c 6966 2070 6c61 6365        elif place
-0000b450: 686f 6c64 6572 203d 3d20 2263 6f6c 756d  holder == "colum
-0000b460: 6e73 5f74 6f5f 7365 6c65 6374 5f73 7472  ns_to_select_str
-0000b470: 223a 0d0a 2020 2020 2020 2020 2020 2020  ":..            
-0000b480: 6966 206c 6179 6572 696e 666f 2069 7320  if layerinfo is 
-0000b490: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2020  None:..         
-0000b4a0: 2020 2020 2020 206c 6179 6572 696e 666f         layerinfo
-0000b4b0: 203d 2067 6574 5f6c 6179 6572 696e 666f   = get_layerinfo
-0000b4c0: 2870 6174 682c 206c 6179 6572 5f74 6d70  (path, layer_tmp
-0000b4d0: 290d 0a20 2020 2020 2020 2020 2020 2063  )..            c
-0000b4e0: 6f6c 756d 6e73 5f61 736b 6564 203d 204e  olumns_asked = N
-0000b4f0: 6f6e 6520 6966 2063 6f6c 756d 6e73 2069  one if columns i
-0000b500: 7320 4e6f 6e65 2065 6c73 6520 6c69 7374  s None else list
-0000b510: 2863 6f6c 756d 6e73 290d 0a20 2020 2020  (columns)..     
-0000b520: 2020 2020 2020 2066 6f72 6d61 7474 6572         formatter
-0000b530: 203d 205f 6f67 725f 7371 6c5f 7574 696c   = _ogr_sql_util
-0000b540: 2e43 6f6c 756d 6e46 6f72 6d61 7474 6572  .ColumnFormatter
-0000b550: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-0000b560: 2020 2063 6f6c 756d 6e73 5f61 736b 6564     columns_asked
-0000b570: 3d63 6f6c 756d 6e73 5f61 736b 6564 2c0d  =columns_asked,.
-0000b580: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b590: 2063 6f6c 756d 6e73 5f69 6e5f 6c61 7965   columns_in_laye
-0000b5a0: 723d 6c61 7965 7269 6e66 6f2e 636f 6c75  r=layerinfo.colu
-0000b5b0: 6d6e 732c 0d0a 2020 2020 2020 2020 2020  mns,..          
-0000b5c0: 2020 2020 2020 6669 645f 636f 6c75 6d6e        fid_column
-0000b5d0: 3d6c 6179 6572 696e 666f 2e66 6964 5f63  =layerinfo.fid_c
-0000b5e0: 6f6c 756d 6e2c 0d0a 2020 2020 2020 2020  olumn,..        
-0000b5f0: 2020 2020 290d 0a20 2020 2020 2020 2020      )..         
-0000b600: 2020 2066 6f72 6d61 745f 6b77 6172 6773     format_kwargs
-0000b610: 5b70 6c61 6365 686f 6c64 6572 5d20 3d20  [placeholder] = 
-0000b620: 666f 726d 6174 7465 722e 7072 6566 6978  formatter.prefix
-0000b630: 6564 5f61 6c69 6173 6564 2829 0d0a 0d0a  ed_aliased()....
-0000b640: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-0000b650: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-0000b660: 2056 616c 7565 4572 726f 7228 0d0a 2020   ValueError(..  
-0000b670: 2020 2020 2020 2020 2020 2020 2020 6622                f"
-0000b680: 756e 6b6e 6f77 6e20 706c 6163 6568 6f6c  unknown placehol
-0000b690: 6465 7220 7b70 6c61 6365 686f 6c64 6572  der {placeholder
-0000b6a0: 7d20 696e 2073 716c 5f73 746d 743a 207b  } in sql_stmt: {
-0000b6b0: 7371 6c5f 7374 6d74 7d22 0d0a 2020 2020  sql_stmt}"..    
-0000b6c0: 2020 2020 2020 2020 290d 0a0d 0a20 2020          )....   
-0000b6d0: 2069 6620 6c65 6e28 666f 726d 6174 5f6b   if len(format_k
-0000b6e0: 7761 7267 7329 203e 2030 3a0d 0a20 2020  wargs) > 0:..   
-0000b6f0: 2020 2020 2073 716c 5f73 746d 7420 3d20       sql_stmt = 
-0000b700: 7371 6c5f 7374 6d74 2e66 6f72 6d61 7428  sql_stmt.format(
-0000b710: 2a2a 666f 726d 6174 5f6b 7761 7267 7329  **format_kwargs)
-0000b720: 0d0a 2020 2020 7265 7475 726e 2073 716c  ..    return sql
-0000b730: 5f73 746d 740d 0a0d 0a0d 0a64 6566 2072  _stmt......def r
-0000b740: 6561 645f 6669 6c65 5f73 716c 280d 0a20  ead_file_sql(.. 
-0000b750: 2020 2070 6174 683a 2055 6e69 6f6e 5b73     path: Union[s
-0000b760: 7472 2c20 226f 732e 5061 7468 4c69 6b65  tr, "os.PathLike
-0000b770: 5b41 6e79 5d22 5d2c 0d0a 2020 2020 7371  [Any]"],..    sq
-0000b780: 6c5f 7374 6d74 3a20 7374 722c 0d0a 2020  l_stmt: str,..  
-0000b790: 2020 7371 6c5f 6469 616c 6563 743a 204f    sql_dialect: O
-0000b7a0: 7074 696f 6e61 6c5b 4c69 7465 7261 6c5b  ptional[Literal[
-0000b7b0: 2253 514c 4954 4522 2c20 224f 4752 5351  "SQLITE", "OGRSQ
-0000b7c0: 4c22 5d5d 203d 2022 5351 4c49 5445 222c  L"]] = "SQLITE",
-0000b7d0: 0d0a 2020 2020 6c61 7965 723a 204f 7074  ..    layer: Opt
-0000b7e0: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
-0000b7f0: 652c 0d0a 2020 2020 6967 6e6f 7265 5f67  e,..    ignore_g
-0000b800: 656f 6d65 7472 793a 2062 6f6f 6c20 3d20  eometry: bool = 
-0000b810: 4661 6c73 652c 0d0a 2920 2d3e 2055 6e69  False,..) -> Uni
-0000b820: 6f6e 5b70 642e 4461 7461 4672 616d 652c  on[pd.DataFrame,
-0000b830: 2067 7064 2e47 656f 4461 7461 4672 616d   gpd.GeoDataFram
-0000b840: 655d 3a0d 0a20 2020 2022 2222 0d0a 2020  e]:..    """..  
-0000b850: 2020 4445 5052 4543 4154 4544 3a20 5265    DEPRECATED: Re
-0000b860: 6164 7320 6120 6669 6c65 2075 7369 6e67  ads a file using
-0000b870: 2061 6e20 7371 6c20 7374 6174 656d 656e   an sql statemen
-0000b880: 742e 0d0a 0d0a 2020 2020 4172 6773 3a0d  t.....    Args:.
-0000b890: 0a20 2020 2020 2020 2070 6174 6820 2866  .        path (f
-0000b8a0: 696c 6520 7061 7468 293a 2070 6174 6820  ile path): path 
-0000b8b0: 746f 2074 6865 2066 696c 6520 746f 2072  to the file to r
-0000b8c0: 6561 6420 6672 6f6d 0d0a 2020 2020 2020  ead from..      
-0000b8d0: 2020 7371 6c5f 7374 6d74 2028 7374 7229    sql_stmt (str)
-0000b8e0: 3a20 7371 6c20 7374 6174 656d 656e 7420  : sql statement 
-0000b8f0: 746f 2075 7365 0d0a 2020 2020 2020 2020  to use..        
-0000b900: 7371 6c5f 6469 616c 6563 7420 2873 7472  sql_dialect (str
-0000b910: 2c20 6f70 7469 6f6e 616c 293a 2053 716c  , optional): Sql
-0000b920: 2064 6961 6c65 6374 2075 7365 642e 2044   dialect used. D
-0000b930: 6566 6175 6c74 7320 746f 2027 5351 4c49  efaults to 'SQLI
-0000b940: 5445 272e 0d0a 2020 2020 2020 2020 6c61  TE'...        la
-0000b950: 7965 7220 2873 7472 2c20 6f70 7469 6f6e  yer (str, option
-0000b960: 616c 293a 2054 6865 206c 6179 6572 2074  al): The layer t
-0000b970: 6f20 7265 6164 2e20 4966 206e 6f20 6c61  o read. If no la
-0000b980: 7965 7220 6973 2073 7065 6369 6669 6564  yer is specified
-0000b990: 2c0d 0a20 2020 2020 2020 2020 2020 2072  ,..            r
-0000b9a0: 6561 6473 2074 6865 206f 6e6c 7920 6c61  eads the only la
-0000b9b0: 7965 7220 696e 2074 6865 2066 696c 6520  yer in the file 
-0000b9c0: 6f72 2074 6872 6f77 7320 616e 2045 7863  or throws an Exc
-0000b9d0: 6570 7469 6f6e 2e0d 0a20 2020 2020 2020  eption...       
-0000b9e0: 2069 676e 6f72 655f 6765 6f6d 6574 7279   ignore_geometry
-0000b9f0: 2028 626f 6f6c 2c20 6f70 7469 6f6e 616c   (bool, optional
-0000ba00: 293a 2054 7275 6520 6e6f 7420 746f 2072  ): True not to r
-0000ba10: 6561 642f 7265 7475 726e 2074 6865 2067  ead/return the g
-0000ba20: 656f 6d61 7472 792e 0d0a 2020 2020 2020  eomatry...      
-0000ba30: 2020 2020 2020 4465 6661 756c 7473 2074        Defaults t
-0000ba40: 6f20 4661 6c73 652e 0d0a 0d0a 2020 2020  o False.....    
-0000ba50: 5265 7475 726e 733a 0d0a 2020 2020 2020  Returns:..      
-0000ba60: 2020 556e 696f 6e5b 7064 2e44 6174 6146    Union[pd.DataF
-0000ba70: 7261 6d65 2c20 6770 642e 4765 6f44 6174  rame, gpd.GeoDat
-0000ba80: 6146 7261 6d65 5d3a 2054 6865 2064 6174  aFrame]: The dat
-0000ba90: 6120 7265 6164 2e0d 0a20 2020 2022 2222  a read...    """
-0000baa0: 0d0a 2020 2020 7761 726e 696e 6773 2e77  ..    warnings.w
-0000bab0: 6172 6e28 0d0a 2020 2020 2020 2020 2772  arn(..        'r
-0000bac0: 6561 645f 6669 6c65 5f73 716c 2069 7320  ead_file_sql is 
-0000bad0: 6465 7072 6563 6174 6564 3a20 7573 6520  deprecated: use 
-0000bae0: 7265 6164 5f66 696c 6521 204d 696e 643a  read_file! Mind:
-0000baf0: 2073 716c 5f64 6961 6c65 6374 2069 7320   sql_dialect is 
-0000bb00: 6e6f 7420 2253 514c 4954 4522 2027 0d0a  not "SQLITE" '..
-0000bb10: 2020 2020 2020 2020 2262 7920 6465 6661          "by defa
-0000bb20: 756c 7420 7468 6572 6521 222c 0d0a 2020  ult there!",..  
-0000bb30: 2020 2020 2020 4675 7475 7265 5761 726e        FutureWarn
-0000bb40: 696e 672c 0d0a 2020 2020 290d 0a0d 0a20  ing,..    ).... 
-0000bb50: 2020 2023 2052 756e 0d0a 2020 2020 7265     # Run..    re
-0000bb60: 7475 726e 205f 7265 6164 5f66 696c 655f  turn _read_file_
-0000bb70: 6261 7365 280d 0a20 2020 2020 2020 2070  base(..        p
-0000bb80: 6174 682c 0d0a 2020 2020 2020 2020 7371  ath,..        sq
-0000bb90: 6c5f 7374 6d74 3d73 716c 5f73 746d 742c  l_stmt=sql_stmt,
-0000bba0: 0d0a 2020 2020 2020 2020 7371 6c5f 6469  ..        sql_di
-0000bbb0: 616c 6563 743d 7371 6c5f 6469 616c 6563  alect=sql_dialec
-0000bbc0: 742c 0d0a 2020 2020 2020 2020 6c61 7965  t,..        laye
-0000bbd0: 723d 6c61 7965 722c 0d0a 2020 2020 2020  r=layer,..      
-0000bbe0: 2020 6967 6e6f 7265 5f67 656f 6d65 7472    ignore_geometr
-0000bbf0: 793d 6967 6e6f 7265 5f67 656f 6d65 7472  y=ignore_geometr
-0000bc00: 792c 0d0a 2020 2020 290d 0a0d 0a0d 0a64  y,..    )......d
-0000bc10: 6566 2074 6f5f 6669 6c65 280d 0a20 2020  ef to_file(..   
-0000bc20: 2067 6466 3a20 556e 696f 6e5b 7064 2e44   gdf: Union[pd.D
-0000bc30: 6174 6146 7261 6d65 2c20 6770 642e 4765  ataFrame, gpd.Ge
-0000bc40: 6f44 6174 6146 7261 6d65 5d2c 0d0a 2020  oDataFrame],..  
-0000bc50: 2020 7061 7468 3a20 556e 696f 6e5b 7374    path: Union[st
-0000bc60: 722c 2022 6f73 2e50 6174 684c 696b 655b  r, "os.PathLike[
-0000bc70: 416e 795d 225d 2c0d 0a20 2020 206c 6179  Any]"],..    lay
-0000bc80: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
-0000bc90: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2066  ] = None,..    f
-0000bca0: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-0000bcb0: 6574 7279 7479 7065 3a20 556e 696f 6e5b  etrytype: Union[
-0000bcc0: 4765 6f6d 6574 7279 5479 7065 2c20 7374  GeometryType, st
-0000bcd0: 722c 204e 6f6e 655d 203d 204e 6f6e 652c  r, None] = None,
-0000bce0: 0d0a 2020 2020 666f 7263 655f 6d75 6c74  ..    force_mult
-0000bcf0: 6974 7970 653a 2062 6f6f 6c20 3d20 4661  itype: bool = Fa
-0000bd00: 6c73 652c 0d0a 2020 2020 6170 7065 6e64  lse,..    append
-0000bd10: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-0000bd20: 0a20 2020 2061 7070 656e 645f 7469 6d65  .    append_time
-0000bd30: 6f75 745f 733a 2069 6e74 203d 2036 3030  out_s: int = 600
-0000bd40: 2c0d 0a20 2020 2069 6e64 6578 3a20 626f  ,..    index: bo
-0000bd50: 6f6c 203d 2054 7275 652c 0d0a 2020 2020  ol = True,..    
-0000bd60: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
-0000bd70: 6e64 6578 3a20 4f70 7469 6f6e 616c 5b62  ndex: Optional[b
-0000bd80: 6f6f 6c5d 203d 2054 7275 652c 0d0a 293a  ool] = True,..):
-0000bd90: 0d0a 2020 2020 2222 220d 0a20 2020 2057  ..    """..    W
-0000bda0: 7269 7465 7320 6120 7061 6e64 6173 2064  rites a pandas d
-0000bdb0: 6174 6166 7261 6d65 2074 6f20 6669 6c65  ataframe to file
-0000bdc0: 2e0d 0a0d 0a20 2020 2054 6865 2066 696c  .....    The fil
-0000bdd0: 6566 6f72 6d61 7420 6973 2064 6574 6563  eformat is detec
-0000bde0: 7465 6420 6261 7365 6420 6f6e 2074 6865  ted based on the
-0000bdf0: 2066 696c 6570 6174 6820 6578 7465 6e73   filepath extens
-0000be00: 696f 6e2e 0d0a 0d0a 2020 2020 5468 6520  ion.....    The 
-0000be10: 756e 6465 726c 7969 6e67 206c 6962 7261  underlying libra
-0000be20: 7279 2075 7365 6420 746f 2077 7269 7465  ry used to write
-0000be30: 2074 6865 2066 696c 6520 6361 6e20 6265   the file can be
-0000be40: 2063 686f 6f73 656e 2075 7369 6e67 2074   choosen using t
-0000be50: 6865 0d0a 2020 2020 2247 464f 5f49 4f5f  he..    "GFO_IO_
-0000be60: 454e 4749 4e45 2220 656e 7669 726f 6e6d  ENGINE" environm
-0000be70: 656e 7420 7661 7269 6162 6c65 2e20 506f  ent variable. Po
-0000be80: 7373 6962 6c65 2076 616c 7565 7320 6172  ssible values ar
-0000be90: 6520 2266 696f 6e61 2220 616e 6420 2270  e "fiona" and "p
-0000bea0: 796f 6772 696f 222e 0d0a 2020 2020 4465  yogrio"...    De
-0000beb0: 6661 756c 7420 656e 6769 6e65 2069 7320  fault engine is 
-0000bec0: 2270 796f 6772 696f 222e 0d0a 0d0a 2020  "pyogrio".....  
-0000bed0: 2020 4172 6773 3a0d 0a20 2020 2020 2020    Args:..       
-0000bee0: 2067 6466 2028 6770 642e 4765 6f44 6174   gdf (gpd.GeoDat
-0000bef0: 6146 7261 6d65 293a 2054 6865 2047 656f  aFrame): The Geo
-0000bf00: 4461 7461 4672 616d 6520 746f 2065 7870  DataFrame to exp
-0000bf10: 6f72 7420 746f 2066 696c 652e 0d0a 2020  ort to file...  
-0000bf20: 2020 2020 2020 7061 7468 2028 556e 696f        path (Unio
-0000bf30: 6e5b 7374 722c 293a 2054 6865 2066 696c  n[str,): The fil
-0000bf40: 6520 7061 7468 2074 6f20 7772 6974 6520  e path to write 
-0000bf50: 746f 2e0d 0a20 2020 2020 2020 206c 6179  to...        lay
-0000bf60: 6572 2028 7374 722c 206f 7074 696f 6e61  er (str, optiona
-0000bf70: 6c29 3a20 5468 6520 6c61 7965 7220 746f  l): The layer to
-0000bf80: 2072 6561 642e 2049 6620 6e6f 206c 6179   read. If no lay
-0000bf90: 6572 2069 7320 7370 6563 6966 6965 642c  er is specified,
-0000bfa0: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-0000bfb0: 6164 7320 7468 6520 6f6e 6c79 206c 6179  ads the only lay
-0000bfc0: 6572 2069 6e20 7468 6520 6669 6c65 206f  er in the file o
-0000bfd0: 7220 7468 726f 7773 2061 6e20 4578 6365  r throws an Exce
-0000bfe0: 7074 696f 6e2e 0d0a 2020 2020 2020 2020  ption...        
+00007790: 684c 696b 655b 416e 795d 225d 2c0a 2020  hLike[Any]"],.  
+000077a0: 2020 6c61 7965 723a 204f 7074 696f 6e61    layer: Optiona
+000077b0: 6c5b 7374 725d 203d 204e 6f6e 652c 0a20  l[str] = None,. 
+000077c0: 2020 2063 6f6c 756d 6e73 3a20 4f70 7469     columns: Opti
+000077d0: 6f6e 616c 5b49 7465 7261 626c 655b 7374  onal[Iterable[st
+000077e0: 725d 5d20 3d20 4e6f 6e65 2c0a 2020 2020  r]] = None,.    
+000077f0: 6262 6f78 3d4e 6f6e 652c 0a20 2020 2072  bbox=None,.    r
+00007800: 6f77 733d 4e6f 6e65 2c0a 2020 2020 7371  ows=None,.    sq
+00007810: 6c5f 7374 6d74 3a20 4f70 7469 6f6e 616c  l_stmt: Optional
+00007820: 5b73 7472 5d20 3d20 4e6f 6e65 2c0a 2020  [str] = None,.  
+00007830: 2020 7371 6c5f 6469 616c 6563 743a 204f    sql_dialect: O
+00007840: 7074 696f 6e61 6c5b 4c69 7465 7261 6c5b  ptional[Literal[
+00007850: 2253 514c 4954 4522 2c20 224f 4752 5351  "SQLITE", "OGRSQ
+00007860: 4c22 5d5d 203d 204e 6f6e 652c 0a20 2020  L"]] = None,.   
+00007870: 2069 676e 6f72 655f 6765 6f6d 6574 7279   ignore_geometry
+00007880: 3a20 626f 6f6c 203d 2046 616c 7365 2c0a  : bool = False,.
+00007890: 2020 2020 6669 645f 6173 5f69 6e64 6578      fid_as_index
+000078a0: 3a20 626f 6f6c 203d 2046 616c 7365 2c0a  : bool = False,.
+000078b0: 2920 2d3e 2067 7064 2e47 656f 4461 7461  ) -> gpd.GeoData
+000078c0: 4672 616d 653a 0a20 2020 2022 2222 0a20  Frame:.    """. 
+000078d0: 2020 2052 6561 6473 2061 2066 696c 6520     Reads a file 
+000078e0: 746f 2061 2067 656f 7061 6e64 6173 2047  to a geopandas G
+000078f0: 656f 4461 7461 6672 616d 652e 0a0a 2020  eoDataframe...  
+00007900: 2020 5468 6520 6669 6c65 2066 6f72 6d61    The file forma
+00007910: 7420 6973 2064 6574 6563 7465 6420 6261  t is detected ba
+00007920: 7365 6420 6f6e 2074 6865 2066 696c 6570  sed on the filep
+00007930: 6174 6820 6578 7465 6e73 696f 6e2e 0a0a  ath extension...
+00007940: 2020 2020 4966 2061 6e20 7371 6c5f 7374      If an sql_st
+00007950: 6d74 2069 7320 7370 6563 6966 6965 642c  mt is specified,
+00007960: 2074 6865 2073 716c 6974 6520 7175 6572   the sqlite quer
+00007970: 7920 6361 6e20 636f 6e74 6169 6e20 666f  y can contain fo
+00007980: 6c6c 6f77 696e 6720 706c 6163 6568 6f6c  llowing placehol
+00007990: 6465 7273 0a20 2020 2074 6861 7420 7769  ders.    that wi
+000079a0: 6c6c 2062 6520 6175 746f 6d61 7469 6361  ll be automatica
+000079b0: 6c6c 7920 7265 706c 6163 6564 2066 6f72  lly replaced for
+000079c0: 2079 6f75 3a0a 0a20 2020 2020 202a 207b   you:..      * {
+000079d0: 6765 6f6d 6574 7279 636f 6c75 6d6e 7d3a  geometrycolumn}:
+000079e0: 2074 6865 2063 6f6c 756d 6e20 7768 6572   the column wher
+000079f0: 6520 7468 6520 7072 696d 6172 7920 6765  e the primary ge
+00007a00: 6f6d 6574 7279 2069 7320 7374 6f72 6564  ometry is stored
+00007a10: 2e0a 2020 2020 2020 2a20 7b63 6f6c 756d  ..      * {colum
+00007a20: 6e73 5f74 6f5f 7365 6c65 6374 5f73 7472  ns_to_select_str
+00007a30: 7d3a 2069 6620 2763 6f6c 756d 6e73 2720  }: if 'columns' 
+00007a40: 6973 206e 6f74 204e 6f6e 652c 2074 686f  is not None, tho
+00007a50: 7365 2063 6f6c 756d 6e73 2c0a 2020 2020  se columns,.    
+00007a60: 2020 2020 6f74 6865 7277 6973 6520 616c      otherwise al
+00007a70: 6c20 636f 6c75 6d6e 7320 6f66 2074 6865  l columns of the
+00007a80: 206c 6179 6572 2e0a 2020 2020 2020 2a20   layer..      * 
+00007a90: 7b69 6e70 7574 5f6c 6179 6572 7d3a 2074  {input_layer}: t
+00007aa0: 6865 206c 6179 6572 206e 616d 6520 6f66  he layer name of
+00007ab0: 2074 6865 2069 6e70 7574 206c 6179 6572   the input layer
+00007ac0: 2e0a 0a20 2020 2045 7861 6d70 6c65 2073  ...    Example s
+00007ad0: 716c 2073 7461 7465 6d65 6e74 2077 6974  ql statement wit
+00007ae0: 6820 706c 6163 6568 6f6c 6465 7273 3a0a  h placeholders:.
+00007af0: 2020 2020 3a3a 0a0a 2020 2020 2020 2020      ::..        
+00007b00: 5345 4c45 4354 207b 6765 6f6d 6574 7279  SELECT {geometry
+00007b10: 636f 6c75 6d6e 7d0a 2020 2020 2020 2020  column}.        
+00007b20: 2020 2020 2020 7b63 6f6c 756d 6e73 5f74        {columns_t
+00007b30: 6f5f 7365 6c65 6374 5f73 7472 7d0a 2020  o_select_str}.  
+00007b40: 2020 2020 2020 2020 4652 4f4d 2022 7b69          FROM "{i
+00007b50: 6e70 7574 5f6c 6179 6572 7d22 206c 6179  nput_layer}" lay
+00007b60: 6572 0a0a 2020 2020 5468 6520 756e 6465  er..    The unde
+00007b70: 726c 7969 6e67 206c 6962 7261 7279 2075  rlying library u
+00007b80: 7365 6420 746f 2072 6561 6420 7468 6520  sed to read the 
+00007b90: 6669 6c65 2063 616e 2062 6520 6368 6f6f  file can be choo
+00007ba0: 7365 6e20 7573 696e 6720 7468 650a 2020  sen using the.  
+00007bb0: 2020 2247 464f 5f49 4f5f 454e 4749 4e45    "GFO_IO_ENGINE
+00007bc0: 2220 656e 7669 726f 6e6d 656e 7420 7661  " environment va
+00007bd0: 7269 6162 6c65 2e20 506f 7373 6962 6c65  riable. Possible
+00007be0: 2076 616c 7565 7320 6172 6520 2266 696f   values are "fio
+00007bf0: 6e61 2220 616e 6420 2270 796f 6772 696f  na" and "pyogrio
+00007c00: 222e 0a20 2020 2054 6869 7320 6f70 7469  "..    This opti
+00007c10: 6f6e 2069 7320 6372 6561 7465 6420 6173  on is created as
+00007c20: 2061 2074 656d 706f 7261 7279 2066 616c   a temporary fal
+00007c30: 6c62 6163 6b20 746f 2022 6669 6f6e 6122  lback to "fiona"
+00007c40: 2066 6f72 2063 6173 6573 2077 6865 7265   for cases where
+00007c50: 2022 7079 6f67 7269 6f22 0a20 2020 2067   "pyogrio".    g
+00007c60: 6976 6573 2069 7373 7565 732c 2073 6f20  ives issues, so 
+00007c70: 706c 6561 7365 2072 6570 6f72 7420 6973  please report is
+00007c80: 7375 6573 2069 6620 7468 6579 2061 7265  sues if they are
+00007c90: 2065 6e63 6f75 6e74 6572 6564 2e20 496e   encountered. In
+00007ca0: 2074 6865 2066 7574 7572 6520 7375 7070   the future supp
+00007cb0: 6f72 740a 2020 2020 666f 7220 7468 6520  ort.    for the 
+00007cc0: 2266 696f 6e61 2220 656e 6769 6e65 206d  "fiona" engine m
+00007cd0: 6f73 7420 6c69 6b65 6c79 2077 696c 6c20  ost likely will 
+00007ce0: 6265 2072 656d 6f76 6564 2e20 4465 6661  be removed. Defa
+00007cf0: 756c 7420 656e 6769 6e65 2069 7320 2270  ult engine is "p
+00007d00: 796f 6772 696f 222e 0a0a 2020 2020 4172  yogrio"...    Ar
+00007d10: 6773 3a0a 2020 2020 2020 2020 7061 7468  gs:.        path
+00007d20: 2028 6669 6c65 2070 6174 6829 3a20 7061   (file path): pa
+00007d30: 7468 2074 6f20 7468 6520 6669 6c65 2074  th to the file t
+00007d40: 6f20 7265 6164 2066 726f 6d0a 2020 2020  o read from.    
+00007d50: 2020 2020 6c61 7965 7220 2873 7472 2c20      layer (str, 
+00007d60: 6f70 7469 6f6e 616c 293a 2054 6865 206c  optional): The l
+00007d70: 6179 6572 2074 6f20 7265 6164 2e20 4465  ayer to read. De
+00007d80: 6661 756c 7473 2074 6f20 4e6f 6e65 2c0a  faults to None,.
+00007d90: 2020 2020 2020 2020 2020 2020 7468 656e              then
+00007da0: 2072 6561 6473 2074 6865 206f 6e6c 7920   reads the only 
+00007db0: 6c61 7965 7220 696e 2074 6865 2066 696c  layer in the fil
+00007dc0: 6520 6f72 2074 6872 6f77 7320 6572 726f  e or throws erro
+00007dd0: 722e 0a20 2020 2020 2020 2063 6f6c 756d  r..        colum
+00007de0: 6e73 2028 4974 6572 6162 6c65 5b73 7472  ns (Iterable[str
+00007df0: 5d2c 206f 7074 696f 6e61 6c29 3a20 5468  ], optional): Th
+00007e00: 6520 286e 6f6e 2d67 656f 6d65 7472 7929  e (non-geometry)
+00007e10: 2063 6f6c 756d 6e73 2074 6f20 7265 6164   columns to read
+00007e20: 2077 696c 6c0a 2020 2020 2020 2020 2020   will.          
+00007e30: 2020 6265 2072 6574 7572 6e65 6420 696e    be returned in
+00007e40: 2074 6865 206f 7264 6572 2073 7065 6369   the order speci
+00007e50: 6669 6564 2e20 4966 204e 6f6e 652c 2061  fied. If None, a
+00007e60: 6c6c 2073 7461 6e64 6172 6420 636f 6c75  ll standard colu
+00007e70: 6d6e 7320 6172 6520 7265 6164 2e0a 2020  mns are read..  
+00007e80: 2020 2020 2020 2020 2020 496e 2061 6464            In add
+00007e90: 6974 696f 6e20 746f 2073 7461 6e64 6172  ition to standar
+00007ea0: 6420 636f 6c75 6d6e 732c 2069 7420 6973  d columns, it is
+00007eb0: 2061 6c73 6f20 706f 7373 6962 6c65 0a20   also possible. 
+00007ec0: 2020 2020 2020 2020 2020 2074 6f20 7370             to sp
+00007ed0: 6563 6966 7920 2266 6964 222c 2061 2075  ecify "fid", a u
+00007ee0: 6e69 7175 6520 696e 6465 7820 6176 6169  nique index avai
+00007ef0: 6c61 626c 6520 696e 2061 6c6c 2069 6e70  lable in all inp
+00007f00: 7574 2066 696c 6573 2e20 4e6f 7465 2074  ut files. Note t
+00007f10: 6861 7420 7468 650a 2020 2020 2020 2020  hat the.        
+00007f20: 2020 2020 2266 6964 2220 7769 6c6c 2062      "fid" will b
+00007f30: 6520 616c 6961 7365 6420 6567 2e20 746f  e aliased eg. to
+00007f40: 2022 6669 645f 3122 2e20 4465 6661 756c   "fid_1". Defaul
+00007f50: 7473 2074 6f20 4e6f 6e65 2e0a 2020 2020  ts to None..    
+00007f60: 2020 2020 6262 6f78 2028 5b74 7970 655d      bbox ([type]
+00007f70: 2c20 6f70 7469 6f6e 616c 293a 2052 6561  , optional): Rea
+00007f80: 6420 6f6e 6c79 2067 656f 6d65 7472 6965  d only geometrie
+00007f90: 7320 696e 7465 7273 6563 7469 6e67 2074  s intersecting t
+00007fa0: 6869 7320 6262 6f78 2e0a 2020 2020 2020  his bbox..      
+00007fb0: 2020 2020 2020 4465 6661 756c 7473 2074        Defaults t
+00007fc0: 6f20 4e6f 6e65 2c20 7468 656e 2061 6c6c  o None, then all
+00007fd0: 2072 6f77 7320 6172 6520 7265 6164 2e0a   rows are read..
+00007fe0: 2020 2020 2020 2020 726f 7773 2028 5b74          rows ([t
+00007ff0: 7970 655d 2c20 6f70 7469 6f6e 616c 293a  ype], optional):
+00008000: 2052 6561 6420 6f6e 6c79 2074 6865 2072   Read only the r
+00008010: 6f77 7320 7370 6563 6966 6965 642e 0a20  ows specified.. 
+00008020: 2020 2020 2020 2020 2020 2044 6566 6175             Defau
+00008030: 6c74 7320 746f 204e 6f6e 652c 2074 6865  lts to None, the
+00008040: 6e20 616c 6c20 726f 7773 2061 7265 2072  n all rows are r
+00008050: 6561 642e 0a20 2020 2020 2020 2073 716c  ead..        sql
+00008060: 5f73 746d 7420 2873 7472 293a 2073 716c  _stmt (str): sql
+00008070: 2073 7461 7465 6d65 6e74 2074 6f20 7573   statement to us
+00008080: 652e 204f 6e6c 7920 7375 7070 6f72 7465  e. Only supporte
+00008090: 6420 7769 7468 2022 7079 6f67 7269 6f22  d with "pyogrio"
+000080a0: 2065 6e67 696e 652e 0a20 2020 2020 2020   engine..       
+000080b0: 2073 716c 5f64 6961 6c65 6374 2028 7374   sql_dialect (st
+000080c0: 722c 206f 7074 696f 6e61 6c29 3a20 5371  r, optional): Sq
+000080d0: 6c20 6469 616c 6563 7420 7573 6564 2e20  l dialect used. 
+000080e0: 4966 204e 6f6e 652c 2066 6f72 2064 6174  If None, for dat
+000080f0: 6120 736f 7572 6365 7320 7769 7468 0a20  a sources with. 
+00008100: 2020 2020 2020 2020 2020 2065 7870 6c69             expli
+00008110: 6369 7420 5351 4c20 7375 7070 6f72 7420  cit SQL support 
+00008120: 7468 6520 7374 6174 656d 656e 7420 6973  the statement is
+00008130: 2070 726f 6365 7373 6564 2062 7920 7468   processed by th
+00008140: 6520 6465 6661 756c 7420 5351 4c20 656e  e default SQL en
+00008150: 6769 6e65 0a20 2020 2020 2020 2020 2020  gine.           
+00008160: 2028 652e 672e 2050 6f73 7447 4953 2c20   (e.g. PostGIS, 
+00008170: 4765 6f70 6163 6b61 6765 2c20 5370 6174  Geopackage, Spat
+00008180: 6961 6c69 7465 2c2e 2e2e 292e 2046 6f72  ialite,...). For
+00008190: 2064 6174 6120 736f 7572 6365 730a 2020   data sources.  
+000081a0: 2020 2020 2020 2020 2020 7769 7468 6f75            withou
+000081b0: 7420 5351 4c20 7375 7070 6f72 742c 2074  t SQL support, t
+000081c0: 6865 2022 4f47 5253 514c 2220 6469 616c  he "OGRSQL" dial
+000081d0: 6563 7420 6973 2074 6865 2064 6566 6175  ect is the defau
+000081e0: 6c74 2e20 4465 6661 756c 7473 2074 6f20  lt. Defaults to 
+000081f0: 4e6f 6e65 2e0a 2020 2020 2020 2020 6967  None..        ig
+00008200: 6e6f 7265 5f67 656f 6d65 7472 7920 2862  nore_geometry (b
+00008210: 6f6f 6c2c 206f 7074 696f 6e61 6c29 3a20  ool, optional): 
+00008220: 5472 7565 206e 6f74 2074 6f20 7265 6164  True not to read
+00008230: 2f72 6574 7572 6e20 7468 6520 6765 6f6d  /return the geom
+00008240: 6574 7279 2e0a 2020 2020 2020 2020 2020  etry..          
+00008250: 2020 4465 6661 756c 7473 2074 6f20 4661    Defaults to Fa
+00008260: 6c73 652e 0a20 2020 2020 2020 2066 6964  lse..        fid
+00008270: 5f61 735f 696e 6465 7820 2862 6f6f 6c2c  _as_index (bool,
+00008280: 206f 7074 696f 6e61 6c29 3a20 4966 2054   optional): If T
+00008290: 7275 652c 2077 696c 6c20 7573 6520 7468  rue, will use th
+000082a0: 6520 4649 4473 206f 6620 7468 6520 6665  e FIDs of the fe
+000082b0: 6174 7572 6573 2074 6861 740a 2020 2020  atures that.    
+000082c0: 2020 2020 2020 2020 7765 7265 2072 6561          were rea
+000082d0: 6420 6173 2074 6865 2069 6e64 6578 206f  d as the index o
+000082e0: 6620 7468 6520 4765 6f44 6174 6146 7261  f the GeoDataFra
+000082f0: 6d65 2e20 4d61 7920 7374 6172 7420 6174  me. May start at
+00008300: 2030 206f 7220 3120 6465 7065 6e64 696e   0 or 1 dependin
+00008310: 6720 6f6e 0a20 2020 2020 2020 2020 2020  g on.           
+00008320: 2074 6865 2064 7269 7665 722e 2044 6566   the driver. Def
+00008330: 6175 6c74 7320 746f 2046 616c 7365 2e0a  aults to False..
+00008340: 0a20 2020 2052 6169 7365 733a 0a20 2020  .    Raises:.   
+00008350: 2020 2020 2056 616c 7565 4572 726f 723a       ValueError:
+00008360: 2061 6e20 696e 7661 6c69 6420 7061 7261   an invalid para
+00008370: 6d65 7465 7220 7661 6c75 6520 7761 7320  meter value was 
+00008380: 7061 7373 6564 2e0a 0a20 2020 2052 6574  passed...    Ret
+00008390: 7572 6e73 3a0a 2020 2020 2020 2020 6770  urns:.        gp
+000083a0: 642e 4765 6f44 6174 6146 7261 6d65 3a20  d.GeoDataFrame: 
+000083b0: 7468 6520 6461 7461 2072 6561 642e 0a20  the data read.. 
+000083c0: 2020 2022 2222 0a20 2020 2072 6573 756c     """.    resul
+000083d0: 745f 6764 6620 3d20 5f72 6561 645f 6669  t_gdf = _read_fi
+000083e0: 6c65 5f62 6173 6528 0a20 2020 2020 2020  le_base(.       
+000083f0: 2070 6174 683d 7061 7468 2c0a 2020 2020   path=path,.    
+00008400: 2020 2020 6c61 7965 723d 6c61 7965 722c      layer=layer,
+00008410: 0a20 2020 2020 2020 2063 6f6c 756d 6e73  .        columns
+00008420: 3d63 6f6c 756d 6e73 2c0a 2020 2020 2020  =columns,.      
+00008430: 2020 6262 6f78 3d62 626f 782c 0a20 2020    bbox=bbox,.   
+00008440: 2020 2020 2072 6f77 733d 726f 7773 2c0a       rows=rows,.
+00008450: 2020 2020 2020 2020 7371 6c5f 7374 6d74          sql_stmt
+00008460: 3d73 716c 5f73 746d 742c 0a20 2020 2020  =sql_stmt,.     
+00008470: 2020 2073 716c 5f64 6961 6c65 6374 3d73     sql_dialect=s
+00008480: 716c 5f64 6961 6c65 6374 2c0a 2020 2020  ql_dialect,.    
+00008490: 2020 2020 6967 6e6f 7265 5f67 656f 6d65      ignore_geome
+000084a0: 7472 793d 6967 6e6f 7265 5f67 656f 6d65  try=ignore_geome
+000084b0: 7472 792c 0a20 2020 2020 2020 2066 6964  try,.        fid
+000084c0: 5f61 735f 696e 6465 783d 6669 645f 6173  _as_index=fid_as
+000084d0: 5f69 6e64 6578 2c0a 2020 2020 290a 0a20  _index,.    ).. 
+000084e0: 2020 2023 204e 6f20 6173 7365 7274 2074     # No assert t
+000084f0: 6f20 6b65 6570 2062 6163 6b77 6172 6473  o keep backwards
+00008500: 2063 6f6d 7061 7469 6269 6c69 7479 0a20   compatibility. 
+00008510: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
+00008520: 5f67 6466 2020 2320 7479 7065 3a20 6967  _gdf  # type: ig
+00008530: 6e6f 7265 0a0a 0a64 6566 2072 6561 645f  nore...def read_
+00008540: 6669 6c65 5f6e 6f67 656f 6d28 0a20 2020  file_nogeom(.   
+00008550: 2070 6174 683a 2055 6e69 6f6e 5b73 7472   path: Union[str
+00008560: 2c20 226f 732e 5061 7468 4c69 6b65 5b41  , "os.PathLike[A
+00008570: 6e79 5d22 5d2c 0a20 2020 206c 6179 6572  ny]"],.    layer
+00008580: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
+00008590: 3d20 4e6f 6e65 2c0a 2020 2020 636f 6c75  = None,.    colu
+000085a0: 6d6e 733a 204f 7074 696f 6e61 6c5b 4974  mns: Optional[It
+000085b0: 6572 6162 6c65 5b73 7472 5d5d 203d 204e  erable[str]] = N
+000085c0: 6f6e 652c 0a20 2020 2062 626f 783d 4e6f  one,.    bbox=No
+000085d0: 6e65 2c0a 2020 2020 726f 7773 3d4e 6f6e  ne,.    rows=Non
+000085e0: 652c 0a20 2020 2073 716c 5f73 746d 743a  e,.    sql_stmt:
+000085f0: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
+00008600: 204e 6f6e 652c 0a20 2020 2073 716c 5f64   None,.    sql_d
+00008610: 6961 6c65 6374 3a20 4f70 7469 6f6e 616c  ialect: Optional
+00008620: 5b4c 6974 6572 616c 5b22 5351 4c49 5445  [Literal["SQLITE
+00008630: 222c 2022 4f47 5253 514c 225d 5d20 3d20  ", "OGRSQL"]] = 
+00008640: 4e6f 6e65 2c0a 2020 2020 6669 645f 6173  None,.    fid_as
+00008650: 5f69 6e64 6578 3a20 626f 6f6c 203d 2046  _index: bool = F
+00008660: 616c 7365 2c0a 2920 2d3e 2070 642e 4461  alse,.) -> pd.Da
+00008670: 7461 4672 616d 653a 0a20 2020 2022 2222  taFrame:.    """
+00008680: 0a20 2020 2044 4550 5245 4341 5445 443a  .    DEPRECATED:
+00008690: 2070 6c65 6173 6520 7573 6520 7265 6164   please use read
+000086a0: 5f66 696c 6520 7769 7468 206f 7074 696f  _file with optio
+000086b0: 6e20 6967 6e6f 7265 5f67 656f 6d65 7472  n ignore_geometr
+000086c0: 793d 5472 7565 2e0a 2020 2020 2222 220a  y=True..    """.
+000086d0: 2020 2020 7761 726e 696e 6773 2e77 6172      warnings.war
+000086e0: 6e28 0a20 2020 2020 2020 2022 7265 6164  n(.        "read
+000086f0: 5f66 696c 655f 6e6f 6765 6f6d 2069 7320  _file_nogeom is 
+00008700: 6465 7072 6563 6174 6564 3a20 7573 6520  deprecated: use 
+00008710: 7265 6164 5f66 696c 6520 7769 7468 2069  read_file with i
+00008720: 676e 6f72 655f 6765 6f6d 6574 7279 3d54  gnore_geometry=T
+00008730: 7275 6522 2c0a 2020 2020 2020 2020 4675  rue",.        Fu
+00008740: 7475 7265 5761 726e 696e 672c 0a20 2020  tureWarning,.   
+00008750: 2029 0a20 2020 2072 6573 756c 745f 6764   ).    result_gd
+00008760: 6620 3d20 5f72 6561 645f 6669 6c65 5f62  f = _read_file_b
+00008770: 6173 6528 0a20 2020 2020 2020 2070 6174  ase(.        pat
+00008780: 683d 7061 7468 2c0a 2020 2020 2020 2020  h=path,.        
+00008790: 6c61 7965 723d 6c61 7965 722c 0a20 2020  layer=layer,.   
+000087a0: 2020 2020 2063 6f6c 756d 6e73 3d63 6f6c       columns=col
+000087b0: 756d 6e73 2c0a 2020 2020 2020 2020 6262  umns,.        bb
+000087c0: 6f78 3d62 626f 782c 0a20 2020 2020 2020  ox=bbox,.       
+000087d0: 2072 6f77 733d 726f 7773 2c0a 2020 2020   rows=rows,.    
+000087e0: 2020 2020 7371 6c5f 7374 6d74 3d73 716c      sql_stmt=sql
+000087f0: 5f73 746d 742c 0a20 2020 2020 2020 2073  _stmt,.        s
+00008800: 716c 5f64 6961 6c65 6374 3d73 716c 5f64  ql_dialect=sql_d
+00008810: 6961 6c65 6374 2c0a 2020 2020 2020 2020  ialect,.        
+00008820: 6967 6e6f 7265 5f67 656f 6d65 7472 793d  ignore_geometry=
+00008830: 5472 7565 2c0a 2020 2020 2020 2020 6669  True,.        fi
+00008840: 645f 6173 5f69 6e64 6578 3d66 6964 5f61  d_as_index=fid_a
+00008850: 735f 696e 6465 782c 0a20 2020 2029 0a20  s_index,.    ). 
+00008860: 2020 2061 7373 6572 7420 6973 696e 7374     assert isinst
+00008870: 616e 6365 2872 6573 756c 745f 6764 662c  ance(result_gdf,
+00008880: 2070 642e 4461 7461 4672 616d 6529 0a20   pd.DataFrame). 
+00008890: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
+000088a0: 5f67 6466 0a0a 0a64 6566 205f 7265 6164  _gdf...def _read
+000088b0: 5f66 696c 655f 6261 7365 280a 2020 2020  _file_base(.    
+000088c0: 7061 7468 3a20 556e 696f 6e5b 7374 722c  path: Union[str,
+000088d0: 2022 6f73 2e50 6174 684c 696b 655b 416e   "os.PathLike[An
+000088e0: 795d 225d 2c0a 2020 2020 6c61 7965 723a  y]"],.    layer:
+000088f0: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
+00008900: 204e 6f6e 652c 0a20 2020 2063 6f6c 756d   None,.    colum
+00008910: 6e73 3a20 4f70 7469 6f6e 616c 5b49 7465  ns: Optional[Ite
+00008920: 7261 626c 655b 7374 725d 5d20 3d20 4e6f  rable[str]] = No
+00008930: 6e65 2c0a 2020 2020 6262 6f78 3d4e 6f6e  ne,.    bbox=Non
+00008940: 652c 0a20 2020 2072 6f77 733d 4e6f 6e65  e,.    rows=None
+00008950: 2c0a 2020 2020 7371 6c5f 7374 6d74 3a20  ,.    sql_stmt: 
+00008960: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
+00008970: 4e6f 6e65 2c0a 2020 2020 7371 6c5f 6469  None,.    sql_di
+00008980: 616c 6563 743a 204f 7074 696f 6e61 6c5b  alect: Optional[
+00008990: 4c69 7465 7261 6c5b 2253 514c 4954 4522  Literal["SQLITE"
+000089a0: 2c20 224f 4752 5351 4c22 5d5d 203d 204e  , "OGRSQL"]] = N
+000089b0: 6f6e 652c 0a20 2020 2069 676e 6f72 655f  one,.    ignore_
+000089c0: 6765 6f6d 6574 7279 3a20 626f 6f6c 203d  geometry: bool =
+000089d0: 2046 616c 7365 2c0a 2020 2020 6669 645f   False,.    fid_
+000089e0: 6173 5f69 6e64 6578 3a20 626f 6f6c 203d  as_index: bool =
+000089f0: 2046 616c 7365 2c0a 2920 2d3e 2055 6e69   False,.) -> Uni
+00008a00: 6f6e 5b70 642e 4461 7461 4672 616d 652c  on[pd.DataFrame,
+00008a10: 2067 7064 2e47 656f 4461 7461 4672 616d   gpd.GeoDataFram
+00008a20: 655d 3a0a 2020 2020 2222 220a 2020 2020  e]:.    """.    
+00008a30: 5265 6164 7320 6120 6669 6c65 2074 6f20  Reads a file to 
+00008a40: 6120 7061 6e64 6173 2044 6174 6166 7261  a pandas Datafra
+00008a50: 6d65 2e0a 2020 2020 2222 220a 2020 2020  me..    """.    
+00008a60: 2320 4368 6563 6b20 6966 2074 6865 2066  # Check if the f
+00008a70: 6964 2063 6f6c 756d 6e20 6e65 6564 7320  id column needs 
+00008a80: 746f 2062 6520 7265 6164 2061 7320 636f  to be read as co
+00008a90: 6c75 6d6e 2076 6961 2074 6865 2063 6f6c  lumn via the col
+00008aa0: 756d 6e73 2070 6172 616d 6574 6572 0a20  umns parameter. 
+00008ab0: 2020 2066 6964 5f61 735f 636f 6c75 6d6e     fid_as_column
+00008ac0: 203d 2046 616c 7365 0a20 2020 2069 6620   = False.    if 
+00008ad0: 636f 6c75 6d6e 7320 6973 206e 6f74 204e  columns is not N
+00008ae0: 6f6e 653a 0a20 2020 2020 2020 2069 6620  one:.        if 
+00008af0: 2266 6964 2220 696e 205b 636f 6c75 6d6e  "fid" in [column
+00008b00: 2e6c 6f77 6572 2829 2066 6f72 2063 6f6c  .lower() for col
+00008b10: 756d 6e20 696e 2063 6f6c 756d 6e73 5d3a  umn in columns]:
+00008b20: 0a20 2020 2020 2020 2020 2020 2066 6964  .            fid
+00008b30: 5f61 735f 636f 6c75 6d6e 203d 2054 7275  _as_column = Tru
+00008b40: 650a 0a20 2020 2023 2052 6561 6420 7769  e..    # Read wi
+00008b50: 7468 2074 6865 2065 6e67 696e 6520 7370  th the engine sp
+00008b60: 6563 6966 6965 640a 2020 2020 656e 6769  ecified.    engi
+00008b70: 6e65 203d 205f 6765 745f 656e 6769 6e65  ne = _get_engine
+00008b80: 2829 0a20 2020 2069 6620 656e 6769 6e65  ().    if engine
+00008b90: 203d 3d20 2270 796f 6772 696f 223a 0a20   == "pyogrio":. 
+00008ba0: 2020 2020 2020 2067 6466 203d 205f 7265         gdf = _re
+00008bb0: 6164 5f66 696c 655f 6261 7365 5f70 796f  ad_file_base_pyo
+00008bc0: 6772 696f 280a 2020 2020 2020 2020 2020  grio(.          
+00008bd0: 2020 7061 7468 3d70 6174 682c 0a20 2020    path=path,.   
+00008be0: 2020 2020 2020 2020 206c 6179 6572 3d6c           layer=l
+00008bf0: 6179 6572 2c0a 2020 2020 2020 2020 2020  ayer,.          
+00008c00: 2020 636f 6c75 6d6e 733d 636f 6c75 6d6e    columns=column
+00008c10: 732c 0a20 2020 2020 2020 2020 2020 2062  s,.            b
+00008c20: 626f 783d 6262 6f78 2c0a 2020 2020 2020  box=bbox,.      
+00008c30: 2020 2020 2020 726f 7773 3d72 6f77 732c        rows=rows,
+00008c40: 0a20 2020 2020 2020 2020 2020 2073 716c  .            sql
+00008c50: 5f73 746d 743d 7371 6c5f 7374 6d74 2c0a  _stmt=sql_stmt,.
+00008c60: 2020 2020 2020 2020 2020 2020 7371 6c5f              sql_
+00008c70: 6469 616c 6563 743d 7371 6c5f 6469 616c  dialect=sql_dial
+00008c80: 6563 742c 0a20 2020 2020 2020 2020 2020  ect,.           
+00008c90: 2069 676e 6f72 655f 6765 6f6d 6574 7279   ignore_geometry
+00008ca0: 3d69 676e 6f72 655f 6765 6f6d 6574 7279  =ignore_geometry
+00008cb0: 2c0a 2020 2020 2020 2020 2020 2020 6669  ,.            fi
+00008cc0: 645f 6173 5f69 6e64 6578 3d66 6964 5f61  d_as_index=fid_a
+00008cd0: 735f 696e 6465 7820 6f72 2066 6964 5f61  s_index or fid_a
+00008ce0: 735f 636f 6c75 6d6e 2c0a 2020 2020 2020  s_column,.      
+00008cf0: 2020 290a 2020 2020 656c 6966 2065 6e67    ).    elif eng
+00008d00: 696e 6520 3d3d 2022 6669 6f6e 6122 3a0a  ine == "fiona":.
+00008d10: 2020 2020 2020 2020 6764 6620 3d20 5f72          gdf = _r
+00008d20: 6561 645f 6669 6c65 5f62 6173 655f 6669  ead_file_base_fi
+00008d30: 6f6e 6128 0a20 2020 2020 2020 2020 2020  ona(.           
+00008d40: 2070 6174 683d 7061 7468 2c0a 2020 2020   path=path,.    
+00008d50: 2020 2020 2020 2020 6c61 7965 723d 6c61          layer=la
+00008d60: 7965 722c 0a20 2020 2020 2020 2020 2020  yer,.           
+00008d70: 2063 6f6c 756d 6e73 3d63 6f6c 756d 6e73   columns=columns
+00008d80: 2c0a 2020 2020 2020 2020 2020 2020 6262  ,.            bb
+00008d90: 6f78 3d62 626f 782c 0a20 2020 2020 2020  ox=bbox,.       
+00008da0: 2020 2020 2072 6f77 733d 726f 7773 2c0a       rows=rows,.
+00008db0: 2020 2020 2020 2020 2020 2020 7371 6c5f              sql_
+00008dc0: 7374 6d74 3d73 716c 5f73 746d 742c 0a20  stmt=sql_stmt,. 
+00008dd0: 2020 2020 2020 2020 2020 2073 716c 5f64             sql_d
+00008de0: 6961 6c65 6374 3d73 716c 5f64 6961 6c65  ialect=sql_diale
+00008df0: 6374 2c0a 2020 2020 2020 2020 2020 2020  ct,.            
+00008e00: 6967 6e6f 7265 5f67 656f 6d65 7472 793d  ignore_geometry=
+00008e10: 6967 6e6f 7265 5f67 656f 6d65 7472 792c  ignore_geometry,
+00008e20: 0a20 2020 2020 2020 2020 2020 2066 6964  .            fid
+00008e30: 5f61 735f 696e 6465 783d 6669 645f 6173  _as_index=fid_as
+00008e40: 5f69 6e64 6578 206f 7220 6669 645f 6173  _index or fid_as
+00008e50: 5f63 6f6c 756d 6e2c 0a20 2020 2020 2020  _column,.       
+00008e60: 2029 0a20 2020 2065 6c73 653a 0a20 2020   ).    else:.   
+00008e70: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00008e80: 4572 726f 7228 6622 556e 7375 7070 6f72  Error(f"Unsuppor
+00008e90: 7465 6420 656e 6769 6e65 3a20 7b65 6e67  ted engine: {eng
+00008ea0: 696e 657d 2229 0a0a 2020 2020 2320 436f  ine}")..    # Co
+00008eb0: 7079 2074 6865 2069 6e64 6578 2074 6f20  py the index to 
+00008ec0: 6120 636f 6c75 6d6e 2069 6620 6e65 6564  a column if need
+00008ed0: 6564 2e2e 2e0a 2020 2020 6966 2066 6964  ed....    if fid
+00008ee0: 5f61 735f 636f 6c75 6d6e 3a0a 2020 2020  _as_column:.    
+00008ef0: 2020 2020 6764 665b 2266 6964 225d 203d      gdf["fid"] =
+00008f00: 2067 6466 2e69 6e64 6578 0a20 2020 2020   gdf.index.     
+00008f10: 2020 2069 6620 6e6f 7420 6669 645f 6173     if not fid_as
+00008f20: 5f69 6e64 6578 3a0a 2020 2020 2020 2020  _index:.        
+00008f30: 2020 2020 6764 6620 3d20 6764 662e 7265      gdf = gdf.re
+00008f40: 7365 745f 696e 6465 7828 6472 6f70 3d54  set_index(drop=T
+00008f50: 7275 6529 0a0a 2020 2020 7265 7475 726e  rue)..    return
+00008f60: 2067 6466 0a0a 0a64 6566 205f 7265 6164   gdf...def _read
+00008f70: 5f66 696c 655f 6261 7365 5f66 696f 6e61  _file_base_fiona
+00008f80: 280a 2020 2020 7061 7468 3a20 556e 696f  (.    path: Unio
+00008f90: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
+00008fa0: 696b 655b 416e 795d 225d 2c0a 2020 2020  ike[Any]"],.    
+00008fb0: 6c61 7965 723a 204f 7074 696f 6e61 6c5b  layer: Optional[
+00008fc0: 7374 725d 203d 204e 6f6e 652c 0a20 2020  str] = None,.   
+00008fd0: 2063 6f6c 756d 6e73 3a20 4f70 7469 6f6e   columns: Option
+00008fe0: 616c 5b49 7465 7261 626c 655b 7374 725d  al[Iterable[str]
+00008ff0: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 6262  ] = None,.    bb
+00009000: 6f78 3d4e 6f6e 652c 0a20 2020 2072 6f77  ox=None,.    row
+00009010: 733d 4e6f 6e65 2c0a 2020 2020 7371 6c5f  s=None,.    sql_
+00009020: 7374 6d74 3a20 4f70 7469 6f6e 616c 5b73  stmt: Optional[s
+00009030: 7472 5d20 3d20 4e6f 6e65 2c0a 2020 2020  tr] = None,.    
+00009040: 7371 6c5f 6469 616c 6563 743a 204f 7074  sql_dialect: Opt
+00009050: 696f 6e61 6c5b 4c69 7465 7261 6c5b 2253  ional[Literal["S
+00009060: 514c 4954 4522 2c20 224f 4752 5351 4c22  QLITE", "OGRSQL"
+00009070: 5d5d 203d 204e 6f6e 652c 0a20 2020 2069  ]] = None,.    i
+00009080: 676e 6f72 655f 6765 6f6d 6574 7279 3a20  gnore_geometry: 
+00009090: 626f 6f6c 203d 2046 616c 7365 2c0a 2020  bool = False,.  
+000090a0: 2020 6669 645f 6173 5f69 6e64 6578 3a20    fid_as_index: 
+000090b0: 626f 6f6c 203d 2046 616c 7365 2c0a 2920  bool = False,.) 
+000090c0: 2d3e 2055 6e69 6f6e 5b70 642e 4461 7461  -> Union[pd.Data
+000090d0: 4672 616d 652c 2067 7064 2e47 656f 4461  Frame, gpd.GeoDa
+000090e0: 7461 4672 616d 655d 3a0a 2020 2020 2222  taFrame]:.    ""
+000090f0: 220a 2020 2020 5265 6164 7320 6120 6669  ".    Reads a fi
+00009100: 6c65 2074 6f20 6120 7061 6e64 6173 2044  le to a pandas D
+00009110: 6174 6166 7261 6d65 2075 7369 6e67 2066  ataframe using f
+00009120: 696f 6e61 2e0a 2020 2020 2222 220a 2020  iona..    """.  
+00009130: 2020 6966 2069 676e 6f72 655f 6765 6f6d    if ignore_geom
+00009140: 6574 7279 2061 6e64 2063 6f6c 756d 6e73  etry and columns
+00009150: 203d 3d20 5b5d 3a0a 2020 2020 2020 2020   == []:.        
+00009160: 7265 7475 726e 2070 642e 4461 7461 4672  return pd.DataFr
+00009170: 616d 6528 290a 2020 2020 6966 2073 716c  ame().    if sql
+00009180: 5f73 746d 7420 6973 206e 6f74 204e 6f6e  _stmt is not Non
+00009190: 653a 0a20 2020 2020 2020 2072 6169 7365  e:.        raise
+000091a0: 2056 616c 7565 4572 726f 7228 2273 716c   ValueError("sql
+000091b0: 5f73 746d 7420 6973 206e 6f74 2073 7570  _stmt is not sup
+000091c0: 706f 7274 6564 2077 6974 6820 6669 6f6e  ported with fion
+000091d0: 6120 656e 6769 6e65 2229 0a0a 2020 2020  a engine")..    
+000091e0: 2320 496e 6974 0a20 2020 2070 6174 6820  # Init.    path 
+000091f0: 3d20 5061 7468 2870 6174 6829 0a20 2020  = Path(path).   
+00009200: 2069 6620 7061 7468 2e65 7869 7374 7328   if path.exists(
+00009210: 2920 6973 2046 616c 7365 3a0a 2020 2020  ) is False:.    
+00009220: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
+00009230: 7272 6f72 2866 2266 696c 6520 646f 6573  rror(f"file does
+00009240: 6e27 7420 6578 6973 743a 207b 7061 7468  n't exist: {path
+00009250: 7d22 290a 0a20 2020 2023 2049 6620 6e6f  }")..    # If no
+00009260: 206c 6179 6572 206e 616d 6520 7370 6563   layer name spec
+00009270: 6966 6965 642c 2063 6865 636b 2069 6620  ified, check if 
+00009280: 7468 6572 6520 6973 206f 6e6c 7920 6f6e  there is only on
+00009290: 6520 6c61 7965 7220 696e 2074 6865 2066  e layer in the f
+000092a0: 696c 652e 0a20 2020 2069 6620 6c61 7965  ile..    if laye
+000092b0: 7220 6973 204e 6f6e 653a 0a20 2020 2020  r is None:.     
+000092c0: 2020 206c 6179 6572 203d 2067 6574 5f6f     layer = get_o
+000092d0: 6e6c 795f 6c61 7965 7228 7061 7468 290a  nly_layer(path).
+000092e0: 0a20 2020 2023 2056 4552 5920 4449 5254  .    # VERY DIRT
+000092f0: 5920 6861 636b 2074 6f20 6765 7420 7468  Y hack to get th
+00009300: 6520 6669 640a 2020 2020 6966 2066 6964  e fid.    if fid
+00009310: 5f61 735f 696e 6465 783a 0a20 2020 2020  _as_index:.     
+00009320: 2020 2023 204d 616b 6520 6120 636f 7079     # Make a copy
+00009330: 2f63 6f70 7920 696e 7075 7420 6669 6c65  /copy input file
+00009340: 2074 6f20 6765 6f70 6163 6b61 6765 2c20   to geopackage, 
+00009350: 6173 2077 6520 7769 6c6c 2061 6464 2061  as we will add a
+00009360: 6e20 6669 642f 726f 7764 2063 6f6c 756d  n fid/rowd colum
+00009370: 6e0a 2020 2020 2020 2020 746d 705f 6669  n.        tmp_fi
+00009380: 645f 7061 7468 203d 2050 6174 6828 7465  d_path = Path(te
+00009390: 6d70 6669 6c65 2e6d 6b64 7465 6d70 2829  mpfile.mkdtemp()
+000093a0: 2920 2f20 6622 7b70 6174 682e 7374 656d  ) / f"{path.stem
+000093b0: 7d2e 6770 6b67 220a 2020 2020 2020 2020  }.gpkg".        
+000093c0: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
+000093d0: 2069 6620 4765 6f66 696c 6554 7970 6528   if GeofileType(
+000093e0: 7061 7468 2920 3d3d 2047 656f 6669 6c65  path) == Geofile
+000093f0: 5479 7065 2e47 504b 473a 0a20 2020 2020  Type.GPKG:.     
+00009400: 2020 2020 2020 2020 2020 2063 6f70 7928             copy(
+00009410: 7061 7468 2c20 746d 705f 6669 645f 7061  path, tmp_fid_pa
+00009420: 7468 290a 2020 2020 2020 2020 2020 2020  th).            
+00009430: 2020 2020 6164 645f 636f 6c75 6d6e 2874      add_column(t
+00009440: 6d70 5f66 6964 5f70 6174 682c 2022 5f5f  mp_fid_path, "__
+00009450: 544d 505f 4745 4f46 494c 454f 5053 5f46  TMP_GEOFILEOPS_F
+00009460: 4944 222c 2022 494e 5445 4745 5222 2c20  ID", "INTEGER", 
+00009470: 2266 6964 2229 0a20 2020 2020 2020 2020  "fid").         
+00009480: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00009490: 2020 2020 2020 2020 2063 6f6e 7665 7274           convert
+000094a0: 2870 6174 682c 2074 6d70 5f66 6964 5f70  (path, tmp_fid_p
+000094b0: 6174 6829 0a20 2020 2020 2020 2020 2020  ath).           
+000094c0: 2020 2020 2023 2066 6964 2069 6e20 7368       # fid in sh
+000094d0: 6170 6566 696c 6520 6973 2030 2062 6173  apefile is 0 bas
+000094e0: 6564 2c20 736f 2066 6964 2d31 0a20 2020  ed, so fid-1.   
+000094f0: 2020 2020 2020 2020 2020 2020 2061 6464               add
+00009500: 5f63 6f6c 756d 6e28 746d 705f 6669 645f  _column(tmp_fid_
+00009510: 7061 7468 2c20 225f 5f54 4d50 5f47 454f  path, "__TMP_GEO
+00009520: 4649 4c45 4f50 535f 4649 4422 2c20 2249  FILEOPS_FID", "I
+00009530: 4e54 4547 4552 222c 2022 6669 642d 3122  NTEGER", "fid-1"
+00009540: 290a 0a20 2020 2020 2020 2020 2020 2070  )..            p
+00009550: 6174 6820 3d20 746d 705f 6669 645f 7061  ath = tmp_fid_pa
+00009560: 7468 0a20 2020 2020 2020 2066 696e 616c  th.        final
+00009570: 6c79 3a0a 2020 2020 2020 2020 2020 2020  ly:.            
+00009580: 6966 2074 6d70 5f66 6964 5f70 6174 682e  if tmp_fid_path.
+00009590: 7061 7265 6e74 2e65 7869 7374 7328 293a  parent.exists():
+000095a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000095b0: 2073 6875 7469 6c2e 726d 7472 6565 2874   shutil.rmtree(t
+000095c0: 6d70 5f66 6964 5f70 6174 682c 2069 676e  mp_fid_path, ign
+000095d0: 6f72 655f 6572 726f 7273 3d54 7275 6529  ore_errors=True)
+000095e0: 0a0a 2020 2020 2320 4368 6563 6b69 6e67  ..    # Checking
+000095f0: 2069 6620 6669 656c 642f 636f 6c75 6d6e   if field/column
+00009600: 206e 616d 6573 2073 686f 756c 6420 6265   names should be
+00009610: 2072 6561 6420 6973 2063 6173 6520 7365   read is case se
+00009620: 6e73 6974 6976 6520 696e 2066 696f 6e61  nsitive in fiona
+00009630: 2c20 736f 0a20 2020 2023 206d 616b 6520  , so.    # make 
+00009640: 7375 7265 2074 6865 2063 6f6c 756d 6e20  sure the column 
+00009650: 6e61 6d65 7320 7370 6563 6966 6965 6420  names specified 
+00009660: 6861 7665 2074 6865 2073 616d 6520 6361  have the same ca
+00009670: 7369 6e67 2e0a 2020 2020 636f 6c75 6d6e  sing..    column
+00009680: 735f 7072 6570 6172 6564 203d 204e 6f6e  s_prepared = Non
+00009690: 650a 2020 2020 6966 2063 6f6c 756d 6e73  e.    if columns
+000096a0: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+000096b0: 2020 2020 2020 6c61 7965 7269 6e66 6f20        layerinfo 
+000096c0: 3d20 6765 745f 6c61 7965 7269 6e66 6f28  = get_layerinfo(
+000096d0: 7061 7468 2c20 6c61 7965 723d 6c61 7965  path, layer=laye
+000096e0: 7229 0a20 2020 2020 2020 2063 6f6c 756d  r).        colum
+000096f0: 6e73 5f75 7070 6572 5f6c 6f6f 6b75 7020  ns_upper_lookup 
+00009700: 3d20 7b63 6f6c 756d 6e2e 7570 7065 7228  = {column.upper(
+00009710: 293a 2063 6f6c 756d 6e20 666f 7220 636f  ): column for co
+00009720: 6c75 6d6e 2069 6e20 636f 6c75 6d6e 737d  lumn in columns}
+00009730: 0a20 2020 2020 2020 2063 6f6c 756d 6e73  .        columns
+00009740: 5f70 7265 7061 7265 6420 3d20 7b0a 2020  _prepared = {.  
+00009750: 2020 2020 2020 2020 2020 636f 6c75 6d6e            column
+00009760: 3a20 636f 6c75 6d6e 735f 7570 7065 725f  : columns_upper_
+00009770: 6c6f 6f6b 7570 5b63 6f6c 756d 6e2e 7570  lookup[column.up
+00009780: 7065 7228 295d 0a20 2020 2020 2020 2020  per()].         
+00009790: 2020 2066 6f72 2063 6f6c 756d 6e20 696e     for column in
+000097a0: 206c 6179 6572 696e 666f 2e63 6f6c 756d   layerinfo.colum
+000097b0: 6e73 0a20 2020 2020 2020 2020 2020 2069  ns.            i
+000097c0: 6620 636f 6c75 6d6e 2e75 7070 6572 2829  f column.upper()
+000097d0: 2069 6e20 636f 6c75 6d6e 735f 7570 7065   in columns_uppe
+000097e0: 725f 6c6f 6f6b 7570 0a20 2020 2020 2020  r_lookup.       
+000097f0: 207d 0a0a 2020 2020 2320 5265 6164 2e2e   }..    # Read..
+00009800: 2e0a 2020 2020 636f 6c75 6d6e 735f 6c69  ..    columns_li
+00009810: 7374 203d 204e 6f6e 6520 6966 2063 6f6c  st = None if col
+00009820: 756d 6e73 5f70 7265 7061 7265 6420 6973  umns_prepared is
+00009830: 204e 6f6e 6520 656c 7365 206c 6973 7428   None else list(
+00009840: 636f 6c75 6d6e 735f 7072 6570 6172 6564  columns_prepared
+00009850: 290a 2020 2020 7265 7375 6c74 5f67 6466  ).    result_gdf
+00009860: 203d 2067 7064 2e72 6561 645f 6669 6c65   = gpd.read_file
+00009870: 280a 2020 2020 2020 2020 7374 7228 7061  (.        str(pa
+00009880: 7468 292c 0a20 2020 2020 2020 206c 6179  th),.        lay
+00009890: 6572 3d6c 6179 6572 2c0a 2020 2020 2020  er=layer,.      
+000098a0: 2020 6262 6f78 3d62 626f 782c 0a20 2020    bbox=bbox,.   
+000098b0: 2020 2020 2072 6f77 733d 726f 7773 2c0a       rows=rows,.
+000098c0: 2020 2020 2020 2020 696e 636c 7564 655f          include_
+000098d0: 6669 656c 6473 3d63 6f6c 756d 6e73 5f6c  fields=columns_l
+000098e0: 6973 742c 0a20 2020 2020 2020 2073 716c  ist,.        sql
+000098f0: 3d73 716c 5f73 746d 742c 0a20 2020 2020  =sql_stmt,.     
+00009900: 2020 2073 716c 5f64 6961 6c65 6374 3d73     sql_dialect=s
+00009910: 716c 5f64 6961 6c65 6374 2c0a 2020 2020  ql_dialect,.    
+00009920: 2020 2020 6967 6e6f 7265 5f67 656f 6d65      ignore_geome
+00009930: 7472 793d 6967 6e6f 7265 5f67 656f 6d65  try=ignore_geome
+00009940: 7472 792c 0a20 2020 2029 0a0a 2020 2020  try,.    )..    
+00009950: 2320 5365 7420 7468 6520 696e 6465 7820  # Set the index 
+00009960: 746f 2074 6865 2062 6163 6b65 642d 7570  to the backed-up
+00009970: 2066 6964 0a20 2020 2069 6620 6669 645f   fid.    if fid_
+00009980: 6173 5f69 6e64 6578 3a0a 2020 2020 2020  as_index:.      
+00009990: 2020 7265 7375 6c74 5f67 6466 203d 2072    result_gdf = r
+000099a0: 6573 756c 745f 6764 662e 7365 745f 696e  esult_gdf.set_in
+000099b0: 6465 7828 225f 5f54 4d50 5f47 454f 4649  dex("__TMP_GEOFI
+000099c0: 4c45 4f50 535f 4649 4422 290a 0a20 2020  LEOPS_FID")..   
+000099d0: 2023 2052 656f 7264 6572 2063 6f6c 756d   # Reorder colum
+000099e0: 6e73 202b 2063 6861 6e67 6520 6361 7369  ns + change casi
+000099f0: 6e67 2073 6f20 7468 6579 2061 7265 2074  ng so they are t
+00009a00: 6865 2073 616d 6520 6173 2063 6f6c 756d  he same as colum
+00009a10: 6e73 2070 6172 616d 6574 6572 0a20 2020  ns parameter.   
+00009a20: 2069 6620 636f 6c75 6d6e 735f 7072 6570   if columns_prep
+00009a30: 6172 6564 2069 7320 6e6f 7420 4e6f 6e65  ared is not None
+00009a40: 2061 6e64 206c 656e 2863 6f6c 756d 6e73   and len(columns
+00009a50: 5f70 7265 7061 7265 6429 203e 2030 3a0a  _prepared) > 0:.
+00009a60: 2020 2020 2020 2020 7265 7375 6c74 5f67          result_g
+00009a70: 6466 203d 2072 6573 756c 745f 6764 665b  df = result_gdf[
+00009a80: 6c69 7374 2863 6f6c 756d 6e73 5f70 7265  list(columns_pre
+00009a90: 7061 7265 6429 202b 205b 2267 656f 6d65  pared) + ["geome
+00009aa0: 7472 7922 5d5d 0a20 2020 2020 2020 2072  try"]].        r
+00009ab0: 6573 756c 745f 6764 6620 3d20 7265 7375  esult_gdf = resu
+00009ac0: 6c74 5f67 6466 2e72 656e 616d 6528 636f  lt_gdf.rename(co
+00009ad0: 6c75 6d6e 733d 636f 6c75 6d6e 735f 7072  lumns=columns_pr
+00009ae0: 6570 6172 6564 2920 2023 2074 7970 653a  epared)  # type:
+00009af0: 2069 676e 6f72 650a 0a20 2020 2023 2053   ignore..    # S
+00009b00: 7461 7274 696e 6720 6672 6f6d 2066 696f  tarting from fio
+00009b10: 6e61 2031 2e39 2c20 7374 7269 6e67 2063  na 1.9, string c
+00009b20: 6f6c 756d 6e73 2077 6974 6820 616c 6c20  olumns with all 
+00009b30: 4e6f 6e65 2076 616c 7565 7320 6172 6520  None values are 
+00009b40: 7265 6164 2061 7320 6265 696e 670a 2020  read as being.  
+00009b50: 2020 2320 666c 6f61 7420 636f 6c75 6d6e    # float column
+00009b60: 732e 2043 6f6e 7665 7274 2074 6865 6d20  s. Convert them 
+00009b70: 746f 206f 626a 6563 7420 7479 7065 2e0a  to object type..
+00009b80: 2020 2020 666c 6f61 745f 636f 6c73 203d      float_cols =
+00009b90: 206c 6973 7428 7265 7375 6c74 5f67 6466   list(result_gdf
+00009ba0: 2e73 656c 6563 745f 6474 7970 6573 285b  .select_dtypes([
+00009bb0: 2266 6c6f 6174 3634 225d 292e 636f 6c75  "float64"]).colu
+00009bc0: 6d6e 7329 0a20 2020 2069 6620 6c65 6e28  mns).    if len(
+00009bd0: 666c 6f61 745f 636f 6c73 2920 3e20 303a  float_cols) > 0:
+00009be0: 0a20 2020 2020 2020 2023 2043 6865 636b  .        # Check
+00009bf0: 2066 6f72 2061 6c6c 2066 6c6f 6174 2063   for all float c
+00009c00: 6f6c 756d 6e73 2066 6f75 6e64 2069 6620  olumns found if 
+00009c10: 7468 6579 2073 686f 756c 6420 6265 206f  they should be o
+00009c20: 626a 6563 7420 636f 6c75 6d6e 7320 696e  bject columns in
+00009c30: 7374 6561 640a 2020 2020 2020 2020 7769  stead.        wi
+00009c40: 7468 2066 696f 6e61 2e6f 7065 6e28 7061  th fiona.open(pa
+00009c50: 7468 2c20 6c61 7965 723d 6c61 7965 7229  th, layer=layer)
+00009c60: 2061 7320 636f 6c6c 6563 7469 6f6e 3a0a   as collection:.
+00009c70: 2020 2020 2020 2020 2020 2020 6173 7365              asse
+00009c80: 7274 2063 6f6c 6c65 6374 696f 6e2e 7363  rt collection.sc
+00009c90: 6865 6d61 2069 7320 6e6f 7420 4e6f 6e65  hema is not None
+00009ca0: 0a20 2020 2020 2020 2020 2020 2070 726f  .            pro
+00009cb0: 7065 7274 6965 7320 3d20 636f 6c6c 6563  perties = collec
+00009cc0: 7469 6f6e 2e73 6368 656d 615b 2270 726f  tion.schema["pro
+00009cd0: 7065 7274 6965 7322 5d0a 2020 2020 2020  perties"].      
+00009ce0: 2020 2020 2020 666f 7220 636f 6c20 696e        for col in
+00009cf0: 2066 6c6f 6174 5f63 6f6c 733a 0a20 2020   float_cols:.   
+00009d00: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00009d10: 636f 6c20 696e 2070 726f 7065 7274 6965  col in propertie
+00009d20: 7320 616e 6420 7072 6f70 6572 7469 6573  s and properties
+00009d30: 5b63 6f6c 5d2e 7374 6172 7473 7769 7468  [col].startswith
+00009d40: 2822 7374 7222 293a 0a20 2020 2020 2020  ("str"):.       
+00009d50: 2020 2020 2020 2020 2020 2020 2072 6573               res
+00009d60: 756c 745f 6764 665b 636f 6c5d 203d 2028  ult_gdf[col] = (
+00009d70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009d80: 2020 2020 2020 2020 2072 6573 756c 745f           result_
+00009d90: 6764 665b 636f 6c5d 2020 2320 7479 7065  gdf[col]  # type
+00009da0: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
+00009db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009dc0: 202e 6173 7479 7065 286f 626a 6563 7429   .astype(object)
+00009dd0: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
+00009de0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009df0: 2020 2020 2020 2020 202e 7265 706c 6163           .replac
+00009e00: 6528 6e70 2e6e 616e 2c20 4e6f 6e65 290a  e(np.nan, None).
+00009e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e20: 2020 2020 290a 0a20 2020 2023 2061 7373      )..    # ass
+00009e30: 6572 7420 746f 2065 7661 6465 2070 794c  ert to evade pyL
+00009e40: 616e 6365 2077 6172 6e69 6e67 0a20 2020  ance warning.   
+00009e50: 2061 7373 6572 7420 6973 696e 7374 616e   assert isinstan
+00009e60: 6365 2872 6573 756c 745f 6764 662c 2070  ce(result_gdf, p
+00009e70: 642e 4461 7461 4672 616d 6529 206f 7220  d.DataFrame) or 
+00009e80: 6973 696e 7374 616e 6365 280a 2020 2020  isinstance(.    
+00009e90: 2020 2020 7265 7375 6c74 5f67 6466 2c20      result_gdf, 
+00009ea0: 6770 642e 4765 6f44 6174 6146 7261 6d65  gpd.GeoDataFrame
+00009eb0: 0a20 2020 2029 0a20 2020 2072 6574 7572  .    ).    retur
+00009ec0: 6e20 7265 7375 6c74 5f67 6466 0a0a 0a64  n result_gdf...d
+00009ed0: 6566 205f 7265 6164 5f66 696c 655f 6261  ef _read_file_ba
+00009ee0: 7365 5f70 796f 6772 696f 280a 2020 2020  se_pyogrio(.    
+00009ef0: 7061 7468 3a20 556e 696f 6e5b 7374 722c  path: Union[str,
+00009f00: 2022 6f73 2e50 6174 684c 696b 655b 416e   "os.PathLike[An
+00009f10: 795d 225d 2c0a 2020 2020 6c61 7965 723a  y]"],.    layer:
+00009f20: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
+00009f30: 204e 6f6e 652c 0a20 2020 2063 6f6c 756d   None,.    colum
+00009f40: 6e73 3a20 4f70 7469 6f6e 616c 5b49 7465  ns: Optional[Ite
+00009f50: 7261 626c 655b 7374 725d 5d20 3d20 4e6f  rable[str]] = No
+00009f60: 6e65 2c0a 2020 2020 6262 6f78 3d4e 6f6e  ne,.    bbox=Non
+00009f70: 652c 0a20 2020 2072 6f77 733d 4e6f 6e65  e,.    rows=None
+00009f80: 2c0a 2020 2020 7371 6c5f 7374 6d74 3a20  ,.    sql_stmt: 
+00009f90: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
+00009fa0: 4e6f 6e65 2c0a 2020 2020 7371 6c5f 6469  None,.    sql_di
+00009fb0: 616c 6563 743a 204f 7074 696f 6e61 6c5b  alect: Optional[
+00009fc0: 4c69 7465 7261 6c5b 2253 514c 4954 4522  Literal["SQLITE"
+00009fd0: 2c20 224f 4752 5351 4c22 5d5d 203d 204e  , "OGRSQL"]] = N
+00009fe0: 6f6e 652c 0a20 2020 2069 676e 6f72 655f  one,.    ignore_
+00009ff0: 6765 6f6d 6574 7279 3a20 626f 6f6c 203d  geometry: bool =
+0000a000: 2046 616c 7365 2c0a 2020 2020 6669 645f   False,.    fid_
+0000a010: 6173 5f69 6e64 6578 3a20 626f 6f6c 203d  as_index: bool =
+0000a020: 2046 616c 7365 2c0a 2920 2d3e 2055 6e69   False,.) -> Uni
+0000a030: 6f6e 5b70 642e 4461 7461 4672 616d 652c  on[pd.DataFrame,
+0000a040: 2067 7064 2e47 656f 4461 7461 4672 616d   gpd.GeoDataFram
+0000a050: 655d 3a0a 2020 2020 2222 220a 2020 2020  e]:.    """.    
+0000a060: 5265 6164 7320 6120 6669 6c65 2074 6f20  Reads a file to 
+0000a070: 6120 7061 6e64 6173 2044 6174 6166 7261  a pandas Datafra
+0000a080: 6d65 2075 7369 6e67 2070 796f 6772 696f  me using pyogrio
+0000a090: 2e0a 2020 2020 2222 220a 2020 2020 2320  ..    """.    # 
+0000a0a0: 496e 6974 0a20 2020 2070 6174 6820 3d20  Init.    path = 
+0000a0b0: 5061 7468 2870 6174 6829 0a20 2020 2069  Path(path).    i
+0000a0c0: 6620 7061 7468 2e65 7869 7374 7328 2920  f path.exists() 
+0000a0d0: 6973 2046 616c 7365 3a0a 2020 2020 2020  is False:.      
+0000a0e0: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+0000a0f0: 6f72 2866 2266 696c 6520 646f 6573 6e27  or(f"file doesn'
+0000a100: 7420 6578 6973 743a 207b 7061 7468 7d22  t exist: {path}"
+0000a110: 290a 0a20 2020 2023 2043 6f6e 7665 7274  )..    # Convert
+0000a120: 2073 6c69 6365 206f 626a 6563 7420 746f   slice object to
+0000a130: 2070 796f 6772 696f 2070 6172 616d 6574   pyogrio paramet
+0000a140: 6572 730a 2020 2020 6966 2072 6f77 7320  ers.    if rows 
+0000a150: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+0000a160: 2020 2020 2073 6b69 705f 6665 6174 7572       skip_featur
+0000a170: 6573 203d 2072 6f77 732e 7374 6172 740a  es = rows.start.
+0000a180: 2020 2020 2020 2020 6d61 785f 6665 6174          max_feat
+0000a190: 7572 6573 203d 2072 6f77 732e 7374 6f70  ures = rows.stop
+0000a1a0: 202d 2072 6f77 732e 7374 6172 740a 2020   - rows.start.  
+0000a1b0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000a1c0: 736b 6970 5f66 6561 7475 7265 7320 3d20  skip_features = 
+0000a1d0: 300a 2020 2020 2020 2020 6d61 785f 6665  0.        max_fe
+0000a1e0: 6174 7572 6573 203d 204e 6f6e 650a 0a20  atures = None.. 
+0000a1f0: 2020 2023 2049 6620 6e6f 2073 716c 5f73     # If no sql_s
+0000a200: 746d 7420 7370 6563 6966 6965 640a 2020  tmt specified.  
+0000a210: 2020 636f 6c75 6d6e 735f 7072 6570 6172    columns_prepar
+0000a220: 6564 203d 204e 6f6e 650a 2020 2020 6966  ed = None.    if
+0000a230: 2073 716c 5f73 746d 7420 6973 204e 6f6e   sql_stmt is Non
+0000a240: 653a 0a20 2020 2020 2020 2023 2049 6620  e:.        # If 
+0000a250: 6e6f 206c 6179 6572 2073 7065 6369 6669  no layer specifi
+0000a260: 6564 2c20 7468 6572 6520 7368 6f75 6c64  ed, there should
+0000a270: 2062 6520 6f6e 6c79 206f 6e65 206c 6179   be only one lay
+0000a280: 6572 2069 6e20 7468 6520 6669 6c65 2e0a  er in the file..
+0000a290: 2020 2020 2020 2020 6966 206c 6179 6572          if layer
+0000a2a0: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+0000a2b0: 2020 2020 2020 6c61 7965 7220 3d20 6765        layer = ge
+0000a2c0: 745f 6f6e 6c79 5f6c 6179 6572 2870 6174  t_only_layer(pat
+0000a2d0: 6829 0a0a 2020 2020 2020 2020 2320 4368  h)..        # Ch
+0000a2e0: 6563 6b69 6e67 2069 6620 636f 6c75 6d6e  ecking if column
+0000a2f0: 206e 616d 6573 2073 686f 756c 6420 6265   names should be
+0000a300: 2072 6561 6420 6973 2063 6173 6520 7365   read is case se
+0000a310: 6e73 6974 6976 6520 696e 2070 796f 6772  nsitive in pyogr
+0000a320: 696f 2c20 736f 0a20 2020 2020 2020 2023  io, so.        #
+0000a330: 206d 616b 6520 7375 7265 2074 6865 2063   make sure the c
+0000a340: 6f6c 756d 6e20 6e61 6d65 7320 7370 6563  olumn names spec
+0000a350: 6966 6965 6420 6861 7665 2074 6865 2073  ified have the s
+0000a360: 616d 6520 6361 7369 6e67 2e0a 2020 2020  ame casing..    
+0000a370: 2020 2020 6966 2063 6f6c 756d 6e73 2069      if columns i
+0000a380: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+0000a390: 2020 2020 2020 2020 6c61 7965 7269 6e66          layerinf
+0000a3a0: 6f20 3d20 6765 745f 6c61 7965 7269 6e66  o = get_layerinf
+0000a3b0: 6f28 7061 7468 2c20 6c61 7965 723d 6c61  o(path, layer=la
+0000a3c0: 7965 7229 0a20 2020 2020 2020 2020 2020  yer).           
+0000a3d0: 2063 6f6c 756d 6e73 5f75 7070 6572 5f6c   columns_upper_l
+0000a3e0: 6f6f 6b75 7020 3d20 7b63 6f6c 756d 6e2e  ookup = {column.
+0000a3f0: 7570 7065 7228 293a 2063 6f6c 756d 6e20  upper(): column 
+0000a400: 666f 7220 636f 6c75 6d6e 2069 6e20 636f  for column in co
+0000a410: 6c75 6d6e 737d 0a20 2020 2020 2020 2020  lumns}.         
+0000a420: 2020 2063 6f6c 756d 6e73 5f70 7265 7061     columns_prepa
+0000a430: 7265 6420 3d20 7b0a 2020 2020 2020 2020  red = {.        
+0000a440: 2020 2020 2020 2020 636f 6c75 6d6e 3a20          column: 
+0000a450: 636f 6c75 6d6e 735f 7570 7065 725f 6c6f  columns_upper_lo
+0000a460: 6f6b 7570 5b63 6f6c 756d 6e2e 7570 7065  okup[column.uppe
+0000a470: 7228 295d 0a20 2020 2020 2020 2020 2020  r()].           
+0000a480: 2020 2020 2066 6f72 2063 6f6c 756d 6e20       for column 
+0000a490: 696e 206c 6179 6572 696e 666f 2e63 6f6c  in layerinfo.col
+0000a4a0: 756d 6e73 0a20 2020 2020 2020 2020 2020  umns.           
+0000a4b0: 2020 2020 2069 6620 636f 6c75 6d6e 2e75       if column.u
+0000a4c0: 7070 6572 2829 2069 6e20 636f 6c75 6d6e  pper() in column
+0000a4d0: 735f 7570 7065 725f 6c6f 6f6b 7570 0a20  s_upper_lookup. 
+0000a4e0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+0000a4f0: 2065 6c73 653a 0a20 2020 2020 2020 2023   else:.        #
+0000a500: 2046 696c 6c20 6f75 7420 706c 6163 6568   Fill out placeh
+0000a510: 6f6c 6465 7273 2c20 6b65 6570 2063 6f6c  olders, keep col
+0000a520: 756d 6e73 5f70 7265 7061 7265 6420 4e6f  umns_prepared No
+0000a530: 6e65 2062 6563 6175 7365 2063 6f6c 756d  ne because colum
+0000a540: 6e20 6669 6c74 6572 696e 670a 2020 2020  n filtering.    
+0000a550: 2020 2020 2320 7368 6f75 6c64 2068 6170      # should hap
+0000a560: 7065 6e20 696e 2073 716c 5f73 746d 742e  pen in sql_stmt.
+0000a570: 0a20 2020 2020 2020 2073 716c 5f73 746d  .        sql_stm
+0000a580: 7420 3d20 5f66 696c 6c5f 6f75 745f 7371  t = _fill_out_sq
+0000a590: 6c5f 706c 6163 6568 6f6c 6465 7273 280a  l_placeholders(.
+0000a5a0: 2020 2020 2020 2020 2020 2020 7061 7468              path
+0000a5b0: 3d70 6174 682c 206c 6179 6572 3d6c 6179  =path, layer=lay
+0000a5c0: 6572 2c20 7371 6c5f 7374 6d74 3d73 716c  er, sql_stmt=sql
+0000a5d0: 5f73 746d 742c 2063 6f6c 756d 6e73 3d63  _stmt, columns=c
+0000a5e0: 6f6c 756d 6e73 0a20 2020 2020 2020 2029  olumns.        )
+0000a5f0: 0a0a 2020 2020 2320 5265 6164 210a 2020  ..    # Read!.  
+0000a600: 2020 636f 6c75 6d6e 735f 6c69 7374 203d    columns_list =
+0000a610: 204e 6f6e 6520 6966 2063 6f6c 756d 6e73   None if columns
+0000a620: 5f70 7265 7061 7265 6420 6973 204e 6f6e  _prepared is Non
+0000a630: 6520 656c 7365 206c 6973 7428 636f 6c75  e else list(colu
+0000a640: 6d6e 735f 7072 6570 6172 6564 290a 2020  mns_prepared).  
+0000a650: 2020 7265 7375 6c74 5f67 6466 203d 2070    result_gdf = p
+0000a660: 796f 6772 696f 2e72 6561 645f 6461 7461  yogrio.read_data
+0000a670: 6672 616d 6528 0a20 2020 2020 2020 2070  frame(.        p
+0000a680: 6174 682c 0a20 2020 2020 2020 206c 6179  ath,.        lay
+0000a690: 6572 3d6c 6179 6572 2c0a 2020 2020 2020  er=layer,.      
+0000a6a0: 2020 636f 6c75 6d6e 733d 636f 6c75 6d6e    columns=column
+0000a6b0: 735f 6c69 7374 2c0a 2020 2020 2020 2020  s_list,.        
+0000a6c0: 6262 6f78 3d62 626f 782c 0a20 2020 2020  bbox=bbox,.     
+0000a6d0: 2020 2073 6b69 705f 6665 6174 7572 6573     skip_features
+0000a6e0: 3d73 6b69 705f 6665 6174 7572 6573 2c0a  =skip_features,.
+0000a6f0: 2020 2020 2020 2020 6d61 785f 6665 6174          max_feat
+0000a700: 7572 6573 3d6d 6178 5f66 6561 7475 7265  ures=max_feature
+0000a710: 732c 0a20 2020 2020 2020 2073 716c 3d73  s,.        sql=s
+0000a720: 716c 5f73 746d 742c 0a20 2020 2020 2020  ql_stmt,.       
+0000a730: 2073 716c 5f64 6961 6c65 6374 3d73 716c   sql_dialect=sql
+0000a740: 5f64 6961 6c65 6374 2c0a 2020 2020 2020  _dialect,.      
+0000a750: 2020 7265 6164 5f67 656f 6d65 7472 793d    read_geometry=
+0000a760: 6e6f 7420 6967 6e6f 7265 5f67 656f 6d65  not ignore_geome
+0000a770: 7472 792c 0a20 2020 2020 2020 2066 6964  try,.        fid
+0000a780: 5f61 735f 696e 6465 783d 6669 645f 6173  _as_index=fid_as
+0000a790: 5f69 6e64 6578 2c0a 2020 2020 290a 0a20  _index,.    ).. 
+0000a7a0: 2020 2023 2052 656f 7264 6572 2063 6f6c     # Reorder col
+0000a7b0: 756d 6e73 202b 2063 6861 6e67 6520 6361  umns + change ca
+0000a7c0: 7369 6e67 2073 6f20 7468 6579 2061 7265  sing so they are
+0000a7d0: 2074 6865 2073 616d 6520 6173 2063 6f6c   the same as col
+0000a7e0: 756d 6e73 2070 6172 616d 6574 6572 0a20  umns parameter. 
+0000a7f0: 2020 2069 6620 636f 6c75 6d6e 735f 7072     if columns_pr
+0000a800: 6570 6172 6564 2069 7320 6e6f 7420 4e6f  epared is not No
+0000a810: 6e65 2061 6e64 206c 656e 2863 6f6c 756d  ne and len(colum
+0000a820: 6e73 5f70 7265 7061 7265 6429 203e 2030  ns_prepared) > 0
+0000a830: 3a0a 2020 2020 2020 2020 7265 7375 6c74  :.        result
+0000a840: 5f67 6466 203d 2072 6573 756c 745f 6764  _gdf = result_gd
+0000a850: 665b 6c69 7374 2863 6f6c 756d 6e73 5f70  f[list(columns_p
+0000a860: 7265 7061 7265 6429 202b 205b 2267 656f  repared) + ["geo
+0000a870: 6d65 7472 7922 5d5d 0a20 2020 2020 2020  metry"]].       
+0000a880: 2072 6573 756c 745f 6764 6620 3d20 7265   result_gdf = re
+0000a890: 7375 6c74 5f67 6466 2e72 656e 616d 6528  sult_gdf.rename(
+0000a8a0: 636f 6c75 6d6e 733d 636f 6c75 6d6e 735f  columns=columns_
+0000a8b0: 7072 6570 6172 6564 2920 2023 2074 7970  prepared)  # typ
+0000a8c0: 653a 2069 676e 6f72 650a 0a20 2020 2023  e: ignore..    #
+0000a8d0: 2061 7373 6572 7420 746f 2065 7661 6465   assert to evade
+0000a8e0: 2070 794c 616e 6365 2077 6172 6e69 6e67   pyLance warning
+0000a8f0: 0a20 2020 2061 7373 6572 7420 6973 696e  .    assert isin
+0000a900: 7374 616e 6365 2872 6573 756c 745f 6764  stance(result_gd
+0000a910: 662c 2070 642e 4461 7461 4672 616d 6529  f, pd.DataFrame)
+0000a920: 206f 7220 6973 696e 7374 616e 6365 280a   or isinstance(.
+0000a930: 2020 2020 2020 2020 7265 7375 6c74 5f67          result_g
+0000a940: 6466 2c20 6770 642e 4765 6f44 6174 6146  df, gpd.GeoDataF
+0000a950: 7261 6d65 0a20 2020 2029 0a20 2020 2072  rame.    ).    r
+0000a960: 6574 7572 6e20 7265 7375 6c74 5f67 6466  eturn result_gdf
+0000a970: 0a0a 0a64 6566 205f 6669 6c6c 5f6f 7574  ...def _fill_out
+0000a980: 5f73 716c 5f70 6c61 6365 686f 6c64 6572  _sql_placeholder
+0000a990: 7328 0a20 2020 2070 6174 683a 2050 6174  s(.    path: Pat
+0000a9a0: 682c 206c 6179 6572 3a20 4f70 7469 6f6e  h, layer: Option
+0000a9b0: 616c 5b73 7472 5d2c 2073 716c 5f73 746d  al[str], sql_stm
+0000a9c0: 743a 2073 7472 2c20 636f 6c75 6d6e 733a  t: str, columns:
+0000a9d0: 204f 7074 696f 6e61 6c5b 4974 6572 6162   Optional[Iterab
+0000a9e0: 6c65 5b73 7472 5d5d 0a29 202d 3e20 7374  le[str]].) -> st
+0000a9f0: 723a 0a20 2020 2023 2046 696c 6c20 6f75  r:.    # Fill ou
+0000aa00: 7420 706c 6163 6568 6f6c 6465 7273 2069  t placeholders i
+0000aa10: 6e20 7468 6520 7371 6c5f 7374 6d74 2069  n the sql_stmt i
+0000aa20: 6620 6e65 6564 6564 3a0a 2020 2020 706c  f needed:.    pl
+0000aa30: 6163 6568 6f6c 6465 7273 203d 205b 0a20  aceholders = [. 
+0000aa40: 2020 2020 2020 206e 616d 6520 666f 7220         name for 
+0000aa50: 5f2c 206e 616d 652c 205f 2c20 5f20 696e  _, name, _, _ in
+0000aa60: 2073 7472 696e 672e 466f 726d 6174 7465   string.Formatte
+0000aa70: 7228 292e 7061 7273 6528 7371 6c5f 7374  r().parse(sql_st
+0000aa80: 6d74 2920 6966 206e 616d 650a 2020 2020  mt) if name.    
+0000aa90: 5d0a 2020 2020 6c61 7965 725f 746d 7020  ].    layer_tmp 
+0000aaa0: 3d20 6c61 7965 720a 2020 2020 6c61 7965  = layer.    laye
+0000aab0: 7269 6e66 6f20 3d20 4e6f 6e65 0a20 2020  rinfo = None.   
+0000aac0: 2066 6f72 6d61 745f 6b77 6172 6773 203d   format_kwargs =
+0000aad0: 207b 7d0a 2020 2020 666f 7220 706c 6163   {}.    for plac
+0000aae0: 6568 6f6c 6465 7220 696e 2070 6c61 6365  eholder in place
+0000aaf0: 686f 6c64 6572 733a 0a20 2020 2020 2020  holders:.       
+0000ab00: 2069 6620 6c61 7965 725f 746d 7020 6973   if layer_tmp is
+0000ab10: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0000ab20: 2020 206c 6179 6572 5f74 6d70 203d 2067     layer_tmp = g
+0000ab30: 6574 5f6f 6e6c 795f 6c61 7965 7228 7061  et_only_layer(pa
+0000ab40: 7468 290a 2020 2020 2020 2020 6966 2070  th).        if p
+0000ab50: 6c61 6365 686f 6c64 6572 203d 3d20 2269  laceholder == "i
+0000ab60: 6e70 7574 5f6c 6179 6572 223a 0a20 2020  nput_layer":.   
+0000ab70: 2020 2020 2020 2020 2066 6f72 6d61 745f           format_
+0000ab80: 6b77 6172 6773 5b70 6c61 6365 686f 6c64  kwargs[placehold
+0000ab90: 6572 5d20 3d20 6c61 7965 725f 746d 700a  er] = layer_tmp.
+0000aba0: 2020 2020 2020 2020 656c 6966 2070 6c61          elif pla
+0000abb0: 6365 686f 6c64 6572 203d 3d20 2267 656f  ceholder == "geo
+0000abc0: 6d65 7472 7963 6f6c 756d 6e22 3a0a 2020  metrycolumn":.  
+0000abd0: 2020 2020 2020 2020 2020 6966 206c 6179            if lay
+0000abe0: 6572 696e 666f 2069 7320 4e6f 6e65 3a0a  erinfo is None:.
+0000abf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ac00: 6c61 7965 7269 6e66 6f20 3d20 6765 745f  layerinfo = get_
+0000ac10: 6c61 7965 7269 6e66 6f28 7061 7468 2c20  layerinfo(path, 
+0000ac20: 6c61 7965 725f 746d 7029 0a20 2020 2020  layer_tmp).     
+0000ac30: 2020 2020 2020 2066 6f72 6d61 745f 6b77         format_kw
+0000ac40: 6172 6773 5b70 6c61 6365 686f 6c64 6572  args[placeholder
+0000ac50: 5d20 3d20 6c61 7965 7269 6e66 6f2e 6765  ] = layerinfo.ge
+0000ac60: 6f6d 6574 7279 636f 6c75 6d6e 0a20 2020  ometrycolumn.   
+0000ac70: 2020 2020 2065 6c69 6620 706c 6163 6568       elif placeh
+0000ac80: 6f6c 6465 7220 3d3d 2022 636f 6c75 6d6e  older == "column
+0000ac90: 735f 746f 5f73 656c 6563 745f 7374 7222  s_to_select_str"
+0000aca0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+0000acb0: 206c 6179 6572 696e 666f 2069 7320 4e6f   layerinfo is No
+0000acc0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+0000acd0: 2020 2020 6c61 7965 7269 6e66 6f20 3d20      layerinfo = 
+0000ace0: 6765 745f 6c61 7965 7269 6e66 6f28 7061  get_layerinfo(pa
+0000acf0: 7468 2c20 6c61 7965 725f 746d 7029 0a20  th, layer_tmp). 
+0000ad00: 2020 2020 2020 2020 2020 2063 6f6c 756d             colum
+0000ad10: 6e73 5f61 736b 6564 203d 204e 6f6e 6520  ns_asked = None 
+0000ad20: 6966 2063 6f6c 756d 6e73 2069 7320 4e6f  if columns is No
+0000ad30: 6e65 2065 6c73 6520 6c69 7374 2863 6f6c  ne else list(col
+0000ad40: 756d 6e73 290a 2020 2020 2020 2020 2020  umns).          
+0000ad50: 2020 666f 726d 6174 7465 7220 3d20 5f6f    formatter = _o
+0000ad60: 6772 5f73 716c 5f75 7469 6c2e 436f 6c75  gr_sql_util.Colu
+0000ad70: 6d6e 466f 726d 6174 7465 7228 0a20 2020  mnFormatter(.   
+0000ad80: 2020 2020 2020 2020 2020 2020 2063 6f6c               col
+0000ad90: 756d 6e73 5f61 736b 6564 3d63 6f6c 756d  umns_asked=colum
+0000ada0: 6e73 5f61 736b 6564 2c0a 2020 2020 2020  ns_asked,.      
+0000adb0: 2020 2020 2020 2020 2020 636f 6c75 6d6e            column
+0000adc0: 735f 696e 5f6c 6179 6572 3d6c 6179 6572  s_in_layer=layer
+0000add0: 696e 666f 2e63 6f6c 756d 6e73 2c0a 2020  info.columns,.  
+0000ade0: 2020 2020 2020 2020 2020 2020 2020 6669                fi
+0000adf0: 645f 636f 6c75 6d6e 3d6c 6179 6572 696e  d_column=layerin
+0000ae00: 666f 2e66 6964 5f63 6f6c 756d 6e2c 0a20  fo.fid_column,. 
+0000ae10: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+0000ae20: 2020 2020 2020 2020 2066 6f72 6d61 745f           format_
+0000ae30: 6b77 6172 6773 5b70 6c61 6365 686f 6c64  kwargs[placehold
+0000ae40: 6572 5d20 3d20 666f 726d 6174 7465 722e  er] = formatter.
+0000ae50: 7072 6566 6978 6564 5f61 6c69 6173 6564  prefixed_aliased
+0000ae60: 2829 0a0a 2020 2020 2020 2020 656c 7365  ()..        else
+0000ae70: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+0000ae80: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
+0000ae90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aea0: 6622 756e 6b6e 6f77 6e20 706c 6163 6568  f"unknown placeh
+0000aeb0: 6f6c 6465 7220 7b70 6c61 6365 686f 6c64  older {placehold
+0000aec0: 6572 7d20 696e 2073 716c 5f73 746d 743a  er} in sql_stmt:
+0000aed0: 207b 7371 6c5f 7374 6d74 7d22 0a20 2020   {sql_stmt}".   
+0000aee0: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+0000aef0: 6966 206c 656e 2866 6f72 6d61 745f 6b77  if len(format_kw
+0000af00: 6172 6773 2920 3e20 303a 0a20 2020 2020  args) > 0:.     
+0000af10: 2020 2073 716c 5f73 746d 7420 3d20 7371     sql_stmt = sq
+0000af20: 6c5f 7374 6d74 2e66 6f72 6d61 7428 2a2a  l_stmt.format(**
+0000af30: 666f 726d 6174 5f6b 7761 7267 7329 0a20  format_kwargs). 
+0000af40: 2020 2072 6574 7572 6e20 7371 6c5f 7374     return sql_st
+0000af50: 6d74 0a0a 0a64 6566 2072 6561 645f 6669  mt...def read_fi
+0000af60: 6c65 5f73 716c 280a 2020 2020 7061 7468  le_sql(.    path
+0000af70: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
+0000af80: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
+0000af90: 2c0a 2020 2020 7371 6c5f 7374 6d74 3a20  ,.    sql_stmt: 
+0000afa0: 7374 722c 0a20 2020 2073 716c 5f64 6961  str,.    sql_dia
+0000afb0: 6c65 6374 3a20 4f70 7469 6f6e 616c 5b4c  lect: Optional[L
+0000afc0: 6974 6572 616c 5b22 5351 4c49 5445 222c  iteral["SQLITE",
+0000afd0: 2022 4f47 5253 514c 225d 5d20 3d20 2253   "OGRSQL"]] = "S
+0000afe0: 514c 4954 4522 2c0a 2020 2020 6c61 7965  QLITE",.    laye
+0000aff0: 723a 204f 7074 696f 6e61 6c5b 7374 725d  r: Optional[str]
+0000b000: 203d 204e 6f6e 652c 0a20 2020 2069 676e   = None,.    ign
+0000b010: 6f72 655f 6765 6f6d 6574 7279 3a20 626f  ore_geometry: bo
+0000b020: 6f6c 203d 2046 616c 7365 2c0a 2920 2d3e  ol = False,.) ->
+0000b030: 2055 6e69 6f6e 5b70 642e 4461 7461 4672   Union[pd.DataFr
+0000b040: 616d 652c 2067 7064 2e47 656f 4461 7461  ame, gpd.GeoData
+0000b050: 4672 616d 655d 3a0a 2020 2020 2222 220a  Frame]:.    """.
+0000b060: 2020 2020 4445 5052 4543 4154 4544 3a20      DEPRECATED: 
+0000b070: 5265 6164 7320 6120 6669 6c65 2075 7369  Reads a file usi
+0000b080: 6e67 2061 6e20 7371 6c20 7374 6174 656d  ng an sql statem
+0000b090: 656e 742e 0a0a 2020 2020 4172 6773 3a0a  ent...    Args:.
+0000b0a0: 2020 2020 2020 2020 7061 7468 2028 6669          path (fi
+0000b0b0: 6c65 2070 6174 6829 3a20 7061 7468 2074  le path): path t
+0000b0c0: 6f20 7468 6520 6669 6c65 2074 6f20 7265  o the file to re
+0000b0d0: 6164 2066 726f 6d0a 2020 2020 2020 2020  ad from.        
+0000b0e0: 7371 6c5f 7374 6d74 2028 7374 7229 3a20  sql_stmt (str): 
+0000b0f0: 7371 6c20 7374 6174 656d 656e 7420 746f  sql statement to
+0000b100: 2075 7365 0a20 2020 2020 2020 2073 716c   use.        sql
+0000b110: 5f64 6961 6c65 6374 2028 7374 722c 206f  _dialect (str, o
+0000b120: 7074 696f 6e61 6c29 3a20 5371 6c20 6469  ptional): Sql di
+0000b130: 616c 6563 7420 7573 6564 2e20 4465 6661  alect used. Defa
+0000b140: 756c 7473 2074 6f20 2753 514c 4954 4527  ults to 'SQLITE'
+0000b150: 2e0a 2020 2020 2020 2020 6c61 7965 7220  ..        layer 
+0000b160: 2873 7472 2c20 6f70 7469 6f6e 616c 293a  (str, optional):
+0000b170: 2054 6865 206c 6179 6572 2074 6f20 7265   The layer to re
+0000b180: 6164 2e20 4966 206e 6f20 6c61 7965 7220  ad. If no layer 
+0000b190: 6973 2073 7065 6369 6669 6564 2c0a 2020  is specified,.  
+0000b1a0: 2020 2020 2020 2020 2020 7265 6164 7320            reads 
+0000b1b0: 7468 6520 6f6e 6c79 206c 6179 6572 2069  the only layer i
+0000b1c0: 6e20 7468 6520 6669 6c65 206f 7220 7468  n the file or th
+0000b1d0: 726f 7773 2061 6e20 4578 6365 7074 696f  rows an Exceptio
+0000b1e0: 6e2e 0a20 2020 2020 2020 2069 676e 6f72  n..        ignor
+0000b1f0: 655f 6765 6f6d 6574 7279 2028 626f 6f6c  e_geometry (bool
+0000b200: 2c20 6f70 7469 6f6e 616c 293a 2054 7275  , optional): Tru
+0000b210: 6520 6e6f 7420 746f 2072 6561 642f 7265  e not to read/re
+0000b220: 7475 726e 2074 6865 2067 656f 6d61 7472  turn the geomatr
+0000b230: 792e 0a20 2020 2020 2020 2020 2020 2044  y..            D
+0000b240: 6566 6175 6c74 7320 746f 2046 616c 7365  efaults to False
+0000b250: 2e0a 0a20 2020 2052 6574 7572 6e73 3a0a  ...    Returns:.
+0000b260: 2020 2020 2020 2020 556e 696f 6e5b 7064          Union[pd
+0000b270: 2e44 6174 6146 7261 6d65 2c20 6770 642e  .DataFrame, gpd.
+0000b280: 4765 6f44 6174 6146 7261 6d65 5d3a 2054  GeoDataFrame]: T
+0000b290: 6865 2064 6174 6120 7265 6164 2e0a 2020  he data read..  
+0000b2a0: 2020 2222 220a 2020 2020 7761 726e 696e    """.    warnin
+0000b2b0: 6773 2e77 6172 6e28 0a20 2020 2020 2020  gs.warn(.       
+0000b2c0: 2027 7265 6164 5f66 696c 655f 7371 6c20   'read_file_sql 
+0000b2d0: 6973 2064 6570 7265 6361 7465 643a 2075  is deprecated: u
+0000b2e0: 7365 2072 6561 645f 6669 6c65 2120 4d69  se read_file! Mi
+0000b2f0: 6e64 3a20 7371 6c5f 6469 616c 6563 7420  nd: sql_dialect 
+0000b300: 6973 206e 6f74 2022 5351 4c49 5445 2220  is not "SQLITE" 
+0000b310: 270a 2020 2020 2020 2020 2262 7920 6465  '.        "by de
+0000b320: 6661 756c 7420 7468 6572 6521 222c 0a20  fault there!",. 
+0000b330: 2020 2020 2020 2046 7574 7572 6557 6172         FutureWar
+0000b340: 6e69 6e67 2c0a 2020 2020 290a 0a20 2020  ning,.    )..   
+0000b350: 2023 2052 756e 0a20 2020 2072 6574 7572   # Run.    retur
+0000b360: 6e20 5f72 6561 645f 6669 6c65 5f62 6173  n _read_file_bas
+0000b370: 6528 0a20 2020 2020 2020 2070 6174 682c  e(.        path,
+0000b380: 0a20 2020 2020 2020 2073 716c 5f73 746d  .        sql_stm
+0000b390: 743d 7371 6c5f 7374 6d74 2c0a 2020 2020  t=sql_stmt,.    
+0000b3a0: 2020 2020 7371 6c5f 6469 616c 6563 743d      sql_dialect=
+0000b3b0: 7371 6c5f 6469 616c 6563 742c 0a20 2020  sql_dialect,.   
+0000b3c0: 2020 2020 206c 6179 6572 3d6c 6179 6572       layer=layer
+0000b3d0: 2c0a 2020 2020 2020 2020 6967 6e6f 7265  ,.        ignore
+0000b3e0: 5f67 656f 6d65 7472 793d 6967 6e6f 7265  _geometry=ignore
+0000b3f0: 5f67 656f 6d65 7472 792c 0a20 2020 2029  _geometry,.    )
+0000b400: 0a0a 0a64 6566 2074 6f5f 6669 6c65 280a  ...def to_file(.
+0000b410: 2020 2020 6764 663a 2055 6e69 6f6e 5b70      gdf: Union[p
+0000b420: 642e 4461 7461 4672 616d 652c 2067 7064  d.DataFrame, gpd
+0000b430: 2e47 656f 4461 7461 4672 616d 655d 2c0a  .GeoDataFrame],.
+0000b440: 2020 2020 7061 7468 3a20 556e 696f 6e5b      path: Union[
+0000b450: 7374 722c 2022 6f73 2e50 6174 684c 696b  str, "os.PathLik
+0000b460: 655b 416e 795d 225d 2c0a 2020 2020 6c61  e[Any]"],.    la
+0000b470: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
+0000b480: 725d 203d 204e 6f6e 652c 0a20 2020 2066  r] = None,.    f
+0000b490: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+0000b4a0: 6574 7279 7479 7065 3a20 556e 696f 6e5b  etrytype: Union[
+0000b4b0: 4765 6f6d 6574 7279 5479 7065 2c20 7374  GeometryType, st
+0000b4c0: 722c 204e 6f6e 655d 203d 204e 6f6e 652c  r, None] = None,
+0000b4d0: 0a20 2020 2066 6f72 6365 5f6d 756c 7469  .    force_multi
+0000b4e0: 7479 7065 3a20 626f 6f6c 203d 2046 616c  type: bool = Fal
+0000b4f0: 7365 2c0a 2020 2020 6170 7065 6e64 3a20  se,.    append: 
+0000b500: 626f 6f6c 203d 2046 616c 7365 2c0a 2020  bool = False,.  
+0000b510: 2020 6170 7065 6e64 5f74 696d 656f 7574    append_timeout
+0000b520: 5f73 3a20 696e 7420 3d20 3630 302c 0a20  _s: int = 600,. 
+0000b530: 2020 2069 6e64 6578 3a20 626f 6f6c 203d     index: bool =
+0000b540: 2054 7275 652c 0a20 2020 2063 7265 6174   True,.    creat
+0000b550: 655f 7370 6174 6961 6c5f 696e 6465 783a  e_spatial_index:
+0000b560: 204f 7074 696f 6e61 6c5b 626f 6f6c 5d20   Optional[bool] 
+0000b570: 3d20 5472 7565 2c0a 293a 0a20 2020 2022  = True,.):.    "
+0000b580: 2222 0a20 2020 2057 7269 7465 7320 6120  "".    Writes a 
+0000b590: 7061 6e64 6173 2064 6174 6166 7261 6d65  pandas dataframe
+0000b5a0: 2074 6f20 6669 6c65 2e0a 0a20 2020 2054   to file...    T
+0000b5b0: 6865 2066 696c 6566 6f72 6d61 7420 6973  he fileformat is
+0000b5c0: 2064 6574 6563 7465 6420 6261 7365 6420   detected based 
+0000b5d0: 6f6e 2074 6865 2066 696c 6570 6174 6820  on the filepath 
+0000b5e0: 6578 7465 6e73 696f 6e2e 0a0a 2020 2020  extension...    
+0000b5f0: 5468 6520 756e 6465 726c 7969 6e67 206c  The underlying l
+0000b600: 6962 7261 7279 2075 7365 6420 746f 2077  ibrary used to w
+0000b610: 7269 7465 2074 6865 2066 696c 6520 6361  rite the file ca
+0000b620: 6e20 6265 2063 686f 6f73 656e 2075 7369  n be choosen usi
+0000b630: 6e67 2074 6865 0a20 2020 2022 4746 4f5f  ng the.    "GFO_
+0000b640: 494f 5f45 4e47 494e 4522 2065 6e76 6972  IO_ENGINE" envir
+0000b650: 6f6e 6d65 6e74 2076 6172 6961 626c 652e  onment variable.
+0000b660: 2050 6f73 7369 626c 6520 7661 6c75 6573   Possible values
+0000b670: 2061 7265 2022 6669 6f6e 6122 2061 6e64   are "fiona" and
+0000b680: 2022 7079 6f67 7269 6f22 2e0a 2020 2020   "pyogrio"..    
+0000b690: 4465 6661 756c 7420 656e 6769 6e65 2069  Default engine i
+0000b6a0: 7320 2270 796f 6772 696f 222e 0a0a 2020  s "pyogrio"...  
+0000b6b0: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
+0000b6c0: 6764 6620 2867 7064 2e47 656f 4461 7461  gdf (gpd.GeoData
+0000b6d0: 4672 616d 6529 3a20 5468 6520 4765 6f44  Frame): The GeoD
+0000b6e0: 6174 6146 7261 6d65 2074 6f20 6578 706f  ataFrame to expo
+0000b6f0: 7274 2074 6f20 6669 6c65 2e0a 2020 2020  rt to file..    
+0000b700: 2020 2020 7061 7468 2028 556e 696f 6e5b      path (Union[
+0000b710: 7374 722c 293a 2054 6865 2066 696c 6520  str,): The file 
+0000b720: 7061 7468 2074 6f20 7772 6974 6520 746f  path to write to
+0000b730: 2e0a 2020 2020 2020 2020 6c61 7965 7220  ..        layer 
+0000b740: 2873 7472 2c20 6f70 7469 6f6e 616c 293a  (str, optional):
+0000b750: 2054 6865 206c 6179 6572 2074 6f20 7265   The layer to re
+0000b760: 6164 2e20 4966 206e 6f20 6c61 7965 7220  ad. If no layer 
+0000b770: 6973 2073 7065 6369 6669 6564 2c0a 2020  is specified,.  
+0000b780: 2020 2020 2020 2020 2020 7265 6164 7320            reads 
+0000b790: 7468 6520 6f6e 6c79 206c 6179 6572 2069  the only layer i
+0000b7a0: 6e20 7468 6520 6669 6c65 206f 7220 7468  n the file or th
+0000b7b0: 726f 7773 2061 6e20 4578 6365 7074 696f  rows an Exceptio
+0000b7c0: 6e2e 0a20 2020 2020 2020 2066 6f72 6365  n..        force
+0000b7d0: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
+0000b7e0: 7479 7065 2028 556e 696f 6e5b 4765 6f6d  type (Union[Geom
+0000b7f0: 6574 7279 5479 7065 2c20 7374 725d 2c20  etryType, str], 
+0000b800: 6f70 7469 6f6e 616c 293a 2047 656f 6d65  optional): Geome
+0000b810: 7472 7920 7479 7065 0a20 2020 2020 2020  try type.       
+0000b820: 2020 2020 2074 6f20 2874 7279 2074 6f29       to (try to)
+0000b830: 2066 6f72 6365 2074 6865 206f 7574 7075   force the outpu
+0000b840: 7420 746f 2e20 4465 6661 756c 7473 2074  t to. Defaults t
+0000b850: 6f20 4e6f 6e65 2e0a 2020 2020 2020 2020  o None..        
+0000b860: 2020 2020 4d61 726b 3a20 636f 6d70 6172      Mark: compar
+0000b870: 6564 2074 6f20 6f74 6865 7220 6675 6e63  ed to other func
+0000b880: 7469 6f6e 7320 696e 2067 666f 2077 6974  tions in gfo wit
+0000b890: 6820 7468 6973 2070 6172 616d 6574 6572  h this parameter
+0000b8a0: 2c20 7468 6520 6265 6861 7669 6f75 720a  , the behaviour.
+0000b8b0: 2020 2020 2020 2020 2020 2020 6865 7265              here
+0000b8c0: 2069 7320 6c69 6d69 7465 6420 746f 2074   is limited to t
+0000b8d0: 6865 2066 6f6c 6c6f 7769 6e67 3a0a 2020  he following:.  
+0000b8e0: 2020 2020 2020 2020 2020 2020 2020 2d20                - 
+0000b8f0: 666f 7220 656d 7074 7920 696e 7075 7420  for empty input 
+0000b900: 6764 6627 732c 2061 2073 7461 6e64 6172  gdf's, a standar
+0000b910: 6420 6765 6f6d 6574 7279 2074 7970 6520  d geometry type 
+0000b920: 2865 672e 2050 6f6c 7967 6f6e 2c2e 2e2e  (eg. Polygon,...
+0000b930: 2920 6361 6e0a 2020 2020 2020 2020 2020  ) can.          
+0000b940: 2020 2020 2020 2020 6265 2075 7365 6420          be used 
+0000b950: 746f 2066 6f72 6365 2074 6865 2067 656f  to force the geo
+0000b960: 6d65 7472 7920 636f 6c75 6d6e 2074 6f20  metry column to 
+0000b970: 6265 206f 6620 7468 6174 2074 7970 652e  be of that type.
+0000b980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b990: 202d 2069 6620 666f 7263 655f 6f75 7470   - if force_outp
+0000b9a0: 7574 5f67 656f 6d65 7472 7974 7970 6520  ut_geometrytype 
+0000b9b0: 6973 2061 204d 554c 5449 2074 7970 652c  is a MULTI type,
+0000b9c0: 2070 6172 616d 6574 6572 0a20 2020 2020   parameter.     
+0000b9d0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0000b9e0: 6365 5f6d 756c 7469 7479 7065 2062 6563  ce_multitype bec
+0000b9f0: 6f6d 6573 2054 7275 652e 0a20 2020 2020  omes True..     
+0000ba00: 2020 2066 6f72 6365 5f6d 756c 7469 7479     force_multity
+0000ba10: 7065 2028 626f 6f6c 2c20 6f70 7469 6f6e  pe (bool, option
+0000ba20: 616c 293a 2066 6f72 6365 2074 6865 2067  al): force the g
+0000ba30: 656f 6d65 7472 7920 7479 7065 2074 6f20  eometry type to 
+0000ba40: 6120 6d75 6c74 6974 7970 650a 2020 2020  a multitype.    
+0000ba50: 2020 2020 2020 2020 666f 7220 6669 6c65          for file
+0000ba60: 2074 7970 6573 2074 6861 7420 7265 7175   types that requ
+0000ba70: 6972 6520 6f6e 6520 6765 6f6d 6574 7279  ire one geometry
+0000ba80: 7479 7065 2070 6572 206c 6179 6572 2e0a  type per layer..
+0000ba90: 2020 2020 2020 2020 2020 2020 4465 6661              Defa
+0000baa0: 756c 7473 2074 6f20 4661 6c73 652e 0a20  ults to False.. 
+0000bab0: 2020 2020 2020 2061 7070 656e 6420 2862         append (b
+0000bac0: 6f6f 6c2c 206f 7074 696f 6e61 6c29 3a20  ool, optional): 
+0000bad0: 5472 7565 2074 6f20 6170 7065 6e64 2074  True to append t
+0000bae0: 6f20 7468 6520 6669 6c65 2f6c 6179 6572  o the file/layer
+0000baf0: 2069 6620 6974 2065 7869 7374 7320 616c   if it exists al
+0000bb00: 7265 6164 792e 0a20 2020 2020 2020 2020  ready..         
+0000bb10: 2020 2049 6620 6974 2064 6f65 736e 2774     If it doesn't
+0000bb20: 2065 7869 7374 2079 6574 2c20 6974 2069   exist yet, it i
+0000bb30: 7320 6372 6561 7465 642e 2044 6566 6175  s created. Defau
+0000bb40: 6c74 7320 746f 2046 616c 7365 2e0a 2020  lts to False..  
+0000bb50: 2020 2020 2020 6170 7065 6e64 5f74 696d        append_tim
+0000bb60: 656f 7574 5f73 2028 696e 742c 206f 7074  eout_s (int, opt
+0000bb70: 696f 6e61 6c29 3a20 5468 6520 6d61 7869  ional): The maxi
+0000bb80: 6d75 6d20 7469 6d65 6f75 7420 746f 2077  mum timeout to w
+0000bb90: 6169 7420 7768 656e 2074 6865 0a20 2020  ait when the.   
+0000bba0: 2020 2020 2020 2020 206f 7574 7075 7420           output 
+0000bbb0: 6669 6c65 2069 7320 616c 7265 6164 7920  file is already 
+0000bbc0: 6265 696e 6720 7772 6974 7465 6e20 746f  being written to
+0000bbd0: 2062 7920 616e 6f74 6865 7220 7072 6f63   by another proc
+0000bbe0: 6573 732e 0a20 2020 2020 2020 2020 2020  ess..           
+0000bbf0: 2044 6566 6175 6c74 7320 746f 2036 3030   Defaults to 600
+0000bc00: 2e0a 2020 2020 2020 2020 696e 6465 7820  ..        index 
+0000bc10: 2862 6f6f 6c2c 206f 7074 696f 6e61 6c29  (bool, optional)
+0000bc20: 3a20 5472 7565 2074 6f20 7772 6974 6520  : True to write 
+0000bc30: 7468 6520 7061 6e64 6173 2069 6e64 6578  the pandas index
+0000bc40: 2074 6f20 7468 6520 6669 6c65 2061 730a   to the file as.
+0000bc50: 2020 2020 2020 2020 2020 2020 7765 6c6c              well
+0000bc60: 2e20 4465 6661 756c 7473 2074 6f20 5472  . Defaults to Tr
+0000bc70: 7565 2e0a 2020 2020 2020 2020 6372 6561  ue..        crea
+0000bc80: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
+0000bc90: 2028 626f 6f6c 2c20 6f70 7469 6f6e 616c   (bool, optional
+0000bca0: 293a 2054 7275 6520 746f 2066 6f72 6365  ): True to force
+0000bcb0: 2063 7265 6174 696f 6e20 6f66 2073 7061   creation of spa
+0000bcc0: 7469 616c 2069 6e64 6578 2c0a 2020 2020  tial index,.    
+0000bcd0: 2020 2020 2020 2020 4661 6c73 6520 746f          False to
+0000bce0: 2061 766f 6964 2063 7265 6174 696f 6e2e   avoid creation.
+0000bcf0: 204e 6f6e 6520 6c65 6164 7320 746f 2074   None leads to t
+0000bd00: 6865 2064 6566 6175 6c74 2062 6568 6176  he default behav
+0000bd10: 696f 7572 206f 6620 6764 616c 2e0a 2020  iour of gdal..  
+0000bd20: 2020 2020 2020 2020 2020 4465 6661 756c            Defaul
+0000bd30: 7473 2074 6f20 5472 7565 2e0a 0a20 2020  ts to True...   
+0000bd40: 2052 6169 7365 733a 0a20 2020 2020 2020   Raises:.       
+0000bd50: 2056 616c 7565 4572 726f 723a 2061 6e20   ValueError: an 
+0000bd60: 696e 7661 6c69 6420 7061 7261 6d65 7465  invalid paramete
+0000bd70: 7220 7661 6c75 6520 7761 7320 7061 7373  r value was pass
+0000bd80: 6564 2e0a 2020 2020 2020 2020 5275 6e74  ed..        Runt
+0000bd90: 696d 6545 7272 6f72 3a20 7469 6d65 6f75  imeError: timeou
+0000bda0: 7420 7761 7320 7265 6163 6865 6420 7768  t was reached wh
+0000bdb0: 696c 6520 7472 7969 6e67 2074 6f20 6170  ile trying to ap
+0000bdc0: 7065 6e64 2064 6174 6120 746f 2070 6174  pend data to pat
+0000bdd0: 682e 0a20 2020 2022 2222 0a20 2020 2023  h..    """.    #
+0000bde0: 2043 6865 636b 2069 6e70 7574 2070 6172   Check input par
+0000bdf0: 616d 6574 6572 730a 2020 2020 2320 2d2d  ameters.    # --
+0000be00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000be10: 2d2d 2d2d 0a20 2020 2070 6174 6820 3d20  ----.    path = 
+0000be20: 5061 7468 2870 6174 6829 0a0a 2020 2020  Path(path)..    
+0000be30: 2320 4966 206e 6f20 6c61 7965 7220 6e61  # If no layer na
+0000be40: 6d65 2073 7065 6369 6669 6564 2c20 6465  me specified, de
+0000be50: 7465 726d 696e 6520 6f6e 650a 2020 2020  termine one.    
+0000be60: 6966 206c 6179 6572 2069 7320 4e6f 6e65  if layer is None
+0000be70: 3a0a 2020 2020 2020 2020 6966 2061 7070  :.        if app
+0000be80: 656e 6420 616e 6420 7061 7468 2e65 7869  end and path.exi
+0000be90: 7374 7328 293a 0a20 2020 2020 2020 2020  sts():.         
+0000bea0: 2020 206c 6179 6572 203d 2067 6574 5f6f     layer = get_o
+0000beb0: 6e6c 795f 6c61 7965 7228 7061 7468 290a  nly_layer(path).
+0000bec0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000bed0: 2020 2020 2020 2020 2020 6c61 7965 7220            layer 
+0000bee0: 3d20 5061 7468 2870 6174 6829 2e73 7465  = Path(path).ste
+0000bef0: 6d0a 0a20 2020 2023 2049 6620 666f 7263  m..    # If forc
+0000bf00: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+0000bf10: 7974 7970 6520 6973 2061 2073 7472 696e  ytype is a strin
+0000bf20: 672c 2063 6865 636b 2069 6620 6974 2069  g, check if it i
+0000bf30: 7320 6120 2273 7461 6e64 6172 6422 2067  s a "standard" g
+0000bf40: 656f 6d65 7472 790a 2020 2020 2320 7479  eometry.    # ty
+0000bf50: 7065 2c20 6173 2047 4441 4c20 616c 736f  pe, as GDAL also
+0000bf60: 2073 7570 706f 7274 7320 7370 6563 6961   supports specia
+0000bf70: 6c20 6765 6f6d 6574 7279 2074 7970 6573  l geometry types
+0000bf80: 206c 696b 6520 2250 524f 4d4f 5445 5f54   like "PROMOTE_T
+0000bf90: 4f5f 4d55 4c54 4922 0a20 2020 2069 6620  O_MULTI".    if 
+0000bfa0: 6973 696e 7374 616e 6365 2866 6f72 6365  isinstance(force
+0000bfb0: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
+0000bfc0: 7479 7065 2c20 7374 7229 3a0a 2020 2020  type, str):.    
+0000bfd0: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
+0000bfe0: 5f67 656f 6d65 7472 7974 7970 6520 3d20  _geometrytype = 
 0000bff0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
-0000c000: 6d65 7472 7974 7970 6520 2855 6e69 6f6e  metrytype (Union
-0000c010: 5b47 656f 6d65 7472 7954 7970 652c 2073  [GeometryType, s
-0000c020: 7472 5d2c 206f 7074 696f 6e61 6c29 3a20  tr], optional): 
-0000c030: 4765 6f6d 6574 7279 2074 7970 650d 0a20  Geometry type.. 
-0000c040: 2020 2020 2020 2020 2020 2074 6f20 2874             to (t
-0000c050: 7279 2074 6f29 2066 6f72 6365 2074 6865  ry to) force the
-0000c060: 206f 7574 7075 7420 746f 2e20 4465 6661   output to. Defa
-0000c070: 756c 7473 2074 6f20 4e6f 6e65 2e0d 0a20  ults to None... 
-0000c080: 2020 2020 2020 2020 2020 204d 6172 6b3a             Mark:
-0000c090: 2063 6f6d 7061 7265 6420 746f 206f 7468   compared to oth
-0000c0a0: 6572 2066 756e 6374 696f 6e73 2069 6e20  er functions in 
-0000c0b0: 6766 6f20 7769 7468 2074 6869 7320 7061  gfo with this pa
-0000c0c0: 7261 6d65 7465 722c 2074 6865 2062 6568  rameter, the beh
-0000c0d0: 6176 696f 7572 0d0a 2020 2020 2020 2020  aviour..        
-0000c0e0: 2020 2020 6865 7265 2069 7320 6c69 6d69      here is limi
-0000c0f0: 7465 6420 746f 2074 6865 2066 6f6c 6c6f  ted to the follo
-0000c100: 7769 6e67 3a0d 0a20 2020 2020 2020 2020  wing:..         
-0000c110: 2020 2020 2020 202d 2066 6f72 2065 6d70         - for emp
-0000c120: 7479 2069 6e70 7574 2067 6466 2773 2c20  ty input gdf's, 
-0000c130: 6120 7374 616e 6461 7264 2067 656f 6d65  a standard geome
-0000c140: 7472 7920 7479 7065 2028 6567 2e20 506f  try type (eg. Po
-0000c150: 6c79 676f 6e2c 2e2e 2e29 2063 616e 0d0a  lygon,...) can..
-0000c160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c170: 2020 6265 2075 7365 6420 746f 2066 6f72    be used to for
-0000c180: 6365 2074 6865 2067 656f 6d65 7472 7920  ce the geometry 
-0000c190: 636f 6c75 6d6e 2074 6f20 6265 206f 6620  column to be of 
-0000c1a0: 7468 6174 2074 7970 652e 0d0a 2020 2020  that type...    
-0000c1b0: 2020 2020 2020 2020 2020 2020 2d20 6966              - if
-0000c1c0: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
-0000c1d0: 6f6d 6574 7279 7479 7065 2069 7320 6120  ometrytype is a 
-0000c1e0: 4d55 4c54 4920 7479 7065 2c20 7061 7261  MULTI type, para
-0000c1f0: 6d65 7465 720d 0a20 2020 2020 2020 2020  meter..         
-0000c200: 2020 2020 2020 2020 2066 6f72 6365 5f6d           force_m
-0000c210: 756c 7469 7479 7065 2062 6563 6f6d 6573  ultitype becomes
-0000c220: 2054 7275 652e 0d0a 2020 2020 2020 2020   True...        
-0000c230: 666f 7263 655f 6d75 6c74 6974 7970 6520  force_multitype 
-0000c240: 2862 6f6f 6c2c 206f 7074 696f 6e61 6c29  (bool, optional)
-0000c250: 3a20 666f 7263 6520 7468 6520 6765 6f6d  : force the geom
-0000c260: 6574 7279 2074 7970 6520 746f 2061 206d  etry type to a m
-0000c270: 756c 7469 7479 7065 0d0a 2020 2020 2020  ultitype..      
-0000c280: 2020 2020 2020 666f 7220 6669 6c65 2074        for file t
-0000c290: 7970 6573 2074 6861 7420 7265 7175 6972  ypes that requir
-0000c2a0: 6520 6f6e 6520 6765 6f6d 6574 7279 7479  e one geometryty
-0000c2b0: 7065 2070 6572 206c 6179 6572 2e0d 0a20  pe per layer... 
-0000c2c0: 2020 2020 2020 2020 2020 2044 6566 6175             Defau
-0000c2d0: 6c74 7320 746f 2046 616c 7365 2e0d 0a20  lts to False... 
-0000c2e0: 2020 2020 2020 2061 7070 656e 6420 2862         append (b
-0000c2f0: 6f6f 6c2c 206f 7074 696f 6e61 6c29 3a20  ool, optional): 
-0000c300: 5472 7565 2074 6f20 6170 7065 6e64 2074  True to append t
-0000c310: 6f20 7468 6520 6669 6c65 2f6c 6179 6572  o the file/layer
-0000c320: 2069 6620 6974 2065 7869 7374 7320 616c   if it exists al
-0000c330: 7265 6164 792e 0d0a 2020 2020 2020 2020  ready...        
-0000c340: 2020 2020 4966 2069 7420 646f 6573 6e27      If it doesn'
-0000c350: 7420 6578 6973 7420 7965 742c 2069 7420  t exist yet, it 
-0000c360: 6973 2063 7265 6174 6564 2e20 4465 6661  is created. Defa
-0000c370: 756c 7473 2074 6f20 4661 6c73 652e 0d0a  ults to False...
-0000c380: 2020 2020 2020 2020 6170 7065 6e64 5f74          append_t
-0000c390: 696d 656f 7574 5f73 2028 696e 742c 206f  imeout_s (int, o
-0000c3a0: 7074 696f 6e61 6c29 3a20 5468 6520 6d61  ptional): The ma
-0000c3b0: 7869 6d75 6d20 7469 6d65 6f75 7420 746f  ximum timeout to
-0000c3c0: 2077 6169 7420 7768 656e 2074 6865 0d0a   wait when the..
-0000c3d0: 2020 2020 2020 2020 2020 2020 6f75 7470              outp
-0000c3e0: 7574 2066 696c 6520 6973 2061 6c72 6561  ut file is alrea
-0000c3f0: 6479 2062 6569 6e67 2077 7269 7474 656e  dy being written
-0000c400: 2074 6f20 6279 2061 6e6f 7468 6572 2070   to by another p
-0000c410: 726f 6365 7373 2e0d 0a20 2020 2020 2020  rocess...       
-0000c420: 2020 2020 2044 6566 6175 6c74 7320 746f       Defaults to
-0000c430: 2036 3030 2e0d 0a20 2020 2020 2020 2069   600...        i
-0000c440: 6e64 6578 2028 626f 6f6c 2c20 6f70 7469  ndex (bool, opti
-0000c450: 6f6e 616c 293a 2054 7275 6520 746f 2077  onal): True to w
-0000c460: 7269 7465 2074 6865 2070 616e 6461 7320  rite the pandas 
-0000c470: 696e 6465 7820 746f 2074 6865 2066 696c  index to the fil
-0000c480: 6520 6173 0d0a 2020 2020 2020 2020 2020  e as..          
-0000c490: 2020 7765 6c6c 2e20 4465 6661 756c 7473    well. Defaults
-0000c4a0: 2074 6f20 5472 7565 2e0d 0a20 2020 2020   to True...     
-0000c4b0: 2020 2063 7265 6174 655f 7370 6174 6961     create_spatia
-0000c4c0: 6c5f 696e 6465 7820 2862 6f6f 6c2c 206f  l_index (bool, o
-0000c4d0: 7074 696f 6e61 6c29 3a20 5472 7565 2074  ptional): True t
-0000c4e0: 6f20 666f 7263 6520 6372 6561 7469 6f6e  o force creation
-0000c4f0: 206f 6620 7370 6174 6961 6c20 696e 6465   of spatial inde
-0000c500: 782c 0d0a 2020 2020 2020 2020 2020 2020  x,..            
-0000c510: 4661 6c73 6520 746f 2061 766f 6964 2063  False to avoid c
-0000c520: 7265 6174 696f 6e2e 204e 6f6e 6520 6c65  reation. None le
-0000c530: 6164 7320 746f 2074 6865 2064 6566 6175  ads to the defau
-0000c540: 6c74 2062 6568 6176 696f 7572 206f 6620  lt behaviour of 
-0000c550: 6764 616c 2e0d 0a20 2020 2020 2020 2020  gdal...         
-0000c560: 2020 2044 6566 6175 6c74 7320 746f 2054     Defaults to T
-0000c570: 7275 652e 0d0a 0d0a 2020 2020 5261 6973  rue.....    Rais
-0000c580: 6573 3a0d 0a20 2020 2020 2020 2056 616c  es:..        Val
-0000c590: 7565 4572 726f 723a 2061 6e20 696e 7661  ueError: an inva
-0000c5a0: 6c69 6420 7061 7261 6d65 7465 7220 7661  lid parameter va
-0000c5b0: 6c75 6520 7761 7320 7061 7373 6564 2e0d  lue was passed..
-0000c5c0: 0a20 2020 2020 2020 2052 756e 7469 6d65  .        Runtime
-0000c5d0: 4572 726f 723a 2074 696d 656f 7574 2077  Error: timeout w
-0000c5e0: 6173 2072 6561 6368 6564 2077 6869 6c65  as reached while
-0000c5f0: 2074 7279 696e 6720 746f 2061 7070 656e   trying to appen
-0000c600: 6420 6461 7461 2074 6f20 7061 7468 2e0d  d data to path..
-0000c610: 0a20 2020 2022 2222 0d0a 2020 2020 2320  .    """..    # 
-0000c620: 4368 6563 6b20 696e 7075 7420 7061 7261  Check input para
-0000c630: 6d65 7465 7273 0d0a 2020 2020 2320 2d2d  meters..    # --
-0000c640: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000c650: 2d2d 2d2d 0d0a 2020 2020 7061 7468 203d  ----..    path =
-0000c660: 2050 6174 6828 7061 7468 290d 0a0d 0a20   Path(path).... 
-0000c670: 2020 2023 2049 6620 6e6f 206c 6179 6572     # If no layer
-0000c680: 206e 616d 6520 7370 6563 6966 6965 642c   name specified,
-0000c690: 2064 6574 6572 6d69 6e65 206f 6e65 0d0a   determine one..
-0000c6a0: 2020 2020 6966 206c 6179 6572 2069 7320      if layer is 
-0000c6b0: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2069  None:..        i
-0000c6c0: 6620 6170 7065 6e64 2061 6e64 2070 6174  f append and pat
-0000c6d0: 682e 6578 6973 7473 2829 3a0d 0a20 2020  h.exists():..   
-0000c6e0: 2020 2020 2020 2020 206c 6179 6572 203d           layer =
-0000c6f0: 2067 6574 5f6f 6e6c 795f 6c61 7965 7228   get_only_layer(
-0000c700: 7061 7468 290d 0a20 2020 2020 2020 2065  path)..        e
-0000c710: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-0000c720: 2020 6c61 7965 7220 3d20 5061 7468 2870    layer = Path(p
-0000c730: 6174 6829 2e73 7465 6d0d 0a0d 0a20 2020  ath).stem....   
-0000c740: 2023 2049 6620 666f 7263 655f 6f75 7470   # If force_outp
-0000c750: 7574 5f67 656f 6d65 7472 7974 7970 6520  ut_geometrytype 
-0000c760: 6973 2061 2073 7472 696e 672c 2063 6865  is a string, che
-0000c770: 636b 2069 6620 6974 2069 7320 6120 2273  ck if it is a "s
-0000c780: 7461 6e64 6172 6422 2067 656f 6d65 7472  tandard" geometr
-0000c790: 790d 0a20 2020 2023 2074 7970 652c 2061  y..    # type, a
-0000c7a0: 7320 4744 414c 2061 6c73 6f20 7375 7070  s GDAL also supp
-0000c7b0: 6f72 7473 2073 7065 6369 616c 2067 656f  orts special geo
-0000c7c0: 6d65 7472 7920 7479 7065 7320 6c69 6b65  metry types like
-0000c7d0: 2022 5052 4f4d 4f54 455f 544f 5f4d 554c   "PROMOTE_TO_MUL
-0000c7e0: 5449 220d 0a20 2020 2069 6620 6973 696e  TI"..    if isin
-0000c7f0: 7374 616e 6365 2866 6f72 6365 5f6f 7574  stance(force_out
-0000c800: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
-0000c810: 2c20 7374 7229 3a0d 0a20 2020 2020 2020  , str):..       
-0000c820: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
-0000c830: 6f6d 6574 7279 7479 7065 203d 2066 6f72  ometrytype = for
-0000c840: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-0000c850: 7279 7479 7065 2e75 7070 6572 2829 0d0a  rytype.upper()..
-0000c860: 2020 2020 2020 2020 7472 793a 0d0a 2020          try:..  
-0000c870: 2020 2020 2020 2020 2020 2320 5665 7269            # Veri
-0000c880: 6679 2069 6620 6974 2069 7320 6120 2273  fy if it is a "s
-0000c890: 7461 6e64 6172 6422 2067 656f 6d65 7472  tandard" geometr
-0000c8a0: 7920 7479 7065 2c20 6173 2047 4441 4c20  y type, as GDAL 
-0000c8b0: 616c 736f 2073 7570 706f 7274 730d 0a20  also supports.. 
-0000c8c0: 2020 2020 2020 2020 2020 2023 2073 7065             # spe
-0000c8d0: 6369 616c 2067 656f 6d65 7472 7920 7479  cial geometry ty
-0000c8e0: 7065 7320 6c69 6b65 2022 5052 4f4d 4f54  pes like "PROMOT
-0000c8f0: 455f 544f 5f4d 554c 5449 220d 0a20 2020  E_TO_MULTI"..   
-0000c900: 2020 2020 2020 2020 2066 6f72 6365 5f6f           force_o
-0000c910: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-0000c920: 7065 203d 2047 656f 6d65 7472 7954 7970  pe = GeometryTyp
-0000c930: 655b 666f 7263 655f 6f75 7470 7574 5f67  e[force_output_g
-0000c940: 656f 6d65 7472 7974 7970 655d 0d0a 2020  eometrytype]..  
-0000c950: 2020 2020 2020 6578 6365 7074 2045 7863        except Exc
-0000c960: 6570 7469 6f6e 3a0d 0a20 2020 2020 2020  eption:..       
-0000c970: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-0000c980: 4572 726f 7228 0d0a 2020 2020 2020 2020  Error(..        
-0000c990: 2020 2020 2020 2020 6622 556e 7375 7070          f"Unsupp
-0000c9a0: 6f72 7465 6420 666f 7263 655f 6f75 7470  orted force_outp
-0000c9b0: 7574 5f67 656f 6d65 7472 7974 7970 653a  ut_geometrytype:
-0000c9c0: 207b 666f 7263 655f 6f75 7470 7574 5f67   {force_output_g
-0000c9d0: 656f 6d65 7472 7974 7970 657d 220d 0a20  eometrytype}".. 
-0000c9e0: 2020 2020 2020 2020 2020 2029 0d0a 2020             )..  
-0000c9f0: 2020 6966 2066 6f72 6365 5f6f 7574 7075    if force_outpu
-0000ca00: 745f 6765 6f6d 6574 7279 7479 7065 2069  t_geometrytype i
-0000ca10: 7320 6e6f 7420 4e6f 6e65 2061 6e64 2066  s not None and f
-0000ca20: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-0000ca30: 6574 7279 7479 7065 2e69 735f 6d75 6c74  etrytype.is_mult
-0000ca40: 6974 7970 653a 0d0a 2020 2020 2020 2020  itype:..        
-0000ca50: 666f 7263 655f 6d75 6c74 6974 7970 6520  force_multitype 
-0000ca60: 3d20 5472 7565 0d0a 0d0a 2020 2020 2320  = True....    # 
-0000ca70: 4966 2074 6865 7265 2069 7320 6e6f 2067  If there is no g
-0000ca80: 656f 6d65 7472 7920 636f 6c75 6d6e 2069  eometry column i
-0000ca90: 6e20 7468 6520 696e 7075 742c 2061 6c77  n the input, alw
-0000caa0: 6179 7320 7573 6520 6669 6f6e 612c 2061  ays use fiona, a
-0000cab0: 7320 7079 6f67 7269 6f20 646f 6573 6e27  s pyogrio doesn'
-0000cac0: 740d 0a20 2020 2023 2073 7570 706f 7274  t..    # support
-0000cad0: 2074 6861 7420 7965 7420 6174 2074 696d   that yet at tim
-0000cae0: 6520 6f66 2077 7269 7469 6e67 2e0d 0a20  e of writing... 
-0000caf0: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
-0000cb00: 2867 6466 2c20 6770 642e 4765 6f44 6174  (gdf, gpd.GeoDat
-0000cb10: 6146 7261 6d65 2920 6973 2046 616c 7365  aFrame) is False
-0000cb20: 206f 7220 280d 0a20 2020 2020 2020 2069   or (..        i
-0000cb30: 7369 6e73 7461 6e63 6528 6764 662c 2067  sinstance(gdf, g
-0000cb40: 7064 2e47 656f 4461 7461 4672 616d 6529  pd.GeoDataFrame)
-0000cb50: 2061 6e64 2022 6765 6f6d 6574 7279 2220   and "geometry" 
-0000cb60: 6e6f 7420 696e 2067 6466 2e63 6f6c 756d  not in gdf.colum
-0000cb70: 6e73 0d0a 2020 2020 293a 0d0a 2020 2020  ns..    ):..    
-0000cb80: 2020 2020 656e 6769 6e65 203d 2022 6669      engine = "fi
-0000cb90: 6f6e 6122 0d0a 2020 2020 656c 7365 3a0d  ona"..    else:.
-0000cba0: 0a20 2020 2020 2020 2065 6e67 696e 6520  .        engine 
-0000cbb0: 3d20 5f67 6574 5f65 6e67 696e 6528 290d  = _get_engine().
-0000cbc0: 0a0d 0a20 2020 2023 204e 6f77 2077 7269  ...    # Now wri
-0000cbd0: 7465 2077 6974 6820 7468 6520 636f 7272  te with the corr
-0000cbe0: 6563 7420 656e 6769 6e65 0d0a 2020 2020  ect engine..    
-0000cbf0: 6966 2065 6e67 696e 6520 3d3d 2022 7079  if engine == "py
-0000cc00: 6f67 7269 6f22 3a0d 0a20 2020 2020 2020  ogrio":..       
-0000cc10: 2072 6574 7572 6e20 5f74 6f5f 6669 6c65   return _to_file
-0000cc20: 5f70 796f 6772 696f 280d 0a20 2020 2020  _pyogrio(..     
-0000cc30: 2020 2020 2020 2067 6466 3d67 6466 2c0d         gdf=gdf,.
-0000cc40: 0a20 2020 2020 2020 2020 2020 2070 6174  .            pat
-0000cc50: 683d 7061 7468 2c0d 0a20 2020 2020 2020  h=path,..       
-0000cc60: 2020 2020 206c 6179 6572 3d6c 6179 6572       layer=layer
-0000cc70: 2c0d 0a20 2020 2020 2020 2020 2020 2066  ,..            f
-0000cc80: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-0000cc90: 6574 7279 7479 7065 3d66 6f72 6365 5f6f  etrytype=force_o
-0000cca0: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-0000ccb0: 7065 2c0d 0a20 2020 2020 2020 2020 2020  pe,..           
-0000ccc0: 2066 6f72 6365 5f6d 756c 7469 7479 7065   force_multitype
-0000ccd0: 3d66 6f72 6365 5f6d 756c 7469 7479 7065  =force_multitype
-0000cce0: 2c0d 0a20 2020 2020 2020 2020 2020 2061  ,..            a
-0000ccf0: 7070 656e 643d 6170 7065 6e64 2c0d 0a20  ppend=append,.. 
-0000cd00: 2020 2020 2020 2020 2020 2061 7070 656e             appen
-0000cd10: 645f 7469 6d65 6f75 745f 733d 6170 7065  d_timeout_s=appe
-0000cd20: 6e64 5f74 696d 656f 7574 5f73 2c0d 0a20  nd_timeout_s,.. 
-0000cd30: 2020 2020 2020 2020 2020 2069 6e64 6578             index
-0000cd40: 3d69 6e64 6578 2c0d 0a20 2020 2020 2020  =index,..       
-0000cd50: 2020 2020 2063 7265 6174 655f 7370 6174       create_spat
-0000cd60: 6961 6c5f 696e 6465 783d 6372 6561 7465  ial_index=create
-0000cd70: 5f73 7061 7469 616c 5f69 6e64 6578 2c0d  _spatial_index,.
-0000cd80: 0a20 2020 2020 2020 2029 0d0a 2020 2020  .        )..    
-0000cd90: 656c 6966 2065 6e67 696e 6520 3d3d 2022  elif engine == "
-0000cda0: 6669 6f6e 6122 3a0d 0a20 2020 2020 2020  fiona":..       
-0000cdb0: 2072 6574 7572 6e20 5f74 6f5f 6669 6c65   return _to_file
-0000cdc0: 5f66 696f 6e61 280d 0a20 2020 2020 2020  _fiona(..       
-0000cdd0: 2020 2020 2067 6466 3d67 6466 2c0d 0a20       gdf=gdf,.. 
-0000cde0: 2020 2020 2020 2020 2020 2070 6174 683d             path=
-0000cdf0: 7061 7468 2c0d 0a20 2020 2020 2020 2020  path,..         
-0000ce00: 2020 206c 6179 6572 3d6c 6179 6572 2c0d     layer=layer,.
-0000ce10: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-0000ce20: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-0000ce30: 7279 7479 7065 3d66 6f72 6365 5f6f 7574  rytype=force_out
-0000ce40: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
-0000ce50: 2c0d 0a20 2020 2020 2020 2020 2020 2066  ,..            f
-0000ce60: 6f72 6365 5f6d 756c 7469 7479 7065 3d66  orce_multitype=f
-0000ce70: 6f72 6365 5f6d 756c 7469 7479 7065 2c0d  orce_multitype,.
-0000ce80: 0a20 2020 2020 2020 2020 2020 2061 7070  .            app
-0000ce90: 656e 643d 6170 7065 6e64 2c0d 0a20 2020  end=append,..   
-0000cea0: 2020 2020 2020 2020 2061 7070 656e 645f           append_
-0000ceb0: 7469 6d65 6f75 745f 733d 6170 7065 6e64  timeout_s=append
-0000cec0: 5f74 696d 656f 7574 5f73 2c0d 0a20 2020  _timeout_s,..   
-0000ced0: 2020 2020 2020 2020 2069 6e64 6578 3d69           index=i
-0000cee0: 6e64 6578 2c0d 0a20 2020 2020 2020 2020  ndex,..         
-0000cef0: 2020 2063 7265 6174 655f 7370 6174 6961     create_spatia
-0000cf00: 6c5f 696e 6465 783d 6372 6561 7465 5f73  l_index=create_s
-0000cf10: 7061 7469 616c 5f69 6e64 6578 2c0d 0a20  patial_index,.. 
-0000cf20: 2020 2020 2020 2029 0d0a 2020 2020 656c         )..    el
-0000cf30: 7365 3a0d 0a20 2020 2020 2020 2072 6169  se:..        rai
-0000cf40: 7365 2056 616c 7565 4572 726f 7228 6622  se ValueError(f"
-0000cf50: 556e 7375 7070 6f72 7465 6420 656e 6769  Unsupported engi
-0000cf60: 6e65 3a20 7b65 6e67 696e 657d 2229 0d0a  ne: {engine}")..
-0000cf70: 0d0a 0d0a 6465 6620 5f67 6574 5f65 6e67  ....def _get_eng
-0000cf80: 696e 6528 293a 0d0a 2020 2020 7265 7475  ine():..    retu
-0000cf90: 726e 206f 732e 656e 7669 726f 6e2e 6765  rn os.environ.ge
-0000cfa0: 7428 2247 464f 5f49 4f5f 454e 4749 4e45  t("GFO_IO_ENGINE
-0000cfb0: 222c 2022 7079 6f67 7269 6f22 290d 0a0d  ", "pyogrio")...
-0000cfc0: 0a0d 0a64 6566 205f 746f 5f66 696c 655f  ...def _to_file_
-0000cfd0: 6669 6f6e 6128 0d0a 2020 2020 6764 663a  fiona(..    gdf:
-0000cfe0: 2055 6e69 6f6e 5b70 642e 4461 7461 4672   Union[pd.DataFr
-0000cff0: 616d 652c 2067 7064 2e47 656f 4461 7461  ame, gpd.GeoData
-0000d000: 4672 616d 655d 2c0d 0a20 2020 2070 6174  Frame],..    pat
-0000d010: 683a 2050 6174 682c 0d0a 2020 2020 6c61  h: Path,..    la
-0000d020: 7965 723a 2073 7472 2c0d 0a20 2020 2066  yer: str,..    f
-0000d030: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-0000d040: 6574 7279 7479 7065 3a20 556e 696f 6e5b  etrytype: Union[
-0000d050: 4765 6f6d 6574 7279 5479 7065 2c20 7374  GeometryType, st
-0000d060: 722c 204e 6f6e 655d 203d 204e 6f6e 652c  r, None] = None,
-0000d070: 0d0a 2020 2020 666f 7263 655f 6d75 6c74  ..    force_mult
-0000d080: 6974 7970 653a 2062 6f6f 6c20 3d20 4661  itype: bool = Fa
-0000d090: 6c73 652c 0d0a 2020 2020 6170 7065 6e64  lse,..    append
-0000d0a0: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-0000d0b0: 0a20 2020 2061 7070 656e 645f 7469 6d65  .    append_time
-0000d0c0: 6f75 745f 733a 2069 6e74 203d 2036 3030  out_s: int = 600
-0000d0d0: 2c0d 0a20 2020 2069 6e64 6578 3a20 626f  ,..    index: bo
-0000d0e0: 6f6c 203d 2054 7275 652c 0d0a 2020 2020  ol = True,..    
-0000d0f0: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
-0000d100: 6e64 6578 3a20 4f70 7469 6f6e 616c 5b62  ndex: Optional[b
-0000d110: 6f6f 6c5d 203d 2054 7275 652c 0d0a 293a  ool] = True,..):
-0000d120: 0d0a 2020 2020 2222 220d 0a20 2020 2057  ..    """..    W
-0000d130: 7269 7465 7320 6120 7061 6e64 6173 2064  rites a pandas d
-0000d140: 6174 6166 7261 6d65 2074 6f20 6669 6c65  ataframe to file
-0000d150: 2075 7369 6e67 2066 696f 6e61 2e0d 0a20   using fiona... 
-0000d160: 2020 2022 2222 0d0a 2020 2020 2320 4861     """..    # Ha
-0000d170: 6e64 6c65 2073 6f6d 6520 7370 6563 6966  ndle some specif
-0000d180: 6963 2063 6173 6573 2077 6865 7265 2074  ic cases where t
-0000d190: 6865 2066 696c 6520 7363 6865 6d61 206e  he file schema n
-0000d1a0: 6565 6473 2074 6f20 6265 206d 616e 6970  eeds to be manip
-0000d1b0: 756c 6174 6564 2e0d 0a20 2020 2073 6368  ulated...    sch
-0000d1c0: 656d 6120 3d20 4e6f 6e65 0d0a 2020 2020  ema = None..    
-0000d1d0: 6966 2069 7369 6e73 7461 6e63 6528 6764  if isinstance(gd
-0000d1e0: 662c 2067 7064 2e47 656f 4461 7461 4672  f, gpd.GeoDataFr
-0000d1f0: 616d 6529 2069 7320 4661 6c73 6520 6f72  ame) is False or
-0000d200: 2028 0d0a 2020 2020 2020 2020 6973 696e   (..        isin
-0000d210: 7374 616e 6365 2867 6466 2c20 6770 642e  stance(gdf, gpd.
-0000d220: 4765 6f44 6174 6146 7261 6d65 2920 616e  GeoDataFrame) an
-0000d230: 6420 2267 656f 6d65 7472 7922 206e 6f74  d "geometry" not
-0000d240: 2069 6e20 6764 662e 636f 6c75 6d6e 730d   in gdf.columns.
-0000d250: 0a20 2020 2029 3a0d 0a20 2020 2020 2020  .    ):..       
-0000d260: 2023 204e 6f20 6765 6f6d 6574 7279 2c20   # No geometry, 
-0000d270: 736f 2070 7265 7061 7265 2074 6f20 6265  so prepare to be
-0000d280: 2077 7269 7474 656e 2061 7320 6174 7472   written as attr
-0000d290: 6962 7574 6520 7461 626c 653a 2061 6464  ibute table: add
-0000d2a0: 2067 656f 6d65 7472 7920 636f 6c75 6d6e   geometry column
-0000d2b0: 0d0a 2020 2020 2020 2020 2320 7769 7468  ..        # with
-0000d2c0: 204e 6f6e 6520 6765 6f6d 6574 7279 2074   None geometry t
-0000d2d0: 7970 6520 696e 2073 6368 656d 610d 0a20  ype in schema.. 
-0000d2e0: 2020 2020 2020 2067 6466 203d 2067 7064         gdf = gpd
-0000d2f0: 2e47 656f 4461 7461 4672 616d 6528 6764  .GeoDataFrame(gd
-0000d300: 662c 2067 656f 6d65 7472 793d 5b4e 6f6e  f, geometry=[Non
-0000d310: 6520 666f 7220 6920 696e 2067 6466 2e69  e for i in gdf.i
-0000d320: 6e64 6578 5d29 2020 2320 7479 7065 3a20  ndex])  # type: 
-0000d330: 6967 6e6f 7265 0d0a 2020 2020 2020 2020  ignore..        
-0000d340: 7363 6865 6d61 203d 2067 7064 5f69 6f5f  schema = gpd_io_
-0000d350: 6669 6c65 2e69 6e66 6572 5f73 6368 656d  file.infer_schem
-0000d360: 6128 6764 6629 0d0a 2020 2020 2020 2020  a(gdf)..        
-0000d370: 7363 6865 6d61 5b22 6765 6f6d 6574 7279  schema["geometry
-0000d380: 225d 203d 2022 4e6f 6e65 220d 0a20 2020  "] = "None"..   
-0000d390: 2065 6c69 6620 280d 0a20 2020 2020 2020   elif (..       
-0000d3a0: 206c 656e 2867 6466 2920 3d3d 2030 0d0a   len(gdf) == 0..
-0000d3b0: 2020 2020 2020 2020 616e 6420 666f 7263          and forc
-0000d3c0: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-0000d3d0: 7974 7970 6520 6973 206e 6f74 204e 6f6e  ytype is not Non
-0000d3e0: 650d 0a20 2020 2020 2020 2061 6e64 2069  e..        and i
-0000d3f0: 7369 6e73 7461 6e63 6528 666f 7263 655f  sinstance(force_
-0000d400: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-0000d410: 7970 652c 2047 656f 6d65 7472 7954 7970  ype, GeometryTyp
-0000d420: 6529 0d0a 2020 2020 293a 0d0a 2020 2020  e)..    ):..    
-0000d430: 2020 2020 2320 4966 2074 6865 2067 6466      # If the gdf
-0000d440: 2069 7320 656d 7074 7920 6275 7420 6120   is empty but a 
-0000d450: 6765 6f6d 6574 7279 2074 7970 6520 6973  geometry type is
-0000d460: 2073 7065 6369 6669 6564 2c20 7573 6520   specified, use 
-0000d470: 7468 6520 7370 6563 6966 6965 6420 7479  the specified ty
-0000d480: 7065 0d0a 2020 2020 2020 2020 7363 6865  pe..        sche
-0000d490: 6d61 203d 2067 7064 5f69 6f5f 6669 6c65  ma = gpd_io_file
-0000d4a0: 2e69 6e66 6572 5f73 6368 656d 6128 6764  .infer_schema(gd
-0000d4b0: 6629 0d0a 2020 2020 2020 2020 2320 4765  f)..        # Ge
-0000d4c0: 6f6d 6574 7279 2074 7970 6520 6d75 7374  ometry type must
-0000d4d0: 2062 6520 696e 2063 616d 656c 6361 7365   be in camelcase
-0000d4e0: 2066 6f72 2066 696f 6e61 0d0a 2020 2020   for fiona..    
-0000d4f0: 2020 2020 7363 6865 6d61 5b22 6765 6f6d      schema["geom
-0000d500: 6574 7279 225d 203d 2066 6f72 6365 5f6f  etry"] = force_o
-0000d510: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-0000d520: 7065 2e6e 616d 655f 6361 6d65 6c63 6173  pe.name_camelcas
-0000d530: 650d 0a20 2020 2061 7373 6572 7420 6973  e..    assert is
-0000d540: 696e 7374 616e 6365 2867 6466 2c20 6770  instance(gdf, gp
-0000d550: 642e 4765 6f44 6174 6146 7261 6d65 290d  d.GeoDataFrame).
-0000d560: 0a0d 0a20 2020 2023 2043 6f6e 7665 7274  ...    # Convert
-0000d570: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
-0000d580: 6f6d 6574 7279 7479 7065 2074 6f20 7374  ometrytype to st
-0000d590: 7269 6e67 2074 6f20 7369 6d70 6c69 6679  ring to simplify
-0000d5a0: 2063 6f64 6520 6166 7465 7277 6172 6473   code afterwards
-0000d5b0: 0d0a 2020 2020 6966 2069 7369 6e73 7461  ..    if isinsta
-0000d5c0: 6e63 6528 666f 7263 655f 6f75 7470 7574  nce(force_output
-0000d5d0: 5f67 656f 6d65 7472 7974 7970 652c 2047  _geometrytype, G
-0000d5e0: 656f 6d65 7472 7954 7970 6529 3a0d 0a20  eometryType):.. 
-0000d5f0: 2020 2020 2020 2066 6f72 6365 5f6f 7574         force_out
-0000d600: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
-0000d610: 203d 2066 6f72 6365 5f6f 7574 7075 745f   = force_output_
-0000d620: 6765 6f6d 6574 7279 7479 7065 2e6e 616d  geometrytype.nam
-0000d630: 650d 0a0d 0a20 2020 2023 204e 6f20 7468  e....    # No th
-0000d640: 6520 6669 6c65 2063 616e 2061 6374 7561  e file can actua
-0000d650: 6c6c 7920 6265 2077 7269 7474 656e 0d0a  lly be written..
-0000d660: 2020 2020 2320 2d2d 2d2d 2d2d 2d2d 2d2d      # ----------
-0000d670: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000d680: 2d2d 2d2d 2d2d 2d2d 2d0d 0a20 2020 2023  ---------..    #
-0000d690: 2046 696f 6e61 2064 6f65 736e 2774 2073   Fiona doesn't s
-0000d6a0: 7570 706f 7274 2074 6865 206f 7574 7075  upport the outpu
-0000d6b0: 7420 6765 6f6d 6574 7279 7479 7065 2070  t geometrytype p
-0000d6c0: 6172 616d 6574 6572 2061 7320 7573 6564  arameter as used
-0000d6d0: 2069 6e20 6764 616c 2c20 736f 2061 7320   in gdal, so as 
-0000d6e0: 610d 0a20 2020 2023 206c 6967 6874 7765  a..    # lightwe
-0000d6f0: 6967 6874 2069 6d70 6c65 6d65 6e74 6174  ight implementat
-0000d700: 696f 6e20 6a75 7374 2073 6574 2066 6f72  ion just set for
-0000d710: 6365 0d0a 2020 2020 6465 6620 7772 6974  ce..    def writ
-0000d720: 655f 746f 5f66 696c 6528 0d0a 2020 2020  e_to_file(..    
-0000d730: 2020 2020 6764 663a 2067 7064 2e47 656f      gdf: gpd.Geo
-0000d740: 4461 7461 4672 616d 652c 0d0a 2020 2020  DataFrame,..    
-0000d750: 2020 2020 7061 7468 3a20 5061 7468 2c0d      path: Path,.
-0000d760: 0a20 2020 2020 2020 206c 6179 6572 3a20  .        layer: 
-0000d770: 7374 722c 0d0a 2020 2020 2020 2020 696e  str,..        in
-0000d780: 6465 783a 2062 6f6f 6c20 3d20 5472 7565  dex: bool = True
-0000d790: 2c0d 0a20 2020 2020 2020 2066 6f72 6365  ,..        force
-0000d7a0: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
-0000d7b0: 7479 7065 3a20 4f70 7469 6f6e 616c 5b73  type: Optional[s
-0000d7c0: 7472 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  tr] = None,..   
-0000d7d0: 2020 2020 2066 6f72 6365 5f6d 756c 7469       force_multi
-0000d7e0: 7479 7065 3a20 626f 6f6c 203d 2046 616c  type: bool = Fal
-0000d7f0: 7365 2c0d 0a20 2020 2020 2020 2061 7070  se,..        app
-0000d800: 656e 643a 2062 6f6f 6c20 3d20 4661 6c73  end: bool = Fals
-0000d810: 652c 0d0a 2020 2020 2020 2020 7363 6865  e,..        sche
-0000d820: 6d61 3a20 4f70 7469 6f6e 616c 5b64 6963  ma: Optional[dic
-0000d830: 745d 203d 204e 6f6e 652c 0d0a 2020 2020  t] = None,..    
-0000d840: 2020 2020 6372 6561 7465 5f73 7061 7469      create_spati
-0000d850: 616c 5f69 6e64 6578 3a20 4f70 7469 6f6e  al_index: Option
-0000d860: 616c 5b62 6f6f 6c5d 203d 2054 7275 652c  al[bool] = True,
-0000d870: 0d0a 2020 2020 293a 0d0a 2020 2020 2020  ..    ):..      
-0000d880: 2020 2320 5072 6570 6172 6520 6172 6773    # Prepare args
-0000d890: 2066 6f72 2074 6f5f 6669 6c65 0d0a 2020   for to_file..  
-0000d8a0: 2020 2020 2020 6966 2061 7070 656e 6420        if append 
-0000d8b0: 6973 2054 7275 653a 0d0a 2020 2020 2020  is True:..      
-0000d8c0: 2020 2020 2020 6966 2070 6174 682e 6578        if path.ex
-0000d8d0: 6973 7473 2829 3a0d 0a20 2020 2020 2020  ists():..       
-0000d8e0: 2020 2020 2020 2020 206d 6f64 6520 3d20           mode = 
-0000d8f0: 2261 220d 0a20 2020 2020 2020 2020 2020  "a"..           
-0000d900: 2065 6c73 653a 0d0a 2020 2020 2020 2020   else:..        
-0000d910: 2020 2020 2020 2020 6d6f 6465 203d 2022          mode = "
-0000d920: 7722 0d0a 2020 2020 2020 2020 656c 7365  w"..        else
-0000d930: 3a0d 0a20 2020 2020 2020 2020 2020 206d  :..            m
-0000d940: 6f64 6520 3d20 2277 220d 0a0d 0a20 2020  ode = "w"....   
-0000d950: 2020 2020 206b 7761 7267 7320 3d20 7b7d       kwargs = {}
-0000d960: 0d0a 2020 2020 2020 2020 6b77 6172 6773  ..        kwargs
-0000d970: 5b22 6d6f 6465 225d 203d 206d 6f64 650d  ["mode"] = mode.
-0000d980: 0a20 2020 2020 2020 2067 656f 6669 6c65  .        geofile
-0000d990: 7479 7065 203d 2047 656f 6669 6c65 5479  type = GeofileTy
-0000d9a0: 7065 2870 6174 6829 0d0a 2020 2020 2020  pe(path)..      
-0000d9b0: 2020 6b77 6172 6773 5b22 6472 6976 6572    kwargs["driver
-0000d9c0: 225d 203d 2067 656f 6669 6c65 7479 7065  "] = geofiletype
-0000d9d0: 2e6f 6772 6472 6976 6572 0d0a 2020 2020  .ogrdriver..    
-0000d9e0: 2020 2020 6966 2063 7265 6174 655f 7370      if create_sp
-0000d9f0: 6174 6961 6c5f 696e 6465 7820 6973 206e  atial_index is n
-0000da00: 6f74 204e 6f6e 653a 0d0a 2020 2020 2020  ot None:..      
-0000da10: 2020 2020 2020 6b77 6172 6773 5b22 5350        kwargs["SP
-0000da20: 4154 4941 4c5f 494e 4445 5822 5d20 3d20  ATIAL_INDEX"] = 
-0000da30: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
-0000da40: 6e64 6578 0d0a 2020 2020 2020 2020 6966  ndex..        if
-0000da50: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
-0000da60: 6f6d 6574 7279 7479 7065 2069 7320 6e6f  ometrytype is no
-0000da70: 7420 4e6f 6e65 3a0d 0a20 2020 2020 2020  t None:..       
-0000da80: 2020 2020 206b 7761 7267 735b 2267 656f       kwargs["geo
-0000da90: 6d65 7472 7974 7970 6522 5d20 3d20 666f  metrytype"] = fo
-0000daa0: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-0000dab0: 7472 7974 7970 650d 0a20 2020 2020 2020  trytype..       
-0000dac0: 2069 6620 7363 6865 6d61 2069 7320 6e6f   if schema is no
-0000dad0: 7420 4e6f 6e65 3a0d 0a20 2020 2020 2020  t None:..       
-0000dae0: 2020 2020 206b 7761 7267 735b 2273 6368       kwargs["sch
-0000daf0: 656d 6122 5d20 3d20 7363 6865 6d61 0d0a  ema"] = schema..
-0000db00: 0d0a 2020 2020 2020 2020 2320 4e6f 7720  ..        # Now 
-0000db10: 7765 2063 616e 2077 7269 7465 0d0a 2020  we can write..  
-0000db20: 2020 2020 2020 6966 2067 656f 6669 6c65        if geofile
-0000db30: 7479 7065 203d 3d20 4765 6f66 696c 6554  type == GeofileT
-0000db40: 7970 652e 4553 5249 5368 6170 6566 696c  ype.ESRIShapefil
-0000db50: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-0000db60: 6966 2069 6e64 6578 2069 7320 5472 7565  if index is True
-0000db70: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0000db80: 2020 2067 6466 5f74 6f5f 7772 6974 6520     gdf_to_write 
-0000db90: 3d20 6764 662e 7265 7365 745f 696e 6465  = gdf.reset_inde
-0000dba0: 7828 6472 6f70 3d54 7275 6529 0d0a 2020  x(drop=True)..  
-0000dbb0: 2020 2020 2020 2020 2020 656c 7365 3a0d            else:.
-0000dbc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000dbd0: 2067 6466 5f74 6f5f 7772 6974 6520 3d20   gdf_to_write = 
-0000dbe0: 6764 660d 0a20 2020 2020 2020 2020 2020  gdf..           
-0000dbf0: 2067 6466 5f74 6f5f 7772 6974 652e 746f   gdf_to_write.to
-0000dc00: 5f66 696c 6528 7374 7228 7061 7468 292c  _file(str(path),
-0000dc10: 202a 2a6b 7761 7267 7329 0d0a 2020 2020   **kwargs)..    
-0000dc20: 2020 2020 656c 6966 2067 656f 6669 6c65      elif geofile
-0000dc30: 7479 7065 203d 3d20 4765 6f66 696c 6554  type == GeofileT
-0000dc40: 7970 652e 4750 4b47 3a0d 0a20 2020 2020  ype.GPKG:..     
-0000dc50: 2020 2020 2020 2023 2054 7279 2074 6f20         # Try to 
-0000dc60: 6861 726d 6f6e 697a 6520 7468 6520 6765  harmonize the ge
-0000dc70: 6f6d 6574 7279 7479 7065 2074 6f20 6f6e  ometrytype to on
-0000dc80: 6520 286d 756c 7469 2974 7970 652c 2061  e (multi)type, a
-0000dc90: 7320 4750 4b47 0d0a 2020 2020 2020 2020  s GPKG..        
-0000dca0: 2020 2020 2320 646f 6573 6e27 7420 6c69      # doesn't li
-0000dcb0: 6b65 203e 2031 2074 7970 6520 696e 2061  ke > 1 type in a
-0000dcc0: 206c 6179 6572 0d0a 2020 2020 2020 2020   layer..        
-0000dcd0: 2020 2020 6966 2073 6368 656d 6120 6973      if schema is
-0000dce0: 204e 6f6e 6520 6f72 2028 6c65 6e28 6764   None or (len(gd
-0000dcf0: 6629 203e 2030 2061 6e64 2073 6368 656d  f) > 0 and schem
-0000dd00: 615b 2267 656f 6d65 7472 7922 5d20 213d  a["geometry"] !=
-0000dd10: 2022 4e6f 6e65 2229 3a0d 0a20 2020 2020   "None"):..     
-0000dd20: 2020 2020 2020 2020 2020 2067 6466 5f74             gdf_t
-0000dd30: 6f5f 7772 6974 6520 3d20 6764 662e 636f  o_write = gdf.co
-0000dd40: 7079 2829 0d0a 2020 2020 2020 2020 2020  py()..          
-0000dd50: 2020 2020 2020 6764 665f 746f 5f77 7269        gdf_to_wri
-0000dd60: 7465 2e67 656f 6d65 7472 7920 3d20 6765  te.geometry = ge
-0000dd70: 6f73 6572 6965 735f 7574 696c 2e68 6172  oseries_util.har
-0000dd80: 6d6f 6e69 7a65 5f67 656f 6d65 7472 7974  monize_geometryt
-0000dd90: 7970 6573 280d 0a20 2020 2020 2020 2020  ypes(..         
-0000dda0: 2020 2020 2020 2020 2020 2067 6466 2e67             gdf.g
-0000ddb0: 656f 6d65 7472 792c 2066 6f72 6365 5f6d  eometry, force_m
-0000ddc0: 756c 7469 7479 7065 3d66 6f72 6365 5f6d  ultitype=force_m
-0000ddd0: 756c 7469 7479 7065 0d0a 2020 2020 2020  ultitype..      
-0000dde0: 2020 2020 2020 2020 2020 290d 0a20 2020            )..   
-0000ddf0: 2020 2020 2020 2020 2065 6c73 653a 0d0a           else:..
-0000de00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de10: 6764 665f 746f 5f77 7269 7465 203d 2067  gdf_to_write = g
-0000de20: 6466 0d0a 2020 2020 2020 2020 2020 2020  df..            
-0000de30: 6764 665f 746f 5f77 7269 7465 2e74 6f5f  gdf_to_write.to_
-0000de40: 6669 6c65 2873 7472 2870 6174 6829 2c20  file(str(path), 
-0000de50: 6c61 7965 723d 6c61 7965 722c 202a 2a6b  layer=layer, **k
-0000de60: 7761 7267 7329 0d0a 2020 2020 2020 2020  wargs)..        
-0000de70: 656c 6966 2067 656f 6669 6c65 7479 7065  elif geofiletype
-0000de80: 203d 3d20 4765 6f66 696c 6554 7970 652e   == GeofileType.
-0000de90: 5351 4c69 7465 3a0d 0a20 2020 2020 2020  SQLite:..       
-0000dea0: 2020 2020 2067 6466 2e74 6f5f 6669 6c65       gdf.to_file
-0000deb0: 2873 7472 2870 6174 6829 2c20 6c61 7965  (str(path), laye
-0000dec0: 723d 6c61 7965 722c 202a 2a6b 7761 7267  r=layer, **kwarg
-0000ded0: 7329 0d0a 2020 2020 2020 2020 656c 6966  s)..        elif
-0000dee0: 2067 656f 6669 6c65 7479 7065 203d 3d20   geofiletype == 
-0000def0: 4765 6f66 696c 6554 7970 652e 4765 6f4a  GeofileType.GeoJ
-0000df00: 534f 4e3a 0d0a 2020 2020 2020 2020 2020  SON:..          
-0000df10: 2020 6764 662e 746f 5f66 696c 6528 7374    gdf.to_file(st
-0000df20: 7228 7061 7468 292c 202a 2a6b 7761 7267  r(path), **kwarg
-0000df30: 7329 0d0a 2020 2020 2020 2020 656c 7365  s)..        else
-0000df40: 3a0d 0a20 2020 2020 2020 2020 2020 2072  :..            r
-0000df50: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-0000df60: 6622 4e6f 7420 696d 706c 656d 656e 7465  f"Not implemente
-0000df70: 6420 666f 7220 6765 6f66 696c 6574 7970  d for geofiletyp
-0000df80: 6520 7b67 656f 6669 6c65 7479 7065 7d22  e {geofiletype}"
-0000df90: 290d 0a0d 0a20 2020 2023 2049 6620 6e6f  )....    # If no
-0000dfa0: 2061 7070 656e 642c 206a 7573 7420 7772   append, just wr
-0000dfb0: 6974 6520 746f 206f 7574 7075 7420 7061  ite to output pa
-0000dfc0: 7468 0d0a 2020 2020 6966 206e 6f74 2061  th..    if not a
-0000dfd0: 7070 656e 643a 0d0a 2020 2020 2020 2020  ppend:..        
-0000dfe0: 7772 6974 655f 746f 5f66 696c 6528 0d0a  write_to_file(..
-0000dff0: 2020 2020 2020 2020 2020 2020 6764 663d              gdf=
-0000e000: 6764 662c 0d0a 2020 2020 2020 2020 2020  gdf,..          
-0000e010: 2020 7061 7468 3d70 6174 682c 0d0a 2020    path=path,..  
-0000e020: 2020 2020 2020 2020 2020 6c61 7965 723d            layer=
-0000e030: 6c61 7965 722c 0d0a 2020 2020 2020 2020  layer,..        
-0000e040: 2020 2020 696e 6465 783d 696e 6465 782c      index=index,
-0000e050: 0d0a 2020 2020 2020 2020 2020 2020 666f  ..            fo
-0000e060: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-0000e070: 7472 7974 7970 653d 666f 7263 655f 6f75  trytype=force_ou
-0000e080: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
-0000e090: 652c 0d0a 2020 2020 2020 2020 2020 2020  e,..            
-0000e0a0: 666f 7263 655f 6d75 6c74 6974 7970 653d  force_multitype=
-0000e0b0: 666f 7263 655f 6d75 6c74 6974 7970 652c  force_multitype,
-0000e0c0: 0d0a 2020 2020 2020 2020 2020 2020 6170  ..            ap
-0000e0d0: 7065 6e64 3d61 7070 656e 642c 0d0a 2020  pend=append,..  
-0000e0e0: 2020 2020 2020 2020 2020 7363 6865 6d61            schema
-0000e0f0: 3d73 6368 656d 612c 0d0a 2020 2020 2020  =schema,..      
-0000e100: 2020 2020 2020 6372 6561 7465 5f73 7061        create_spa
-0000e110: 7469 616c 5f69 6e64 6578 3d63 7265 6174  tial_index=creat
-0000e120: 655f 7370 6174 6961 6c5f 696e 6465 782c  e_spatial_index,
-0000e130: 0d0a 2020 2020 2020 2020 290d 0a20 2020  ..        )..   
-0000e140: 2065 6c73 653a 0d0a 2020 2020 2020 2020   else:..        
-0000e150: 2320 4170 7065 6e64 2069 7320 6173 6b65  # Append is aske
-0000e160: 642c 2063 6865 636b 2069 6620 7468 6520  d, check if the 
-0000e170: 6669 6f6e 6120 6472 6976 6572 2073 7570  fiona driver sup
-0000e180: 706f 7274 7320 6170 7065 6e64 696e 672e  ports appending.
-0000e190: 2049 660d 0a20 2020 2020 2020 2023 206e   If..        # n
-0000e1a0: 6f74 2c20 7772 6974 6520 746f 2074 656d  ot, write to tem
-0000e1b0: 706f 7261 7279 206f 7574 7075 7420 6669  porary output fi
-0000e1c0: 6c65 0d0a 0d0a 2020 2020 2020 2020 2320  le....        # 
-0000e1d0: 5265 6d61 726b 3a20 6669 6f6e 6120 7072  Remark: fiona pr
-0000e1e0: 652d 312e 382e 3134 2064 6964 6e27 7420  e-1.8.14 didn't 
-0000e1f0: 7375 7070 6f72 7420 6170 7065 6e64 696e  support appendin
-0000e200: 6720 746f 2067 656f 7061 636b 6167 652e  g to geopackage.
-0000e210: 204f 6e63 650d 0a20 2020 2020 2020 2023   Once..        #
-0000e220: 206f 6c64 6572 2076 6572 7369 6f6e 7320   older versions 
-0000e230: 6265 636f 6d65 7320 7261 7265 2c20 6465  becomes rare, de
-0000e240: 7065 6e64 656e 6379 2063 616e 2062 6520  pendency can be 
-0000e250: 7075 7420 746f 2074 6869 7320 7665 7273  put to this vers
-0000e260: 696f 6e2c 2061 6e64 0d0a 2020 2020 2020  ion, and..      
-0000e270: 2020 2320 7468 6973 2063 6f64 6520 6361    # this code ca
-0000e280: 6e20 6265 2063 6c65 616e 6564 2075 702e  n be cleaned up.
-0000e290: 2e2e 0d0a 2020 2020 2020 2020 6765 6f66  ....        geof
-0000e2a0: 696c 6574 7970 6520 3d20 4765 6f66 696c  iletype = Geofil
-0000e2b0: 6554 7970 6528 7061 7468 290d 0a20 2020  eType(path)..   
-0000e2c0: 2020 2020 2067 6466 7465 6d70 5f70 6174       gdftemp_pat
-0000e2d0: 6820 3d20 4e6f 6e65 0d0a 2020 2020 2020  h = None..      
-0000e2e0: 2020 6764 6674 656d 705f 6c6f 636b 7061    gdftemp_lockpa
-0000e2f0: 7468 203d 204e 6f6e 650d 0a20 2020 2020  th = None..     
-0000e300: 2020 2069 6620 2261 2220 6e6f 7420 696e     if "a" not in
-0000e310: 2066 696f 6e61 2e73 7570 706f 7274 6564   fiona.supported
-0000e320: 5f64 7269 7665 7273 5b67 656f 6669 6c65  _drivers[geofile
-0000e330: 7479 7065 2e6f 6772 6472 6976 6572 5d3a  type.ogrdriver]:
-0000e340: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0000e350: 4765 7420 6120 756e 6971 7565 2074 656d  Get a unique tem
-0000e360: 7020 6669 6c65 2070 6174 682e 2054 6865  p file path. The
-0000e370: 2066 696c 6520 6361 6e6e 6f74 2062 6520   file cannot be 
-0000e380: 6372 6561 7465 6420 7965 742c 2073 6f0d  created yet, so.
-0000e390: 0a20 2020 2020 2020 2020 2020 2023 206f  .            # o
-0000e3a0: 6e6c 7920 6372 6561 7465 2061 206c 6f63  nly create a loc
-0000e3b0: 6b20 6669 6c65 2074 6f20 6576 6164 6520  k file to evade 
-0000e3c0: 6f74 6865 7220 7072 6f63 6573 7365 7320  other processes 
-0000e3d0: 7573 696e 6720 7468 6520 7361 6d65 0d0a  using the same..
-0000e3e0: 2020 2020 2020 2020 2020 2020 2320 7465              # te
-0000e3f0: 6d70 2066 696c 6520 6e61 6d65 0d0a 2020  mp file name..  
-0000e400: 2020 2020 2020 2020 2020 6764 6674 656d            gdftem
-0000e410: 705f 7061 7468 2c20 6764 6674 656d 705f  p_path, gdftemp_
-0000e420: 6c6f 636b 7061 7468 203d 205f 696f 5f75  lockpath = _io_u
-0000e430: 7469 6c2e 6765 745f 7465 6d70 6669 6c65  til.get_tempfile
-0000e440: 5f6c 6f63 6b65 6428 0d0a 2020 2020 2020  _locked(..      
-0000e450: 2020 2020 2020 2020 2020 6261 7365 5f66            base_f
-0000e460: 696c 656e 616d 653d 2267 6466 7465 6d70  ilename="gdftemp
-0000e470: 222c 2073 7566 6669 783d 7061 7468 2e73  ", suffix=path.s
-0000e480: 7566 6669 782c 2064 6972 6e61 6d65 3d22  uffix, dirname="
-0000e490: 6765 6f66 696c 655f 746f 5f66 696c 6522  geofile_to_file"
-0000e4a0: 0d0a 2020 2020 2020 2020 2020 2020 290d  ..            ).
-0000e4b0: 0a20 2020 2020 2020 2020 2020 2077 7269  .            wri
-0000e4c0: 7465 5f74 6f5f 6669 6c65 280d 0a20 2020  te_to_file(..   
-0000e4d0: 2020 2020 2020 2020 2020 2020 2067 6466               gdf
-0000e4e0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000e4f0: 2020 2070 6174 683d 6764 6674 656d 705f     path=gdftemp_
-0000e500: 7061 7468 2c0d 0a20 2020 2020 2020 2020  path,..         
-0000e510: 2020 2020 2020 206c 6179 6572 3d6c 6179         layer=lay
-0000e520: 6572 2c0d 0a20 2020 2020 2020 2020 2020  er,..           
-0000e530: 2020 2020 2069 6e64 6578 3d69 6e64 6578       index=index
-0000e540: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000e550: 2020 2066 6f72 6365 5f6f 7574 7075 745f     force_output_
-0000e560: 6765 6f6d 6574 7279 7479 7065 3d66 6f72  geometrytype=for
-0000e570: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-0000e580: 7279 7479 7065 2c0d 0a20 2020 2020 2020  rytype,..       
-0000e590: 2020 2020 2020 2020 2066 6f72 6365 5f6d           force_m
-0000e5a0: 756c 7469 7479 7065 3d66 6f72 6365 5f6d  ultitype=force_m
-0000e5b0: 756c 7469 7479 7065 2c0d 0a20 2020 2020  ultitype,..     
-0000e5c0: 2020 2020 2020 2020 2020 2073 6368 656d             schem
-0000e5d0: 613d 7363 6865 6d61 2c0d 0a20 2020 2020  a=schema,..     
-0000e5e0: 2020 2020 2020 2020 2020 2063 7265 6174             creat
-0000e5f0: 655f 7370 6174 6961 6c5f 696e 6465 783d  e_spatial_index=
-0000e600: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
-0000e610: 6e64 6578 2c0d 0a20 2020 2020 2020 2020  ndex,..         
-0000e620: 2020 2029 0d0a 0d0a 2020 2020 2020 2020     )....        
-0000e630: 2320 4669 6c65 7320 646f 6e27 7420 7479  # Files don't ty
-0000e640: 7069 6361 6c6c 7920 7375 7070 6f72 7420  pically support 
-0000e650: 6861 7669 6e67 206d 756c 7469 706c 6520  having multiple 
-0000e660: 7072 6f63 6573 7365 7320 7772 6974 696e  processes writin
-0000e670: 670d 0a20 2020 2020 2020 2023 2073 696d  g..        # sim
-0000e680: 756c 7461 6e6f 7573 6c79 2074 6f20 7468  ultanously to th
-0000e690: 656d 2c20 736f 2075 7365 206c 6f63 6b20  em, so use lock 
-0000e6a0: 6669 6c65 2074 6f20 7379 6e63 6872 6f6e  file to synchron
-0000e6b0: 697a 6520 6163 6365 7373 2e0d 0a20 2020  ize access...   
-0000e6c0: 2020 2020 206c 6f63 6b66 696c 6520 3d20       lockfile = 
-0000e6d0: 5061 7468 2866 227b 7374 7228 7061 7468  Path(f"{str(path
-0000e6e0: 297d 2e6c 6f63 6b22 290d 0a20 2020 2020  )}.lock")..     
-0000e6f0: 2020 2073 7461 7274 5f74 696d 6520 3d20     start_time = 
-0000e700: 6461 7465 7469 6d65 2e64 6174 6574 696d  datetime.datetim
-0000e710: 652e 6e6f 7728 290d 0a20 2020 2020 2020  e.now()..       
-0000e720: 2072 6561 6479 203d 2046 616c 7365 0d0a   ready = False..
-0000e730: 2020 2020 2020 2020 7768 696c 6520 6e6f          while no
-0000e740: 7420 7265 6164 793a 0d0a 2020 2020 2020  t ready:..      
-0000e750: 2020 2020 2020 6966 205f 696f 5f75 7469        if _io_uti
-0000e760: 6c2e 6372 6561 7465 5f66 696c 655f 6174  l.create_file_at
-0000e770: 6f6d 6963 286c 6f63 6b66 696c 6529 2069  omic(lockfile) i
-0000e780: 7320 5472 7565 3a0d 0a20 2020 2020 2020  s True:..       
-0000e790: 2020 2020 2020 2020 2074 7279 3a0d 0a20           try:.. 
-0000e7a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e7b0: 2020 2023 2049 6620 6764 6620 7761 736e     # If gdf wasn
-0000e7c0: 2774 2077 7269 7474 656e 2074 6f20 7465  't written to te
-0000e7d0: 6d70 2066 696c 652c 2075 7365 2073 7461  mp file, use sta
-0000e7e0: 6e64 6172 6420 7772 6974 652d 746f 2d66  ndard write-to-f
-0000e7f0: 696c 650d 0a20 2020 2020 2020 2020 2020  ile..           
-0000e800: 2020 2020 2020 2020 2069 6620 6764 6674           if gdft
-0000e810: 656d 705f 7061 7468 2069 7320 4e6f 6e65  emp_path is None
-0000e820: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0000e830: 2020 2020 2020 2020 2020 2077 7269 7465             write
-0000e840: 5f74 6f5f 6669 6c65 280d 0a20 2020 2020  _to_file(..     
-0000e850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e860: 2020 2020 2020 2067 6466 3d67 6466 2c0d         gdf=gdf,.
-0000e870: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e880: 2020 2020 2020 2020 2020 2020 2070 6174               pat
-0000e890: 683d 7061 7468 2c0d 0a20 2020 2020 2020  h=path,..       
-0000e8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e8b0: 2020 2020 206c 6179 6572 3d6c 6179 6572       layer=layer
-0000e8c0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000e8d0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000e8e0: 6e64 6578 3d69 6e64 6578 2c0d 0a20 2020  ndex=index,..   
-0000e8f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e900: 2020 2020 2020 2020 2066 6f72 6365 5f6f           force_o
-0000e910: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-0000e920: 7065 3d66 6f72 6365 5f6f 7574 7075 745f  pe=force_output_
-0000e930: 6765 6f6d 6574 7279 7479 7065 2c0d 0a20  geometrytype,.. 
-0000e940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e950: 2020 2020 2020 2020 2020 2066 6f72 6365             force
-0000e960: 5f6d 756c 7469 7479 7065 3d66 6f72 6365  _multitype=force
-0000e970: 5f6d 756c 7469 7479 7065 2c0d 0a20 2020  _multitype,..   
-0000e980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e990: 2020 2020 2020 2020 2061 7070 656e 643d           append=
-0000e9a0: 5472 7565 2c0d 0a20 2020 2020 2020 2020  True,..         
-0000e9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e9c0: 2020 2073 6368 656d 613d 7363 6865 6d61     schema=schema
-0000e9d0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000e9e0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-0000e9f0: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
-0000ea00: 6465 783d 6372 6561 7465 5f73 7061 7469  dex=create_spati
-0000ea10: 616c 5f69 6e64 6578 2c0d 0a20 2020 2020  al_index,..     
-0000ea20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ea30: 2020 2029 0d0a 2020 2020 2020 2020 2020     )..          
-0000ea40: 2020 2020 2020 2020 2020 656c 7365 3a0d            else:.
-0000ea50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ea60: 2020 2020 2020 2020 2023 2049 6620 6764           # If gd
-0000ea70: 6620 7772 6974 7465 6e20 746f 2074 656d  f written to tem
-0000ea80: 7020 6669 6c65 2c20 7573 6520 6170 7065  p file, use appe
-0000ea90: 6e64 5f74 6f5f 6e6f 6c6f 636b 202b 2063  nd_to_nolock + c
-0000eaa0: 6c65 616e 7570 0d0a 2020 2020 2020 2020  leanup..        
-0000eab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eac0: 5f61 7070 656e 645f 746f 5f6e 6f6c 6f63  _append_to_noloc
-0000ead0: 6b28 0d0a 2020 2020 2020 2020 2020 2020  k(..            
-0000eae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eaf0: 7372 633d 6764 6674 656d 705f 7061 7468  src=gdftemp_path
-0000eb00: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000eb10: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-0000eb20: 7374 3d70 6174 682c 0d0a 2020 2020 2020  st=path,..      
-0000eb30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eb40: 2020 2020 2020 6473 745f 6c61 7965 723d        dst_layer=
-0000eb50: 6c61 7965 722c 0d0a 2020 2020 2020 2020  layer,..        
-0000eb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eb70: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
-0000eb80: 5f67 656f 6d65 7472 7974 7970 653d 666f  _geometrytype=fo
-0000eb90: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-0000eba0: 7472 7974 7970 652c 0d0a 2020 2020 2020  trytype,..      
-0000ebb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ebc0: 2020 2020 2020 6372 6561 7465 5f73 7061        create_spa
-0000ebd0: 7469 616c 5f69 6e64 6578 3d63 7265 6174  tial_index=creat
-0000ebe0: 655f 7370 6174 6961 6c5f 696e 6465 782c  e_spatial_index,
-0000ebf0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000ec00: 2020 2020 2020 2020 2020 290d 0a20 2020            )..   
-0000ec10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ec20: 2020 2020 2072 656d 6f76 6528 6764 6674       remove(gdft
-0000ec30: 656d 705f 7061 7468 290d 0a20 2020 2020  emp_path)..     
-0000ec40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ec50: 2020 2069 6620 6764 6674 656d 705f 6c6f     if gdftemp_lo
-0000ec60: 636b 7061 7468 2069 7320 6e6f 7420 4e6f  ckpath is not No
-0000ec70: 6e65 3a0d 0a20 2020 2020 2020 2020 2020  ne:..           
-0000ec80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ec90: 2067 6466 7465 6d70 5f6c 6f63 6b70 6174   gdftemp_lockpat
-0000eca0: 682e 756e 6c69 6e6b 2829 0d0a 2020 2020  h.unlink()..    
-0000ecb0: 2020 2020 2020 2020 2020 2020 6578 6365              exce
-0000ecc0: 7074 2045 7863 6570 7469 6f6e 2061 7320  pt Exception as 
-0000ecd0: 6578 3a0d 0a20 2020 2020 2020 2020 2020  ex:..           
-0000ece0: 2020 2020 2020 2020 2023 2049 6620 7371           # If sq
-0000ecf0: 6c69 7465 206f 7574 7075 7420 6669 6c65  lite output file
-0000ed00: 206c 6f63 6b65 642c 2061 6c73 6f20 7265   locked, also re
-0000ed10: 7472 790d 0a20 2020 2020 2020 2020 2020  try..           
-0000ed20: 2020 2020 2020 2020 2069 6620 6765 6f66           if geof
-0000ed30: 696c 6574 7970 652e 6973 5f73 7061 7469  iletype.is_spati
-0000ed40: 616c 6974 655f 6261 7365 6420 616e 6420  alite_based and 
-0000ed50: 7374 7228 6578 2920 6e6f 7420 696e 205b  str(ex) not in [
-0000ed60: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000ed70: 2020 2020 2020 2020 2020 2264 6174 6162            "datab
-0000ed80: 6173 6520 6973 206c 6f63 6b65 6422 2c0d  ase is locked",.
-0000ed90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000eda0: 2020 2020 2020 2020 2022 6174 7465 6d70           "attemp
-0000edb0: 7420 746f 2077 7269 7465 2061 2072 6561  t to write a rea
-0000edc0: 646f 6e6c 7920 6461 7461 6261 7365 222c  donly database",
-0000edd0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000ede0: 2020 2020 2020 5d3a 0d0a 2020 2020 2020        ]:..      
-0000edf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ee00: 2020 7261 6973 6520 6578 0d0a 2020 2020    raise ex..    
-0000ee10: 2020 2020 2020 2020 2020 2020 6669 6e61              fina
-0000ee20: 6c6c 793a 0d0a 2020 2020 2020 2020 2020  lly:..          
-0000ee30: 2020 2020 2020 2020 2020 7265 6164 7920            ready 
-0000ee40: 3d20 5472 7565 0d0a 2020 2020 2020 2020  = True..        
-0000ee50: 2020 2020 2020 2020 2020 2020 6c6f 636b              lock
-0000ee60: 6669 6c65 2e75 6e6c 696e 6b28 290d 0a20  file.unlink().. 
-0000ee70: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0000ee80: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000ee90: 2020 7469 6d65 5f77 6169 7469 6e67 203d    time_waiting =
-0000eea0: 2028 6461 7465 7469 6d65 2e64 6174 6574   (datetime.datet
-0000eeb0: 696d 652e 6e6f 7728 2920 2d20 7374 6172  ime.now() - star
-0000eec0: 745f 7469 6d65 292e 746f 7461 6c5f 7365  t_time).total_se
-0000eed0: 636f 6e64 7328 290d 0a20 2020 2020 2020  conds()..       
-0000eee0: 2020 2020 2020 2020 2069 6620 7469 6d65           if time
-0000eef0: 5f77 6169 7469 6e67 203e 2061 7070 656e  _waiting > appen
-0000ef00: 645f 7469 6d65 6f75 745f 733a 0d0a 2020  d_timeout_s:..  
-0000ef10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ef20: 2020 7261 6973 6520 5275 6e74 696d 6545    raise RuntimeE
-0000ef30: 7272 6f72 280d 0a20 2020 2020 2020 2020  rror(..         
-0000ef40: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0000ef50: 2274 6f5f 6669 6c65 2074 696d 656f 7574  "to_file timeout
-0000ef60: 206f 6620 7b61 7070 656e 645f 7469 6d65   of {append_time
-0000ef70: 6f75 745f 737d 2072 6561 6368 6564 2c20  out_s} reached, 
-0000ef80: 7374 6f70 2061 7070 656e 6420 220d 0a20  stop append ".. 
-0000ef90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000efa0: 2020 2020 2020 2066 2274 6f20 7b70 6174         f"to {pat
-0000efb0: 687d 2122 0d0a 2020 2020 2020 2020 2020  h}!"..          
-0000efc0: 2020 2020 2020 2020 2020 290d 0a0d 0a20            ).... 
-0000efd0: 2020 2020 2020 2020 2020 2023 2053 6c65             # Sle
-0000efe0: 6570 2066 6f72 2061 2073 6563 6f6e 6420  ep for a second 
-0000eff0: 6265 666f 7265 2074 7279 696e 6720 6167  before trying ag
-0000f000: 6169 6e0d 0a20 2020 2020 2020 2020 2020  ain..           
-0000f010: 2074 696d 652e 736c 6565 7028 3129 0d0a   time.sleep(1)..
-0000f020: 0d0a 0d0a 6465 6620 5f74 6f5f 6669 6c65  ....def _to_file
-0000f030: 5f70 796f 6772 696f 280d 0a20 2020 2067  _pyogrio(..    g
-0000f040: 6466 3a20 556e 696f 6e5b 7064 2e44 6174  df: Union[pd.Dat
-0000f050: 6146 7261 6d65 2c20 6770 642e 4765 6f44  aFrame, gpd.GeoD
-0000f060: 6174 6146 7261 6d65 5d2c 0d0a 2020 2020  ataFrame],..    
-0000f070: 7061 7468 3a20 5061 7468 2c0d 0a20 2020  path: Path,..   
-0000f080: 206c 6179 6572 3a20 7374 722c 0d0a 2020   layer: str,..  
-0000f090: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
-0000f0a0: 656f 6d65 7472 7974 7970 653a 2055 6e69  eometrytype: Uni
-0000f0b0: 6f6e 5b47 656f 6d65 7472 7954 7970 652c  on[GeometryType,
-0000f0c0: 2073 7472 2c20 4e6f 6e65 5d20 3d20 4e6f   str, None] = No
-0000f0d0: 6e65 2c0d 0a20 2020 2066 6f72 6365 5f6d  ne,..    force_m
-0000f0e0: 756c 7469 7479 7065 3a20 626f 6f6c 203d  ultitype: bool =
-0000f0f0: 2046 616c 7365 2c0d 0a20 2020 2061 7070   False,..    app
-0000f100: 656e 643a 2062 6f6f 6c20 3d20 4661 6c73  end: bool = Fals
-0000f110: 652c 0d0a 2020 2020 6170 7065 6e64 5f74  e,..    append_t
-0000f120: 696d 656f 7574 5f73 3a20 696e 7420 3d20  imeout_s: int = 
-0000f130: 3630 302c 0d0a 2020 2020 696e 6465 783a  600,..    index:
-0000f140: 2062 6f6f 6c20 3d20 5472 7565 2c0d 0a20   bool = True,.. 
-0000f150: 2020 2063 7265 6174 655f 7370 6174 6961     create_spatia
-0000f160: 6c5f 696e 6465 783a 204f 7074 696f 6e61  l_index: Optiona
-0000f170: 6c5b 626f 6f6c 5d20 3d20 5472 7565 2c0d  l[bool] = True,.
-0000f180: 0a29 3a0d 0a20 2020 2022 2222 0d0a 2020  .):..    """..  
-0000f190: 2020 5772 6974 6573 2061 2070 616e 6461    Writes a panda
-0000f1a0: 7320 6461 7461 6672 616d 6520 746f 2066  s dataframe to f
-0000f1b0: 696c 6520 7573 696e 6720 7079 6f67 7269  ile using pyogri
-0000f1c0: 6f2e 0d0a 2020 2020 2222 220d 0a20 2020  o...    """..   
-0000f1d0: 2023 2050 7265 7061 7265 2061 7267 7320   # Prepare args 
-0000f1e0: 666f 7220 7772 6974 655f 6461 7461 6672  for write_datafr
-0000f1f0: 616d 650d 0a20 2020 206b 7761 7267 7320  ame..    kwargs 
-0000f200: 3d20 7b7d 0d0a 0d0a 2020 2020 6966 2061  = {}....    if a
-0000f210: 7070 656e 6420 6973 2054 7275 6520 616e  ppend is True an
-0000f220: 6420 7061 7468 2e65 7869 7374 7328 293a  d path.exists():
-0000f230: 0d0a 2020 2020 2020 2020 6b77 6172 6773  ..        kwargs
-0000f240: 5b22 6170 7065 6e64 225d 203d 2054 7275  ["append"] = Tru
-0000f250: 650d 0a20 2020 2020 2020 206c 6179 6572  e..        layer
-0000f260: 696e 666f 203d 2067 6574 5f6c 6179 6572  info = get_layer
-0000f270: 696e 666f 2870 6174 682c 206c 6179 6572  info(path, layer
-0000f280: 290d 0a20 2020 2020 2020 2066 696c 655f  )..        file_
-0000f290: 636f 6c73 203d 205b 636f 6c2e 7570 7065  cols = [col.uppe
-0000f2a0: 7228 2920 666f 7220 636f 6c20 696e 206c  r() for col in l
-0000f2b0: 6179 6572 696e 666f 2e63 6f6c 756d 6e73  ayerinfo.columns
-0000f2c0: 5d0d 0a20 2020 2020 2020 2067 6466 5f63  ]..        gdf_c
-0000f2d0: 6f6c 7320 3d20 5b63 6f6c 2e75 7070 6572  ols = [col.upper
-0000f2e0: 2829 2066 6f72 2063 6f6c 2069 6e20 6764  () for col in gd
-0000f2f0: 662e 636f 6c75 6d6e 7320 6966 2063 6f6c  f.columns if col
-0000f300: 2021 3d20 6764 662e 6765 6f6d 6574 7279   != gdf.geometry
-0000f310: 2e6e 616d 655d 0d0a 2020 2020 2020 2020  .name]..        
-0000f320: 6966 2067 6466 5f63 6f6c 7320 213d 2066  if gdf_cols != f
-0000f330: 696c 655f 636f 6c73 3a0d 0a20 2020 2020  ile_cols:..     
-0000f340: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
-0000f350: 7565 4572 726f 7228 0d0a 2020 2020 2020  ueError(..      
-0000f360: 2020 2020 2020 2020 2020 2264 6573 7469            "desti
-0000f370: 6e61 7469 6f6e 206c 6179 6572 2064 6f65  nation layer doe
-0000f380: 736e 2774 2068 6176 6520 7468 6520 7361  sn't have the sa
-0000f390: 6d65 2063 6f6c 756d 6e73 2061 7320 6764  me columns as gd
-0000f3a0: 663a 2022 0d0a 2020 2020 2020 2020 2020  f: "..          
-0000f3b0: 2020 2020 2020 6622 7b66 696c 655f 636f        f"{file_co
-0000f3c0: 6c73 7d20 7673 207b 6764 665f 636f 6c73  ls} vs {gdf_cols
-0000f3d0: 7d22 0d0a 2020 2020 2020 2020 2020 2020  }"..            
-0000f3e0: 290d 0a0d 0a20 2020 2069 6620 6372 6561  )....    if crea
-0000f3f0: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
-0000f400: 2069 7320 6e6f 7420 4e6f 6e65 3a0d 0a20   is not None:.. 
-0000f410: 2020 2020 2020 206b 7761 7267 735b 2253         kwargs["S
-0000f420: 5041 5449 414c 5f49 4e44 4558 225d 203d  PATIAL_INDEX"] =
-0000f430: 2063 7265 6174 655f 7370 6174 6961 6c5f   create_spatial_
-0000f440: 696e 6465 780d 0a20 2020 2067 656f 6669  index..    geofi
-0000f450: 6c65 7479 7065 203d 2047 656f 6669 6c65  letype = Geofile
-0000f460: 5479 7065 2870 6174 6829 0d0a 2020 2020  Type(path)..    
-0000f470: 6b77 6172 6773 5b22 6472 6976 6572 225d  kwargs["driver"]
-0000f480: 203d 2067 656f 6669 6c65 7479 7065 2e6f   = geofiletype.o
-0000f490: 6772 6472 6976 6572 0d0a 2020 2020 6966  grdriver..    if
-0000f4a0: 2063 7265 6174 655f 7370 6174 6961 6c5f   create_spatial_
-0000f4b0: 696e 6465 7820 6973 206e 6f74 204e 6f6e  index is not Non
-0000f4c0: 653a 0d0a 2020 2020 2020 2020 6b77 6172  e:..        kwar
-0000f4d0: 6773 5b22 5350 4154 4941 4c5f 494e 4445  gs["SPATIAL_INDE
-0000f4e0: 5822 5d20 3d20 6372 6561 7465 5f73 7061  X"] = create_spa
-0000f4f0: 7469 616c 5f69 6e64 6578 0d0a 2020 2020  tial_index..    
-0000f500: 6966 2066 6f72 6365 5f6f 7574 7075 745f  if force_output_
-0000f510: 6765 6f6d 6574 7279 7479 7065 2069 7320  geometrytype is 
-0000f520: 6e6f 7420 4e6f 6e65 3a0d 0a20 2020 2020  not None:..     
-0000f530: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
-0000f540: 2866 6f72 6365 5f6f 7574 7075 745f 6765  (force_output_ge
-0000f550: 6f6d 6574 7279 7479 7065 2c20 4765 6f6d  ometrytype, Geom
-0000f560: 6574 7279 5479 7065 293a 0d0a 2020 2020  etryType):..    
-0000f570: 2020 2020 2020 2020 666f 7263 655f 6f75          force_ou
-0000f580: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
-0000f590: 6520 3d20 666f 7263 655f 6f75 7470 7574  e = force_output
-0000f5a0: 5f67 656f 6d65 7472 7974 7970 652e 6e61  _geometrytype.na
-0000f5b0: 6d65 5f63 616d 656c 6361 7365 0d0a 2020  me_camelcase..  
-0000f5c0: 2020 2020 2020 6b77 6172 6773 5b22 6765        kwargs["ge
-0000f5d0: 6f6d 6574 7279 5f74 7970 6522 5d20 3d20  ometry_type"] = 
-0000f5e0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
-0000f5f0: 6d65 7472 7974 7970 650d 0a20 2020 2069  metrytype..    i
-0000f600: 6620 666f 7263 655f 6d75 6c74 6974 7970  f force_multityp
-0000f610: 653a 0d0a 2020 2020 2020 2020 6b77 6172  e:..        kwar
-0000f620: 6773 5b22 7072 6f6d 6f74 655f 746f 5f6d  gs["promote_to_m
-0000f630: 756c 7469 225d 203d 2054 7275 650d 0a0d  ulti"] = True...
-0000f640: 0a20 2020 2023 204e 6f77 2077 6520 6361  .    # Now we ca
-0000f650: 6e20 7772 6974 650d 0a20 2020 2067 6466  n write..    gdf
-0000f660: 5f74 6f5f 7772 6974 6520 3d20 6764 660d  _to_write = gdf.
-0000f670: 0a20 2020 2069 6620 6765 6f66 696c 6574  .    if geofilet
-0000f680: 7970 6520 3d3d 2047 656f 6669 6c65 5479  ype == GeofileTy
-0000f690: 7065 2e45 5352 4953 6861 7065 6669 6c65  pe.ESRIShapefile
-0000f6a0: 3a0d 0a20 2020 2020 2020 2069 6620 696e  :..        if in
-0000f6b0: 6465 7820 6973 2054 7275 653a 0d0a 2020  dex is True:..  
-0000f6c0: 2020 2020 2020 2020 2020 6764 665f 746f            gdf_to
-0000f6d0: 5f77 7269 7465 203d 2067 6466 2e72 6573  _write = gdf.res
-0000f6e0: 6574 5f69 6e64 6578 2864 726f 703d 5472  et_index(drop=Tr
-0000f6f0: 7565 290d 0a0d 0a20 2020 2069 6620 6765  ue)....    if ge
-0000f700: 6f66 696c 6574 7970 652e 6973 5f73 696e  ofiletype.is_sin
-0000f710: 676c 656c 6179 6572 3a0d 0a20 2020 2020  glelayer:..     
-0000f720: 2020 2070 796f 6772 696f 2e77 7269 7465     pyogrio.write
-0000f730: 5f64 6174 6166 7261 6d65 2867 6466 5f74  _dataframe(gdf_t
-0000f740: 6f5f 7772 6974 652c 2073 7472 2870 6174  o_write, str(pat
-0000f750: 6829 2c20 2a2a 6b77 6172 6773 290d 0a20  h), **kwargs).. 
-0000f760: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-0000f770: 2020 7079 6f67 7269 6f2e 7772 6974 655f    pyogrio.write_
-0000f780: 6461 7461 6672 616d 6528 6764 665f 746f  dataframe(gdf_to
-0000f790: 5f77 7269 7465 2c20 7374 7228 7061 7468  _write, str(path
-0000f7a0: 292c 206c 6179 6572 3d6c 6179 6572 2c20  ), layer=layer, 
-0000f7b0: 2a2a 6b77 6172 6773 290d 0a0d 0a20 2020  **kwargs)....   
-0000f7c0: 2072 6574 7572 6e0d 0a0d 0a0d 0a64 6566   return......def
-0000f7d0: 2067 6574 5f63 7273 2870 6174 683a 2055   get_crs(path: U
-0000f7e0: 6e69 6f6e 5b73 7472 2c20 226f 732e 5061  nion[str, "os.Pa
-0000f7f0: 7468 4c69 6b65 5b41 6e79 5d22 5d29 202d  thLike[Any]"]) -
-0000f800: 3e20 7079 7072 6f6a 2e43 5253 3a0d 0a20  > pyproj.CRS:.. 
-0000f810: 2020 2022 2222 0d0a 2020 2020 4765 7420     """..    Get 
-0000f820: 7468 6520 4352 5320 2870 726f 6a65 6374  the CRS (project
-0000f830: 696f 6e29 206f 6620 7468 6520 6669 6c65  ion) of the file
-0000f840: 0d0a 0d0a 2020 2020 4172 6773 3a0d 0a20  ....    Args:.. 
-0000f850: 2020 2020 2020 2070 6174 6820 2850 6174         path (Pat
-0000f860: 684c 696b 6529 3a20 5061 7468 2074 6f20  hLike): Path to 
-0000f870: 7468 6520 6669 6c65 2e0d 0a0d 0a20 2020  the file.....   
-0000f880: 2052 6574 7572 6e73 3a0d 0a20 2020 2020   Returns:..     
-0000f890: 2020 2070 7970 726f 6a2e 4352 533a 2054     pyproj.CRS: T
-0000f8a0: 6865 2070 726f 6a65 6374 696f 6e20 6f66  he projection of
-0000f8b0: 2074 6865 2066 696c 650d 0a20 2020 2022   the file..    "
-0000f8c0: 2222 0d0a 2020 2020 2320 544f 444f 3a20  ""..    # TODO: 
-0000f8d0: 7365 656d 7320 6c69 6b65 2073 7570 706f  seems like suppo
-0000f8e0: 7274 2066 6f72 206d 756c 7469 706c 6520  rt for multiple 
-0000f8f0: 6c61 7965 7273 2069 6e20 7468 6520 6669  layers in the fi
-0000f900: 6c65 2069 736e 2774 2068 6572 6520 7965  le isn't here ye
-0000f910: 743f 3f3f 0d0a 2020 2020 7769 7468 2066  t???..    with f
-0000f920: 696f 6e61 2e6f 7065 6e28 7374 7228 7061  iona.open(str(pa
-0000f930: 7468 292c 2022 7222 2920 6173 2067 656f  th), "r") as geo
-0000f940: 6669 6c65 3a0d 0a20 2020 2020 2020 2061  file:..        a
-0000f950: 7373 6572 7420 6765 6f66 696c 6520 6973  ssert geofile is
-0000f960: 206e 6f74 204e 6f6e 650d 0a20 2020 2020   not None..     
-0000f970: 2020 2072 6574 7572 6e20 7079 7072 6f6a     return pyproj
-0000f980: 2e43 5253 2867 656f 6669 6c65 2e63 7273  .CRS(geofile.crs
-0000f990: 290d 0a0d 0a0d 0a64 6566 2069 735f 6765  )......def is_ge
-0000f9a0: 6f66 696c 6528 7061 7468 3a20 556e 696f  ofile(path: Unio
-0000f9b0: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
-0000f9c0: 696b 655b 416e 795d 225d 2920 2d3e 2062  ike[Any]"]) -> b
-0000f9d0: 6f6f 6c3a 0d0a 2020 2020 2222 220d 0a20  ool:..    """.. 
-0000f9e0: 2020 2044 6574 6572 6d69 6e65 7320 6261     Determines ba
-0000f9f0: 7365 6420 6f6e 2074 6865 2066 696c 6570  sed on the filep
-0000fa00: 6174 6820 6966 2074 6869 7320 6973 2061  ath if this is a
-0000fa10: 2067 656f 6669 6c65 2e0d 0a0d 0a20 2020   geofile.....   
-0000fa20: 2041 7267 733a 0d0a 2020 2020 2020 2020   Args:..        
-0000fa30: 7061 7468 2028 5061 7468 4c69 6b65 293a  path (PathLike):
-0000fa40: 2054 6865 2066 696c 6520 7061 7468 2e0d   The file path..
-0000fa50: 0a0d 0a20 2020 2052 6574 7572 6e73 3a0d  ...    Returns:.
-0000fa60: 0a20 2020 2020 2020 2062 6f6f 6c3a 2054  .        bool: T
-0000fa70: 7275 6520 6966 2069 7420 6973 2061 2067  rue if it is a g
-0000fa80: 656f 2066 696c 652e 0d0a 2020 2020 2222  eo file...    ""
-0000fa90: 220d 0a20 2020 2072 6574 7572 6e20 6973  "..    return is
-0000faa0: 5f67 656f 6669 6c65 5f65 7874 2850 6174  _geofile_ext(Pat
-0000fab0: 6828 7061 7468 292e 7375 6666 6978 290d  h(path).suffix).
-0000fac0: 0a0d 0a0d 0a64 6566 2069 735f 6765 6f66  .....def is_geof
-0000fad0: 696c 655f 6578 7428 6669 6c65 5f65 7874  ile_ext(file_ext
-0000fae0: 3a20 7374 7229 202d 3e20 626f 6f6c 3a0d  : str) -> bool:.
-0000faf0: 0a20 2020 2022 2222 0d0a 2020 2020 4465  .    """..    De
-0000fb00: 7465 726d 696e 6573 2062 6173 6564 206f  termines based o
-0000fb10: 6e20 7468 6520 6669 6c65 2065 7874 656e  n the file exten
-0000fb20: 7369 6f6e 2069 6620 7468 6973 2069 7320  sion if this is 
-0000fb30: 6120 6765 6f66 696c 652e 0d0a 0d0a 2020  a geofile.....  
-0000fb40: 2020 4172 6773 3a0d 0a20 2020 2020 2020    Args:..       
-0000fb50: 2066 696c 655f 6578 7420 2873 7472 293a   file_ext (str):
-0000fb60: 2074 6865 2065 7874 656e 7369 6f6e 2e0d   the extension..
-0000fb70: 0a0d 0a20 2020 2052 6574 7572 6e73 3a0d  ...    Returns:.
-0000fb80: 0a20 2020 2020 2020 2062 6f6f 6c3a 2054  .        bool: T
-0000fb90: 7275 6520 6966 2069 7420 6973 2061 2067  rue if it is a g
-0000fba0: 656f 6669 6c65 2e0d 0a20 2020 2022 2222  eofile...    """
-0000fbb0: 0d0a 2020 2020 7472 793a 0d0a 2020 2020  ..    try:..    
-0000fbc0: 2020 2020 2320 4966 2074 6865 2064 7269      # If the dri
-0000fbd0: 7665 7220 6361 6e20 6265 2064 6574 6572  ver can be deter
-0000fbe0: 6d69 6e65 642c 2069 7420 6973 2061 2028  mined, it is a (
-0000fbf0: 7375 7070 6f72 7465 6429 2067 656f 2066  supported) geo f
-0000fc00: 696c 652e 0d0a 2020 2020 2020 2020 5f20  ile...        _ 
-0000fc10: 3d20 4765 6f66 696c 6554 7970 6528 6669  = GeofileType(fi
-0000fc20: 6c65 5f65 7874 290d 0a20 2020 2020 2020  le_ext)..       
-0000fc30: 2072 6574 7572 6e20 5472 7565 0d0a 2020   return True..  
-0000fc40: 2020 6578 6365 7074 2045 7863 6570 7469    except Excepti
-0000fc50: 6f6e 3a0d 0a20 2020 2020 2020 2072 6574  on:..        ret
-0000fc60: 7572 6e20 4661 6c73 650d 0a0d 0a0d 0a64  urn False......d
-0000fc70: 6566 2063 6d70 280d 0a20 2020 2070 6174  ef cmp(..    pat
-0000fc80: 6831 3a20 556e 696f 6e5b 7374 722c 2022  h1: Union[str, "
-0000fc90: 6f73 2e50 6174 684c 696b 655b 416e 795d  os.PathLike[Any]
-0000fca0: 225d 2c20 7061 7468 323a 2055 6e69 6f6e  "], path2: Union
-0000fcb0: 5b73 7472 2c20 226f 732e 5061 7468 4c69  [str, "os.PathLi
-0000fcc0: 6b65 5b41 6e79 5d22 5d0d 0a29 202d 3e20  ke[Any]"]..) -> 
-0000fcd0: 626f 6f6c 3a0d 0a20 2020 2022 2222 0d0a  bool:..    """..
-0000fce0: 2020 2020 436f 6d70 6172 6520 6966 2074      Compare if t
-0000fcf0: 776f 2067 656f 6669 6c65 7320 6172 6520  wo geofiles are 
-0000fd00: 6964 656e 7469 6361 6c2e 0d0a 0d0a 2020  identical.....  
-0000fd10: 2020 466f 7220 6765 6f66 696c 6573 2074    For geofiles t
-0000fd20: 6861 7420 7573 6520 6d75 6c74 6970 6c65  hat use multiple
-0000fd30: 2066 696c 6573 2c20 616c 6c20 7265 6c65   files, all rele
-0000fd40: 7661 6e74 2066 696c 6573 206d 7573 7420  vant files must 
-0000fd50: 6265 2069 6465 6e74 6963 616c 2e0d 0a20  be identical... 
-0000fd60: 2020 2045 672e 2066 6f72 2073 6861 7065     Eg. for shape
-0000fd70: 6669 6c65 732c 2074 6865 202e 7368 702c  files, the .shp,
-0000fd80: 202e 7368 7820 616e 6420 2e64 6266 2066   .shx and .dbf f
-0000fd90: 696c 6520 6d75 7374 2062 6520 6964 656e  ile must be iden
-0000fda0: 7469 6361 6c2e 0d0a 0d0a 2020 2020 4172  tical.....    Ar
-0000fdb0: 6773 3a0d 0a20 2020 2020 2020 2070 6174  gs:..        pat
-0000fdc0: 6831 2028 5061 7468 4c69 6b65 293a 2070  h1 (PathLike): p
-0000fdd0: 6174 6820 746f 2074 6865 2066 6972 7374  ath to the first
-0000fde0: 2066 696c 652e 0d0a 2020 2020 2020 2020   file...        
-0000fdf0: 7061 7468 3220 2850 6174 684c 696b 6529  path2 (PathLike)
-0000fe00: 3a20 7061 7468 2074 6f20 7468 6520 7365  : path to the se
-0000fe10: 636f 6e64 2066 696c 652e 0d0a 0d0a 2020  cond file.....  
-0000fe20: 2020 5265 7475 726e 733a 0d0a 2020 2020    Returns:..    
-0000fe30: 2020 2020 626f 6f6c 3a20 5472 7565 2069      bool: True i
-0000fe40: 6620 7468 6520 6669 6c65 7320 6172 6520  f the files are 
-0000fe50: 6964 656e 7469 6361 6c0d 0a20 2020 2022  identical..    "
-0000fe60: 2222 0d0a 2020 2020 2320 4368 6563 6b20  ""..    # Check 
-0000fe70: 696e 7075 7420 7061 7261 6d65 7465 7273  input parameters
-0000fe80: 0d0a 2020 2020 7061 7468 315f 7020 3d20  ..    path1_p = 
-0000fe90: 5061 7468 2870 6174 6831 290d 0a20 2020  Path(path1)..   
-0000fea0: 2070 6174 6832 5f70 203d 2050 6174 6828   path2_p = Path(
-0000feb0: 7061 7468 3229 0d0a 0d0a 2020 2020 2320  path2)....    # 
-0000fec0: 466f 7220 6120 7368 6170 6566 696c 652c  For a shapefile,
-0000fed0: 206d 756c 7469 706c 6520 6669 6c65 7320   multiple files 
-0000fee0: 6e65 6564 2074 6f20 6265 2063 6f6d 7061  need to be compa
-0000fef0: 7265 640d 0a20 2020 2069 6620 7061 7468  red..    if path
-0000ff00: 315f 702e 7375 6666 6978 2e6c 6f77 6572  1_p.suffix.lower
-0000ff10: 2829 203d 3d20 222e 7368 7022 3a0d 0a20  () == ".shp":.. 
-0000ff20: 2020 2020 2020 2070 6174 6832 5f6e 6f65         path2_noe
-0000ff30: 7874 2c20 5f20 3d20 6f73 2e70 6174 682e  xt, _ = os.path.
-0000ff40: 7370 6c69 7465 7874 2870 6174 6832 5f70  splitext(path2_p
-0000ff50: 290d 0a20 2020 2020 2020 2073 6861 7065  )..        shape
-0000ff60: 6669 6c65 5f62 6173 655f 7375 6666 6978  file_base_suffix
-0000ff70: 6573 203d 205b 222e 7368 7022 2c20 222e  es = [".shp", ".
-0000ff80: 6462 6622 2c20 222e 7368 7822 5d0d 0a20  dbf", ".shx"].. 
-0000ff90: 2020 2020 2020 2070 6174 6831 5f6e 6f65         path1_noe
-0000ffa0: 7874 203d 2070 6174 6831 5f70 2e70 6172  xt = path1_p.par
-0000ffb0: 656e 7420 2f20 7061 7468 315f 702e 7374  ent / path1_p.st
-0000ffc0: 656d 0d0a 2020 2020 2020 2020 7061 7468  em..        path
-0000ffd0: 325f 6e6f 6578 7420 3d20 7061 7468 325f  2_noext = path2_
-0000ffe0: 702e 7061 7265 6e74 202f 2070 6174 6832  p.parent / path2
-0000fff0: 5f70 2e73 7465 6d0d 0a20 2020 2020 2020  _p.stem..       
-00010000: 2066 6f72 2065 7874 2069 6e20 7368 6170   for ext in shap
-00010010: 6566 696c 655f 6261 7365 5f73 7566 6669  efile_base_suffi
-00010020: 7865 733a 0d0a 2020 2020 2020 2020 2020  xes:..          
-00010030: 2020 6966 206e 6f74 2066 696c 6563 6d70    if not filecmp
-00010040: 2e63 6d70 2866 227b 7374 7228 7061 7468  .cmp(f"{str(path
-00010050: 315f 6e6f 6578 7429 7d7b 6578 747d 222c  1_noext)}{ext}",
-00010060: 2066 227b 7374 7228 7061 7468 325f 6e6f   f"{str(path2_no
-00010070: 6578 7429 7d7b 6578 747d 2229 3a0d 0a20  ext)}{ext}"):.. 
-00010080: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00010090: 6f67 6765 722e 696e 666f 280d 0a20 2020  ogger.info(..   
-000100a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000100b0: 2066 2246 696c 6520 7b70 6174 6831 5f6e   f"File {path1_n
-000100c0: 6f65 7874 7d7b 6578 747d 2069 7320 6469  oext}{ext} is di
-000100d0: 6666 6572 656e 7420 6672 6f6d 207b 7061  fferent from {pa
-000100e0: 7468 325f 6e6f 6578 747d 7b65 7874 7d22  th2_noext}{ext}"
-000100f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00010100: 2020 290d 0a20 2020 2020 2020 2020 2020    )..           
-00010110: 2020 2020 2072 6574 7572 6e20 4661 6c73       return Fals
-00010120: 650d 0a20 2020 2020 2020 2072 6574 7572  e..        retur
-00010130: 6e20 5472 7565 0d0a 2020 2020 656c 7365  n True..    else
-00010140: 3a0d 0a20 2020 2020 2020 2072 6574 7572  :..        retur
-00010150: 6e20 6669 6c65 636d 702e 636d 7028 7374  n filecmp.cmp(st
-00010160: 7228 7061 7468 315f 7029 2c20 7374 7228  r(path1_p), str(
-00010170: 7061 7468 325f 7029 290d 0a0d 0a0d 0a64  path2_p))......d
-00010180: 6566 2063 6f70 7928 7372 633a 2055 6e69  ef copy(src: Uni
-00010190: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
-000101a0: 4c69 6b65 5b41 6e79 5d22 5d2c 2064 7374  Like[Any]"], dst
-000101b0: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
-000101c0: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
-000101d0: 293a 0d0a 2020 2020 2222 220d 0a20 2020  ):..    """..   
-000101e0: 2043 6f70 6965 7320 7468 6520 6765 6f66   Copies the geof
-000101f0: 696c 6520 6672 6f6d 2073 7263 2074 6f20  ile from src to 
-00010200: 6473 742e 2049 7320 7468 6520 736f 7572  dst. Is the sour
-00010210: 6365 2066 696c 6520 6973 2061 2067 656f  ce file is a geo
-00010220: 6669 6c65 2063 6f6e 7461 696e 696e 670d  file containing.
-00010230: 0a20 2020 206f 6620 6d75 6c74 6970 6c65  .    of multiple
-00010240: 2066 696c 6573 2028 6567 2e20 2e73 6870   files (eg. .shp
-00010250: 2920 616c 6c20 6669 6c65 7320 6172 6520  ) all files are 
-00010260: 636f 7069 6564 2e0d 0a0d 0a20 2020 2041  copied.....    A
-00010270: 7267 733a 0d0a 2020 2020 2020 2020 7372  rgs:..        sr
-00010280: 6320 2850 6174 684c 696b 6529 3a20 7468  c (PathLike): th
-00010290: 6520 6669 6c65 2074 6f20 636f 7079 2e0d  e file to copy..
-000102a0: 0a20 2020 2020 2020 2064 7374 2028 5061  .        dst (Pa
-000102b0: 7468 4c69 6b65 293a 2074 6865 206c 6f63  thLike): the loc
-000102c0: 6174 696f 6e20 746f 2063 6f70 7920 7468  ation to copy th
-000102d0: 6520 6669 6c65 2873 2920 746f 2e0d 0a20  e file(s) to... 
-000102e0: 2020 2022 2222 0d0a 2020 2020 2320 4368     """..    # Ch
-000102f0: 6563 6b20 696e 7075 7420 7061 7261 6d65  eck input parame
-00010300: 7465 7273 0d0a 2020 2020 7372 6320 3d20  ters..    src = 
-00010310: 5061 7468 2873 7263 290d 0a20 2020 2064  Path(src)..    d
-00010320: 7374 203d 2050 6174 6828 6473 7429 0d0a  st = Path(dst)..
-00010330: 2020 2020 6765 6f66 696c 6574 7970 6520      geofiletype 
-00010340: 3d20 4765 6f66 696c 6554 7970 6528 7372  = GeofileType(sr
-00010350: 6329 0d0a 0d0a 2020 2020 2320 436f 7079  c)....    # Copy
-00010360: 2074 6865 206d 6169 6e20 6669 6c65 0d0a   the main file..
-00010370: 2020 2020 7368 7574 696c 2e63 6f70 7928      shutil.copy(
-00010380: 7374 7228 7372 6329 2c20 6473 7429 0d0a  str(src), dst)..
-00010390: 0d0a 2020 2020 2320 466f 7220 736f 6d65  ..    # For some
-000103a0: 2066 696c 6520 7479 7065 732c 2065 7874   file types, ext
-000103b0: 7261 2066 696c 6573 206e 6565 6420 746f  ra files need to
-000103c0: 2062 6520 636f 7069 6564 0d0a 2020 2020   be copied..    
-000103d0: 2320 4966 2064 6573 7420 6973 2061 2064  # If dest is a d
-000103e0: 6972 2c20 6a75 7374 2075 7365 206d 6f76  ir, just use mov
-000103f0: 652e 204f 7468 6572 7769 7365 2063 6f6e  e. Otherwise con
-00010400: 6361 7420 6465 7374 2066 696c 6570 6174  cat dest filepat
-00010410: 6873 0d0a 2020 2020 6966 2067 656f 6669  hs..    if geofi
-00010420: 6c65 7479 7065 2e73 7566 6669 7865 735f  letype.suffixes_
-00010430: 6578 7472 6166 696c 6573 2069 7320 6e6f  extrafiles is no
-00010440: 7420 4e6f 6e65 3a0d 0a20 2020 2020 2020  t None:..       
-00010450: 2069 6620 6473 742e 6973 5f64 6972 2829   if dst.is_dir()
-00010460: 3a0d 0a20 2020 2020 2020 2020 2020 2066  :..            f
-00010470: 6f72 2073 7566 6669 7820 696e 2067 656f  or suffix in geo
-00010480: 6669 6c65 7479 7065 2e73 7566 6669 7865  filetype.suffixe
-00010490: 735f 6578 7472 6166 696c 6573 3a0d 0a20  s_extrafiles:.. 
-000104a0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-000104b0: 7263 6669 6c65 203d 2073 7263 2e70 6172  rcfile = src.par
-000104c0: 656e 7420 2f20 6622 7b73 7263 2e73 7465  ent / f"{src.ste
-000104d0: 6d7d 7b73 7566 6669 787d 220d 0a20 2020  m}{suffix}"..   
-000104e0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-000104f0: 7372 6366 696c 652e 6578 6973 7473 2829  srcfile.exists()
-00010500: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00010510: 2020 2020 2020 2073 6875 7469 6c2e 636f         shutil.co
-00010520: 7079 2873 7472 2873 7263 6669 6c65 292c  py(str(srcfile),
-00010530: 2064 7374 290d 0a20 2020 2020 2020 2065   dst)..        e
-00010540: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-00010550: 2020 666f 7220 7375 6666 6978 2069 6e20    for suffix in 
-00010560: 6765 6f66 696c 6574 7970 652e 7375 6666  geofiletype.suff
-00010570: 6978 6573 5f65 7874 7261 6669 6c65 733a  ixes_extrafiles:
-00010580: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00010590: 2020 7372 6366 696c 6520 3d20 7372 632e    srcfile = src.
-000105a0: 7061 7265 6e74 202f 2066 227b 7372 632e  parent / f"{src.
-000105b0: 7374 656d 7d7b 7375 6666 6978 7d22 0d0a  stem}{suffix}"..
-000105c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000105d0: 6473 7466 696c 6520 3d20 6473 742e 7061  dstfile = dst.pa
-000105e0: 7265 6e74 202f 2066 227b 6473 742e 7374  rent / f"{dst.st
-000105f0: 656d 7d7b 7375 6666 6978 7d22 0d0a 2020  em}{suffix}"..  
-00010600: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00010610: 2073 7263 6669 6c65 2e65 7869 7374 7328   srcfile.exists(
-00010620: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-00010630: 2020 2020 2020 2020 7368 7574 696c 2e63          shutil.c
-00010640: 6f70 7928 7374 7228 7372 6366 696c 6529  opy(str(srcfile)
-00010650: 2c20 6473 7466 696c 6529 0d0a 0d0a 0d0a  , dstfile)......
-00010660: 6465 6620 6d6f 7665 2873 7263 3a20 556e  def move(src: Un
-00010670: 696f 6e5b 7374 722c 2022 6f73 2e50 6174  ion[str, "os.Pat
-00010680: 684c 696b 655b 416e 795d 225d 2c20 6473  hLike[Any]"], ds
-00010690: 743a 2055 6e69 6f6e 5b73 7472 2c20 226f  t: Union[str, "o
-000106a0: 732e 5061 7468 4c69 6b65 5b41 6e79 5d22  s.PathLike[Any]"
-000106b0: 5d29 3a0d 0a20 2020 2022 2222 0d0a 2020  ]):..    """..  
-000106c0: 2020 4d6f 7665 7320 7468 6520 6765 6f66    Moves the geof
-000106d0: 696c 6520 6672 6f6d 2073 7263 2074 6f20  ile from src to 
-000106e0: 6473 742e 2049 6620 7468 6520 736f 7572  dst. If the sour
-000106f0: 6365 2066 696c 6520 6973 2061 2067 656f  ce file is a geo
-00010700: 6669 6c65 2063 6f6e 7461 696e 696e 670d  file containing.
-00010710: 0a20 2020 206f 6620 6d75 6c74 6970 6c65  .    of multiple
-00010720: 2066 696c 6573 2028 6567 2e20 2e73 6870   files (eg. .shp
-00010730: 2920 616c 6c20 6669 6c65 7320 6172 6520  ) all files are 
-00010740: 6d6f 7665 642e 0d0a 0d0a 2020 2020 4172  moved.....    Ar
-00010750: 6773 3a0d 0a20 2020 2020 2020 2073 7263  gs:..        src
-00010760: 2028 5061 7468 4c69 6b65 293a 2074 6865   (PathLike): the
-00010770: 2066 696c 6520 746f 206d 6f76 650d 0a20   file to move.. 
-00010780: 2020 2020 2020 2064 7374 2028 5061 7468         dst (Path
-00010790: 4c69 6b65 293a 2074 6865 206c 6f63 6174  Like): the locat
-000107a0: 696f 6e20 746f 206d 6f76 6520 7468 6520  ion to move the 
-000107b0: 6669 6c65 2873 2920 746f 0d0a 2020 2020  file(s) to..    
-000107c0: 2222 220d 0a20 2020 2023 2043 6865 636b  """..    # Check
-000107d0: 2069 6e70 7574 2070 6172 616d 6574 6572   input parameter
-000107e0: 730d 0a20 2020 2073 7263 203d 2050 6174  s..    src = Pat
-000107f0: 6828 7372 6329 0d0a 2020 2020 6473 7420  h(src)..    dst 
-00010800: 3d20 5061 7468 2864 7374 290d 0a20 2020  = Path(dst)..   
-00010810: 2067 656f 6669 6c65 7479 7065 203d 2047   geofiletype = G
-00010820: 656f 6669 6c65 5479 7065 2873 7263 290d  eofileType(src).
-00010830: 0a0d 0a20 2020 2023 204d 6f76 6520 7468  ...    # Move th
-00010840: 6520 6d61 696e 2066 696c 650d 0a20 2020  e main file..   
-00010850: 2073 6875 7469 6c2e 6d6f 7665 2873 7472   shutil.move(str
-00010860: 2873 7263 292c 2064 7374 290d 0a0d 0a20  (src), dst).... 
-00010870: 2020 2023 2046 6f72 2073 6f6d 6520 6669     # For some fi
-00010880: 6c65 2074 7970 6573 2c20 6578 7472 6120  le types, extra 
-00010890: 6669 6c65 7320 6e65 6564 2074 6f20 6265  files need to be
-000108a0: 206d 6f76 6564 0d0a 2020 2020 2320 4966   moved..    # If
-000108b0: 2064 6573 7420 6973 2061 2064 6972 2c20   dest is a dir, 
-000108c0: 6a75 7374 2075 7365 206d 6f76 652e 204f  just use move. O
-000108d0: 7468 6572 7769 7365 2063 6f6e 6361 7420  therwise concat 
-000108e0: 6465 7374 2066 696c 6570 6174 6873 0d0a  dest filepaths..
-000108f0: 2020 2020 6966 2067 656f 6669 6c65 7479      if geofilety
-00010900: 7065 2e73 7566 6669 7865 735f 6578 7472  pe.suffixes_extr
-00010910: 6166 696c 6573 2069 7320 6e6f 7420 4e6f  afiles is not No
-00010920: 6e65 3a0d 0a20 2020 2020 2020 2069 6620  ne:..        if 
-00010930: 6473 742e 6973 5f64 6972 2829 3a0d 0a20  dst.is_dir():.. 
-00010940: 2020 2020 2020 2020 2020 2066 6f72 2073             for s
-00010950: 7566 6669 7820 696e 2067 656f 6669 6c65  uffix in geofile
-00010960: 7479 7065 2e73 7566 6669 7865 735f 6578  type.suffixes_ex
-00010970: 7472 6166 696c 6573 3a0d 0a20 2020 2020  trafiles:..     
-00010980: 2020 2020 2020 2020 2020 2073 7263 6669             srcfi
-00010990: 6c65 203d 2073 7263 2e70 6172 656e 7420  le = src.parent 
-000109a0: 2f20 6622 7b73 7263 2e73 7465 6d7d 7b73  / f"{src.stem}{s
-000109b0: 7566 6669 787d 220d 0a20 2020 2020 2020  uffix}"..       
-000109c0: 2020 2020 2020 2020 2069 6620 7372 6366           if srcf
-000109d0: 696c 652e 6578 6973 7473 2829 3a0d 0a20  ile.exists():.. 
-000109e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000109f0: 2020 2073 6875 7469 6c2e 6d6f 7665 2873     shutil.move(s
-00010a00: 7472 2873 7263 6669 6c65 292c 2064 7374  tr(srcfile), dst
-00010a10: 290d 0a20 2020 2020 2020 2065 6c73 653a  )..        else:
-00010a20: 0d0a 2020 2020 2020 2020 2020 2020 666f  ..            fo
-00010a30: 7220 7375 6666 6978 2069 6e20 6765 6f66  r suffix in geof
-00010a40: 696c 6574 7970 652e 7375 6666 6978 6573  iletype.suffixes
-00010a50: 5f65 7874 7261 6669 6c65 733a 0d0a 2020  _extrafiles:..  
-00010a60: 2020 2020 2020 2020 2020 2020 2020 7372                sr
-00010a70: 6366 696c 6520 3d20 7372 632e 7061 7265  cfile = src.pare
-00010a80: 6e74 202f 2066 227b 7372 632e 7374 656d  nt / f"{src.stem
-00010a90: 7d7b 7375 6666 6978 7d22 0d0a 2020 2020  }{suffix}"..    
-00010aa0: 2020 2020 2020 2020 2020 2020 6473 7466              dstf
-00010ab0: 696c 6520 3d20 6473 742e 7061 7265 6e74  ile = dst.parent
-00010ac0: 202f 2066 227b 6473 742e 7374 656d 7d7b   / f"{dst.stem}{
-00010ad0: 7375 6666 6978 7d22 0d0a 2020 2020 2020  suffix}"..      
-00010ae0: 2020 2020 2020 2020 2020 6966 2073 7263            if src
-00010af0: 6669 6c65 2e65 7869 7374 7328 293a 0d0a  file.exists():..
-00010b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010b10: 2020 2020 7368 7574 696c 2e6d 6f76 6528      shutil.move(
-00010b20: 7374 7228 7372 6366 696c 6529 2c20 6473  str(srcfile), ds
-00010b30: 7466 696c 6529 0d0a 0d0a 0d0a 6465 6620  tfile)......def 
-00010b40: 7265 6d6f 7665 2870 6174 683a 2055 6e69  remove(path: Uni
-00010b50: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
-00010b60: 4c69 6b65 5b41 6e79 5d22 5d2c 206d 6973  Like[Any]"], mis
-00010b70: 7369 6e67 5f6f 6b3a 2062 6f6f 6c20 3d20  sing_ok: bool = 
-00010b80: 4661 6c73 6529 3a0d 0a20 2020 2022 2222  False):..    """
-00010b90: 0d0a 2020 2020 5265 6d6f 7665 7320 7468  ..    Removes th
-00010ba0: 6520 6765 6f66 696c 652e 2049 7320 6974  e geofile. Is it
-00010bb0: 2069 7320 6120 6765 6f66 696c 6520 636f   is a geofile co
-00010bc0: 6d70 6f73 6564 206f 6620 6d75 6c74 6970  mposed of multip
-00010bd0: 6c65 2066 696c 6573 0d0a 2020 2020 2865  le files..    (e
-00010be0: 672e 202e 7368 7029 2061 6c6c 2066 696c  g. .shp) all fil
-00010bf0: 6573 2061 7265 2072 656d 6f76 6564 2e0d  es are removed..
-00010c00: 0a20 2020 2049 6620 2e6c 6f63 6b20 6669  .    If .lock fi
-00010c10: 6c65 7320 6172 6520 7072 6573 656e 742c  les are present,
-00010c20: 2074 6865 7920 6172 6520 7265 6d6f 7665   they are remove
-00010c30: 6420 6173 2077 656c 6c2e 0d0a 0d0a 2020  d as well.....  
-00010c40: 2020 4172 6773 3a0d 0a20 2020 2020 2020    Args:..       
-00010c50: 2070 6174 6820 2850 6174 684c 696b 6529   path (PathLike)
-00010c60: 3a20 7468 6520 6669 6c65 2074 6f20 7265  : the file to re
-00010c70: 6d6f 7665 0d0a 2020 2020 2222 220d 0a20  move..    """.. 
-00010c80: 2020 2023 2043 6865 636b 2069 6e70 7574     # Check input
-00010c90: 2070 6172 616d 6574 6572 730d 0a20 2020   parameters..   
-00010ca0: 2070 6174 6820 3d20 5061 7468 2870 6174   path = Path(pat
-00010cb0: 6829 0d0a 2020 2020 6765 6f66 696c 6574  h)..    geofilet
-00010cc0: 7970 6520 3d20 4765 6f66 696c 6554 7970  ype = GeofileTyp
-00010cd0: 6528 7061 7468 290d 0a0d 0a20 2020 2023  e(path)....    #
-00010ce0: 2049 6620 7468 6572 6520 6973 2061 206c   If there is a l
-00010cf0: 6f63 6b20 6669 6c65 2c20 7265 6d6f 7665  ock file, remove
-00010d00: 2069 740d 0a20 2020 206c 6f63 6b66 696c   it..    lockfil
-00010d10: 655f 7061 7468 203d 2070 6174 682e 7061  e_path = path.pa
-00010d20: 7265 6e74 202f 2066 227b 7061 7468 2e6e  rent / f"{path.n
-00010d30: 616d 657d 2e6c 6f63 6b22 0d0a 2020 2020  ame}.lock"..    
-00010d40: 6c6f 636b 6669 6c65 5f70 6174 682e 756e  lockfile_path.un
-00010d50: 6c69 6e6b 286d 6973 7369 6e67 5f6f 6b3d  link(missing_ok=
-00010d60: 5472 7565 290d 0a0d 0a20 2020 2023 2052  True)....    # R
-00010d70: 656d 6f76 6520 7468 6520 6d61 696e 2066  emove the main f
-00010d80: 696c 650d 0a20 2020 2069 6620 7061 7468  ile..    if path
-00010d90: 2e65 7869 7374 7328 293a 0d0a 2020 2020  .exists():..    
-00010da0: 2020 2020 7061 7468 2e75 6e6c 696e 6b28      path.unlink(
-00010db0: 6d69 7373 696e 675f 6f6b 3d6d 6973 7369  missing_ok=missi
-00010dc0: 6e67 5f6f 6b29 0d0a 0d0a 2020 2020 2320  ng_ok)....    # 
-00010dd0: 466f 7220 736f 6d65 2066 696c 6520 7479  For some file ty
-00010de0: 7065 732c 2065 7874 7261 2066 696c 6573  pes, extra files
-00010df0: 206e 6565 6420 746f 2062 6520 7265 6d6f   need to be remo
-00010e00: 7665 640d 0a20 2020 2069 6620 6765 6f66  ved..    if geof
-00010e10: 696c 6574 7970 652e 7375 6666 6978 6573  iletype.suffixes
-00010e20: 5f65 7874 7261 6669 6c65 7320 6973 206e  _extrafiles is n
-00010e30: 6f74 204e 6f6e 653a 0d0a 2020 2020 2020  ot None:..      
-00010e40: 2020 666f 7220 7375 6666 6978 2069 6e20    for suffix in 
-00010e50: 6765 6f66 696c 6574 7970 652e 7375 6666  geofiletype.suff
-00010e60: 6978 6573 5f65 7874 7261 6669 6c65 733a  ixes_extrafiles:
-00010e70: 0d0a 2020 2020 2020 2020 2020 2020 6375  ..            cu
-00010e80: 7272 5f70 6174 6820 3d20 7061 7468 2e70  rr_path = path.p
-00010e90: 6172 656e 7420 2f20 6622 7b70 6174 682e  arent / f"{path.
-00010ea0: 7374 656d 7d7b 7375 6666 6978 7d22 0d0a  stem}{suffix}"..
-00010eb0: 2020 2020 2020 2020 2020 2020 6375 7272              curr
-00010ec0: 5f70 6174 682e 756e 6c69 6e6b 286d 6973  _path.unlink(mis
-00010ed0: 7369 6e67 5f6f 6b3d 5472 7565 290d 0a0d  sing_ok=True)...
-00010ee0: 0a0d 0a64 6566 2061 7070 656e 645f 746f  ...def append_to
-00010ef0: 280d 0a20 2020 2073 7263 3a20 556e 696f  (..    src: Unio
-00010f00: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
-00010f10: 696b 655b 416e 795d 225d 2c0d 0a20 2020  ike[Any]"],..   
-00010f20: 2064 7374 3a20 556e 696f 6e5b 7374 722c   dst: Union[str,
-00010f30: 2022 6f73 2e50 6174 684c 696b 655b 416e   "os.PathLike[An
-00010f40: 795d 225d 2c0d 0a20 2020 2073 7263 5f6c  y]"],..    src_l
-00010f50: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
-00010f60: 7472 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  tr] = None,..   
-00010f70: 2064 7374 5f6c 6179 6572 3a20 4f70 7469   dst_layer: Opti
-00010f80: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
-00010f90: 2c0d 0a20 2020 2073 7263 5f63 7273 3a20  ,..    src_crs: 
-00010fa0: 556e 696f 6e5b 696e 742c 2073 7472 2c20  Union[int, str, 
-00010fb0: 4e6f 6e65 5d20 3d20 4e6f 6e65 2c0d 0a20  None] = None,.. 
-00010fc0: 2020 2064 7374 5f63 7273 3a20 556e 696f     dst_crs: Unio
-00010fd0: 6e5b 696e 742c 2073 7472 2c20 4e6f 6e65  n[int, str, None
-00010fe0: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2072  ] = None,..    r
-00010ff0: 6570 726f 6a65 6374 3a20 626f 6f6c 203d  eproject: bool =
-00011000: 2046 616c 7365 2c0d 0a20 2020 2065 7870   False,..    exp
-00011010: 6c6f 6465 636f 6c6c 6563 7469 6f6e 733a  lodecollections:
-00011020: 2062 6f6f 6c20 3d20 4661 6c73 652c 0d0a   bool = False,..
-00011030: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
-00011040: 5f67 656f 6d65 7472 7974 7970 653a 2055  _geometrytype: U
-00011050: 6e69 6f6e 5b47 656f 6d65 7472 7954 7970  nion[GeometryTyp
-00011060: 652c 2073 7472 2c20 4e6f 6e65 5d20 3d20  e, str, None] = 
-00011070: 4e6f 6e65 2c0d 0a20 2020 2063 7265 6174  None,..    creat
-00011080: 655f 7370 6174 6961 6c5f 696e 6465 783a  e_spatial_index:
-00011090: 204f 7074 696f 6e61 6c5b 626f 6f6c 5d20   Optional[bool] 
-000110a0: 3d20 5472 7565 2c0d 0a20 2020 2061 7070  = True,..    app
-000110b0: 656e 645f 7469 6d65 6f75 745f 733a 2069  end_timeout_s: i
-000110c0: 6e74 203d 2036 3030 2c0d 0a20 2020 2074  nt = 600,..    t
-000110d0: 7261 6e73 6163 7469 6f6e 5f73 697a 653a  ransaction_size:
-000110e0: 2069 6e74 203d 2035 3030 3030 2c0d 0a20   int = 50000,.. 
-000110f0: 2020 2070 7265 7365 7276 655f 6669 643a     preserve_fid:
-00011100: 204f 7074 696f 6e61 6c5b 626f 6f6c 5d20   Optional[bool] 
-00011110: 3d20 4e6f 6e65 2c0d 0a20 2020 206f 7074  = None,..    opt
-00011120: 696f 6e73 3a20 6469 6374 203d 207b 7d2c  ions: dict = {},
-00011130: 0d0a 293a 0d0a 2020 2020 2222 220d 0a20  ..):..    """.. 
-00011140: 2020 2041 7070 656e 6420 7372 6320 6669     Append src fi
-00011150: 6c65 2074 6f20 7468 6520 6473 7420 6669  le to the dst fi
-00011160: 6c65 2e0d 0a0d 0a20 2020 2052 656d 6172  le.....    Remar
-00011170: 6b3a 2061 7070 656e 6420 6973 206e 6f74  k: append is not
-00011180: 2073 7570 706f 7274 6564 2066 6f72 2061   supported for a
-00011190: 6c6c 2066 696c 6574 7970 6573 2069 6e20  ll filetypes in 
-000111a0: 6669 6f6e 612f 6765 6f70 616e 6461 7320  fiona/geopandas 
-000111b0: 2830 2e38 290d 0a20 2020 2073 6f20 776f  (0.8)..    so wo
-000111c0: 726b 6172 6f75 6e64 2076 6961 2067 6461  rkaround via gda
-000111d0: 6c20 6e65 6564 6564 2e0d 0a0d 0a20 2020  l needed.....   
-000111e0: 2054 6865 206f 7074 696f 6e73 2070 6172   The options par
-000111f0: 616d 6574 6572 2063 616e 2062 6520 7573  ameter can be us
-00011200: 6564 2074 6f20 7061 7373 2061 6e79 2074  ed to pass any t
-00011210: 7970 6520 6f66 206f 7074 696f 6e73 2074  ype of options t
-00011220: 6f20 4744 414c 2069 6e0d 0a20 2020 2074  o GDAL in..    t
-00011230: 6865 2066 6f6c 6c6f 7769 6e67 2066 6f72  he following for
-00011240: 6d3a 0d0a 2020 2020 2020 2020 7b20 223c  m:..        { "<
-00011250: 6f70 7469 6f6e 5f74 7970 653e 2e3c 6f70  option_type>.<op
-00011260: 7469 6f6e 5f6e 616d 653e 223a 203c 6f70  tion_name>": <op
-00011270: 7469 6f6e 5f76 616c 7565 3e20 7d0d 0a0d  tion_value> }...
-00011280: 0a20 2020 2054 6865 206f 7074 696f 6e20  .    The option 
-00011290: 7479 7065 7320 6361 6e20 6265 2061 6e79  types can be any
-000112a0: 206f 6620 7468 6520 666f 6c6c 6f77 696e   of the followin
-000112b0: 673a 0d0a 2020 2020 2020 2020 2d20 4c41  g:..        - LA
-000112c0: 5945 525f 4352 4541 5449 4f4e 3a20 6c61  YER_CREATION: la
-000112d0: 7965 7220 6372 6561 7469 6f6e 206f 7074  yer creation opt
-000112e0: 696f 6e20 286c 636f 290d 0a20 2020 2020  ion (lco)..     
-000112f0: 2020 202d 2044 4154 4153 4554 5f43 5245     - DATASET_CRE
-00011300: 4154 494f 4e3a 2064 6174 6173 6574 2063  ATION: dataset c
-00011310: 7265 6174 696f 6e20 6f70 7469 6f6e 2028  reation option (
-00011320: 6473 636f 290d 0a20 2020 2020 2020 202d  dsco)..        -
-00011330: 2049 4e50 5554 5f4f 5045 4e3a 2069 6e70   INPUT_OPEN: inp
-00011340: 7574 2064 6174 6173 6574 206f 7065 6e20  ut dataset open 
-00011350: 6f70 7469 6f6e 2028 6f6f 290d 0a20 2020  option (oo)..   
-00011360: 2020 2020 202d 2044 4553 5449 4e41 5449       - DESTINATI
-00011370: 4f4e 5f4f 5045 4e3a 2064 6573 7469 6e61  ON_OPEN: destina
-00011380: 7469 6f6e 2064 6174 6173 6574 206f 7065  tion dataset ope
-00011390: 6e20 6f70 7469 6f6e 2028 646f 6f29 0d0a  n option (doo)..
-000113a0: 2020 2020 2020 2020 2d20 434f 4e46 4947          - CONFIG
-000113b0: 3a20 636f 6e66 6967 206f 7074 696f 6e20  : config option 
-000113c0: 2863 6f6e 6669 6729 0d0a 0d0a 2020 2020  (config)....    
-000113d0: 5468 6520 6f70 7469 6f6e 7320 6361 6e20  The options can 
-000113e0: 6265 2066 6f75 6e64 2069 6e20 7468 6520  be found in the 
-000113f0: 5b47 4441 4c20 7665 6374 6f72 2064 7269  [GDAL vector dri
-00011400: 7665 7220 646f 6375 6d65 6e74 6174 696f  ver documentatio
-00011410: 6e5d 0d0a 2020 2020 2868 7474 7073 3a2f  n]..    (https:/
-00011420: 2f67 6461 6c2e 6f72 672f 6472 6976 6572  /gdal.org/driver
-00011430: 732f 7665 6374 6f72 2f69 6e64 6578 2e68  s/vector/index.h
-00011440: 746d 6c29 2e0d 0a0d 0a20 2020 2041 7267  tml).....    Arg
-00011450: 733a 0d0a 2020 2020 2020 2020 7372 6320  s:..        src 
-00011460: 2855 6e69 6f6e 5b73 7472 2c29 3a20 736f  (Union[str,): so
-00011470: 7572 6365 2066 696c 6520 7061 7468 2e0d  urce file path..
-00011480: 0a20 2020 2020 2020 2064 7374 2028 556e  .        dst (Un
-00011490: 696f 6e5b 7374 722c 293a 2064 6573 7469  ion[str,): desti
-000114a0: 6e61 7469 6f6e 2066 696c 6520 7061 7468  nation file path
-000114b0: 2e0d 0a20 2020 2020 2020 2073 7263 5f6c  ...        src_l
-000114c0: 6179 6572 2028 7374 722c 206f 7074 696f  ayer (str, optio
-000114d0: 6e61 6c29 3a20 736f 7572 6365 206c 6179  nal): source lay
-000114e0: 6572 2e20 4465 6661 756c 7473 2074 6f20  er. Defaults to 
-000114f0: 4e6f 6e65 2e0d 0a20 2020 2020 2020 2064  None...        d
-00011500: 7374 5f6c 6179 6572 2028 7374 722c 206f  st_layer (str, o
-00011510: 7074 696f 6e61 6c29 3a20 6465 7374 696e  ptional): destin
-00011520: 6174 696f 6e20 6c61 7965 722e 2044 6566  ation layer. Def
-00011530: 6175 6c74 7320 746f 204e 6f6e 652e 0d0a  aults to None...
-00011540: 2020 2020 2020 2020 7372 635f 6372 7320          src_crs 
-00011550: 2873 7472 2c20 6f70 7469 6f6e 616c 293a  (str, optional):
-00011560: 2061 6e20 6570 7367 2069 6e74 206f 7220   an epsg int or 
-00011570: 616e 7974 6869 6e67 2073 7570 706f 7274  anything support
-00011580: 6564 0d0a 2020 2020 2020 2020 2020 2020  ed..            
-00011590: 6279 2074 6865 204f 4752 5370 6174 6961  by the OGRSpatia
-000115a0: 6c52 6566 6572 656e 6365 2e53 6574 4672  lReference.SetFr
-000115b0: 6f6d 5573 6572 496e 7075 7428 2920 6361  omUserInput() ca
-000115c0: 6c6c 2c20 7768 6963 6820 696e 636c 7564  ll, which includ
-000115d0: 6573 0d0a 2020 2020 2020 2020 2020 2020  es..            
-000115e0: 616e 2045 5053 4720 7374 7269 6e67 2028  an EPSG string (
-000115f0: 6567 2e20 2245 5053 473a 3433 3236 2229  eg. "EPSG:4326")
-00011600: 2c20 6120 7765 6c6c 206b 6e6f 776e 2074  , a well known t
-00011610: 6578 7420 2857 4b54 2920 4352 530d 0a20  ext (WKT) CRS.. 
-00011620: 2020 2020 2020 2020 2020 2064 6566 696e             defin
-00011630: 6974 696f 6e2c 2e2e 2e20 4465 6661 756c  ition,... Defaul
-00011640: 7473 2074 6f20 4e6f 6e65 2e0d 0a20 2020  ts to None...   
-00011650: 2020 2020 2064 7374 5f63 7273 2028 7374       dst_crs (st
-00011660: 722c 206f 7074 696f 6e61 6c29 3a20 616e  r, optional): an
-00011670: 2065 7073 6720 696e 7420 6f72 2061 6e79   epsg int or any
-00011680: 7468 696e 6720 7375 7070 6f72 7465 640d  thing supported.
-00011690: 0a20 2020 2020 2020 2020 2020 2062 7920  .            by 
-000116a0: 7468 6520 4f47 5253 7061 7469 616c 5265  the OGRSpatialRe
-000116b0: 6665 7265 6e63 652e 5365 7446 726f 6d55  ference.SetFromU
-000116c0: 7365 7249 6e70 7574 2829 2063 616c 6c2c  serInput() call,
-000116d0: 2077 6869 6368 2069 6e63 6c75 6465 730d   which includes.
-000116e0: 0a20 2020 2020 2020 2020 2020 2061 6e20  .            an 
-000116f0: 4550 5347 2073 7472 696e 6720 2865 672e  EPSG string (eg.
-00011700: 2022 4550 5347 3a34 3332 3622 292c 2061   "EPSG:4326"), a
-00011710: 2077 656c 6c20 6b6e 6f77 6e20 7465 7874   well known text
-00011720: 2028 574b 5429 2043 5253 0d0a 2020 2020   (WKT) CRS..    
-00011730: 2020 2020 2020 2020 6465 6669 6e69 7469          definiti
-00011740: 6f6e 2c2e 2e2e 2044 6566 6175 6c74 7320  on,... Defaults 
-00011750: 746f 204e 6f6e 652e 0d0a 2020 2020 2020  to None...      
-00011760: 2020 7265 7072 6f6a 6563 7420 2862 6f6f    reproject (boo
-00011770: 6c2c 206f 7074 696f 6e61 6c29 3a20 5472  l, optional): Tr
-00011780: 7565 2074 6f20 7265 7072 6f6a 6563 7420  ue to reproject 
-00011790: 7768 696c 6520 636f 6e76 6572 7469 6e67  while converting
-000117a0: 2074 6865 0d0a 2020 2020 2020 2020 2020   the..          
-000117b0: 2020 6669 6c65 2e20 4465 6661 756c 7473    file. Defaults
-000117c0: 2074 6f20 4661 6c73 652e 0d0a 2020 2020   to False...    
-000117d0: 2020 2020 6578 706c 6f64 6563 6f6c 6c65      explodecolle
-000117e0: 6374 696f 6e73 2028 626f 6f6c 292c 206f  ctions (bool), o
-000117f0: 7074 696f 6e61 6c29 3a20 5472 7565 2074  ptional): True t
-00011800: 6f20 6f75 7470 7574 206f 6e6c 7920 7369  o output only si
-00011810: 6d70 6c65 2067 656f 6d65 7472 6965 732e  mple geometries.
-00011820: 0d0a 2020 2020 2020 2020 2020 2020 4465  ..            De
-00011830: 6661 756c 7473 2074 6f20 4661 6c73 652e  faults to False.
-00011840: 0d0a 2020 2020 2020 2020 666f 7263 655f  ..        force_
-00011850: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-00011860: 7970 6520 2855 6e69 6f6e 5b47 656f 6d65  ype (Union[Geome
-00011870: 7472 7954 7970 652c 2073 7472 5d2c 206f  tryType, str], o
-00011880: 7074 696f 6e61 6c29 3a20 4765 6f6d 6574  ptional): Geomet
-00011890: 7279 2074 7970 652e 0d0a 2020 2020 2020  ry type...      
-000118a0: 2020 2020 2020 746f 2028 7472 7920 746f        to (try to
-000118b0: 2920 666f 7263 6520 7468 6520 6f75 7470  ) force the outp
-000118c0: 7574 2074 6f2e 2044 6566 6175 6c74 7320  ut to. Defaults 
-000118d0: 746f 204e 6f6e 652e 0d0a 2020 2020 2020  to None...      
-000118e0: 2020 6372 6561 7465 5f73 7061 7469 616c    create_spatial
-000118f0: 5f69 6e64 6578 2028 626f 6f6c 2c20 6f70  _index (bool, op
-00011900: 7469 6f6e 616c 293a 2054 7275 6520 746f  tional): True to
-00011910: 2063 7265 6174 6520 6120 7370 6174 6961   create a spatia
-00011920: 6c20 696e 6465 780d 0a20 2020 2020 2020  l index..       
-00011930: 2020 2020 206f 6e20 7468 6520 6465 7374       on the dest
-00011940: 696e 6174 696f 6e20 6669 6c65 2f6c 6179  ination file/lay
-00011950: 6572 2e20 4966 204e 6f6e 652c 2074 6865  er. If None, the
-00011960: 2064 6566 6175 6c74 2062 6568 6176 696f   default behavio
-00011970: 7572 2062 7920 6764 616c 2066 6f72 0d0a  ur by gdal for..
-00011980: 2020 2020 2020 2020 2020 2020 7468 6174              that
-00011990: 2066 696c 6520 7479 7065 2069 7320 7265   file type is re
-000119a0: 7370 6563 7465 642e 2049 6620 7468 6520  spected. If the 
-000119b0: 4c41 5945 525f 4352 4541 5449 4f4e 2e53  LAYER_CREATION.S
-000119c0: 5041 5449 414c 5f49 4e44 4558 0d0a 2020  PATIAL_INDEX..  
-000119d0: 2020 2020 2020 2020 2020 7061 7261 6d65            parame
-000119e0: 7465 7220 6973 2073 7065 6369 6669 6564  ter is specified
-000119f0: 2069 6e20 6f70 7469 6f6e 732c 2063 7265   in options, cre
-00011a00: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
-00011a10: 7820 6973 2069 676e 6f72 6564 2e0d 0a20  x is ignored... 
-00011a20: 2020 2020 2020 2020 2020 2044 6566 6175             Defau
-00011a30: 6c74 7320 746f 2054 7275 652e 0d0a 2020  lts to True...  
-00011a40: 2020 2020 2020 6170 7065 6e64 5f74 696d        append_tim
-00011a50: 656f 7574 5f73 2028 696e 742c 206f 7074  eout_s (int, opt
-00011a60: 696f 6e61 6c29 3a20 7469 6d65 6f75 7420  ional): timeout 
-00011a70: 746f 2075 7365 2069 6620 7468 6520 6f75  to use if the ou
-00011a80: 7470 7574 2066 696c 6520 6973 0d0a 2020  tput file is..  
-00011a90: 2020 2020 2020 2020 2020 6265 696e 6720            being 
-00011aa0: 7772 6974 7465 6e20 746f 2062 7920 616e  written to by an
-00011ab0: 6f74 6865 7220 7072 6f63 6573 7320 616c  other process al
-00011ac0: 7265 6164 792e 2044 6566 6175 6c74 7320  ready. Defaults 
-00011ad0: 746f 2036 3030 2e0d 0a20 2020 2020 2020  to 600...       
-00011ae0: 2074 7261 6e73 6163 7469 6f6e 5f73 697a   transaction_siz
-00011af0: 6520 2869 6e74 2c20 6f70 7469 6f6e 616c  e (int, optional
-00011b00: 293a 2054 7261 6e73 6163 7469 6f6e 2073  ): Transaction s
-00011b10: 697a 652e 0d0a 2020 2020 2020 2020 2020  ize...          
-00011b20: 2020 4465 6661 756c 7473 2074 6f20 3530    Defaults to 50
-00011b30: 3030 302e 0d0a 2020 2020 2020 2020 7072  000...        pr
-00011b40: 6573 6572 7665 5f66 6964 2028 626f 6f6c  eserve_fid (bool
-00011b50: 2c20 6f70 7469 6f6e 616c 293a 2054 7275  , optional): Tru
-00011b60: 6520 746f 206d 616b 6520 616e 2065 7874  e to make an ext
-00011b70: 7261 2065 6666 6f72 7420 746f 2070 7265  ra effort to pre
-00011b80: 7365 7276 6520 6669 6427 7320 6f66 0d0a  serve fid's of..
-00011b90: 2020 2020 2020 2020 2020 2020 7468 6520              the 
-00011ba0: 736f 7572 6365 206c 6179 6572 2074 6f20  source layer to 
-00011bb0: 7468 6520 6465 7374 696e 6174 696f 6e20  the destination 
-00011bc0: 6c61 7965 722e 2046 616c 7365 206e 6f74  layer. False not
-00011bd0: 2074 6f20 646f 2061 6e79 2065 6666 6f72   to do any effor
-00011be0: 742e 204e 6f6e 650d 0a20 2020 2020 2020  t. None..       
-00011bf0: 2020 2020 2074 6f20 7573 6520 7468 6520       to use the 
-00011c00: 6465 6661 756c 7420 6265 6861 7669 6f75  default behaviou
-00011c10: 7220 6f66 2067 6461 6c2c 2074 6861 7420  r of gdal, that 
-00011c20: 616c 7265 6164 7920 7072 6573 6572 7665  already preserve
-00011c30: 7320 696e 2073 6f6d 6520 6361 7365 732e  s in some cases.
-00011c40: 0d0a 2020 2020 2020 2020 2020 2020 536f  ..            So
-00011c50: 6d65 2066 696c 6520 666f 726d 6174 7320  me file formats 
-00011c60: 646f 6e27 7420 6578 706c 6963 6974 6c79  don't explicitly
-00011c70: 2073 746f 7265 2074 6865 2066 6964 2028   store the fid (
-00011c80: 652e 672e 2073 6861 7065 6669 6c65 292c  e.g. shapefile),
-00011c90: 2073 6f20 7468 6579 0d0a 2020 2020 2020   so they..      
-00011ca0: 2020 2020 2020 7769 6c6c 206e 6576 6572        will never
-00011cb0: 2062 6520 6162 6c65 2074 6f20 7072 6573   be able to pres
-00011cc0: 6572 7665 2066 6964 732e 2044 6566 6175  erve fids. Defau
-00011cd0: 6c74 7320 746f 204e 6f6e 652e 0d0a 2020  lts to None...  
-00011ce0: 2020 2020 2020 6f70 7469 6f6e 7320 2864        options (d
-00011cf0: 6963 742c 206f 7074 696f 6e61 6c29 3a20  ict, optional): 
-00011d00: 6f70 7469 6f6e 7320 746f 2070 6173 7320  options to pass 
-00011d10: 746f 2067 6461 6c2e 0d0a 0d0a 2020 2020  to gdal.....    
-00011d20: 5261 6973 6573 3a0d 0a20 2020 2020 2020  Raises:..       
-00011d30: 2056 616c 7565 4572 726f 723a 2061 6e20   ValueError: an 
-00011d40: 696e 7661 6c69 6420 7061 7261 6d65 7465  invalid paramete
-00011d50: 7220 7661 6c75 6520 7761 7320 7061 7373  r value was pass
-00011d60: 6564 2e0d 0a20 2020 2020 2020 2052 756e  ed...        Run
-00011d70: 7469 6d65 4572 726f 723a 2074 696d 656f  timeError: timeo
-00011d80: 7574 2077 6173 2072 6561 6368 6564 2077  ut was reached w
-00011d90: 6869 6c65 2074 7279 696e 6720 746f 2061  hile trying to a
-00011da0: 7070 656e 6420 6461 7461 2074 6f20 7061  ppend data to pa
-00011db0: 7468 2e0d 0a20 2020 2022 2222 0d0a 2020  th...    """..  
-00011dc0: 2020 2320 4368 6563 6b2f 636c 6561 6e20    # Check/clean 
-00011dd0: 696e 7075 7420 7061 7261 6d73 0d0a 2020  input params..  
-00011de0: 2020 7372 6320 3d20 5061 7468 2873 7263    src = Path(src
-00011df0: 290d 0a20 2020 2064 7374 203d 2050 6174  )..    dst = Pat
-00011e00: 6828 6473 7429 0d0a 2020 2020 6966 2066  h(dst)..    if f
-00011e10: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-00011e20: 6574 7279 7479 7065 2069 7320 6e6f 7420  etrytype is not 
-00011e30: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2066  None:..        f
-00011e40: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-00011e50: 6574 7279 7479 7065 203d 2047 656f 6d65  etrytype = Geome
-00011e60: 7472 7954 7970 6528 666f 7263 655f 6f75  tryType(force_ou
-00011e70: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
-00011e80: 6529 0d0a 0d0a 2020 2020 2320 4669 6c65  e)....    # File
-00011e90: 7320 646f 6e27 7420 7479 7069 6361 6c6c  s don't typicall
-00011ea0: 7920 7375 7070 6f72 7420 6861 7669 6e67  y support having
-00011eb0: 206d 756c 7469 706c 6520 7072 6f63 6573   multiple proces
-00011ec0: 7365 7320 7772 6974 696e 670d 0a20 2020  ses writing..   
-00011ed0: 2023 2073 696d 756c 7461 6e6f 7573 6c79   # simultanously
-00011ee0: 2074 6f20 7468 656d 2c20 736f 2075 7365   to them, so use
-00011ef0: 206c 6f63 6b20 6669 6c65 2074 6f20 7379   lock file to sy
-00011f00: 6e63 6872 6f6e 697a 6520 6163 6365 7373  nchronize access
-00011f10: 2e0d 0a20 2020 206c 6f63 6b66 696c 6520  ...    lockfile 
-00011f20: 3d20 5061 7468 2866 227b 7374 7228 6473  = Path(f"{str(ds
-00011f30: 7429 7d2e 6c6f 636b 2229 0d0a 0d0a 2020  t)}.lock")....  
-00011f40: 2020 2320 4966 2074 6865 2064 6573 7469    # If the desti
-00011f50: 6e61 7469 6f6e 2066 696c 6520 646f 6573  nation file does
-00011f60: 6e27 7420 6578 6973 7420 7965 742c 2062  n't exist yet, b
-00011f70: 7574 2074 6865 206c 6f63 6b66 696c 6520  ut the lockfile 
-00011f80: 646f 6573 2c0d 0a20 2020 2023 2074 7279  does,..    # try
-00011f90: 2072 656d 6f76 696e 6720 7468 6520 6c6f   removing the lo
-00011fa0: 636b 6669 6c65 2061 7320 6974 206d 6967  ckfile as it mig
-00011fb0: 6874 2062 6520 6120 6768 6f73 7420 6c6f  ht be a ghost lo
-00011fc0: 636b 6669 6c65 2e0d 0a20 2020 2069 6620  ckfile...    if 
-00011fd0: 6e6f 7420 6473 742e 6578 6973 7473 2829  not dst.exists()
-00011fe0: 2061 6e64 206c 6f63 6b66 696c 652e 6578   and lockfile.ex
-00011ff0: 6973 7473 2829 3a0d 0a20 2020 2020 2020  ists():..       
-00012000: 2074 7279 3a0d 0a20 2020 2020 2020 2020   try:..         
-00012010: 2020 206c 6f63 6b66 696c 652e 756e 6c69     lockfile.unli
-00012020: 6e6b 2829 0d0a 2020 2020 2020 2020 6578  nk()..        ex
-00012030: 6365 7074 2045 7863 6570 7469 6f6e 3a0d  cept Exception:.
-00012040: 0a20 2020 2020 2020 2020 2020 205f 203d  .            _ =
-00012050: 204e 6f6e 650d 0a0d 0a20 2020 2023 2043   None....    # C
-00012060: 7265 6174 696e 6720 6c6f 636b 6669 6c65  reating lockfile
-00012070: 2061 6e64 2061 7070 656e 640d 0a20 2020   and append..   
-00012080: 2073 7461 7274 5f74 696d 6520 3d20 6461   start_time = da
-00012090: 7465 7469 6d65 2e64 6174 6574 696d 652e  tetime.datetime.
-000120a0: 6e6f 7728 290d 0a20 2020 2072 6561 6479  now()..    ready
-000120b0: 203d 2046 616c 7365 0d0a 2020 2020 7768   = False..    wh
-000120c0: 696c 6520 6e6f 7420 7265 6164 793a 0d0a  ile not ready:..
-000120d0: 2020 2020 2020 2020 6966 205f 696f 5f75          if _io_u
-000120e0: 7469 6c2e 6372 6561 7465 5f66 696c 655f  til.create_file_
-000120f0: 6174 6f6d 6963 286c 6f63 6b66 696c 6529  atomic(lockfile)
-00012100: 2069 7320 5472 7565 3a0d 0a20 2020 2020   is True:..     
-00012110: 2020 2020 2020 2074 7279 3a0d 0a20 2020         try:..   
-00012120: 2020 2020 2020 2020 2020 2020 2023 2061               # a
-00012130: 7070 656e 640d 0a20 2020 2020 2020 2020  ppend..         
-00012140: 2020 2020 2020 205f 6170 7065 6e64 5f74         _append_t
-00012150: 6f5f 6e6f 6c6f 636b 280d 0a20 2020 2020  o_nolock(..     
-00012160: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00012170: 7263 3d73 7263 2c0d 0a20 2020 2020 2020  rc=src,..       
-00012180: 2020 2020 2020 2020 2020 2020 2064 7374               dst
-00012190: 3d64 7374 2c0d 0a20 2020 2020 2020 2020  =dst,..         
-000121a0: 2020 2020 2020 2020 2020 2073 7263 5f6c             src_l
-000121b0: 6179 6572 3d73 7263 5f6c 6179 6572 2c0d  ayer=src_layer,.
-000121c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000121d0: 2020 2020 2064 7374 5f6c 6179 6572 3d64       dst_layer=d
-000121e0: 7374 5f6c 6179 6572 2c0d 0a20 2020 2020  st_layer,..     
-000121f0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00012200: 7263 5f63 7273 3d73 7263 5f63 7273 2c0d  rc_crs=src_crs,.
-00012210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012220: 2020 2020 2064 7374 5f63 7273 3d64 7374       dst_crs=dst
-00012230: 5f63 7273 2c0d 0a20 2020 2020 2020 2020  _crs,..         
-00012240: 2020 2020 2020 2020 2020 2072 6570 726f             repro
-00012250: 6a65 6374 3d72 6570 726f 6a65 6374 2c0d  ject=reproject,.
-00012260: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012270: 2020 2020 2065 7870 6c6f 6465 636f 6c6c       explodecoll
-00012280: 6563 7469 6f6e 733d 6578 706c 6f64 6563  ections=explodec
-00012290: 6f6c 6c65 6374 696f 6e73 2c0d 0a20 2020  ollections,..   
-000122a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000122b0: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
-000122c0: 6f6d 6574 7279 7479 7065 3d66 6f72 6365  ometrytype=force
-000122d0: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
-000122e0: 7479 7065 2c0d 0a20 2020 2020 2020 2020  type,..         
-000122f0: 2020 2020 2020 2020 2020 2063 7265 6174             creat
-00012300: 655f 7370 6174 6961 6c5f 696e 6465 783d  e_spatial_index=
-00012310: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
-00012320: 6e64 6578 2c0d 0a20 2020 2020 2020 2020  ndex,..         
-00012330: 2020 2020 2020 2020 2020 2074 7261 6e73             trans
-00012340: 6163 7469 6f6e 5f73 697a 653d 7472 616e  action_size=tran
-00012350: 7361 6374 696f 6e5f 7369 7a65 2c0d 0a20  saction_size,.. 
-00012360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012370: 2020 2070 7265 7365 7276 655f 6669 643d     preserve_fid=
-00012380: 7072 6573 6572 7665 5f66 6964 2c0d 0a20  preserve_fid,.. 
-00012390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000123a0: 2020 206f 7074 696f 6e73 3d6f 7074 696f     options=optio
-000123b0: 6e73 2c0d 0a20 2020 2020 2020 2020 2020  ns,..           
-000123c0: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-000123d0: 2020 2020 6669 6e61 6c6c 793a 0d0a 2020      finally:..  
-000123e0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-000123f0: 6164 7920 3d20 5472 7565 0d0a 2020 2020  ady = True..    
-00012400: 2020 2020 2020 2020 2020 2020 6c6f 636b              lock
-00012410: 6669 6c65 2e75 6e6c 696e 6b28 290d 0a20  file.unlink().. 
-00012420: 2020 2020 2020 2065 6c73 653a 0d0a 2020         else:..  
-00012430: 2020 2020 2020 2020 2020 7469 6d65 5f77            time_w
-00012440: 6169 7469 6e67 203d 2028 6461 7465 7469  aiting = (dateti
-00012450: 6d65 2e64 6174 6574 696d 652e 6e6f 7728  me.datetime.now(
-00012460: 2920 2d20 7374 6172 745f 7469 6d65 292e  ) - start_time).
-00012470: 746f 7461 6c5f 7365 636f 6e64 7328 290d  total_seconds().
-00012480: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00012490: 7469 6d65 5f77 6169 7469 6e67 203e 2061  time_waiting > a
-000124a0: 7070 656e 645f 7469 6d65 6f75 745f 733a  ppend_timeout_s:
-000124b0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000124c0: 2020 7261 6973 6520 5275 6e74 696d 6545    raise RuntimeE
-000124d0: 7272 6f72 280d 0a20 2020 2020 2020 2020  rror(..         
-000124e0: 2020 2020 2020 2020 2020 2066 2261 7070             f"app
-000124f0: 656e 645f 746f 2074 696d 656f 7574 206f  end_to timeout o
-00012500: 6620 7b61 7070 656e 645f 7469 6d65 6f75  f {append_timeou
-00012510: 745f 737d 2072 6561 6368 6564 2c20 736f  t_s} reached, so
-00012520: 2073 746f 7020 7772 6974 6520 220d 0a20   stop write ".. 
-00012530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012540: 2020 2066 2274 6f20 7b64 7374 7d21 220d     f"to {dst}!".
-00012550: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012560: 2029 0d0a 0d0a 2020 2020 2020 2020 2320   )....        # 
-00012570: 536c 6565 7020 666f 7220 6120 7365 636f  Sleep for a seco
-00012580: 6e64 2062 6566 6f72 6520 7472 7969 6e67  nd before trying
-00012590: 2061 6761 696e 0d0a 2020 2020 2020 2020   again..        
-000125a0: 7469 6d65 2e73 6c65 6570 2831 290d 0a0d  time.sleep(1)...
-000125b0: 0a0d 0a64 6566 205f 6170 7065 6e64 5f74  ...def _append_t
-000125c0: 6f5f 6e6f 6c6f 636b 280d 0a20 2020 2073  o_nolock(..    s
-000125d0: 7263 3a20 5061 7468 2c0d 0a20 2020 2064  rc: Path,..    d
-000125e0: 7374 3a20 5061 7468 2c0d 0a20 2020 2073  st: Path,..    s
-000125f0: 7263 5f6c 6179 6572 3a20 4f70 7469 6f6e  rc_layer: Option
-00012600: 616c 5b73 7472 5d20 3d20 4e6f 6e65 2c0d  al[str] = None,.
-00012610: 0a20 2020 2064 7374 5f6c 6179 6572 3a20  .    dst_layer: 
-00012620: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
-00012630: 4e6f 6e65 2c0d 0a20 2020 2073 7263 5f63  None,..    src_c
-00012640: 7273 3a20 556e 696f 6e5b 696e 742c 2073  rs: Union[int, s
-00012650: 7472 2c20 4e6f 6e65 5d20 3d20 4e6f 6e65  tr, None] = None
-00012660: 2c0d 0a20 2020 2064 7374 5f63 7273 3a20  ,..    dst_crs: 
-00012670: 556e 696f 6e5b 696e 742c 2073 7472 2c20  Union[int, str, 
-00012680: 4e6f 6e65 5d20 3d20 4e6f 6e65 2c0d 0a20  None] = None,.. 
-00012690: 2020 2072 6570 726f 6a65 6374 3a20 626f     reproject: bo
-000126a0: 6f6c 203d 2046 616c 7365 2c0d 0a20 2020  ol = False,..   
-000126b0: 2065 7870 6c6f 6465 636f 6c6c 6563 7469   explodecollecti
-000126c0: 6f6e 733a 2062 6f6f 6c20 3d20 4661 6c73  ons: bool = Fals
-000126d0: 652c 0d0a 2020 2020 6372 6561 7465 5f73  e,..    create_s
-000126e0: 7061 7469 616c 5f69 6e64 6578 3a20 4f70  patial_index: Op
-000126f0: 7469 6f6e 616c 5b62 6f6f 6c5d 203d 2054  tional[bool] = T
-00012700: 7275 652c 0d0a 2020 2020 666f 7263 655f  rue,..    force_
-00012710: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-00012720: 7970 653a 2055 6e69 6f6e 5b47 656f 6d65  ype: Union[Geome
-00012730: 7472 7954 7970 652c 2073 7472 2c20 4e6f  tryType, str, No
-00012740: 6e65 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  ne] = None,..   
-00012750: 2074 7261 6e73 6163 7469 6f6e 5f73 697a   transaction_siz
-00012760: 653a 2069 6e74 203d 2035 3030 3030 2c0d  e: int = 50000,.
-00012770: 0a20 2020 2070 7265 7365 7276 655f 6669  .    preserve_fi
-00012780: 643a 204f 7074 696f 6e61 6c5b 626f 6f6c  d: Optional[bool
-00012790: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 206f  ] = None,..    o
-000127a0: 7074 696f 6e73 3a20 6469 6374 203d 207b  ptions: dict = {
-000127b0: 7d2c 0d0a 293a 0d0a 2020 2020 2320 4368  },..):..    # Ch
-000127c0: 6563 6b2f 636c 6561 6e20 696e 7075 7420  eck/clean input 
-000127d0: 7061 7261 6d73 0d0a 2020 2020 6f70 7469  params..    opti
-000127e0: 6f6e 7320 3d20 5f6f 6772 5f75 7469 6c2e  ons = _ogr_util.
-000127f0: 5f70 7265 7061 7265 5f67 6461 6c5f 6f70  _prepare_gdal_op
-00012800: 7469 6f6e 7328 6f70 7469 6f6e 7329 0d0a  tions(options)..
-00012810: 2020 2020 6966 2028 0d0a 2020 2020 2020      if (..      
-00012820: 2020 6372 6561 7465 5f73 7061 7469 616c    create_spatial
-00012830: 5f69 6e64 6578 2069 7320 6e6f 7420 4e6f  _index is not No
-00012840: 6e65 0d0a 2020 2020 2020 2020 616e 6420  ne..        and 
-00012850: 224c 4159 4552 5f43 5245 4154 494f 4e2e  "LAYER_CREATION.
-00012860: 5350 4154 4941 4c5f 494e 4445 5822 206e  SPATIAL_INDEX" n
-00012870: 6f74 2069 6e20 6f70 7469 6f6e 730d 0a20  ot in options.. 
-00012880: 2020 2029 3a0d 0a20 2020 2020 2020 206f     ):..        o
-00012890: 7074 696f 6e73 5b22 4c41 5945 525f 4352  ptions["LAYER_CR
-000128a0: 4541 5449 4f4e 2e53 5041 5449 414c 5f49  EATION.SPATIAL_I
-000128b0: 4e44 4558 225d 203d 2063 7265 6174 655f  NDEX"] = create_
-000128c0: 7370 6174 6961 6c5f 696e 6465 780d 0a0d  spatial_index...
-000128d0: 0a20 2020 2023 2057 6865 6e20 6372 6561  .    # When crea
-000128e0: 7469 6e67 2f61 7070 656e 6469 6e67 2074  ting/appending t
-000128f0: 6f20 6120 7368 6170 6566 696c 652c 206c  o a shapefile, l
-00012900: 6175 6e64 6572 2074 6865 2063 6f6c 756d  aunder the colum
-00012910: 6e73 206e 616d 6573 2076 6961 0d0a 2020  ns names via..  
-00012920: 2020 2320 6120 7371 6c20 7374 6174 656d    # a sql statem
-00012930: 656e 742c 206f 7468 6572 7769 7365 2077  ent, otherwise w
-00012940: 6865 6e20 6170 7065 6e64 696e 6720 7468  hen appending th
-00012950: 6520 6c61 756e 6465 7265 6420 636f 6c75  e laundered colu
-00012960: 6d6e 7320 7769 6c6c 0d0a 2020 2020 2320  mns will..    # 
-00012970: 6765 7420 4e55 4c4c 2076 616c 7565 7320  get NULL values 
-00012980: 696e 7374 6561 6420 6f66 2074 6865 2064  instead of the d
-00012990: 6174 612e 0d0a 2020 2020 7371 6c5f 7374  ata...    sql_st
-000129a0: 6d74 203d 204e 6f6e 650d 0a20 2020 2073  mt = None..    s
-000129b0: 7263 5f6c 6179 6572 696e 666f 203d 204e  rc_layerinfo = N
-000129c0: 6f6e 650d 0a20 2020 2069 6620 6473 742e  one..    if dst.
-000129d0: 7375 6666 6978 2e6c 6f77 6572 2829 203d  suffix.lower() =
-000129e0: 3d20 222e 7368 7022 3a0d 0a20 2020 2020  = ".shp":..     
-000129f0: 2020 2073 7263 5f6c 6179 6572 696e 666f     src_layerinfo
-00012a00: 203d 2067 6574 5f6c 6179 6572 696e 666f   = get_layerinfo
-00012a10: 2873 7263 2c20 7372 635f 6c61 7965 7229  (src, src_layer)
-00012a20: 0d0a 2020 2020 2020 2020 7372 635f 636f  ..        src_co
-00012a30: 6c75 6d6e 7320 3d20 7372 635f 6c61 7965  lumns = src_laye
-00012a40: 7269 6e66 6f2e 636f 6c75 6d6e 730d 0a20  rinfo.columns.. 
-00012a50: 2020 2020 2020 2063 6f6c 756d 6e73 5f6c         columns_l
-00012a60: 6175 6e64 6572 6564 203d 205f 6c61 756e  aundered = _laun
-00012a70: 6465 725f 636f 6c75 6d6e 5f6e 616d 6573  der_column_names
-00012a80: 2873 7263 5f63 6f6c 756d 6e73 290d 0a20  (src_columns).. 
-00012a90: 2020 2020 2020 2063 6f6c 756d 6e73 5f61         columns_a
-00012aa0: 6c69 6173 6564 203d 205b 0d0a 2020 2020  liased = [..    
-00012ab0: 2020 2020 2020 2020 6627 227b 636f 6c75          f'"{colu
-00012ac0: 6d6e 7d22 2041 5320 227b 6c61 756e 6465  mn}" AS "{launde
-00012ad0: 7265 647d 2227 2066 6f72 2063 6f6c 756d  red}"' for colum
-00012ae0: 6e2c 206c 6175 6e64 6572 6564 2069 6e20  n, laundered in 
-00012af0: 636f 6c75 6d6e 735f 6c61 756e 6465 7265  columns_laundere
-00012b00: 640d 0a20 2020 2020 2020 205d 0d0a 2020  d..        ]..  
-00012b10: 2020 2020 2020 6c61 7965 7220 3d20 7372        layer = sr
-00012b20: 635f 6c61 7965 7220 6966 2073 7263 5f6c  c_layer if src_l
-00012b30: 6179 6572 2069 7320 6e6f 7420 4e6f 6e65  ayer is not None
-00012b40: 2065 6c73 6520 6765 745f 6f6e 6c79 5f6c   else get_only_l
-00012b50: 6179 6572 2873 7263 290d 0a20 2020 2020  ayer(src)..     
-00012b60: 2020 2073 716c 5f73 746d 7420 3d20 6627     sql_stmt = f'
-00012b70: 5345 4c45 4354 207b 222c 2022 2e6a 6f69  SELECT {", ".joi
-00012b80: 6e28 636f 6c75 6d6e 735f 616c 6961 7365  n(columns_aliase
-00012b90: 6429 7d20 4652 4f4d 2022 7b6c 6179 6572  d)} FROM "{layer
-00012ba0: 7d22 270d 0a0d 0a20 2020 2023 2057 6865  }"'....    # Whe
-00012bb0: 6e20 6473 7420 6669 6c65 2064 6f65 736e  n dst file doesn
-00012bc0: 2774 2065 7869 7374 2061 6e64 2073 7263  't exist and src
-00012bd0: 2069 7320 656d 7074 7920 666f 7263 655f   is empty force_
-00012be0: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-00012bf0: 7970 6520 7368 6f75 6c64 2062 650d 0a20  ype should be.. 
-00012c00: 2020 2023 2073 7065 6369 6669 6564 2c20     # specified, 
-00012c10: 6f74 6865 7277 6973 6520 696e 7661 6c69  otherwise invali
-00012c20: 6420 6f75 7470 7574 2e0d 0a20 2020 2069  d output...    i
-00012c30: 6620 666f 7263 655f 6f75 7470 7574 5f67  f force_output_g
-00012c40: 656f 6d65 7472 7974 7970 6520 6973 204e  eometrytype is N
-00012c50: 6f6e 6520 616e 6420 6e6f 7420 6473 742e  one and not dst.
-00012c60: 6578 6973 7473 2829 3a0d 0a20 2020 2020  exists():..     
-00012c70: 2020 2069 6620 7372 635f 6c61 7965 7269     if src_layeri
-00012c80: 6e66 6f20 6973 204e 6f6e 653a 0d0a 2020  nfo is None:..  
-00012c90: 2020 2020 2020 2020 2020 7372 635f 6c61            src_la
-00012ca0: 7965 7269 6e66 6f20 3d20 6765 745f 6c61  yerinfo = get_la
-00012cb0: 7965 7269 6e66 6f28 7372 632c 2073 7263  yerinfo(src, src
-00012cc0: 5f6c 6179 6572 290d 0a20 2020 2020 2020  _layer)..       
-00012cd0: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
-00012ce0: 6f6d 6574 7279 7479 7065 203d 2073 7263  ometrytype = src
-00012cf0: 5f6c 6179 6572 696e 666f 2e67 656f 6d65  _layerinfo.geome
-00012d00: 7472 7974 7970 650d 0a0d 0a20 2020 2023  trytype....    #
-00012d10: 2047 6f21 0d0a 2020 2020 7472 616e 736c   Go!..    transl
-00012d20: 6174 655f 696e 666f 203d 205f 6f67 725f  ate_info = _ogr_
-00012d30: 7574 696c 2e56 6563 746f 7254 7261 6e73  util.VectorTrans
-00012d40: 6c61 7465 496e 666f 280d 0a20 2020 2020  lateInfo(..     
-00012d50: 2020 2069 6e70 7574 5f70 6174 683d 7372     input_path=sr
-00012d60: 632c 0d0a 2020 2020 2020 2020 6f75 7470  c,..        outp
-00012d70: 7574 5f70 6174 683d 6473 742c 0d0a 2020  ut_path=dst,..  
-00012d80: 2020 2020 2020 696e 7075 745f 6c61 7965        input_laye
-00012d90: 7273 3d73 7263 5f6c 6179 6572 2c0d 0a20  rs=src_layer,.. 
-00012da0: 2020 2020 2020 206f 7574 7075 745f 6c61         output_la
-00012db0: 7965 723d 6473 745f 6c61 7965 722c 0d0a  yer=dst_layer,..
-00012dc0: 2020 2020 2020 2020 696e 7075 745f 7372          input_sr
-00012dd0: 733d 7372 635f 6372 732c 0d0a 2020 2020  s=src_crs,..    
-00012de0: 2020 2020 6f75 7470 7574 5f73 7273 3d64      output_srs=d
-00012df0: 7374 5f63 7273 2c0d 0a20 2020 2020 2020  st_crs,..       
-00012e00: 2073 716c 5f73 746d 743d 7371 6c5f 7374   sql_stmt=sql_st
-00012e10: 6d74 2c0d 0a20 2020 2020 2020 2073 716c  mt,..        sql
-00012e20: 5f64 6961 6c65 6374 3d22 4f47 5253 514c  _dialect="OGRSQL
-00012e30: 222c 0d0a 2020 2020 2020 2020 7265 7072  ",..        repr
-00012e40: 6f6a 6563 743d 7265 7072 6f6a 6563 742c  oject=reproject,
-00012e50: 0d0a 2020 2020 2020 2020 7472 616e 7361  ..        transa
-00012e60: 6374 696f 6e5f 7369 7a65 3d74 7261 6e73  ction_size=trans
-00012e70: 6163 7469 6f6e 5f73 697a 652c 0d0a 2020  action_size,..  
-00012e80: 2020 2020 2020 6170 7065 6e64 3d54 7275        append=Tru
-00012e90: 652c 0d0a 2020 2020 2020 2020 7570 6461  e,..        upda
-00012ea0: 7465 3d54 7275 652c 0d0a 2020 2020 2020  te=True,..      
-00012eb0: 2020 6578 706c 6f64 6563 6f6c 6c65 6374    explodecollect
-00012ec0: 696f 6e73 3d65 7870 6c6f 6465 636f 6c6c  ions=explodecoll
-00012ed0: 6563 7469 6f6e 732c 0d0a 2020 2020 2020  ections,..      
-00012ee0: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
-00012ef0: 656f 6d65 7472 7974 7970 653d 666f 7263  eometrytype=forc
-00012f00: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-00012f10: 7974 7970 652c 0d0a 2020 2020 2020 2020  ytype,..        
-00012f20: 6f70 7469 6f6e 733d 6f70 7469 6f6e 732c  options=options,
-00012f30: 0d0a 2020 2020 2020 2020 7072 6573 6572  ..        preser
-00012f40: 7665 5f66 6964 3d70 7265 7365 7276 655f  ve_fid=preserve_
-00012f50: 6669 642c 0d0a 2020 2020 290d 0a20 2020  fid,..    )..   
-00012f60: 205f 6f67 725f 7574 696c 2e76 6563 746f   _ogr_util.vecto
-00012f70: 725f 7472 616e 736c 6174 655f 6279 5f69  r_translate_by_i
-00012f80: 6e66 6f28 696e 666f 3d74 7261 6e73 6c61  nfo(info=transla
-00012f90: 7465 5f69 6e66 6f29 0d0a 0d0a 0d0a 6465  te_info)......de
-00012fa0: 6620 636f 6e76 6572 7428 0d0a 2020 2020  f convert(..    
-00012fb0: 7372 633a 2055 6e69 6f6e 5b73 7472 2c20  src: Union[str, 
-00012fc0: 226f 732e 5061 7468 4c69 6b65 5b41 6e79  "os.PathLike[Any
-00012fd0: 5d22 5d2c 0d0a 2020 2020 6473 743a 2055  ]"],..    dst: U
-00012fe0: 6e69 6f6e 5b73 7472 2c20 226f 732e 5061  nion[str, "os.Pa
-00012ff0: 7468 4c69 6b65 5b41 6e79 5d22 5d2c 0d0a  thLike[Any]"],..
-00013000: 2020 2020 7372 635f 6c61 7965 723a 204f      src_layer: O
-00013010: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
-00013020: 6f6e 652c 0d0a 2020 2020 6473 745f 6c61  one,..    dst_la
-00013030: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
-00013040: 725d 203d 204e 6f6e 652c 0d0a 2020 2020  r] = None,..    
-00013050: 7372 635f 6372 733a 2055 6e69 6f6e 5b73  src_crs: Union[s
-00013060: 7472 2c20 696e 742c 204e 6f6e 655d 203d  tr, int, None] =
-00013070: 204e 6f6e 652c 0d0a 2020 2020 6473 745f   None,..    dst_
-00013080: 6372 733a 2055 6e69 6f6e 5b73 7472 2c20  crs: Union[str, 
-00013090: 696e 742c 204e 6f6e 655d 203d 204e 6f6e  int, None] = Non
-000130a0: 652c 0d0a 2020 2020 7265 7072 6f6a 6563  e,..    reprojec
-000130b0: 743a 2062 6f6f 6c20 3d20 4661 6c73 652c  t: bool = False,
-000130c0: 0d0a 2020 2020 6578 706c 6f64 6563 6f6c  ..    explodecol
-000130d0: 6c65 6374 696f 6e73 3a20 626f 6f6c 203d  lections: bool =
-000130e0: 2046 616c 7365 2c0d 0a20 2020 2066 6f72   False,..    for
-000130f0: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-00013100: 7279 7479 7065 3a20 556e 696f 6e5b 4765  rytype: Union[Ge
-00013110: 6f6d 6574 7279 5479 7065 2c20 7374 722c  ometryType, str,
-00013120: 204e 6f6e 655d 203d 204e 6f6e 652c 0d0a   None] = None,..
-00013130: 2020 2020 6372 6561 7465 5f73 7061 7469      create_spati
-00013140: 616c 5f69 6e64 6578 3a20 4f70 7469 6f6e  al_index: Option
-00013150: 616c 5b62 6f6f 6c5d 203d 2054 7275 652c  al[bool] = True,
-00013160: 0d0a 2020 2020 7072 6573 6572 7665 5f66  ..    preserve_f
-00013170: 6964 3a20 4f70 7469 6f6e 616c 5b62 6f6f  id: Optional[boo
-00013180: 6c5d 203d 204e 6f6e 652c 0d0a 2020 2020  l] = None,..    
-00013190: 6f70 7469 6f6e 733a 2064 6963 7420 3d20  options: dict = 
-000131a0: 7b7d 2c0d 0a20 2020 2061 7070 656e 643a  {},..    append:
-000131b0: 2062 6f6f 6c20 3d20 4661 6c73 652c 0d0a   bool = False,..
-000131c0: 2020 2020 666f 7263 653a 2062 6f6f 6c20      force: bool 
-000131d0: 3d20 4661 6c73 652c 0d0a 293a 0d0a 2020  = False,..):..  
-000131e0: 2020 2222 220d 0a20 2020 2052 6561 6420    """..    Read 
-000131f0: 6120 6c61 7965 7220 6672 6f6d 2061 2073  a layer from a s
-00013200: 6f75 7263 6520 6669 6c65 2061 6e64 2077  ource file and w
-00013210: 7269 7465 2069 7420 746f 2061 206e 6577  rite it to a new
-00013220: 2064 6573 7469 6e61 7469 6f6e 2066 696c   destination fil
-00013230: 652e 0d0a 0d0a 2020 2020 5479 7069 6361  e.....    Typica
-00013240: 6c6c 7920 7573 6564 2074 6f20 636f 6e76  lly used to conv
-00013250: 6572 7420 6672 6f6d 206f 6e65 2066 696c  ert from one fil
-00013260: 6566 6f72 6d61 7420 746f 2061 6e6f 7468  eformat to anoth
-00013270: 6572 206f 7220 746f 2072 6570 726f 6a65  er or to reproje
-00013280: 6374 2e0d 0a0d 0a20 2020 2054 6865 206f  ct.....    The o
-00013290: 7074 696f 6e73 2070 6172 616d 6574 6572  ptions parameter
-000132a0: 2063 616e 2062 6520 7573 6564 2074 6f20   can be used to 
-000132b0: 7061 7373 2061 6e79 2074 7970 6520 6f66  pass any type of
-000132c0: 206f 7074 696f 6e73 2074 6f20 4744 414c   options to GDAL
-000132d0: 2069 6e0d 0a20 2020 2074 6865 2066 6f6c   in..    the fol
-000132e0: 6c6f 7769 6e67 2066 6f72 6d3a 0d0a 2020  lowing form:..  
-000132f0: 2020 2020 2020 7b20 223c 6f70 7469 6f6e        { "<option
-00013300: 5f74 7970 653e 2e3c 6f70 7469 6f6e 5f6e  _type>.<option_n
-00013310: 616d 653e 223a 203c 6f70 7469 6f6e 5f76  ame>": <option_v
-00013320: 616c 7565 3e20 7d0d 0a0d 0a20 2020 2054  alue> }....    T
-00013330: 6865 206f 7074 696f 6e20 7479 7065 7320  he option types 
-00013340: 6361 6e20 6265 2061 6e79 206f 6620 7468  can be any of th
-00013350: 6520 666f 6c6c 6f77 696e 673a 0d0a 2020  e following:..  
-00013360: 2020 2020 2020 2d20 4c41 5945 525f 4352        - LAYER_CR
-00013370: 4541 5449 4f4e 3a20 6c61 7965 7220 6372  EATION: layer cr
-00013380: 6561 7469 6f6e 206f 7074 696f 6e20 286c  eation option (l
-00013390: 636f 290d 0a20 2020 2020 2020 202d 2044  co)..        - D
-000133a0: 4154 4153 4554 5f43 5245 4154 494f 4e3a  ATASET_CREATION:
-000133b0: 2064 6174 6173 6574 2063 7265 6174 696f   dataset creatio
-000133c0: 6e20 6f70 7469 6f6e 2028 6473 636f 290d  n option (dsco).
-000133d0: 0a20 2020 2020 2020 202d 2049 4e50 5554  .        - INPUT
-000133e0: 5f4f 5045 4e3a 2069 6e70 7574 2064 6174  _OPEN: input dat
-000133f0: 6173 6574 206f 7065 6e20 6f70 7469 6f6e  aset open option
-00013400: 2028 6f6f 290d 0a20 2020 2020 2020 202d   (oo)..        -
-00013410: 2044 4553 5449 4e41 5449 4f4e 5f4f 5045   DESTINATION_OPE
-00013420: 4e3a 2064 6573 7469 6e61 7469 6f6e 2064  N: destination d
-00013430: 6174 6173 6574 206f 7065 6e20 6f70 7469  ataset open opti
-00013440: 6f6e 2028 646f 6f29 0d0a 2020 2020 2020  on (doo)..      
-00013450: 2020 2d20 434f 4e46 4947 3a20 636f 6e66    - CONFIG: conf
-00013460: 6967 206f 7074 696f 6e20 2863 6f6e 6669  ig option (confi
-00013470: 6729 0d0a 0d0a 2020 2020 5468 6520 6f70  g)....    The op
-00013480: 7469 6f6e 7320 6361 6e20 6265 2066 6f75  tions can be fou
-00013490: 6e64 2069 6e20 7468 6520 5b47 4441 4c20  nd in the [GDAL 
-000134a0: 7665 6374 6f72 2064 7269 7665 7220 646f  vector driver do
-000134b0: 6375 6d65 6e74 6174 696f 6e5d 0d0a 2020  cumentation]..  
-000134c0: 2020 2868 7474 7073 3a2f 2f67 6461 6c2e    (https://gdal.
-000134d0: 6f72 672f 6472 6976 6572 732f 7665 6374  org/drivers/vect
-000134e0: 6f72 2f69 6e64 6578 2e68 746d 6c29 2e0d  or/index.html)..
-000134f0: 0a0d 0a20 2020 2041 7267 733a 0d0a 2020  ...    Args:..  
-00013500: 2020 2020 2020 7372 6320 2850 6174 684c        src (PathL
-00013510: 696b 6529 3a20 5468 6520 736f 7572 6365  ike): The source
-00013520: 2066 696c 6520 7061 7468 2e0d 0a20 2020   file path...   
-00013530: 2020 2020 2064 7374 2028 5061 7468 4c69       dst (PathLi
-00013540: 6b65 293a 2054 6865 2064 6573 7469 6e61  ke): The destina
-00013550: 7469 6f6e 2066 696c 6520 7061 7468 2e0d  tion file path..
-00013560: 0a20 2020 2020 2020 2073 7263 5f6c 6179  .        src_lay
-00013570: 6572 2028 7374 722c 206f 7074 696f 6e61  er (str, optiona
-00013580: 6c29 3a20 5468 6520 736f 7572 6365 206c  l): The source l
-00013590: 6179 6572 2e20 4966 204e 6f6e 6520 616e  ayer. If None an
-000135a0: 6420 7468 6572 6520 6973 206f 6e6c 790d  d there is only.
-000135b0: 0a20 2020 2020 2020 2020 2020 206f 6e65  .            one
-000135c0: 206c 6179 6572 2069 6e20 7468 6520 7372   layer in the sr
-000135d0: 6320 6669 6c65 2c20 7468 6174 206c 6179  c file, that lay
-000135e0: 6572 2069 7320 7461 6b65 6e2e 2044 6566  er is taken. Def
-000135f0: 6175 6c74 7320 746f 204e 6f6e 652e 0d0a  aults to None...
-00013600: 2020 2020 2020 2020 6473 745f 6c61 7965          dst_laye
-00013610: 7220 2873 7472 2c20 6f70 7469 6f6e 616c  r (str, optional
-00013620: 293a 2054 6865 2064 6573 7469 6e61 7469  ): The destinati
-00013630: 6f6e 206c 6179 6572 2e20 4966 204e 6f6e  on layer. If Non
-00013640: 652c 2074 6865 2066 696c 650d 0a20 2020  e, the file..   
-00013650: 2020 2020 2020 2020 2073 7465 6d20 6973           stem is
-00013660: 2074 616b 656e 2061 7320 6c61 7965 7220   taken as layer 
-00013670: 6e61 6d65 2e20 4465 6661 756c 7473 2074  name. Defaults t
-00013680: 6f20 4e6f 6e65 2e0d 0a20 2020 2020 2020  o None...       
-00013690: 2073 7263 5f63 7273 2028 556e 696f 6e5b   src_crs (Union[
-000136a0: 7374 722c 2069 6e74 5d2c 206f 7074 696f  str, int], optio
-000136b0: 6e61 6c29 3a20 616e 2065 7073 6720 696e  nal): an epsg in
-000136c0: 7420 6f72 2061 6e79 7468 696e 6720 7375  t or anything su
-000136d0: 7070 6f72 7465 640d 0a20 2020 2020 2020  pported..       
-000136e0: 2020 2020 2062 7920 7468 6520 4f47 5253       by the OGRS
-000136f0: 7061 7469 616c 5265 6665 7265 6e63 652e  patialReference.
-00013700: 5365 7446 726f 6d55 7365 7249 6e70 7574  SetFromUserInput
-00013710: 2829 2063 616c 6c2c 2077 6869 6368 2069  () call, which i
-00013720: 6e63 6c75 6465 730d 0a20 2020 2020 2020  ncludes..       
-00013730: 2020 2020 2061 6e20 4550 5347 2073 7472       an EPSG str
-00013740: 696e 6720 2865 672e 2022 4550 5347 3a34  ing (eg. "EPSG:4
-00013750: 3332 3622 292c 2061 2077 656c 6c20 6b6e  326"), a well kn
-00013760: 6f77 6e20 7465 7874 2028 574b 5429 2043  own text (WKT) C
-00013770: 5253 0d0a 2020 2020 2020 2020 2020 2020  RS..            
-00013780: 6465 6669 6e69 7469 6f6e 2c2e 2e2e 2044  definition,... D
-00013790: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
-000137a0: 0d0a 2020 2020 2020 2020 6473 745f 6372  ..        dst_cr
-000137b0: 7320 2855 6e69 6f6e 5b73 7472 2c20 696e  s (Union[str, in
-000137c0: 745d 2c20 6f70 7469 6f6e 616c 293a 2061  t], optional): a
-000137d0: 6e20 6570 7367 2069 6e74 206f 7220 616e  n epsg int or an
-000137e0: 7974 6869 6e67 2073 7570 706f 7274 6564  ything supported
-000137f0: 0d0a 2020 2020 2020 2020 2020 2020 6279  ..            by
-00013800: 2074 6865 204f 4752 5370 6174 6961 6c52   the OGRSpatialR
-00013810: 6566 6572 656e 6365 2e53 6574 4672 6f6d  eference.SetFrom
-00013820: 5573 6572 496e 7075 7428 2920 6361 6c6c  UserInput() call
-00013830: 2c20 7768 6963 6820 696e 636c 7564 6573  , which includes
-00013840: 0d0a 2020 2020 2020 2020 2020 2020 616e  ..            an
-00013850: 2045 5053 4720 7374 7269 6e67 2028 6567   EPSG string (eg
-00013860: 2e20 2245 5053 473a 3433 3236 2229 2c20  . "EPSG:4326"), 
-00013870: 6120 7765 6c6c 206b 6e6f 776e 2074 6578  a well known tex
-00013880: 7420 2857 4b54 2920 4352 530d 0a20 2020  t (WKT) CRS..   
-00013890: 2020 2020 2020 2020 2064 6566 696e 6974           definit
-000138a0: 696f 6e2c 2e2e 2e20 4465 6661 756c 7473  ion,... Defaults
-000138b0: 2074 6f20 4e6f 6e65 2e0d 0a20 2020 2020   to None...     
-000138c0: 2020 2072 6570 726f 6a65 6374 2028 626f     reproject (bo
-000138d0: 6f6c 2c20 6f70 7469 6f6e 616c 293a 2054  ol, optional): T
-000138e0: 7275 6520 746f 2072 6570 726f 6a65 6374  rue to reproject
-000138f0: 2077 6869 6c65 2063 6f6e 7665 7274 696e   while convertin
-00013900: 6720 7468 650d 0a20 2020 2020 2020 2020  g the..         
-00013910: 2020 2066 696c 652e 2044 6566 6175 6c74     file. Default
-00013920: 7320 746f 2046 616c 7365 2e0d 0a20 2020  s to False...   
-00013930: 2020 2020 2065 7870 6c6f 6465 636f 6c6c       explodecoll
-00013940: 6563 7469 6f6e 7320 2862 6f6f 6c2c 206f  ections (bool, o
-00013950: 7074 696f 6e61 6c29 3a20 5472 7565 2074  ptional): True t
-00013960: 6f20 6f75 7470 7574 206f 6e6c 7920 7369  o output only si
-00013970: 6d70 6c65 0d0a 2020 2020 2020 2020 2020  mple..          
-00013980: 2020 6765 6f6d 6574 7269 6573 2e20 4465    geometries. De
-00013990: 6661 756c 7473 2074 6f20 4661 6c73 652e  faults to False.
-000139a0: 0d0a 2020 2020 2020 2020 666f 7263 655f  ..        force_
-000139b0: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-000139c0: 7970 6520 2855 6e69 6f6e 5b47 656f 6d65  ype (Union[Geome
-000139d0: 7472 7954 7970 652c 2073 7472 5d2c 206f  tryType, str], o
-000139e0: 7074 696f 6e61 6c29 3a20 4765 6f6d 6574  ptional): Geomet
-000139f0: 7279 2074 7970 652e 0d0a 2020 2020 2020  ry type...      
-00013a00: 2020 2020 2020 746f 2028 7472 7920 746f        to (try to
-00013a10: 2920 666f 7263 6520 7468 6520 6f75 7470  ) force the outp
-00013a20: 7574 2074 6f2e 2044 6566 6175 6c74 7320  ut to. Defaults 
-00013a30: 746f 204e 6f6e 652e 0d0a 2020 2020 2020  to None...      
-00013a40: 2020 6372 6561 7465 5f73 7061 7469 616c    create_spatial
-00013a50: 5f69 6e64 6578 2028 626f 6f6c 2c20 6f70  _index (bool, op
-00013a60: 7469 6f6e 616c 293a 2054 7275 6520 746f  tional): True to
-00013a70: 2063 7265 6174 6520 6120 7370 6174 6961   create a spatia
-00013a80: 6c20 696e 6465 780d 0a20 2020 2020 2020  l index..       
-00013a90: 2020 2020 206f 6e20 7468 6520 6465 7374       on the dest
-00013aa0: 696e 6174 696f 6e20 6669 6c65 2f6c 6179  ination file/lay
-00013ab0: 6572 2e20 4966 204e 6f6e 652c 2074 6865  er. If None, the
-00013ac0: 2064 6566 6175 6c74 2062 6568 6176 696f   default behavio
-00013ad0: 7572 2062 7920 6764 616c 2066 6f72 0d0a  ur by gdal for..
-00013ae0: 2020 2020 2020 2020 2020 2020 7468 6174              that
-00013af0: 2066 696c 6520 7479 7065 2069 7320 7265   file type is re
-00013b00: 7370 6563 7465 642e 2049 6620 7468 6520  spected. If the 
-00013b10: 4c41 5945 525f 4352 4541 5449 4f4e 2e53  LAYER_CREATION.S
-00013b20: 5041 5449 414c 5f49 4e44 4558 0d0a 2020  PATIAL_INDEX..  
-00013b30: 2020 2020 2020 2020 2020 7061 7261 6d65            parame
-00013b40: 7465 7220 6973 2073 7065 6369 6669 6564  ter is specified
-00013b50: 2069 6e20 6f70 7469 6f6e 732c 2063 7265   in options, cre
-00013b60: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
-00013b70: 7820 6973 2069 676e 6f72 6564 2e0d 0a20  x is ignored... 
-00013b80: 2020 2020 2020 2020 2020 2044 6566 6175             Defau
-00013b90: 6c74 7320 746f 2054 7275 652e 0d0a 2020  lts to True...  
-00013ba0: 2020 2020 2020 7072 6573 6572 7665 5f66        preserve_f
-00013bb0: 6964 2028 626f 6f6c 2c20 6f70 7469 6f6e  id (bool, option
-00013bc0: 616c 293a 2054 7275 6520 746f 206d 616b  al): True to mak
-00013bd0: 6520 616e 2065 7874 7261 2065 6666 6f72  e an extra effor
-00013be0: 7420 746f 2070 7265 7365 7276 6520 6669  t to preserve fi
-00013bf0: 6427 7320 6f66 0d0a 2020 2020 2020 2020  d's of..        
-00013c00: 2020 2020 7468 6520 736f 7572 6365 206c      the source l
-00013c10: 6179 6572 2074 6f20 7468 6520 6465 7374  ayer to the dest
-00013c20: 696e 6174 696f 6e20 6c61 7965 722e 2046  ination layer. F
-00013c30: 616c 7365 206e 6f74 2074 6f20 646f 2061  alse not to do a
-00013c40: 6e79 2065 6666 6f72 742e 204e 6f6e 650d  ny effort. None.
-00013c50: 0a20 2020 2020 2020 2020 2020 2074 6f20  .            to 
-00013c60: 7573 6520 7468 6520 6465 6661 756c 7420  use the default 
-00013c70: 6265 6861 7669 6f75 7220 6f66 2067 6461  behaviour of gda
-00013c80: 6c2c 2074 6861 7420 616c 7265 6164 7920  l, that already 
-00013c90: 7072 6573 6572 7665 7320 696e 2073 6f6d  preserves in som
-00013ca0: 6520 6361 7365 732e 0d0a 2020 2020 2020  e cases...      
-00013cb0: 2020 2020 2020 536f 6d65 2066 696c 6520        Some file 
-00013cc0: 666f 726d 6174 7320 646f 6e27 7420 6578  formats don't ex
-00013cd0: 706c 6963 6974 6c79 2073 746f 7265 2074  plicitly store t
-00013ce0: 6865 2066 6964 2028 652e 672e 2073 6861  he fid (e.g. sha
-00013cf0: 7065 6669 6c65 292c 2073 6f20 7468 6579  pefile), so they
-00013d00: 0d0a 2020 2020 2020 2020 2020 2020 7769  ..            wi
-00013d10: 6c6c 206e 6576 6572 2062 6520 6162 6c65  ll never be able
-00013d20: 2074 6f20 7072 6573 6572 7665 2066 6964   to preserve fid
-00013d30: 732e 2044 6566 6175 6c74 7320 746f 204e  s. Defaults to N
-00013d40: 6f6e 652e 0d0a 2020 2020 2020 2020 6f70  one...        op
-00013d50: 7469 6f6e 7320 2864 6963 742c 206f 7074  tions (dict, opt
-00013d60: 696f 6e61 6c29 3a20 6f70 7469 6f6e 7320  ional): options 
-00013d70: 746f 2070 6173 7320 746f 2067 6461 6c2e  to pass to gdal.
-00013d80: 0d0a 2020 2020 2020 2020 6170 7065 6e64  ..        append
-00013d90: 2028 626f 6f6c 2c20 6f70 7469 6f6e 616c   (bool, optional
-00013da0: 293a 2054 7275 6520 746f 2061 7070 656e  ): True to appen
-00013db0: 6420 746f 2074 6865 206f 7574 7075 7420  d to the output 
-00013dc0: 6669 6c65 2069 6620 6974 2065 7869 7374  file if it exist
-00013dd0: 732e 0d0a 2020 2020 2020 2020 2020 2020  s...            
-00013de0: 4465 6661 756c 7473 2074 6f20 4661 6c73  Defaults to Fals
-00013df0: 652e 0d0a 2020 2020 2020 2020 666f 7263  e...        forc
-00013e00: 6520 2862 6f6f 6c2c 206f 7074 696f 6e61  e (bool, optiona
-00013e10: 6c29 3a20 6f76 6572 7772 6974 6520 6578  l): overwrite ex
-00013e20: 6973 7469 6e67 206f 7574 7075 7420 6669  isting output fi
-00013e30: 6c65 2873 290d 0a20 2020 2020 2020 2020  le(s)..         
-00013e40: 2020 2044 6566 6175 6c74 7320 746f 2046     Defaults to F
-00013e50: 616c 7365 2e0d 0a20 2020 2022 2222 0d0a  alse...    """..
-00013e60: 2020 2020 2320 496e 6974 0d0a 2020 2020      # Init..    
-00013e70: 7372 6320 3d20 5061 7468 2873 7263 290d  src = Path(src).
-00013e80: 0a20 2020 2064 7374 203d 2050 6174 6828  .    dst = Path(
-00013e90: 6473 7429 0d0a 0d0a 2020 2020 2320 4966  dst)....    # If
-00013ea0: 2073 6f75 7263 6520 6669 6c65 2064 6f65   source file doe
-00013eb0: 736e 2774 2065 7869 7374 2c20 7261 6973  sn't exist, rais
-00013ec0: 6520 6572 726f 720d 0a20 2020 2069 6620  e error..    if 
-00013ed0: 6e6f 7420 7372 632e 6578 6973 7473 2829  not src.exists()
-00013ee0: 3a0d 0a20 2020 2020 2020 2072 6169 7365  :..        raise
-00013ef0: 2056 616c 7565 4572 726f 7228 6622 7372   ValueError(f"sr
-00013f00: 6320 6669 6c65 2064 6f65 736e 2774 2065  c file doesn't e
-00013f10: 7869 7374 3a20 7b73 7263 7d22 290d 0a20  xist: {src}").. 
-00013f20: 2020 2023 2049 6620 6465 7374 2066 696c     # If dest fil
-00013f30: 6520 6578 6973 7473 2061 6c72 6561 6479  e exists already
-00013f40: 2c20 7265 6d6f 7665 2069 740d 0a20 2020  , remove it..   
-00013f50: 2069 6620 6e6f 7420 6170 7065 6e64 2061   if not append a
-00013f60: 6e64 2064 7374 2e65 7869 7374 7328 293a  nd dst.exists():
-00013f70: 0d0a 2020 2020 2020 2020 6966 2066 6f72  ..        if for
-00013f80: 6365 2069 7320 5472 7565 3a0d 0a20 2020  ce is True:..   
-00013f90: 2020 2020 2020 2020 2072 656d 6f76 6528           remove(
-00013fa0: 6473 7429 0d0a 2020 2020 2020 2020 656c  dst)..        el
-00013fb0: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-00013fc0: 206c 6f67 6765 722e 696e 666f 2866 224f   logger.info(f"O
-00013fd0: 7574 7075 7420 6669 6c65 2065 7869 7374  utput file exist
-00013fe0: 7320 616c 7265 6164 792c 2073 6f20 7374  s already, so st
-00013ff0: 6f70 3a20 7b64 7374 7d22 290d 0a20 2020  op: {dst}")..   
-00014000: 2020 2020 2020 2020 2072 6574 7572 6e0d           return.
-00014010: 0a0d 0a20 2020 2023 2043 6f6e 7665 7274  ...    # Convert
-00014020: 0d0a 2020 2020 6c6f 6767 6572 2e69 6e66  ..    logger.inf
-00014030: 6f28 6622 436f 6e76 6572 7420 7b73 7263  o(f"Convert {src
-00014040: 7d20 746f 207b 6473 747d 2229 0d0a 2020  } to {dst}")..  
-00014050: 2020 5f61 7070 656e 645f 746f 5f6e 6f6c    _append_to_nol
-00014060: 6f63 6b28 0d0a 2020 2020 2020 2020 7372  ock(..        sr
-00014070: 632c 0d0a 2020 2020 2020 2020 6473 742c  c,..        dst,
-00014080: 0d0a 2020 2020 2020 2020 7372 635f 6c61  ..        src_la
-00014090: 7965 722c 0d0a 2020 2020 2020 2020 6473  yer,..        ds
-000140a0: 745f 6c61 7965 722c 0d0a 2020 2020 2020  t_layer,..      
-000140b0: 2020 7372 635f 6372 733d 7372 635f 6372    src_crs=src_cr
-000140c0: 732c 0d0a 2020 2020 2020 2020 6473 745f  s,..        dst_
-000140d0: 6372 733d 6473 745f 6372 732c 0d0a 2020  crs=dst_crs,..  
-000140e0: 2020 2020 2020 7265 7072 6f6a 6563 743d        reproject=
-000140f0: 7265 7072 6f6a 6563 742c 0d0a 2020 2020  reproject,..    
-00014100: 2020 2020 6578 706c 6f64 6563 6f6c 6c65      explodecolle
-00014110: 6374 696f 6e73 3d65 7870 6c6f 6465 636f  ctions=explodeco
-00014120: 6c6c 6563 7469 6f6e 732c 0d0a 2020 2020  llections,..    
-00014130: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
-00014140: 5f67 656f 6d65 7472 7974 7970 653d 666f  _geometrytype=fo
-00014150: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-00014160: 7472 7974 7970 652c 0d0a 2020 2020 2020  trytype,..      
-00014170: 2020 6372 6561 7465 5f73 7061 7469 616c    create_spatial
-00014180: 5f69 6e64 6578 3d63 7265 6174 655f 7370  _index=create_sp
-00014190: 6174 6961 6c5f 696e 6465 782c 0d0a 2020  atial_index,..  
-000141a0: 2020 2020 2020 7072 6573 6572 7665 5f66        preserve_f
-000141b0: 6964 3d70 7265 7365 7276 655f 6669 642c  id=preserve_fid,
-000141c0: 0d0a 2020 2020 2020 2020 6f70 7469 6f6e  ..        option
-000141d0: 733d 6f70 7469 6f6e 732c 0d0a 2020 2020  s=options,..    
-000141e0: 290d 0a0d 0a0d 0a64 6566 205f 6c61 756e  )......def _laun
-000141f0: 6465 725f 636f 6c75 6d6e 5f6e 616d 6573  der_column_names
-00014200: 2863 6f6c 756d 6e73 3a20 4974 6572 6162  (columns: Iterab
-00014210: 6c65 2920 2d3e 204c 6973 745b 5475 706c  le) -> List[Tupl
-00014220: 655b 7374 722c 2073 7472 5d5d 3a0d 0a20  e[str, str]]:.. 
-00014230: 2020 2022 2222 0d0a 2020 2020 4c61 756e     """..    Laun
-00014240: 6465 7273 2074 6865 2063 6f6c 756d 6e20  ders the column 
-00014250: 6e61 6d65 7320 7061 7373 6564 2074 6f20  names passed to 
-00014260: 636f 6d70 6c79 2077 6974 6820 7368 6170  comply with shap
-00014270: 6566 696c 6520 7265 7374 7269 6374 696f  efile restrictio
-00014280: 6e73 2e0d 0a0d 0a20 2020 2052 6174 696f  ns.....    Ratio
-00014290: 6e61 6c65 3a20 6e6f 726d 616c 6c79 2067  nale: normally g
-000142a0: 6461 6c20 6c61 756e 6465 7273 2074 6865  dal launders the
-000142b0: 6d20 6966 206e 6565 6465 642c 2062 7574  m if needed, but
-000142c0: 2077 6865 6e20 796f 7520 6170 7065 6e64   when you append
-000142d0: 0d0a 2020 2020 6d75 6c74 6970 6c65 2066  ..    multiple f
-000142e0: 696c 6573 2074 6f20 6120 7368 6170 6566  iles to a shapef
-000142f0: 696c 6520 7769 7468 2063 6f6c 756d 6e73  ile with columns
-00014300: 2074 6861 7420 6e65 6564 2074 6f20 6265   that need to be
-00014310: 206c 6175 6e64 6572 6564 0d0a 2020 2020   laundered..    
-00014320: 7468 6579 2061 7265 206e 6f74 206d 6174  they are not mat
-00014330: 6368 6564 2061 6e64 2073 6f20 6172 6520  ched and so are 
-00014340: 6170 7065 6e64 6564 2077 6974 6820 4e55  appended with NU
-00014350: 4c4c 2076 616c 7565 7320 666f 7220 7468  LL values for th
-00014360: 6573 650d 0a20 2020 2063 6f6c 756d 6e73  ese..    columns
-00014370: 2e20 4e6f 726d 616c 6c79 2074 6865 202d  . Normally the -
-00014380: 7265 6c61 7865 6446 6965 6c64 4e61 6d65  relaxedFieldName
-00014390: 4d61 7463 6820 7061 7261 6d65 7465 7220  Match parameter 
-000143a0: 696e 206f 6772 326f 6772 0d0a 2020 2020  in ogr2ogr..    
-000143b0: 7368 6f75 6c64 2066 6978 2074 6869 732c  should fix this,
-000143c0: 2062 7574 2069 7420 7365 656d 7320 7468   but it seems th
-000143d0: 6174 2074 6869 7320 6973 6e27 7420 7375  at this isn't su
-000143e0: 7070 6f72 7465 6420 666f 7220 7368 6170  pported for shap
-000143f0: 6566 696c 6573 2e0d 0a0d 0a20 2020 204c  efiles.....    L
-00014400: 6175 6e64 6572 696e 6720 6973 2062 6173  aundering is bas
-00014410: 6564 206f 6e20 7468 6973 2074 6578 7420  ed on this text 
-00014420: 6672 6f6d 2074 6865 2067 6461 6c20 7368  from the gdal sh
-00014430: 6170 6566 696c 6520 6472 6976 6572 0d0a  apefile driver..
-00014440: 2020 2020 646f 6375 6d65 6e74 6174 696f      documentatio
-00014450: 6e3a 0d0a 0d0a 2020 2020 5368 6170 6566  n:....    Shapef
-00014460: 696c 6520 6665 6174 7572 6520 6174 7472  ile feature attr
-00014470: 6962 7574 6573 2061 7265 2073 746f 7265  ibutes are store
-00014480: 6420 696e 2061 6e20 6173 736f 6369 6174  d in an associat
-00014490: 6564 202e 6462 6620 6669 6c65 2c20 616e  ed .dbf file, an
-000144a0: 640d 0a20 2020 2073 6f20 6174 7472 6962  d..    so attrib
-000144b0: 7574 6573 2073 7566 6665 7220 6120 6e75  utes suffer a nu
-000144c0: 6d62 6572 206f 6620 6c69 6d69 7461 7469  mber of limitati
-000144d0: 6f6e 733a 0d0a 2020 2020 2d20 2020 4174  ons:..    -   At
-000144e0: 7472 6962 7574 6520 6e61 6d65 7320 6361  tribute names ca
-000144f0: 6e20 6f6e 6c79 2062 6520 7570 2074 6f20  n only be up to 
-00014500: 3130 2063 6861 7261 6374 6572 7320 6c6f  10 characters lo
-00014510: 6e67 2e0d 0a20 2020 2020 2020 2054 6865  ng...        The
-00014520: 204f 4752 2053 6861 7065 6669 6c65 2064   OGR Shapefile d
-00014530: 7269 7665 7220 7472 6965 7320 746f 2067  river tries to g
-00014540: 656e 6572 6174 6520 756e 6971 7565 2066  enerate unique f
-00014550: 6965 6c64 0d0a 2020 2020 2020 2020 6e61  ield..        na
-00014560: 6d65 732e 2053 7563 6365 7373 6976 6520  mes. Successive 
-00014570: 6475 706c 6963 6174 6520 6669 656c 6420  duplicate field 
-00014580: 6e61 6d65 732c 2069 6e63 6c75 6469 6e67  names, including
-00014590: 2074 686f 7365 2063 7265 6174 6564 2062   those created b
-000145a0: 790d 0a20 2020 2020 2020 2074 7275 6e63  y..        trunc
-000145b0: 6174 696f 6e20 746f 2031 3020 6368 6172  ation to 10 char
-000145c0: 6163 7465 7273 2c20 7769 6c6c 2062 6520  acters, will be 
-000145d0: 7472 756e 6361 7465 6420 746f 2038 2063  truncated to 8 c
-000145e0: 6861 7261 6374 6572 7320 616e 640d 0a20  haracters and.. 
-000145f0: 2020 2020 2020 2061 7070 656e 6465 6420         appended 
-00014600: 7769 7468 2061 2073 6572 6961 6c20 6e75  with a serial nu
-00014610: 6d62 6572 2066 726f 6d20 3120 746f 2039  mber from 1 to 9
-00014620: 392e 0d0a 0d0a 2020 2020 2020 2020 466f  9.....        Fo
-00014630: 7220 6578 616d 706c 653a 0d0a 0d0a 2020  r example:....  
-00014640: 2020 2020 2020 2d20 2061 20e2 8692 2061        -  a ... a
-00014650: 2c20 6120 e286 9220 615f 312c 2041 20e2  , a ... a_1, A .
-00014660: 8692 2041 5f32 3b0d 0a20 2020 2020 2020  .. A_2;..       
-00014670: 202d 2020 6162 6364 6566 6768 696a 6b20   -  abcdefghijk 
-00014680: e286 9220 6162 6364 6566 6768 696a 2c20  ... abcdefghij, 
-00014690: 6162 6364 6566 6768 696a 6b6c 20e2 8692  abcdefghijkl ...
-000146a0: 2061 6263 6465 6667 685f 310d 0a0d 0a20   abcdefgh_1.... 
-000146b0: 2020 202d 2020 204f 6e6c 7920 496e 7465     -   Only Inte
-000146c0: 6765 722c 2049 6e74 6567 6572 3634 2c20  ger, Integer64, 
-000146d0: 5265 616c 2c20 5374 7269 6e67 2061 6e64  Real, String and
-000146e0: 2044 6174 6520 286e 6f74 2044 6174 6554   Date (not DateT
-000146f0: 696d 652c 206a 7573 740d 0a20 2020 2020  ime, just..     
-00014700: 2020 2079 6561 722f 6d6f 6e74 682f 6461     year/month/da
-00014710: 7929 2066 6965 6c64 2074 7970 6573 2061  y) field types a
-00014720: 7265 2073 7570 706f 7274 6564 2e20 5468  re supported. Th
-00014730: 6520 7661 7269 6f75 7320 6c69 7374 2c20  e various list, 
-00014740: 616e 640d 0a20 2020 2020 2020 2062 696e  and..        bin
-00014750: 6172 7920 6669 656c 6420 7479 7065 7320  ary field types 
-00014760: 6361 6e6e 6f74 2062 6520 6372 6561 7465  cannot be create
-00014770: 642e 0d0a 2020 2020 2d20 2020 5468 6520  d...    -   The 
-00014780: 6669 656c 6420 7769 6474 6820 616e 6420  field width and 
-00014790: 7072 6563 6973 696f 6e20 6172 6520 6469  precision are di
-000147a0: 7265 6374 6c79 2075 7365 6420 746f 2065  rectly used to e
-000147b0: 7374 6162 6c69 7368 2073 746f 7261 6765  stablish storage
-000147c0: 0d0a 2020 2020 2020 2020 7369 7a65 2069  ..        size i
-000147d0: 6e20 7468 6520 2e64 6266 2066 696c 652e  n the .dbf file.
-000147e0: 2054 6869 7320 6d65 616e 7320 7468 6174   This means that
-000147f0: 2073 7472 696e 6773 206c 6f6e 6765 7220   strings longer 
-00014800: 7468 616e 2074 6865 2066 6965 6c64 0d0a  than the field..
-00014810: 2020 2020 2020 2020 7769 6474 682c 206f          width, o
-00014820: 7220 6e75 6d62 6572 7320 7468 6174 2064  r numbers that d
-00014830: 6f6e 2774 2066 6974 2069 6e74 6f20 7468  on't fit into th
-00014840: 6520 696e 6469 6361 7465 6420 6669 656c  e indicated fiel
-00014850: 6420 666f 726d 6174 2077 696c 6c0d 0a20  d format will.. 
-00014860: 2020 2020 2020 2073 7566 6665 7220 7472         suffer tr
-00014870: 756e 6361 7469 6f6e 2e0d 0a20 2020 202d  uncation...    -
-00014880: 2020 2049 6e74 6567 6572 2066 6965 6c64     Integer field
-00014890: 7320 7769 7468 6f75 7420 616e 2065 7870  s without an exp
-000148a0: 6c69 6369 7420 7769 6474 6820 6172 6520  licit width are 
-000148b0: 7472 6561 7465 6420 6173 2077 6964 7468  treated as width
-000148c0: 2039 2c20 616e 640d 0a20 2020 2020 2020   9, and..       
-000148d0: 2065 7874 656e 6465 6420 746f 2031 3020   extended to 10 
-000148e0: 6f72 2031 3120 6966 206e 6565 6465 642e  or 11 if needed.
-000148f0: 0d0a 2020 2020 2d20 2020 496e 7465 6765  ..    -   Intege
-00014900: 7236 3420 6669 656c 6473 2077 6974 686f  r64 fields witho
-00014910: 7574 2061 6e20 6578 706c 6963 6974 2077  ut an explicit w
-00014920: 6964 7468 2061 7265 2074 7265 6174 6564  idth are treated
-00014930: 2061 7320 7769 6474 6820 3138 2c0d 0a20   as width 18,.. 
-00014940: 2020 2020 2020 2061 6e64 2065 7874 656e         and exten
-00014950: 6465 6420 746f 2031 3920 6f72 2032 3020  ded to 19 or 20 
-00014960: 6966 206e 6565 6465 642e 0d0a 2020 2020  if needed...    
-00014970: 2d20 2020 5265 616c 2028 666c 6f61 7469  -   Real (floati
-00014980: 6e67 2070 6f69 6e74 2920 6669 656c 6473  ng point) fields
-00014990: 2077 6974 686f 7574 2061 6e20 6578 706c   without an expl
-000149a0: 6963 6974 2077 6964 7468 2061 7265 2074  icit width are t
-000149b0: 7265 6174 6564 2061 730d 0a20 2020 2020  reated as..     
-000149c0: 2020 2077 6964 7468 2032 3420 7769 7468     width 24 with
-000149d0: 2031 3520 6465 6369 6d61 6c20 706c 6163   15 decimal plac
-000149e0: 6573 206f 6620 7072 6563 6973 696f 6e2e  es of precision.
-000149f0: 0d0a 2020 2020 2d20 2020 5374 7269 6e67  ..    -   String
-00014a00: 2066 6965 6c64 7320 7769 7468 6f75 7420   fields without 
-00014a10: 616e 2061 7373 6967 6e65 6420 7769 6474  an assigned widt
-00014a20: 6820 6172 6520 7472 6561 7465 6420 6173  h are treated as
-00014a30: 2038 3020 6368 6172 6163 7465 7273 2e0d   80 characters..
-00014a40: 0a0d 0a20 2020 2041 7267 733a 0d0a 2020  ...    Args:..  
-00014a50: 2020 2020 2020 636f 6c75 6d6e 7320 2849        columns (I
-00014a60: 7465 7261 626c 6529 3a20 7468 6520 636f  terable): the co
-00014a70: 6c75 6d6e 7320 746f 206c 6175 6e64 6572  lumns to launder
-00014a80: 2e0d 0a0d 0a20 2020 2052 6574 7572 6e73  .....    Returns
-00014a90: 3a20 6120 4c69 7374 206f 6620 7475 7070  : a List of tupp
-00014aa0: 6c65 7320 7769 7468 2074 6865 206f 7269  les with the ori
-00014ab0: 6769 6e61 6c20 616e 6420 6c61 756e 6465  ginal and launde
-00014ac0: 7265 6420 636f 6c75 6d6e 206e 616d 6573  red column names
-00014ad0: 2e0d 0a20 2020 2022 2222 0d0a 2020 2020  ...    """..    
-00014ae0: 6c61 756e 6465 7265 6420 3d20 5b5d 0d0a  laundered = []..
-00014af0: 2020 2020 6c61 756e 6465 7265 645f 7570      laundered_up
-00014b00: 7065 7220 3d20 5b5d 0d0a 2020 2020 666f  per = []..    fo
-00014b10: 7220 636f 6c75 6d6e 2069 6e20 636f 6c75  r column in colu
-00014b20: 6d6e 733a 0d0a 2020 2020 2020 2020 2320  mns:..        # 
-00014b30: 446f 7562 6c65 7320 696e 2063 6173 696e  Doubles in casin
-00014b40: 6720 6172 6565 206e 6f74 2061 6c6c 6f77  g aree not allow
-00014b50: 6564 2065 6974 6865 720d 0a20 2020 2020  ed either..     
-00014b60: 2020 2069 6620 6c65 6e28 636f 6c75 6d6e     if len(column
-00014b70: 2920 3c3d 2031 303a 0d0a 2020 2020 2020  ) <= 10:..      
-00014b80: 2020 2020 2020 6966 2063 6f6c 756d 6e2e        if column.
-00014b90: 7570 7065 7228 2920 6e6f 7420 696e 206c  upper() not in l
-00014ba0: 6175 6e64 6572 6564 5f75 7070 6572 3a0d  aundered_upper:.
-00014bb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014bc0: 206c 6175 6e64 6572 6564 5f75 7070 6572   laundered_upper
-00014bd0: 2e61 7070 656e 6428 636f 6c75 6d6e 2e75  .append(column.u
-00014be0: 7070 6572 2829 290d 0a20 2020 2020 2020  pper())..       
-00014bf0: 2020 2020 2020 2020 206c 6175 6e64 6572           launder
-00014c00: 6564 2e61 7070 656e 6428 2863 6f6c 756d  ed.append((colum
-00014c10: 6e2c 2063 6f6c 756d 6e29 290d 0a20 2020  n, column))..   
-00014c20: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-00014c30: 7469 6e75 650d 0a0d 0a20 2020 2020 2020  tinue....       
-00014c40: 2023 204c 6175 6e64 6572 696e 6720 6973   # Laundering is
-00014c50: 206e 6565 6465 640d 0a20 2020 2020 2020   needed..       
-00014c60: 2063 6f6c 756d 6e5f 6c61 756e 6465 7265   column_laundere
-00014c70: 6420 3d20 636f 6c75 6d6e 5b3a 3130 5d0d  d = column[:10].
-00014c80: 0a20 2020 2020 2020 2069 6620 636f 6c75  .        if colu
-00014c90: 6d6e 5f6c 6175 6e64 6572 6564 2e75 7070  mn_laundered.upp
-00014ca0: 6572 2829 206e 6f74 2069 6e20 6c61 756e  er() not in laun
-00014cb0: 6465 7265 645f 7570 7065 723a 0d0a 2020  dered_upper:..  
-00014cc0: 2020 2020 2020 2020 2020 6c61 756e 6465            launde
-00014cd0: 7265 645f 7570 7065 722e 6170 7065 6e64  red_upper.append
-00014ce0: 2863 6f6c 756d 6e5f 6c61 756e 6465 7265  (column_laundere
-00014cf0: 642e 7570 7065 7228 2929 0d0a 2020 2020  d.upper())..    
-00014d00: 2020 2020 2020 2020 6c61 756e 6465 7265          laundere
-00014d10: 642e 6170 7065 6e64 2828 636f 6c75 6d6e  d.append((column
-00014d20: 2c20 636f 6c75 6d6e 5f6c 6175 6e64 6572  , column_launder
-00014d30: 6564 2929 0d0a 2020 2020 2020 2020 656c  ed))..        el
-00014d40: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-00014d50: 2023 204a 7573 7420 7461 6b69 6e67 2066   # Just taking f
-00014d60: 6972 7374 2031 3020 6368 6172 6163 7465  irst 10 characte
-00014d70: 7273 2064 6964 6e27 7420 6865 6c70 0d0a  rs didn't help..
-00014d80: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00014d90: 696e 6465 7820 696e 2072 616e 6765 2831  index in range(1
-00014da0: 2c20 3130 3129 3a0d 0a20 2020 2020 2020  , 101):..       
-00014db0: 2020 2020 2020 2020 2069 6620 696e 6465           if inde
-00014dc0: 7820 3e3d 2031 3030 3a0d 0a20 2020 2020  x >= 100:..     
-00014dd0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00014de0: 6169 7365 204e 6f74 496d 706c 656d 656e  aise NotImplemen
-00014df0: 7465 6445 7272 6f72 280d 0a20 2020 2020  tedError(..     
-00014e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014e10: 2020 2022 4e6f 7420 7375 7070 6f72 7465     "Not supporte
-00014e20: 6420 746f 206c 6175 6e64 6572 203e 2039  d to launder > 9
-00014e30: 3920 636f 6c75 6d6e 7320 7374 6172 7469  9 columns starti
-00014e40: 6e67 2022 0d0a 2020 2020 2020 2020 2020  ng "..          
-00014e50: 2020 2020 2020 2020 2020 2020 2020 6622                f"
-00014e60: 7769 7468 207b 636f 6c75 6d6e 5f6c 6175  with {column_lau
-00014e70: 6e64 6572 6564 5b3a 385d 7d22 0d0a 2020  ndered[:8]}"..  
-00014e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014e90: 2020 290d 0a20 2020 2020 2020 2020 2020    )..           
-00014ea0: 2020 2020 2069 6620 696e 6465 7820 3c3d       if index <=
-00014eb0: 2039 3a0d 0a20 2020 2020 2020 2020 2020   9:..           
-00014ec0: 2020 2020 2020 2020 2063 6f6c 756d 6e5f           column_
-00014ed0: 6c61 756e 6465 7265 6420 3d20 6622 7b63  laundered = f"{c
-00014ee0: 6f6c 756d 6e5f 6c61 756e 6465 7265 645b  olumn_laundered[
-00014ef0: 3a38 5d7d 5f7b 696e 6465 787d 220d 0a20  :8]}_{index}".. 
-00014f00: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00014f10: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-00014f20: 2020 2020 2020 2020 2020 636f 6c75 6d6e            column
-00014f30: 5f6c 6175 6e64 6572 6564 203d 2066 227b  _laundered = f"{
-00014f40: 636f 6c75 6d6e 5f6c 6175 6e64 6572 6564  column_laundered
-00014f50: 5b3a 385d 7d7b 696e 6465 787d 220d 0a20  [:8]}{index}".. 
-00014f60: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00014f70: 6620 636f 6c75 6d6e 5f6c 6175 6e64 6572  f column_launder
-00014f80: 6564 2e75 7070 6572 2829 206e 6f74 2069  ed.upper() not i
-00014f90: 6e20 6c61 756e 6465 7265 645f 7570 7065  n laundered_uppe
-00014fa0: 723a 0d0a 2020 2020 2020 2020 2020 2020  r:..            
-00014fb0: 2020 2020 2020 2020 6c61 756e 6465 7265          laundere
-00014fc0: 645f 7570 7065 722e 6170 7065 6e64 2863  d_upper.append(c
-00014fd0: 6f6c 756d 6e5f 6c61 756e 6465 7265 642e  olumn_laundered.
-00014fe0: 7570 7065 7228 2929 0d0a 2020 2020 2020  upper())..      
-00014ff0: 2020 2020 2020 2020 2020 2020 2020 6c61                la
-00015000: 756e 6465 7265 642e 6170 7065 6e64 2828  undered.append((
-00015010: 636f 6c75 6d6e 2c20 636f 6c75 6d6e 5f6c  column, column_l
-00015020: 6175 6e64 6572 6564 2929 0d0a 2020 2020  aundered))..    
-00015030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015040: 6272 6561 6b0d 0a0d 0a20 2020 2072 6574  break....    ret
-00015050: 7572 6e20 6c61 756e 6465 7265 640d 0a0d  urn laundered...
-00015060: 0a0d 0a64 6566 2067 6574 5f64 7269 7665  ...def get_drive
-00015070: 7228 7061 7468 3a20 556e 696f 6e5b 7374  r(path: Union[st
-00015080: 722c 2022 6f73 2e50 6174 684c 696b 655b  r, "os.PathLike[
-00015090: 416e 795d 225d 2920 2d3e 2073 7472 3a0d  Any]"]) -> str:.
-000150a0: 0a20 2020 2022 2222 0d0a 2020 2020 4765  .    """..    Ge
-000150b0: 7420 7468 6520 6472 6976 6572 2074 6f20  t the driver to 
-000150c0: 7573 6520 666f 7220 7468 6520 6669 6c65  use for the file
-000150d0: 2065 7874 656e 7369 6f6e 206f 6620 7468   extension of th
-000150e0: 6973 2066 696c 6570 6174 682e 0d0a 0d0a  is filepath.....
-000150f0: 2020 2020 4445 5052 4543 4154 4544 2c20      DEPRECATED, 
-00015100: 7573 6520 4765 6f6d 6574 7279 5479 7065  use GeometryType
-00015110: 2850 6174 6829 2e6f 6772 6472 6976 6572  (Path).ogrdriver
-00015120: 2e0d 0a0d 0a20 2020 2041 7267 733a 0d0a  .....    Args:..
-00015130: 2020 2020 2020 2020 7061 7468 2028 5061          path (Pa
-00015140: 7468 4c69 6b65 293a 2054 6865 2066 696c  thLike): The fil
-00015150: 6520 7061 7468 2e0d 0a0d 0a20 2020 2052  e path.....    R
-00015160: 6574 7572 6e73 3a0d 0a20 2020 2020 2020  eturns:..       
-00015170: 2073 7472 3a20 5468 6520 4f47 5220 6472   str: The OGR dr
-00015180: 6976 6572 206e 616d 652e 0d0a 2020 2020  iver name...    
-00015190: 2222 220d 0a20 2020 2077 6172 6e69 6e67  """..    warning
-000151a0: 732e 7761 726e 280d 0a20 2020 2020 2020  s.warn(..       
-000151b0: 2022 6765 745f 6472 6976 6572 2069 7320   "get_driver is 
-000151c0: 6465 7072 6563 6174 6564 2c20 7573 6520  deprecated, use 
-000151d0: 4765 6f6d 6574 7279 5479 7065 2850 6174  GeometryType(Pat
-000151e0: 6829 2e6f 6772 6472 6976 6572 222c 2046  h).ogrdriver", F
-000151f0: 7574 7572 6557 6172 6e69 6e67 0d0a 2020  utureWarning..  
-00015200: 2020 290d 0a20 2020 2072 6574 7572 6e20    )..    return 
-00015210: 4765 6f66 696c 6554 7970 6528 5061 7468  GeofileType(Path
-00015220: 2870 6174 6829 292e 6f67 7264 7269 7665  (path)).ogrdrive
-00015230: 720d 0a0d 0a0d 0a64 6566 2067 6574 5f64  r......def get_d
-00015240: 7269 7665 725f 666f 725f 6578 7428 6669  river_for_ext(fi
-00015250: 6c65 5f65 7874 3a20 7374 7229 202d 3e20  le_ext: str) -> 
-00015260: 7374 723a 0d0a 2020 2020 2222 220d 0a20  str:..    """.. 
-00015270: 2020 2047 6574 2074 6865 2064 7269 7665     Get the drive
-00015280: 7220 746f 2075 7365 2066 6f72 2074 6869  r to use for thi
-00015290: 7320 6669 6c65 2065 7874 656e 7369 6f6e  s file extension
-000152a0: 2e0d 0a0d 0a20 2020 2044 4550 5245 4341  .....    DEPRECA
-000152b0: 5445 442c 2075 7365 2047 656f 6d65 7472  TED, use Geometr
-000152c0: 7954 7970 6528 6669 6c65 5f65 7874 292e  yType(file_ext).
-000152d0: 6f67 7264 7269 7665 722e 0d0a 0d0a 2020  ogrdriver.....  
-000152e0: 2020 4172 6773 3a0d 0a20 2020 2020 2020    Args:..       
-000152f0: 2066 696c 655f 6578 7420 2873 7472 293a   file_ext (str):
-00015300: 2054 6865 2065 7874 656e 7465 6e73 696f   The extentensio
-00015310: 6e2e 0d0a 0d0a 2020 2020 5261 6973 6573  n.....    Raises
-00015320: 3a0d 0a20 2020 2020 2020 2056 616c 7565  :..        Value
-00015330: 4572 726f 723a 2049 6620 696e 7075 7420  Error: If input 
-00015340: 6765 6f6d 6574 7279 7479 7065 2069 7320  geometrytype is 
-00015350: 6e6f 7420 6b6e 6f77 6e2e 0d0a 0d0a 2020  not known.....  
-00015360: 2020 5265 7475 726e 733a 0d0a 2020 2020    Returns:..    
-00015370: 2020 2020 7374 723a 2054 6865 204f 4752      str: The OGR
-00015380: 2064 7269 7665 7220 6e61 6d65 2e0d 0a20   driver name... 
-00015390: 2020 2022 2222 0d0a 2020 2020 7761 726e     """..    warn
-000153a0: 696e 6773 2e77 6172 6e28 0d0a 2020 2020  ings.warn(..    
-000153b0: 2020 2020 2267 6574 5f64 7269 7665 725f      "get_driver_
-000153c0: 666f 725f 6578 7420 6973 2064 6570 7265  for_ext is depre
-000153d0: 6361 7465 642c 2075 7365 2047 656f 6d65  cated, use Geome
-000153e0: 7472 7954 7970 6528 5061 7468 292e 6f67  tryType(Path).og
-000153f0: 7264 7269 7665 7222 2c0d 0a20 2020 2020  rdriver",..     
-00015400: 2020 2046 7574 7572 6557 6172 6e69 6e67     FutureWarning
-00015410: 2c0d 0a20 2020 2029 0d0a 2020 2020 7265  ,..    )..    re
-00015420: 7475 726e 2047 656f 6669 6c65 5479 7065  turn GeofileType
-00015430: 2866 696c 655f 6578 7429 2e6f 6772 6472  (file_ext).ogrdr
-00015440: 6976 6572 0d0a 0d0a 0d0a 6465 6620 746f  iver......def to
-00015450: 5f6d 756c 7469 5f74 7970 6528 6765 6f6d  _multi_type(geom
-00015460: 6574 7279 7479 7065 6e61 6d65 3a20 7374  etrytypename: st
-00015470: 7229 202d 3e20 7374 723a 0d0a 2020 2020  r) -> str:..    
-00015480: 2222 220d 0a20 2020 204d 6170 2074 6865  """..    Map the
-00015490: 2069 6e70 7574 2067 656f 6d65 7472 7920   input geometry 
-000154a0: 7479 7065 2074 6f20 7468 6520 636f 7272  type to the corr
-000154b0: 6573 706f 6e64 696e 6720 274d 554c 5449  esponding 'MULTI
-000154c0: 2720 6765 6f6d 6574 7279 2074 7970 652e  ' geometry type.
-000154d0: 2e2e 0d0a 0d0a 2020 2020 4445 5052 4543  ......    DEPREC
-000154e0: 4154 4544 2c20 7573 6520 746f 5f6d 756c  ATED, use to_mul
-000154f0: 7469 6765 6f6d 6574 7279 7479 7065 0d0a  tigeometrytype..
-00015500: 0d0a 2020 2020 4172 6773 3a0d 0a20 2020  ..    Args:..   
-00015510: 2020 2020 2067 656f 6d65 7472 7974 7970       geometrytyp
-00015520: 656e 616d 6520 2873 7472 293a 2049 6e70  ename (str): Inp
-00015530: 7574 2067 656f 6d65 7472 7920 7479 7065  ut geometry type
-00015540: 0d0a 0d0a 2020 2020 5261 6973 6573 3a0d  ....    Raises:.
-00015550: 0a20 2020 2020 2020 2056 616c 7565 4572  .        ValueEr
-00015560: 726f 723a 2049 6620 696e 7075 7420 6765  ror: If input ge
-00015570: 6f6d 6574 7279 7479 7065 2069 7320 6e6f  ometrytype is no
-00015580: 7420 6b6e 6f77 6e2e 0d0a 0d0a 2020 2020  t known.....    
-00015590: 5265 7475 726e 733a 0d0a 2020 2020 2020  Returns:..      
-000155a0: 2020 7374 723a 2043 6f72 7265 7370 6f6e    str: Correspon
-000155b0: 6469 6e67 2027 4d55 4c54 4927 2067 656f  ding 'MULTI' geo
-000155c0: 6d65 7472 7920 7479 7065 0d0a 2020 2020  metry type..    
-000155d0: 2222 220d 0a20 2020 2077 6172 6e69 6e67  """..    warning
-000155e0: 732e 7761 726e 280d 0a20 2020 2020 2020  s.warn(..       
-000155f0: 2022 746f 5f67 656e 6572 616c 7479 7065   "to_generaltype
-00015600: 6964 2069 7320 6465 7072 6563 6174 6564  id is deprecated
-00015610: 2c20 7573 6520 4765 6f6d 6574 7279 5479  , use GeometryTy
-00015620: 7065 2e74 6f5f 6d75 6c74 6967 656f 6d65  pe.to_multigeome
-00015630: 7472 7974 7970 6522 2c0d 0a20 2020 2020  trytype",..     
-00015640: 2020 2046 7574 7572 6557 6172 6e69 6e67     FutureWarning
-00015650: 2c0d 0a20 2020 2029 0d0a 2020 2020 7265  ,..    )..    re
-00015660: 7475 726e 2067 656f 6d65 7472 795f 7574  turn geometry_ut
-00015670: 696c 2e47 656f 6d65 7472 7954 7970 6528  il.GeometryType(
-00015680: 6765 6f6d 6574 7279 7479 7065 6e61 6d65  geometrytypename
-00015690: 292e 746f 5f6d 756c 7469 7479 7065 2e6e  ).to_multitype.n
-000156a0: 616d 650d 0a0d 0a0d 0a64 6566 2074 6f5f  ame......def to_
-000156b0: 6765 6e65 7261 6c74 7970 6569 6428 6765  generaltypeid(ge
-000156c0: 6f6d 6574 7279 7479 7065 6e61 6d65 3a20  ometrytypename: 
-000156d0: 7374 7229 202d 3e20 696e 743a 0d0a 2020  str) -> int:..  
-000156e0: 2020 2222 220d 0a20 2020 204d 6170 2074    """..    Map t
-000156f0: 6865 2069 6e70 7574 2067 656f 6d65 7472  he input geometr
-00015700: 7920 7479 7065 206e 616d 6520 746f 2074  y type name to t
-00015710: 6865 2063 6f72 7265 7370 6f6e 6469 6e67  he corresponding
-00015720: 2067 656f 6d65 7472 7920 7479 7065 2069   geometry type i
-00015730: 643a 0d0a 2020 2020 2020 2020 2a20 3120  d:..        * 1 
-00015740: 3d20 504f 494e 542d 7479 7065 0d0a 2020  = POINT-type..  
-00015750: 2020 2020 2020 2a20 3220 3d20 4c49 4e45        * 2 = LINE
-00015760: 5354 5249 4e47 2d74 7970 650d 0a20 2020  STRING-type..   
-00015770: 2020 2020 202a 2033 203d 2050 4f4c 5947       * 3 = POLYG
-00015780: 4f4e 2d74 7970 650d 0a0d 0a20 2020 2044  ON-type....    D
-00015790: 4550 5245 4341 5445 442c 2075 7365 2074  EPRECATED, use t
-000157a0: 6f5f 7072 696d 6974 6976 6574 7970 6569  o_primitivetypei
-000157b0: 6428 290d 0a0d 0a20 2020 2041 7267 733a  d()....    Args:
-000157c0: 0d0a 2020 2020 2020 2020 6765 6f6d 6574  ..        geomet
-000157d0: 7279 7479 7065 6e61 6d65 2028 7374 7229  rytypename (str)
-000157e0: 3a20 496e 7075 7420 6765 6f6d 6574 7279  : Input geometry
-000157f0: 2074 7970 650d 0a0d 0a20 2020 2052 6169   type....    Rai
-00015800: 7365 733a 0d0a 2020 2020 2020 2020 5661  ses:..        Va
-00015810: 6c75 6545 7272 6f72 3a20 4966 2069 6e70  lueError: If inp
-00015820: 7574 2067 656f 6d65 7472 7974 7970 6520  ut geometrytype 
-00015830: 6973 206e 6f74 206b 6e6f 776e 2e0d 0a0d  is not known....
-00015840: 0a20 2020 2052 6574 7572 6e73 3a0d 0a20  .    Returns:.. 
-00015850: 2020 2020 2020 2069 6e74 3a20 436f 7272         int: Corr
-00015860: 6573 706f 6e64 696e 6720 6765 6f6d 6574  esponding geomet
-00015870: 7279 2074 7970 6520 6964 0d0a 2020 2020  ry type id..    
-00015880: 2222 220d 0a20 2020 2077 6172 6e69 6e67  """..    warning
-00015890: 732e 7761 726e 280d 0a20 2020 2020 2020  s.warn(..       
-000158a0: 2022 746f 5f67 656e 6572 616c 7479 7065   "to_generaltype
-000158b0: 6964 2069 7320 6465 7072 6563 6174 6564  id is deprecated
-000158c0: 2c20 7573 6520 4765 6f6d 6574 7279 5479  , use GeometryTy
-000158d0: 7065 2e74 6f5f 7072 696d 6974 6976 6574  pe.to_primitivet
-000158e0: 7970 6569 6422 2c0d 0a20 2020 2020 2020  ypeid",..       
-000158f0: 2046 7574 7572 6557 6172 6e69 6e67 2c0d   FutureWarning,.
-00015900: 0a20 2020 2029 0d0a 2020 2020 7265 7475  .    )..    retu
-00015910: 726e 2067 656f 6d65 7472 795f 7574 696c  rn geometry_util
-00015920: 2e47 656f 6d65 7472 7954 7970 6528 6765  .GeometryType(ge
-00015930: 6f6d 6574 7279 7479 7065 6e61 6d65 292e  ometrytypename).
-00015940: 746f 5f70 7269 6d69 7469 7665 7479 7065  to_primitivetype
-00015950: 2e76 616c 7565 0d0a                      .value..
+0000c000: 6d65 7472 7974 7970 652e 7570 7065 7228  metrytype.upper(
+0000c010: 290a 2020 2020 2020 2020 7472 793a 0a20  ).        try:. 
+0000c020: 2020 2020 2020 2020 2020 2023 2056 6572             # Ver
+0000c030: 6966 7920 6966 2069 7420 6973 2061 2022  ify if it is a "
+0000c040: 7374 616e 6461 7264 2220 6765 6f6d 6574  standard" geomet
+0000c050: 7279 2074 7970 652c 2061 7320 4744 414c  ry type, as GDAL
+0000c060: 2061 6c73 6f20 7375 7070 6f72 7473 0a20   also supports. 
+0000c070: 2020 2020 2020 2020 2020 2023 2073 7065             # spe
+0000c080: 6369 616c 2067 656f 6d65 7472 7920 7479  cial geometry ty
+0000c090: 7065 7320 6c69 6b65 2022 5052 4f4d 4f54  pes like "PROMOT
+0000c0a0: 455f 544f 5f4d 554c 5449 220a 2020 2020  E_TO_MULTI".    
+0000c0b0: 2020 2020 2020 2020 666f 7263 655f 6f75          force_ou
+0000c0c0: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+0000c0d0: 6520 3d20 4765 6f6d 6574 7279 5479 7065  e = GeometryType
+0000c0e0: 5b66 6f72 6365 5f6f 7574 7075 745f 6765  [force_output_ge
+0000c0f0: 6f6d 6574 7279 7479 7065 5d0a 2020 2020  ometrytype].    
+0000c100: 2020 2020 6578 6365 7074 2045 7863 6570      except Excep
+0000c110: 7469 6f6e 3a0a 2020 2020 2020 2020 2020  tion:.          
+0000c120: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+0000c130: 6f72 280a 2020 2020 2020 2020 2020 2020  or(.            
+0000c140: 2020 2020 6622 556e 7375 7070 6f72 7465      f"Unsupporte
+0000c150: 6420 666f 7263 655f 6f75 7470 7574 5f67  d force_output_g
+0000c160: 656f 6d65 7472 7974 7970 653a 207b 666f  eometrytype: {fo
+0000c170: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
+0000c180: 7472 7974 7970 657d 220a 2020 2020 2020  trytype}".      
+0000c190: 2020 2020 2020 290a 2020 2020 6966 2066        ).    if f
+0000c1a0: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+0000c1b0: 6574 7279 7479 7065 2069 7320 6e6f 7420  etrytype is not 
+0000c1c0: 4e6f 6e65 2061 6e64 2066 6f72 6365 5f6f  None and force_o
+0000c1d0: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
+0000c1e0: 7065 2e69 735f 6d75 6c74 6974 7970 653a  pe.is_multitype:
+0000c1f0: 0a20 2020 2020 2020 2066 6f72 6365 5f6d  .        force_m
+0000c200: 756c 7469 7479 7065 203d 2054 7275 650a  ultitype = True.
+0000c210: 0a20 2020 2023 2049 6620 7468 6572 6520  .    # If there 
+0000c220: 6973 206e 6f20 6765 6f6d 6574 7279 2063  is no geometry c
+0000c230: 6f6c 756d 6e20 696e 2074 6865 2069 6e70  olumn in the inp
+0000c240: 7574 2c20 616c 7761 7973 2075 7365 2066  ut, always use f
+0000c250: 696f 6e61 2c20 6173 2070 796f 6772 696f  iona, as pyogrio
+0000c260: 2064 6f65 736e 2774 0a20 2020 2023 2073   doesn't.    # s
+0000c270: 7570 706f 7274 2074 6861 7420 7965 7420  upport that yet 
+0000c280: 6174 2074 696d 6520 6f66 2077 7269 7469  at time of writi
+0000c290: 6e67 2e0a 2020 2020 6966 2069 7369 6e73  ng..    if isins
+0000c2a0: 7461 6e63 6528 6764 662c 2067 7064 2e47  tance(gdf, gpd.G
+0000c2b0: 656f 4461 7461 4672 616d 6529 2069 7320  eoDataFrame) is 
+0000c2c0: 4661 6c73 6520 6f72 2028 0a20 2020 2020  False or (.     
+0000c2d0: 2020 2069 7369 6e73 7461 6e63 6528 6764     isinstance(gd
+0000c2e0: 662c 2067 7064 2e47 656f 4461 7461 4672  f, gpd.GeoDataFr
+0000c2f0: 616d 6529 2061 6e64 2022 6765 6f6d 6574  ame) and "geomet
+0000c300: 7279 2220 6e6f 7420 696e 2067 6466 2e63  ry" not in gdf.c
+0000c310: 6f6c 756d 6e73 0a20 2020 2029 3a0a 2020  olumns.    ):.  
+0000c320: 2020 2020 2020 656e 6769 6e65 203d 2022        engine = "
+0000c330: 6669 6f6e 6122 0a20 2020 2065 6c73 653a  fiona".    else:
+0000c340: 0a20 2020 2020 2020 2065 6e67 696e 6520  .        engine 
+0000c350: 3d20 5f67 6574 5f65 6e67 696e 6528 290a  = _get_engine().
+0000c360: 0a20 2020 2023 204e 6f77 2077 7269 7465  .    # Now write
+0000c370: 2077 6974 6820 7468 6520 636f 7272 6563   with the correc
+0000c380: 7420 656e 6769 6e65 0a20 2020 2069 6620  t engine.    if 
+0000c390: 656e 6769 6e65 203d 3d20 2270 796f 6772  engine == "pyogr
+0000c3a0: 696f 223a 0a20 2020 2020 2020 2072 6574  io":.        ret
+0000c3b0: 7572 6e20 5f74 6f5f 6669 6c65 5f70 796f  urn _to_file_pyo
+0000c3c0: 6772 696f 280a 2020 2020 2020 2020 2020  grio(.          
+0000c3d0: 2020 6764 663d 6764 662c 0a20 2020 2020    gdf=gdf,.     
+0000c3e0: 2020 2020 2020 2070 6174 683d 7061 7468         path=path
+0000c3f0: 2c0a 2020 2020 2020 2020 2020 2020 6c61  ,.            la
+0000c400: 7965 723d 6c61 7965 722c 0a20 2020 2020  yer=layer,.     
+0000c410: 2020 2020 2020 2066 6f72 6365 5f6f 7574         force_out
+0000c420: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
+0000c430: 3d66 6f72 6365 5f6f 7574 7075 745f 6765  =force_output_ge
+0000c440: 6f6d 6574 7279 7479 7065 2c0a 2020 2020  ometrytype,.    
+0000c450: 2020 2020 2020 2020 666f 7263 655f 6d75          force_mu
+0000c460: 6c74 6974 7970 653d 666f 7263 655f 6d75  ltitype=force_mu
+0000c470: 6c74 6974 7970 652c 0a20 2020 2020 2020  ltitype,.       
+0000c480: 2020 2020 2061 7070 656e 643d 6170 7065       append=appe
+0000c490: 6e64 2c0a 2020 2020 2020 2020 2020 2020  nd,.            
+0000c4a0: 6170 7065 6e64 5f74 696d 656f 7574 5f73  append_timeout_s
+0000c4b0: 3d61 7070 656e 645f 7469 6d65 6f75 745f  =append_timeout_
+0000c4c0: 732c 0a20 2020 2020 2020 2020 2020 2069  s,.            i
+0000c4d0: 6e64 6578 3d69 6e64 6578 2c0a 2020 2020  ndex=index,.    
+0000c4e0: 2020 2020 2020 2020 6372 6561 7465 5f73          create_s
+0000c4f0: 7061 7469 616c 5f69 6e64 6578 3d63 7265  patial_index=cre
+0000c500: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
+0000c510: 782c 0a20 2020 2020 2020 2029 0a20 2020  x,.        ).   
+0000c520: 2065 6c69 6620 656e 6769 6e65 203d 3d20   elif engine == 
+0000c530: 2266 696f 6e61 223a 0a20 2020 2020 2020  "fiona":.       
+0000c540: 2072 6574 7572 6e20 5f74 6f5f 6669 6c65   return _to_file
+0000c550: 5f66 696f 6e61 280a 2020 2020 2020 2020  _fiona(.        
+0000c560: 2020 2020 6764 663d 6764 662c 0a20 2020      gdf=gdf,.   
+0000c570: 2020 2020 2020 2020 2070 6174 683d 7061           path=pa
+0000c580: 7468 2c0a 2020 2020 2020 2020 2020 2020  th,.            
+0000c590: 6c61 7965 723d 6c61 7965 722c 0a20 2020  layer=layer,.   
+0000c5a0: 2020 2020 2020 2020 2066 6f72 6365 5f6f           force_o
+0000c5b0: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
+0000c5c0: 7065 3d66 6f72 6365 5f6f 7574 7075 745f  pe=force_output_
+0000c5d0: 6765 6f6d 6574 7279 7479 7065 2c0a 2020  geometrytype,.  
+0000c5e0: 2020 2020 2020 2020 2020 666f 7263 655f            force_
+0000c5f0: 6d75 6c74 6974 7970 653d 666f 7263 655f  multitype=force_
+0000c600: 6d75 6c74 6974 7970 652c 0a20 2020 2020  multitype,.     
+0000c610: 2020 2020 2020 2061 7070 656e 643d 6170         append=ap
+0000c620: 7065 6e64 2c0a 2020 2020 2020 2020 2020  pend,.          
+0000c630: 2020 6170 7065 6e64 5f74 696d 656f 7574    append_timeout
+0000c640: 5f73 3d61 7070 656e 645f 7469 6d65 6f75  _s=append_timeou
+0000c650: 745f 732c 0a20 2020 2020 2020 2020 2020  t_s,.           
+0000c660: 2069 6e64 6578 3d69 6e64 6578 2c0a 2020   index=index,.  
+0000c670: 2020 2020 2020 2020 2020 6372 6561 7465            create
+0000c680: 5f73 7061 7469 616c 5f69 6e64 6578 3d63  _spatial_index=c
+0000c690: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
+0000c6a0: 6465 782c 0a20 2020 2020 2020 2029 0a20  dex,.        ). 
+0000c6b0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000c6c0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
+0000c6d0: 7228 6622 556e 7375 7070 6f72 7465 6420  r(f"Unsupported 
+0000c6e0: 656e 6769 6e65 3a20 7b65 6e67 696e 657d  engine: {engine}
+0000c6f0: 2229 0a0a 0a64 6566 205f 6765 745f 656e  ")...def _get_en
+0000c700: 6769 6e65 2829 3a0a 2020 2020 7265 7475  gine():.    retu
+0000c710: 726e 206f 732e 656e 7669 726f 6e2e 6765  rn os.environ.ge
+0000c720: 7428 2247 464f 5f49 4f5f 454e 4749 4e45  t("GFO_IO_ENGINE
+0000c730: 222c 2022 7079 6f67 7269 6f22 290a 0a0a  ", "pyogrio")...
+0000c740: 6465 6620 5f74 6f5f 6669 6c65 5f66 696f  def _to_file_fio
+0000c750: 6e61 280a 2020 2020 6764 663a 2055 6e69  na(.    gdf: Uni
+0000c760: 6f6e 5b70 642e 4461 7461 4672 616d 652c  on[pd.DataFrame,
+0000c770: 2067 7064 2e47 656f 4461 7461 4672 616d   gpd.GeoDataFram
+0000c780: 655d 2c0a 2020 2020 7061 7468 3a20 5061  e],.    path: Pa
+0000c790: 7468 2c0a 2020 2020 6c61 7965 723a 2073  th,.    layer: s
+0000c7a0: 7472 2c0a 2020 2020 666f 7263 655f 6f75  tr,.    force_ou
+0000c7b0: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+0000c7c0: 653a 2055 6e69 6f6e 5b47 656f 6d65 7472  e: Union[Geometr
+0000c7d0: 7954 7970 652c 2073 7472 2c20 4e6f 6e65  yType, str, None
+0000c7e0: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 666f  ] = None,.    fo
+0000c7f0: 7263 655f 6d75 6c74 6974 7970 653a 2062  rce_multitype: b
+0000c800: 6f6f 6c20 3d20 4661 6c73 652c 0a20 2020  ool = False,.   
+0000c810: 2061 7070 656e 643a 2062 6f6f 6c20 3d20   append: bool = 
+0000c820: 4661 6c73 652c 0a20 2020 2061 7070 656e  False,.    appen
+0000c830: 645f 7469 6d65 6f75 745f 733a 2069 6e74  d_timeout_s: int
+0000c840: 203d 2036 3030 2c0a 2020 2020 696e 6465   = 600,.    inde
+0000c850: 783a 2062 6f6f 6c20 3d20 5472 7565 2c0a  x: bool = True,.
+0000c860: 2020 2020 6372 6561 7465 5f73 7061 7469      create_spati
+0000c870: 616c 5f69 6e64 6578 3a20 4f70 7469 6f6e  al_index: Option
+0000c880: 616c 5b62 6f6f 6c5d 203d 2054 7275 652c  al[bool] = True,
+0000c890: 0a29 3a0a 2020 2020 2222 220a 2020 2020  .):.    """.    
+0000c8a0: 5772 6974 6573 2061 2070 616e 6461 7320  Writes a pandas 
+0000c8b0: 6461 7461 6672 616d 6520 746f 2066 696c  dataframe to fil
+0000c8c0: 6520 7573 696e 6720 6669 6f6e 612e 0a20  e using fiona.. 
+0000c8d0: 2020 2022 2222 0a20 2020 2023 2048 616e     """.    # Han
+0000c8e0: 646c 6520 736f 6d65 2073 7065 6369 6669  dle some specifi
+0000c8f0: 6320 6361 7365 7320 7768 6572 6520 7468  c cases where th
+0000c900: 6520 6669 6c65 2073 6368 656d 6120 6e65  e file schema ne
+0000c910: 6564 7320 746f 2062 6520 6d61 6e69 7075  eds to be manipu
+0000c920: 6c61 7465 642e 0a20 2020 2073 6368 656d  lated..    schem
+0000c930: 6120 3d20 4e6f 6e65 0a20 2020 2069 6620  a = None.    if 
+0000c940: 6973 696e 7374 616e 6365 2867 6466 2c20  isinstance(gdf, 
+0000c950: 6770 642e 4765 6f44 6174 6146 7261 6d65  gpd.GeoDataFrame
+0000c960: 2920 6973 2046 616c 7365 206f 7220 280a  ) is False or (.
+0000c970: 2020 2020 2020 2020 6973 696e 7374 616e          isinstan
+0000c980: 6365 2867 6466 2c20 6770 642e 4765 6f44  ce(gdf, gpd.GeoD
+0000c990: 6174 6146 7261 6d65 2920 616e 6420 2267  ataFrame) and "g
+0000c9a0: 656f 6d65 7472 7922 206e 6f74 2069 6e20  eometry" not in 
+0000c9b0: 6764 662e 636f 6c75 6d6e 730a 2020 2020  gdf.columns.    
+0000c9c0: 293a 0a20 2020 2020 2020 2023 204e 6f20  ):.        # No 
+0000c9d0: 6765 6f6d 6574 7279 2c20 736f 2070 7265  geometry, so pre
+0000c9e0: 7061 7265 2074 6f20 6265 2077 7269 7474  pare to be writt
+0000c9f0: 656e 2061 7320 6174 7472 6962 7574 6520  en as attribute 
+0000ca00: 7461 626c 653a 2061 6464 2067 656f 6d65  table: add geome
+0000ca10: 7472 7920 636f 6c75 6d6e 0a20 2020 2020  try column.     
+0000ca20: 2020 2023 2077 6974 6820 4e6f 6e65 2067     # with None g
+0000ca30: 656f 6d65 7472 7920 7479 7065 2069 6e20  eometry type in 
+0000ca40: 7363 6865 6d61 0a20 2020 2020 2020 2067  schema.        g
+0000ca50: 6466 203d 2067 7064 2e47 656f 4461 7461  df = gpd.GeoData
+0000ca60: 4672 616d 6528 6764 662c 2067 656f 6d65  Frame(gdf, geome
+0000ca70: 7472 793d 5b4e 6f6e 6520 666f 7220 6920  try=[None for i 
+0000ca80: 696e 2067 6466 2e69 6e64 6578 5d29 2020  in gdf.index])  
+0000ca90: 2320 7479 7065 3a20 6967 6e6f 7265 0a20  # type: ignore. 
+0000caa0: 2020 2020 2020 2073 6368 656d 6120 3d20         schema = 
+0000cab0: 6770 645f 696f 5f66 696c 652e 696e 6665  gpd_io_file.infe
+0000cac0: 725f 7363 6865 6d61 2867 6466 290a 2020  r_schema(gdf).  
+0000cad0: 2020 2020 2020 7363 6865 6d61 5b22 6765        schema["ge
+0000cae0: 6f6d 6574 7279 225d 203d 2022 4e6f 6e65  ometry"] = "None
+0000caf0: 220a 2020 2020 656c 6966 2028 0a20 2020  ".    elif (.   
+0000cb00: 2020 2020 206c 656e 2867 6466 2920 3d3d       len(gdf) ==
+0000cb10: 2030 0a20 2020 2020 2020 2061 6e64 2066   0.        and f
+0000cb20: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+0000cb30: 6574 7279 7479 7065 2069 7320 6e6f 7420  etrytype is not 
+0000cb40: 4e6f 6e65 0a20 2020 2020 2020 2061 6e64  None.        and
+0000cb50: 2069 7369 6e73 7461 6e63 6528 666f 7263   isinstance(forc
+0000cb60: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+0000cb70: 7974 7970 652c 2047 656f 6d65 7472 7954  ytype, GeometryT
+0000cb80: 7970 6529 0a20 2020 2029 3a0a 2020 2020  ype).    ):.    
+0000cb90: 2020 2020 2320 4966 2074 6865 2067 6466      # If the gdf
+0000cba0: 2069 7320 656d 7074 7920 6275 7420 6120   is empty but a 
+0000cbb0: 6765 6f6d 6574 7279 2074 7970 6520 6973  geometry type is
+0000cbc0: 2073 7065 6369 6669 6564 2c20 7573 6520   specified, use 
+0000cbd0: 7468 6520 7370 6563 6966 6965 6420 7479  the specified ty
+0000cbe0: 7065 0a20 2020 2020 2020 2073 6368 656d  pe.        schem
+0000cbf0: 6120 3d20 6770 645f 696f 5f66 696c 652e  a = gpd_io_file.
+0000cc00: 696e 6665 725f 7363 6865 6d61 2867 6466  infer_schema(gdf
+0000cc10: 290a 2020 2020 2020 2020 2320 4765 6f6d  ).        # Geom
+0000cc20: 6574 7279 2074 7970 6520 6d75 7374 2062  etry type must b
+0000cc30: 6520 696e 2063 616d 656c 6361 7365 2066  e in camelcase f
+0000cc40: 6f72 2066 696f 6e61 0a20 2020 2020 2020  or fiona.       
+0000cc50: 2073 6368 656d 615b 2267 656f 6d65 7472   schema["geometr
+0000cc60: 7922 5d20 3d20 666f 7263 655f 6f75 7470  y"] = force_outp
+0000cc70: 7574 5f67 656f 6d65 7472 7974 7970 652e  ut_geometrytype.
+0000cc80: 6e61 6d65 5f63 616d 656c 6361 7365 0a20  name_camelcase. 
+0000cc90: 2020 2061 7373 6572 7420 6973 696e 7374     assert isinst
+0000cca0: 616e 6365 2867 6466 2c20 6770 642e 4765  ance(gdf, gpd.Ge
+0000ccb0: 6f44 6174 6146 7261 6d65 290a 0a20 2020  oDataFrame)..   
+0000ccc0: 2023 2043 6f6e 7665 7274 2066 6f72 6365   # Convert force
+0000ccd0: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
+0000cce0: 7479 7065 2074 6f20 7374 7269 6e67 2074  type to string t
+0000ccf0: 6f20 7369 6d70 6c69 6679 2063 6f64 6520  o simplify code 
+0000cd00: 6166 7465 7277 6172 6473 0a20 2020 2069  afterwards.    i
+0000cd10: 6620 6973 696e 7374 616e 6365 2866 6f72  f isinstance(for
+0000cd20: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
+0000cd30: 7279 7479 7065 2c20 4765 6f6d 6574 7279  rytype, Geometry
+0000cd40: 5479 7065 293a 0a20 2020 2020 2020 2066  Type):.        f
+0000cd50: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+0000cd60: 6574 7279 7479 7065 203d 2066 6f72 6365  etrytype = force
+0000cd70: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
+0000cd80: 7479 7065 2e6e 616d 650a 0a20 2020 2023  type.name..    #
+0000cd90: 204e 6f20 7468 6520 6669 6c65 2063 616e   No the file can
+0000cda0: 2061 6374 7561 6c6c 7920 6265 2077 7269   actually be wri
+0000cdb0: 7474 656e 0a20 2020 2023 202d 2d2d 2d2d  tten.    # -----
+0000cdc0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000cdd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
+0000cde0: 2020 2023 2046 696f 6e61 2064 6f65 736e     # Fiona doesn
+0000cdf0: 2774 2073 7570 706f 7274 2074 6865 206f  't support the o
+0000ce00: 7574 7075 7420 6765 6f6d 6574 7279 7479  utput geometryty
+0000ce10: 7065 2070 6172 616d 6574 6572 2061 7320  pe parameter as 
+0000ce20: 7573 6564 2069 6e20 6764 616c 2c20 736f  used in gdal, so
+0000ce30: 2061 7320 610a 2020 2020 2320 6c69 6768   as a.    # ligh
+0000ce40: 7477 6569 6768 7420 696d 706c 656d 656e  tweight implemen
+0000ce50: 7461 7469 6f6e 206a 7573 7420 7365 7420  tation just set 
+0000ce60: 666f 7263 650a 2020 2020 6465 6620 7772  force.    def wr
+0000ce70: 6974 655f 746f 5f66 696c 6528 0a20 2020  ite_to_file(.   
+0000ce80: 2020 2020 2067 6466 3a20 6770 642e 4765       gdf: gpd.Ge
+0000ce90: 6f44 6174 6146 7261 6d65 2c0a 2020 2020  oDataFrame,.    
+0000cea0: 2020 2020 7061 7468 3a20 5061 7468 2c0a      path: Path,.
+0000ceb0: 2020 2020 2020 2020 6c61 7965 723a 2073          layer: s
+0000cec0: 7472 2c0a 2020 2020 2020 2020 696e 6465  tr,.        inde
+0000ced0: 783a 2062 6f6f 6c20 3d20 5472 7565 2c0a  x: bool = True,.
+0000cee0: 2020 2020 2020 2020 666f 7263 655f 6f75          force_ou
+0000cef0: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+0000cf00: 653a 204f 7074 696f 6e61 6c5b 7374 725d  e: Optional[str]
+0000cf10: 203d 204e 6f6e 652c 0a20 2020 2020 2020   = None,.       
+0000cf20: 2066 6f72 6365 5f6d 756c 7469 7479 7065   force_multitype
+0000cf30: 3a20 626f 6f6c 203d 2046 616c 7365 2c0a  : bool = False,.
+0000cf40: 2020 2020 2020 2020 6170 7065 6e64 3a20          append: 
+0000cf50: 626f 6f6c 203d 2046 616c 7365 2c0a 2020  bool = False,.  
+0000cf60: 2020 2020 2020 7363 6865 6d61 3a20 4f70        schema: Op
+0000cf70: 7469 6f6e 616c 5b64 6963 745d 203d 204e  tional[dict] = N
+0000cf80: 6f6e 652c 0a20 2020 2020 2020 2063 7265  one,.        cre
+0000cf90: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
+0000cfa0: 783a 204f 7074 696f 6e61 6c5b 626f 6f6c  x: Optional[bool
+0000cfb0: 5d20 3d20 5472 7565 2c0a 2020 2020 293a  ] = True,.    ):
+0000cfc0: 0a20 2020 2020 2020 2023 2050 7265 7061  .        # Prepa
+0000cfd0: 7265 2061 7267 7320 666f 7220 746f 5f66  re args for to_f
+0000cfe0: 696c 650a 2020 2020 2020 2020 6966 2061  ile.        if a
+0000cff0: 7070 656e 6420 6973 2054 7275 653a 0a20  ppend is True:. 
+0000d000: 2020 2020 2020 2020 2020 2069 6620 7061             if pa
+0000d010: 7468 2e65 7869 7374 7328 293a 0a20 2020  th.exists():.   
+0000d020: 2020 2020 2020 2020 2020 2020 206d 6f64               mod
+0000d030: 6520 3d20 2261 220a 2020 2020 2020 2020  e = "a".        
+0000d040: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000d050: 2020 2020 2020 2020 2020 6d6f 6465 203d            mode =
+0000d060: 2022 7722 0a20 2020 2020 2020 2065 6c73   "w".        els
+0000d070: 653a 0a20 2020 2020 2020 2020 2020 206d  e:.            m
+0000d080: 6f64 6520 3d20 2277 220a 0a20 2020 2020  ode = "w"..     
+0000d090: 2020 206b 7761 7267 7320 3d20 7b7d 0a20     kwargs = {}. 
+0000d0a0: 2020 2020 2020 206b 7761 7267 735b 226d         kwargs["m
+0000d0b0: 6f64 6522 5d20 3d20 6d6f 6465 0a20 2020  ode"] = mode.   
+0000d0c0: 2020 2020 2067 656f 6669 6c65 7479 7065       geofiletype
+0000d0d0: 203d 2047 656f 6669 6c65 5479 7065 2870   = GeofileType(p
+0000d0e0: 6174 6829 0a20 2020 2020 2020 206b 7761  ath).        kwa
+0000d0f0: 7267 735b 2264 7269 7665 7222 5d20 3d20  rgs["driver"] = 
+0000d100: 6765 6f66 696c 6574 7970 652e 6f67 7264  geofiletype.ogrd
+0000d110: 7269 7665 720a 2020 2020 2020 2020 6966  river.        if
+0000d120: 2063 7265 6174 655f 7370 6174 6961 6c5f   create_spatial_
+0000d130: 696e 6465 7820 6973 206e 6f74 204e 6f6e  index is not Non
+0000d140: 653a 0a20 2020 2020 2020 2020 2020 206b  e:.            k
+0000d150: 7761 7267 735b 2253 5041 5449 414c 5f49  wargs["SPATIAL_I
+0000d160: 4e44 4558 225d 203d 2063 7265 6174 655f  NDEX"] = create_
+0000d170: 7370 6174 6961 6c5f 696e 6465 780a 2020  spatial_index.  
+0000d180: 2020 2020 2020 6966 2066 6f72 6365 5f6f        if force_o
+0000d190: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
+0000d1a0: 7065 2069 7320 6e6f 7420 4e6f 6e65 3a0a  pe is not None:.
+0000d1b0: 2020 2020 2020 2020 2020 2020 6b77 6172              kwar
+0000d1c0: 6773 5b22 6765 6f6d 6574 7279 7479 7065  gs["geometrytype
+0000d1d0: 225d 203d 2066 6f72 6365 5f6f 7574 7075  "] = force_outpu
+0000d1e0: 745f 6765 6f6d 6574 7279 7479 7065 0a20  t_geometrytype. 
+0000d1f0: 2020 2020 2020 2069 6620 7363 6865 6d61         if schema
+0000d200: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+0000d210: 2020 2020 2020 2020 2020 6b77 6172 6773            kwargs
+0000d220: 5b22 7363 6865 6d61 225d 203d 2073 6368  ["schema"] = sch
+0000d230: 656d 610a 0a20 2020 2020 2020 2023 204e  ema..        # N
+0000d240: 6f77 2077 6520 6361 6e20 7772 6974 650a  ow we can write.
+0000d250: 2020 2020 2020 2020 6966 2067 656f 6669          if geofi
+0000d260: 6c65 7479 7065 203d 3d20 4765 6f66 696c  letype == Geofil
+0000d270: 6554 7970 652e 4553 5249 5368 6170 6566  eType.ESRIShapef
+0000d280: 696c 653a 0a20 2020 2020 2020 2020 2020  ile:.           
+0000d290: 2069 6620 696e 6465 7820 6973 2054 7275   if index is Tru
+0000d2a0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000d2b0: 2020 2067 6466 5f74 6f5f 7772 6974 6520     gdf_to_write 
+0000d2c0: 3d20 6764 662e 7265 7365 745f 696e 6465  = gdf.reset_inde
+0000d2d0: 7828 6472 6f70 3d54 7275 6529 0a20 2020  x(drop=True).   
+0000d2e0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000d2f0: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+0000d300: 6466 5f74 6f5f 7772 6974 6520 3d20 6764  df_to_write = gd
+0000d310: 660a 2020 2020 2020 2020 2020 2020 6764  f.            gd
+0000d320: 665f 746f 5f77 7269 7465 2e74 6f5f 6669  f_to_write.to_fi
+0000d330: 6c65 2873 7472 2870 6174 6829 2c20 2a2a  le(str(path), **
+0000d340: 6b77 6172 6773 2920 2023 2074 7970 653a  kwargs)  # type:
+0000d350: 2069 676e 6f72 650a 2020 2020 2020 2020   ignore.        
+0000d360: 656c 6966 2067 656f 6669 6c65 7479 7065  elif geofiletype
+0000d370: 203d 3d20 4765 6f66 696c 6554 7970 652e   == GeofileType.
+0000d380: 4750 4b47 3a0a 2020 2020 2020 2020 2020  GPKG:.          
+0000d390: 2020 2320 5472 7920 746f 2068 6172 6d6f    # Try to harmo
+0000d3a0: 6e69 7a65 2074 6865 2067 656f 6d65 7472  nize the geometr
+0000d3b0: 7974 7970 6520 746f 206f 6e65 2028 6d75  ytype to one (mu
+0000d3c0: 6c74 6929 7479 7065 2c20 6173 2047 504b  lti)type, as GPK
+0000d3d0: 470a 2020 2020 2020 2020 2020 2020 2320  G.            # 
+0000d3e0: 646f 6573 6e27 7420 6c69 6b65 203e 2031  doesn't like > 1
+0000d3f0: 2074 7970 6520 696e 2061 206c 6179 6572   type in a layer
+0000d400: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000d410: 7363 6865 6d61 2069 7320 4e6f 6e65 206f  schema is None o
+0000d420: 7220 286c 656e 2867 6466 2920 3e20 3020  r (len(gdf) > 0 
+0000d430: 616e 6420 7363 6865 6d61 5b22 6765 6f6d  and schema["geom
+0000d440: 6574 7279 225d 2021 3d20 224e 6f6e 6522  etry"] != "None"
+0000d450: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000d460: 2020 2067 6466 5f74 6f5f 7772 6974 6520     gdf_to_write 
+0000d470: 3d20 6764 662e 636f 7079 2829 0a20 2020  = gdf.copy().   
+0000d480: 2020 2020 2020 2020 2020 2020 2067 6466               gdf
+0000d490: 5f74 6f5f 7772 6974 652e 6765 6f6d 6574  _to_write.geomet
+0000d4a0: 7279 203d 2067 656f 7365 7269 6573 5f75  ry = geoseries_u
+0000d4b0: 7469 6c2e 6861 726d 6f6e 697a 655f 6765  til.harmonize_ge
+0000d4c0: 6f6d 6574 7279 7479 7065 7328 0a20 2020  ometrytypes(.   
+0000d4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d4e0: 2067 6466 2e67 656f 6d65 7472 792c 2066   gdf.geometry, f
+0000d4f0: 6f72 6365 5f6d 756c 7469 7479 7065 3d66  orce_multitype=f
+0000d500: 6f72 6365 5f6d 756c 7469 7479 7065 0a20  orce_multitype. 
+0000d510: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0000d520: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+0000d530: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000d540: 2020 2067 6466 5f74 6f5f 7772 6974 6520     gdf_to_write 
+0000d550: 3d20 6764 660a 2020 2020 2020 2020 2020  = gdf.          
+0000d560: 2020 6764 665f 746f 5f77 7269 7465 2e74    gdf_to_write.t
+0000d570: 6f5f 6669 6c65 2873 7472 2870 6174 6829  o_file(str(path)
+0000d580: 2c20 6c61 7965 723d 6c61 7965 722c 202a  , layer=layer, *
+0000d590: 2a6b 7761 7267 7329 2020 2320 7479 7065  *kwargs)  # type
+0000d5a0: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
+0000d5b0: 2065 6c69 6620 6765 6f66 696c 6574 7970   elif geofiletyp
+0000d5c0: 6520 3d3d 2047 656f 6669 6c65 5479 7065  e == GeofileType
+0000d5d0: 2e53 514c 6974 653a 0a20 2020 2020 2020  .SQLite:.       
+0000d5e0: 2020 2020 2067 6466 2e74 6f5f 6669 6c65       gdf.to_file
+0000d5f0: 2873 7472 2870 6174 6829 2c20 6c61 7965  (str(path), laye
+0000d600: 723d 6c61 7965 722c 202a 2a6b 7761 7267  r=layer, **kwarg
+0000d610: 7329 0a20 2020 2020 2020 2065 6c69 6620  s).        elif 
+0000d620: 6765 6f66 696c 6574 7970 6520 3d3d 2047  geofiletype == G
+0000d630: 656f 6669 6c65 5479 7065 2e47 656f 4a53  eofileType.GeoJS
+0000d640: 4f4e 3a0a 2020 2020 2020 2020 2020 2020  ON:.            
+0000d650: 6764 662e 746f 5f66 696c 6528 7374 7228  gdf.to_file(str(
+0000d660: 7061 7468 292c 202a 2a6b 7761 7267 7329  path), **kwargs)
+0000d670: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0000d680: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+0000d690: 2056 616c 7565 4572 726f 7228 6622 4e6f   ValueError(f"No
+0000d6a0: 7420 696d 706c 656d 656e 7465 6420 666f  t implemented fo
+0000d6b0: 7220 6765 6f66 696c 6574 7970 6520 7b67  r geofiletype {g
+0000d6c0: 656f 6669 6c65 7479 7065 7d22 290a 0a20  eofiletype}").. 
+0000d6d0: 2020 2023 2049 6620 6e6f 2061 7070 656e     # If no appen
+0000d6e0: 642c 206a 7573 7420 7772 6974 6520 746f  d, just write to
+0000d6f0: 206f 7574 7075 7420 7061 7468 0a20 2020   output path.   
+0000d700: 2069 6620 6e6f 7420 6170 7065 6e64 3a0a   if not append:.
+0000d710: 2020 2020 2020 2020 7772 6974 655f 746f          write_to
+0000d720: 5f66 696c 6528 0a20 2020 2020 2020 2020  _file(.         
+0000d730: 2020 2067 6466 3d67 6466 2c0a 2020 2020     gdf=gdf,.    
+0000d740: 2020 2020 2020 2020 7061 7468 3d70 6174          path=pat
+0000d750: 682c 0a20 2020 2020 2020 2020 2020 206c  h,.            l
+0000d760: 6179 6572 3d6c 6179 6572 2c0a 2020 2020  ayer=layer,.    
+0000d770: 2020 2020 2020 2020 696e 6465 783d 696e          index=in
+0000d780: 6465 782c 0a20 2020 2020 2020 2020 2020  dex,.           
+0000d790: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
+0000d7a0: 6f6d 6574 7279 7479 7065 3d66 6f72 6365  ometrytype=force
+0000d7b0: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
+0000d7c0: 7479 7065 2c0a 2020 2020 2020 2020 2020  type,.          
+0000d7d0: 2020 666f 7263 655f 6d75 6c74 6974 7970    force_multityp
+0000d7e0: 653d 666f 7263 655f 6d75 6c74 6974 7970  e=force_multityp
+0000d7f0: 652c 0a20 2020 2020 2020 2020 2020 2061  e,.            a
+0000d800: 7070 656e 643d 6170 7065 6e64 2c0a 2020  ppend=append,.  
+0000d810: 2020 2020 2020 2020 2020 7363 6865 6d61            schema
+0000d820: 3d73 6368 656d 612c 0a20 2020 2020 2020  =schema,.       
+0000d830: 2020 2020 2063 7265 6174 655f 7370 6174       create_spat
+0000d840: 6961 6c5f 696e 6465 783d 6372 6561 7465  ial_index=create
+0000d850: 5f73 7061 7469 616c 5f69 6e64 6578 2c0a  _spatial_index,.
+0000d860: 2020 2020 2020 2020 290a 2020 2020 656c          ).    el
+0000d870: 7365 3a0a 2020 2020 2020 2020 2320 4170  se:.        # Ap
+0000d880: 7065 6e64 2069 7320 6173 6b65 642c 2063  pend is asked, c
+0000d890: 6865 636b 2069 6620 7468 6520 6669 6f6e  heck if the fion
+0000d8a0: 6120 6472 6976 6572 2073 7570 706f 7274  a driver support
+0000d8b0: 7320 6170 7065 6e64 696e 672e 2049 660a  s appending. If.
+0000d8c0: 2020 2020 2020 2020 2320 6e6f 742c 2077          # not, w
+0000d8d0: 7269 7465 2074 6f20 7465 6d70 6f72 6172  rite to temporar
+0000d8e0: 7920 6f75 7470 7574 2066 696c 650a 0a20  y output file.. 
+0000d8f0: 2020 2020 2020 2023 2052 656d 6172 6b3a         # Remark:
+0000d900: 2066 696f 6e61 2070 7265 2d31 2e38 2e31   fiona pre-1.8.1
+0000d910: 3420 6469 646e 2774 2073 7570 706f 7274  4 didn't support
+0000d920: 2061 7070 656e 6469 6e67 2074 6f20 6765   appending to ge
+0000d930: 6f70 6163 6b61 6765 2e20 4f6e 6365 0a20  opackage. Once. 
+0000d940: 2020 2020 2020 2023 206f 6c64 6572 2076         # older v
+0000d950: 6572 7369 6f6e 7320 6265 636f 6d65 7320  ersions becomes 
+0000d960: 7261 7265 2c20 6465 7065 6e64 656e 6379  rare, dependency
+0000d970: 2063 616e 2062 6520 7075 7420 746f 2074   can be put to t
+0000d980: 6869 7320 7665 7273 696f 6e2c 2061 6e64  his version, and
+0000d990: 0a20 2020 2020 2020 2023 2074 6869 7320  .        # this 
+0000d9a0: 636f 6465 2063 616e 2062 6520 636c 6561  code can be clea
+0000d9b0: 6e65 6420 7570 2e2e 2e0a 2020 2020 2020  ned up....      
+0000d9c0: 2020 6765 6f66 696c 6574 7970 6520 3d20    geofiletype = 
+0000d9d0: 4765 6f66 696c 6554 7970 6528 7061 7468  GeofileType(path
+0000d9e0: 290a 2020 2020 2020 2020 6764 6674 656d  ).        gdftem
+0000d9f0: 705f 7061 7468 203d 204e 6f6e 650a 2020  p_path = None.  
+0000da00: 2020 2020 2020 6764 6674 656d 705f 6c6f        gdftemp_lo
+0000da10: 636b 7061 7468 203d 204e 6f6e 650a 2020  ckpath = None.  
+0000da20: 2020 2020 2020 6966 2022 6122 206e 6f74        if "a" not
+0000da30: 2069 6e20 6669 6f6e 612e 7375 7070 6f72   in fiona.suppor
+0000da40: 7465 645f 6472 6976 6572 735b 6765 6f66  ted_drivers[geof
+0000da50: 696c 6574 7970 652e 6f67 7264 7269 7665  iletype.ogrdrive
+0000da60: 725d 3a0a 2020 2020 2020 2020 2020 2020  r]:.            
+0000da70: 2320 4765 7420 6120 756e 6971 7565 2074  # Get a unique t
+0000da80: 656d 7020 6669 6c65 2070 6174 682e 2054  emp file path. T
+0000da90: 6865 2066 696c 6520 6361 6e6e 6f74 2062  he file cannot b
+0000daa0: 6520 6372 6561 7465 6420 7965 742c 2073  e created yet, s
+0000dab0: 6f0a 2020 2020 2020 2020 2020 2020 2320  o.            # 
+0000dac0: 6f6e 6c79 2063 7265 6174 6520 6120 6c6f  only create a lo
+0000dad0: 636b 2066 696c 6520 746f 2065 7661 6465  ck file to evade
+0000dae0: 206f 7468 6572 2070 726f 6365 7373 6573   other processes
+0000daf0: 2075 7369 6e67 2074 6865 2073 616d 650a   using the same.
+0000db00: 2020 2020 2020 2020 2020 2020 2320 7465              # te
+0000db10: 6d70 2066 696c 6520 6e61 6d65 0a20 2020  mp file name.   
+0000db20: 2020 2020 2020 2020 2067 6466 7465 6d70           gdftemp
+0000db30: 5f70 6174 682c 2067 6466 7465 6d70 5f6c  _path, gdftemp_l
+0000db40: 6f63 6b70 6174 6820 3d20 5f69 6f5f 7574  ockpath = _io_ut
+0000db50: 696c 2e67 6574 5f74 656d 7066 696c 655f  il.get_tempfile_
+0000db60: 6c6f 636b 6564 280a 2020 2020 2020 2020  locked(.        
+0000db70: 2020 2020 2020 2020 6261 7365 5f66 696c          base_fil
+0000db80: 656e 616d 653d 2267 6466 7465 6d70 222c  ename="gdftemp",
+0000db90: 2073 7566 6669 783d 7061 7468 2e73 7566   suffix=path.suf
+0000dba0: 6669 782c 2064 6972 6e61 6d65 3d22 6765  fix, dirname="ge
+0000dbb0: 6f66 696c 655f 746f 5f66 696c 6522 0a20  ofile_to_file". 
+0000dbc0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+0000dbd0: 2020 2020 2020 2020 2077 7269 7465 5f74           write_t
+0000dbe0: 6f5f 6669 6c65 280a 2020 2020 2020 2020  o_file(.        
+0000dbf0: 2020 2020 2020 2020 6764 662c 0a20 2020          gdf,.   
+0000dc00: 2020 2020 2020 2020 2020 2020 2070 6174               pat
+0000dc10: 683d 6764 6674 656d 705f 7061 7468 2c0a  h=gdftemp_path,.
+0000dc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc30: 6c61 7965 723d 6c61 7965 722c 0a20 2020  layer=layer,.   
+0000dc40: 2020 2020 2020 2020 2020 2020 2069 6e64               ind
+0000dc50: 6578 3d69 6e64 6578 2c0a 2020 2020 2020  ex=index,.      
+0000dc60: 2020 2020 2020 2020 2020 666f 7263 655f            force_
+0000dc70: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
+0000dc80: 7970 653d 666f 7263 655f 6f75 7470 7574  ype=force_output
+0000dc90: 5f67 656f 6d65 7472 7974 7970 652c 0a20  _geometrytype,. 
+0000dca0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0000dcb0: 6f72 6365 5f6d 756c 7469 7479 7065 3d66  orce_multitype=f
+0000dcc0: 6f72 6365 5f6d 756c 7469 7479 7065 2c0a  orce_multitype,.
+0000dcd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dce0: 7363 6865 6d61 3d73 6368 656d 612c 0a20  schema=schema,. 
+0000dcf0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0000dd00: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
+0000dd10: 6465 783d 6372 6561 7465 5f73 7061 7469  dex=create_spati
+0000dd20: 616c 5f69 6e64 6578 2c0a 2020 2020 2020  al_index,.      
+0000dd30: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+0000dd40: 2023 2046 696c 6573 2064 6f6e 2774 2074   # Files don't t
+0000dd50: 7970 6963 616c 6c79 2073 7570 706f 7274  ypically support
+0000dd60: 2068 6176 696e 6720 6d75 6c74 6970 6c65   having multiple
+0000dd70: 2070 726f 6365 7373 6573 2077 7269 7469   processes writi
+0000dd80: 6e67 0a20 2020 2020 2020 2023 2073 696d  ng.        # sim
+0000dd90: 756c 7461 6e6f 7573 6c79 2074 6f20 7468  ultanously to th
+0000dda0: 656d 2c20 736f 2075 7365 206c 6f63 6b20  em, so use lock 
+0000ddb0: 6669 6c65 2074 6f20 7379 6e63 6872 6f6e  file to synchron
+0000ddc0: 697a 6520 6163 6365 7373 2e0a 2020 2020  ize access..    
+0000ddd0: 2020 2020 6c6f 636b 6669 6c65 203d 2050      lockfile = P
+0000dde0: 6174 6828 6622 7b73 7472 2870 6174 6829  ath(f"{str(path)
+0000ddf0: 7d2e 6c6f 636b 2229 0a20 2020 2020 2020  }.lock").       
+0000de00: 2073 7461 7274 5f74 696d 6520 3d20 6461   start_time = da
+0000de10: 7465 7469 6d65 2e64 6174 6574 696d 652e  tetime.datetime.
+0000de20: 6e6f 7728 290a 2020 2020 2020 2020 7265  now().        re
+0000de30: 6164 7920 3d20 4661 6c73 650a 2020 2020  ady = False.    
+0000de40: 2020 2020 7768 696c 6520 6e6f 7420 7265      while not re
+0000de50: 6164 793a 0a20 2020 2020 2020 2020 2020  ady:.           
+0000de60: 2069 6620 5f69 6f5f 7574 696c 2e63 7265   if _io_util.cre
+0000de70: 6174 655f 6669 6c65 5f61 746f 6d69 6328  ate_file_atomic(
+0000de80: 6c6f 636b 6669 6c65 2920 6973 2054 7275  lockfile) is Tru
+0000de90: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000dea0: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+0000deb0: 2020 2020 2020 2020 2020 2020 2320 4966              # If
+0000dec0: 2067 6466 2077 6173 6e27 7420 7772 6974   gdf wasn't writ
+0000ded0: 7465 6e20 746f 2074 656d 7020 6669 6c65  ten to temp file
+0000dee0: 2c20 7573 6520 7374 616e 6461 7264 2077  , use standard w
+0000def0: 7269 7465 2d74 6f2d 6669 6c65 0a20 2020  rite-to-file.   
+0000df00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df10: 2069 6620 6764 6674 656d 705f 7061 7468   if gdftemp_path
+0000df20: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+0000df30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df40: 2020 7772 6974 655f 746f 5f66 696c 6528    write_to_file(
+0000df50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000df60: 2020 2020 2020 2020 2020 2020 2067 6466               gdf
+0000df70: 3d67 6466 2c0a 2020 2020 2020 2020 2020  =gdf,.          
+0000df80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df90: 2020 7061 7468 3d70 6174 682c 0a20 2020    path=path,.   
+0000dfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dfb0: 2020 2020 2020 2020 206c 6179 6572 3d6c           layer=l
+0000dfc0: 6179 6572 2c0a 2020 2020 2020 2020 2020  ayer,.          
+0000dfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dfe0: 2020 696e 6465 783d 696e 6465 782c 0a20    index=index,. 
+0000dff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e000: 2020 2020 2020 2020 2020 2066 6f72 6365             force
+0000e010: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
+0000e020: 7479 7065 3d66 6f72 6365 5f6f 7574 7075  type=force_outpu
+0000e030: 745f 6765 6f6d 6574 7279 7479 7065 2c0a  t_geometrytype,.
+0000e040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e050: 2020 2020 2020 2020 2020 2020 666f 7263              forc
+0000e060: 655f 6d75 6c74 6974 7970 653d 666f 7263  e_multitype=forc
+0000e070: 655f 6d75 6c74 6974 7970 652c 0a20 2020  e_multitype,.   
+0000e080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e090: 2020 2020 2020 2020 2061 7070 656e 643d           append=
+0000e0a0: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
+0000e0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e0c0: 2020 7363 6865 6d61 3d73 6368 656d 612c    schema=schema,
+0000e0d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e0e0: 2020 2020 2020 2020 2020 2020 2063 7265               cre
+0000e0f0: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
+0000e100: 783d 6372 6561 7465 5f73 7061 7469 616c  x=create_spatial
+0000e110: 5f69 6e64 6578 2c0a 2020 2020 2020 2020  _index,.        
+0000e120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e130: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000e140: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000e150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e160: 2020 2020 2320 4966 2067 6466 2077 7269      # If gdf wri
+0000e170: 7474 656e 2074 6f20 7465 6d70 2066 696c  tten to temp fil
+0000e180: 652c 2075 7365 2061 7070 656e 645f 746f  e, use append_to
+0000e190: 5f6e 6f6c 6f63 6b20 2b20 636c 6561 6e75  _nolock + cleanu
+0000e1a0: 700a 2020 2020 2020 2020 2020 2020 2020  p.              
+0000e1b0: 2020 2020 2020 2020 2020 5f61 7070 656e            _appen
+0000e1c0: 645f 746f 5f6e 6f6c 6f63 6b28 0a20 2020  d_to_nolock(.   
+0000e1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e1e0: 2020 2020 2020 2020 2073 7263 3d67 6466           src=gdf
+0000e1f0: 7465 6d70 5f70 6174 682c 0a20 2020 2020  temp_path,.     
+0000e200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e210: 2020 2020 2020 2064 7374 3d70 6174 682c         dst=path,
+0000e220: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e230: 2020 2020 2020 2020 2020 2020 2064 7374               dst
+0000e240: 5f6c 6179 6572 3d6c 6179 6572 2c0a 2020  _layer=layer,.  
+0000e250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e260: 2020 2020 2020 2020 2020 666f 7263 655f            force_
+0000e270: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
+0000e280: 7970 653d 666f 7263 655f 6f75 7470 7574  ype=force_output
+0000e290: 5f67 656f 6d65 7472 7974 7970 652c 0a20  _geometrytype,. 
+0000e2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e2b0: 2020 2020 2020 2020 2020 2063 7265 6174             creat
+0000e2c0: 655f 7370 6174 6961 6c5f 696e 6465 783d  e_spatial_index=
+0000e2d0: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
+0000e2e0: 6e64 6578 2c0a 2020 2020 2020 2020 2020  ndex,.          
+0000e2f0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000e300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e310: 2020 2020 2020 2020 7265 6d6f 7665 2867          remove(g
+0000e320: 6466 7465 6d70 5f70 6174 6829 0a20 2020  dftemp_path).   
+0000e330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e340: 2020 2020 2069 6620 6764 6674 656d 705f       if gdftemp_
+0000e350: 6c6f 636b 7061 7468 2069 7320 6e6f 7420  lockpath is not 
+0000e360: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0000e370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e380: 2020 6764 6674 656d 705f 6c6f 636b 7061    gdftemp_lockpa
+0000e390: 7468 2e75 6e6c 696e 6b28 290a 2020 2020  th.unlink().    
+0000e3a0: 2020 2020 2020 2020 2020 2020 6578 6365              exce
+0000e3b0: 7074 2045 7863 6570 7469 6f6e 2061 7320  pt Exception as 
+0000e3c0: 6578 3a0a 2020 2020 2020 2020 2020 2020  ex:.            
+0000e3d0: 2020 2020 2020 2020 2320 4966 2073 716c          # If sql
+0000e3e0: 6974 6520 6f75 7470 7574 2066 696c 6520  ite output file 
+0000e3f0: 6c6f 636b 6564 2c20 616c 736f 2072 6574  locked, also ret
+0000e400: 7279 0a20 2020 2020 2020 2020 2020 2020  ry.             
+0000e410: 2020 2020 2020 2069 6620 6765 6f66 696c         if geofil
+0000e420: 6574 7970 652e 6973 5f73 7061 7469 616c  etype.is_spatial
+0000e430: 6974 655f 6261 7365 6420 616e 6420 7374  ite_based and st
+0000e440: 7228 6578 2920 6e6f 7420 696e 205b 0a20  r(ex) not in [. 
+0000e450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e460: 2020 2020 2020 2022 6461 7461 6261 7365         "database
+0000e470: 2069 7320 6c6f 636b 6564 222c 0a20 2020   is locked",.   
+0000e480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e490: 2020 2020 2022 6174 7465 6d70 7420 746f       "attempt to
+0000e4a0: 2077 7269 7465 2061 2072 6561 646f 6e6c   write a readonl
+0000e4b0: 7920 6461 7461 6261 7365 222c 0a20 2020  y database",.   
+0000e4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e4d0: 205d 3a0a 2020 2020 2020 2020 2020 2020   ]:.            
+0000e4e0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+0000e4f0: 6520 6578 0a20 2020 2020 2020 2020 2020  e ex.           
+0000e500: 2020 2020 2066 696e 616c 6c79 3a0a 2020       finally:.  
+0000e510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e520: 2020 7265 6164 7920 3d20 5472 7565 0a20    ready = True. 
+0000e530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e540: 2020 206c 6f63 6b66 696c 652e 756e 6c69     lockfile.unli
+0000e550: 6e6b 2829 0a20 2020 2020 2020 2020 2020  nk().           
+0000e560: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000e570: 2020 2020 2020 2074 696d 655f 7761 6974         time_wait
+0000e580: 696e 6720 3d20 2864 6174 6574 696d 652e  ing = (datetime.
+0000e590: 6461 7465 7469 6d65 2e6e 6f77 2829 202d  datetime.now() -
+0000e5a0: 2073 7461 7274 5f74 696d 6529 2e74 6f74   start_time).tot
+0000e5b0: 616c 5f73 6563 6f6e 6473 2829 0a20 2020  al_seconds().   
+0000e5c0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000e5d0: 7469 6d65 5f77 6169 7469 6e67 203e 2061  time_waiting > a
+0000e5e0: 7070 656e 645f 7469 6d65 6f75 745f 733a  ppend_timeout_s:
+0000e5f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e600: 2020 2020 2072 6169 7365 2052 756e 7469       raise Runti
+0000e610: 6d65 4572 726f 7228 0a20 2020 2020 2020  meError(.       
+0000e620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e630: 2066 2274 6f5f 6669 6c65 2074 696d 656f   f"to_file timeo
+0000e640: 7574 206f 6620 7b61 7070 656e 645f 7469  ut of {append_ti
+0000e650: 6d65 6f75 745f 737d 2072 6561 6368 6564  meout_s} reached
+0000e660: 2c20 7374 6f70 2061 7070 656e 6420 220a  , stop append ".
+0000e670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e680: 2020 2020 2020 2020 6622 746f 207b 7061          f"to {pa
+0000e690: 7468 7d21 220a 2020 2020 2020 2020 2020  th}!".          
+0000e6a0: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+0000e6b0: 2020 2020 2020 2020 2023 2053 6c65 6570           # Sleep
+0000e6c0: 2066 6f72 2061 2073 6563 6f6e 6420 6265   for a second be
+0000e6d0: 666f 7265 2074 7279 696e 6720 6167 6169  fore trying agai
+0000e6e0: 6e0a 2020 2020 2020 2020 2020 2020 7469  n.            ti
+0000e6f0: 6d65 2e73 6c65 6570 2831 290a 0a0a 6465  me.sleep(1)...de
+0000e700: 6620 5f74 6f5f 6669 6c65 5f70 796f 6772  f _to_file_pyogr
+0000e710: 696f 280a 2020 2020 6764 663a 2055 6e69  io(.    gdf: Uni
+0000e720: 6f6e 5b70 642e 4461 7461 4672 616d 652c  on[pd.DataFrame,
+0000e730: 2067 7064 2e47 656f 4461 7461 4672 616d   gpd.GeoDataFram
+0000e740: 655d 2c0a 2020 2020 7061 7468 3a20 5061  e],.    path: Pa
+0000e750: 7468 2c0a 2020 2020 6c61 7965 723a 2073  th,.    layer: s
+0000e760: 7472 2c0a 2020 2020 666f 7263 655f 6f75  tr,.    force_ou
+0000e770: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+0000e780: 653a 2055 6e69 6f6e 5b47 656f 6d65 7472  e: Union[Geometr
+0000e790: 7954 7970 652c 2073 7472 2c20 4e6f 6e65  yType, str, None
+0000e7a0: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 666f  ] = None,.    fo
+0000e7b0: 7263 655f 6d75 6c74 6974 7970 653a 2062  rce_multitype: b
+0000e7c0: 6f6f 6c20 3d20 4661 6c73 652c 0a20 2020  ool = False,.   
+0000e7d0: 2061 7070 656e 643a 2062 6f6f 6c20 3d20   append: bool = 
+0000e7e0: 4661 6c73 652c 0a20 2020 2061 7070 656e  False,.    appen
+0000e7f0: 645f 7469 6d65 6f75 745f 733a 2069 6e74  d_timeout_s: int
+0000e800: 203d 2036 3030 2c0a 2020 2020 696e 6465   = 600,.    inde
+0000e810: 783a 2062 6f6f 6c20 3d20 5472 7565 2c0a  x: bool = True,.
+0000e820: 2020 2020 6372 6561 7465 5f73 7061 7469      create_spati
+0000e830: 616c 5f69 6e64 6578 3a20 4f70 7469 6f6e  al_index: Option
+0000e840: 616c 5b62 6f6f 6c5d 203d 2054 7275 652c  al[bool] = True,
+0000e850: 0a29 3a0a 2020 2020 2222 220a 2020 2020  .):.    """.    
+0000e860: 5772 6974 6573 2061 2070 616e 6461 7320  Writes a pandas 
+0000e870: 6461 7461 6672 616d 6520 746f 2066 696c  dataframe to fil
+0000e880: 6520 7573 696e 6720 7079 6f67 7269 6f2e  e using pyogrio.
+0000e890: 0a20 2020 2022 2222 0a20 2020 2023 2050  .    """.    # P
+0000e8a0: 7265 7061 7265 2061 7267 7320 666f 7220  repare args for 
+0000e8b0: 7772 6974 655f 6461 7461 6672 616d 650a  write_dataframe.
+0000e8c0: 2020 2020 6b77 6172 6773 203d 207b 7d0a      kwargs = {}.
+0000e8d0: 0a20 2020 2069 6620 6170 7065 6e64 2069  .    if append i
+0000e8e0: 7320 5472 7565 2061 6e64 2070 6174 682e  s True and path.
+0000e8f0: 6578 6973 7473 2829 3a0a 2020 2020 2020  exists():.      
+0000e900: 2020 6b77 6172 6773 5b22 6170 7065 6e64    kwargs["append
+0000e910: 225d 203d 2054 7275 650a 2020 2020 2020  "] = True.      
+0000e920: 2020 6c61 7965 7269 6e66 6f20 3d20 6765    layerinfo = ge
+0000e930: 745f 6c61 7965 7269 6e66 6f28 7061 7468  t_layerinfo(path
+0000e940: 2c20 6c61 7965 7229 0a20 2020 2020 2020  , layer).       
+0000e950: 2066 696c 655f 636f 6c73 203d 205b 636f   file_cols = [co
+0000e960: 6c2e 7570 7065 7228 2920 666f 7220 636f  l.upper() for co
+0000e970: 6c20 696e 206c 6179 6572 696e 666f 2e63  l in layerinfo.c
+0000e980: 6f6c 756d 6e73 5d0a 2020 2020 2020 2020  olumns].        
+0000e990: 6764 665f 636f 6c73 203d 205b 636f 6c2e  gdf_cols = [col.
+0000e9a0: 7570 7065 7228 2920 666f 7220 636f 6c20  upper() for col 
+0000e9b0: 696e 2067 6466 2e63 6f6c 756d 6e73 2069  in gdf.columns i
+0000e9c0: 6620 636f 6c20 213d 2067 6466 2e67 656f  f col != gdf.geo
+0000e9d0: 6d65 7472 792e 6e61 6d65 5d0a 2020 2020  metry.name].    
+0000e9e0: 2020 2020 6966 2067 6466 5f63 6f6c 7320      if gdf_cols 
+0000e9f0: 213d 2066 696c 655f 636f 6c73 3a0a 2020  != file_cols:.  
+0000ea00: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+0000ea10: 5661 6c75 6545 7272 6f72 280a 2020 2020  ValueError(.    
+0000ea20: 2020 2020 2020 2020 2020 2020 2264 6573              "des
+0000ea30: 7469 6e61 7469 6f6e 206c 6179 6572 2064  tination layer d
+0000ea40: 6f65 736e 2774 2068 6176 6520 7468 6520  oesn't have the 
+0000ea50: 7361 6d65 2063 6f6c 756d 6e73 2061 7320  same columns as 
+0000ea60: 6764 663a 2022 0a20 2020 2020 2020 2020  gdf: ".         
+0000ea70: 2020 2020 2020 2066 227b 6669 6c65 5f63         f"{file_c
+0000ea80: 6f6c 737d 2076 7320 7b67 6466 5f63 6f6c  ols} vs {gdf_col
+0000ea90: 737d 220a 2020 2020 2020 2020 2020 2020  s}".            
+0000eaa0: 290a 0a20 2020 2069 6620 6372 6561 7465  )..    if create
+0000eab0: 5f73 7061 7469 616c 5f69 6e64 6578 2069  _spatial_index i
+0000eac0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+0000ead0: 2020 2020 6b77 6172 6773 5b22 5350 4154      kwargs["SPAT
+0000eae0: 4941 4c5f 494e 4445 5822 5d20 3d20 6372  IAL_INDEX"] = cr
+0000eaf0: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
+0000eb00: 6578 0a20 2020 2067 656f 6669 6c65 7479  ex.    geofilety
+0000eb10: 7065 203d 2047 656f 6669 6c65 5479 7065  pe = GeofileType
+0000eb20: 2870 6174 6829 0a20 2020 206b 7761 7267  (path).    kwarg
+0000eb30: 735b 2264 7269 7665 7222 5d20 3d20 6765  s["driver"] = ge
+0000eb40: 6f66 696c 6574 7970 652e 6f67 7264 7269  ofiletype.ogrdri
+0000eb50: 7665 720a 2020 2020 6966 2063 7265 6174  ver.    if creat
+0000eb60: 655f 7370 6174 6961 6c5f 696e 6465 7820  e_spatial_index 
+0000eb70: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+0000eb80: 2020 2020 206b 7761 7267 735b 2253 5041       kwargs["SPA
+0000eb90: 5449 414c 5f49 4e44 4558 225d 203d 2063  TIAL_INDEX"] = c
+0000eba0: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
+0000ebb0: 6465 780a 2020 2020 6966 2066 6f72 6365  dex.    if force
+0000ebc0: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
+0000ebd0: 7479 7065 2069 7320 6e6f 7420 4e6f 6e65  type is not None
+0000ebe0: 3a0a 2020 2020 2020 2020 6966 2069 7369  :.        if isi
+0000ebf0: 6e73 7461 6e63 6528 666f 7263 655f 6f75  nstance(force_ou
+0000ec00: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+0000ec10: 652c 2047 656f 6d65 7472 7954 7970 6529  e, GeometryType)
+0000ec20: 3a0a 2020 2020 2020 2020 2020 2020 666f  :.            fo
+0000ec30: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
+0000ec40: 7472 7974 7970 6520 3d20 666f 7263 655f  trytype = force_
+0000ec50: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
+0000ec60: 7970 652e 6e61 6d65 5f63 616d 656c 6361  ype.name_camelca
+0000ec70: 7365 0a20 2020 2020 2020 206b 7761 7267  se.        kwarg
+0000ec80: 735b 2267 656f 6d65 7472 795f 7479 7065  s["geometry_type
+0000ec90: 225d 203d 2066 6f72 6365 5f6f 7574 7075  "] = force_outpu
+0000eca0: 745f 6765 6f6d 6574 7279 7479 7065 0a20  t_geometrytype. 
+0000ecb0: 2020 2069 6620 666f 7263 655f 6d75 6c74     if force_mult
+0000ecc0: 6974 7970 653a 0a20 2020 2020 2020 206b  itype:.        k
+0000ecd0: 7761 7267 735b 2270 726f 6d6f 7465 5f74  wargs["promote_t
+0000ece0: 6f5f 6d75 6c74 6922 5d20 3d20 5472 7565  o_multi"] = True
+0000ecf0: 0a0a 2020 2020 2320 4e6f 7720 7765 2063  ..    # Now we c
+0000ed00: 616e 2077 7269 7465 0a20 2020 2067 6466  an write.    gdf
+0000ed10: 5f74 6f5f 7772 6974 6520 3d20 6764 660a  _to_write = gdf.
+0000ed20: 2020 2020 6966 2067 656f 6669 6c65 7479      if geofilety
+0000ed30: 7065 203d 3d20 4765 6f66 696c 6554 7970  pe == GeofileTyp
+0000ed40: 652e 4553 5249 5368 6170 6566 696c 653a  e.ESRIShapefile:
+0000ed50: 0a20 2020 2020 2020 2069 6620 696e 6465  .        if inde
+0000ed60: 7820 6973 2054 7275 653a 0a20 2020 2020  x is True:.     
+0000ed70: 2020 2020 2020 2067 6466 5f74 6f5f 7772         gdf_to_wr
+0000ed80: 6974 6520 3d20 6764 662e 7265 7365 745f  ite = gdf.reset_
+0000ed90: 696e 6465 7828 6472 6f70 3d54 7275 6529  index(drop=True)
+0000eda0: 0a0a 2020 2020 6966 2067 656f 6669 6c65  ..    if geofile
+0000edb0: 7479 7065 2e69 735f 7369 6e67 6c65 6c61  type.is_singlela
+0000edc0: 7965 723a 0a20 2020 2020 2020 2070 796f  yer:.        pyo
+0000edd0: 6772 696f 2e77 7269 7465 5f64 6174 6166  grio.write_dataf
+0000ede0: 7261 6d65 2867 6466 5f74 6f5f 7772 6974  rame(gdf_to_writ
+0000edf0: 652c 2073 7472 2870 6174 6829 2c20 2a2a  e, str(path), **
+0000ee00: 6b77 6172 6773 290a 2020 2020 656c 7365  kwargs).    else
+0000ee10: 3a0a 2020 2020 2020 2020 7079 6f67 7269  :.        pyogri
+0000ee20: 6f2e 7772 6974 655f 6461 7461 6672 616d  o.write_datafram
+0000ee30: 6528 6764 665f 746f 5f77 7269 7465 2c20  e(gdf_to_write, 
+0000ee40: 7374 7228 7061 7468 292c 206c 6179 6572  str(path), layer
+0000ee50: 3d6c 6179 6572 2c20 2a2a 6b77 6172 6773  =layer, **kwargs
+0000ee60: 290a 0a20 2020 2072 6574 7572 6e0a 0a0a  )..    return...
+0000ee70: 6465 6620 6765 745f 6372 7328 7061 7468  def get_crs(path
+0000ee80: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
+0000ee90: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
+0000eea0: 2920 2d3e 2070 7970 726f 6a2e 4352 533a  ) -> pyproj.CRS:
+0000eeb0: 0a20 2020 2022 2222 0a20 2020 2047 6574  .    """.    Get
+0000eec0: 2074 6865 2043 5253 2028 7072 6f6a 6563   the CRS (projec
+0000eed0: 7469 6f6e 2920 6f66 2074 6865 2066 696c  tion) of the fil
+0000eee0: 650a 0a20 2020 2041 7267 733a 0a20 2020  e..    Args:.   
+0000eef0: 2020 2020 2070 6174 6820 2850 6174 684c       path (PathL
+0000ef00: 696b 6529 3a20 5061 7468 2074 6f20 7468  ike): Path to th
+0000ef10: 6520 6669 6c65 2e0a 0a20 2020 2052 6574  e file...    Ret
+0000ef20: 7572 6e73 3a0a 2020 2020 2020 2020 7079  urns:.        py
+0000ef30: 7072 6f6a 2e43 5253 3a20 5468 6520 7072  proj.CRS: The pr
+0000ef40: 6f6a 6563 7469 6f6e 206f 6620 7468 6520  ojection of the 
+0000ef50: 6669 6c65 0a20 2020 2022 2222 0a20 2020  file.    """.   
+0000ef60: 2023 2054 4f44 4f3a 2073 6565 6d73 206c   # TODO: seems l
+0000ef70: 696b 6520 7375 7070 6f72 7420 666f 7220  ike support for 
+0000ef80: 6d75 6c74 6970 6c65 206c 6179 6572 7320  multiple layers 
+0000ef90: 696e 2074 6865 2066 696c 6520 6973 6e27  in the file isn'
+0000efa0: 7420 6865 7265 2079 6574 3f3f 3f0a 2020  t here yet???.  
+0000efb0: 2020 7769 7468 2066 696f 6e61 2e6f 7065    with fiona.ope
+0000efc0: 6e28 7374 7228 7061 7468 292c 2022 7222  n(str(path), "r"
+0000efd0: 2920 6173 2067 656f 6669 6c65 3a0a 2020  ) as geofile:.  
+0000efe0: 2020 2020 2020 6173 7365 7274 2067 656f        assert geo
+0000eff0: 6669 6c65 2069 7320 6e6f 7420 4e6f 6e65  file is not None
+0000f000: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0000f010: 7079 7072 6f6a 2e43 5253 2867 656f 6669  pyproj.CRS(geofi
+0000f020: 6c65 2e63 7273 290a 0a0a 6465 6620 6973  le.crs)...def is
+0000f030: 5f67 656f 6669 6c65 2870 6174 683a 2055  _geofile(path: U
+0000f040: 6e69 6f6e 5b73 7472 2c20 226f 732e 5061  nion[str, "os.Pa
+0000f050: 7468 4c69 6b65 5b41 6e79 5d22 5d29 202d  thLike[Any]"]) -
+0000f060: 3e20 626f 6f6c 3a0a 2020 2020 2222 220a  > bool:.    """.
+0000f070: 2020 2020 4465 7465 726d 696e 6573 2062      Determines b
+0000f080: 6173 6564 206f 6e20 7468 6520 6669 6c65  ased on the file
+0000f090: 7061 7468 2069 6620 7468 6973 2069 7320  path if this is 
+0000f0a0: 6120 6765 6f66 696c 652e 0a0a 2020 2020  a geofile...    
+0000f0b0: 4172 6773 3a0a 2020 2020 2020 2020 7061  Args:.        pa
+0000f0c0: 7468 2028 5061 7468 4c69 6b65 293a 2054  th (PathLike): T
+0000f0d0: 6865 2066 696c 6520 7061 7468 2e0a 0a20  he file path... 
+0000f0e0: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
+0000f0f0: 2020 2020 626f 6f6c 3a20 5472 7565 2069      bool: True i
+0000f100: 6620 6974 2069 7320 6120 6765 6f20 6669  f it is a geo fi
+0000f110: 6c65 2e0a 2020 2020 2222 220a 2020 2020  le..    """.    
+0000f120: 7265 7475 726e 2069 735f 6765 6f66 696c  return is_geofil
+0000f130: 655f 6578 7428 5061 7468 2870 6174 6829  e_ext(Path(path)
+0000f140: 2e73 7566 6669 7829 0a0a 0a64 6566 2069  .suffix)...def i
+0000f150: 735f 6765 6f66 696c 655f 6578 7428 6669  s_geofile_ext(fi
+0000f160: 6c65 5f65 7874 3a20 7374 7229 202d 3e20  le_ext: str) -> 
+0000f170: 626f 6f6c 3a0a 2020 2020 2222 220a 2020  bool:.    """.  
+0000f180: 2020 4465 7465 726d 696e 6573 2062 6173    Determines bas
+0000f190: 6564 206f 6e20 7468 6520 6669 6c65 2065  ed on the file e
+0000f1a0: 7874 656e 7369 6f6e 2069 6620 7468 6973  xtension if this
+0000f1b0: 2069 7320 6120 6765 6f66 696c 652e 0a0a   is a geofile...
+0000f1c0: 2020 2020 4172 6773 3a0a 2020 2020 2020      Args:.      
+0000f1d0: 2020 6669 6c65 5f65 7874 2028 7374 7229    file_ext (str)
+0000f1e0: 3a20 7468 6520 6578 7465 6e73 696f 6e2e  : the extension.
+0000f1f0: 0a0a 2020 2020 5265 7475 726e 733a 0a20  ..    Returns:. 
+0000f200: 2020 2020 2020 2062 6f6f 6c3a 2054 7275         bool: Tru
+0000f210: 6520 6966 2069 7420 6973 2061 2067 656f  e if it is a geo
+0000f220: 6669 6c65 2e0a 2020 2020 2222 220a 2020  file..    """.  
+0000f230: 2020 7472 793a 0a20 2020 2020 2020 2023    try:.        #
+0000f240: 2049 6620 7468 6520 6472 6976 6572 2063   If the driver c
+0000f250: 616e 2062 6520 6465 7465 726d 696e 6564  an be determined
+0000f260: 2c20 6974 2069 7320 6120 2873 7570 706f  , it is a (suppo
+0000f270: 7274 6564 2920 6765 6f20 6669 6c65 2e0a  rted) geo file..
+0000f280: 2020 2020 2020 2020 5f20 3d20 4765 6f66          _ = Geof
+0000f290: 696c 6554 7970 6528 6669 6c65 5f65 7874  ileType(file_ext
+0000f2a0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+0000f2b0: 2054 7275 650a 2020 2020 6578 6365 7074   True.    except
+0000f2c0: 2045 7863 6570 7469 6f6e 3a0a 2020 2020   Exception:.    
+0000f2d0: 2020 2020 7265 7475 726e 2046 616c 7365      return False
+0000f2e0: 0a0a 0a64 6566 2063 6d70 280a 2020 2020  ...def cmp(.    
+0000f2f0: 7061 7468 313a 2055 6e69 6f6e 5b73 7472  path1: Union[str
+0000f300: 2c20 226f 732e 5061 7468 4c69 6b65 5b41  , "os.PathLike[A
+0000f310: 6e79 5d22 5d2c 2070 6174 6832 3a20 556e  ny]"], path2: Un
+0000f320: 696f 6e5b 7374 722c 2022 6f73 2e50 6174  ion[str, "os.Pat
+0000f330: 684c 696b 655b 416e 795d 225d 0a29 202d  hLike[Any]"].) -
+0000f340: 3e20 626f 6f6c 3a0a 2020 2020 2222 220a  > bool:.    """.
+0000f350: 2020 2020 436f 6d70 6172 6520 6966 2074      Compare if t
+0000f360: 776f 2067 656f 6669 6c65 7320 6172 6520  wo geofiles are 
+0000f370: 6964 656e 7469 6361 6c2e 0a0a 2020 2020  identical...    
+0000f380: 466f 7220 6765 6f66 696c 6573 2074 6861  For geofiles tha
+0000f390: 7420 7573 6520 6d75 6c74 6970 6c65 2066  t use multiple f
+0000f3a0: 696c 6573 2c20 616c 6c20 7265 6c65 7661  iles, all releva
+0000f3b0: 6e74 2066 696c 6573 206d 7573 7420 6265  nt files must be
+0000f3c0: 2069 6465 6e74 6963 616c 2e0a 2020 2020   identical..    
+0000f3d0: 4567 2e20 666f 7220 7368 6170 6566 696c  Eg. for shapefil
+0000f3e0: 6573 2c20 7468 6520 2e73 6870 2c20 2e73  es, the .shp, .s
+0000f3f0: 6878 2061 6e64 202e 6462 6620 6669 6c65  hx and .dbf file
+0000f400: 206d 7573 7420 6265 2069 6465 6e74 6963   must be identic
+0000f410: 616c 2e0a 0a20 2020 2041 7267 733a 0a20  al...    Args:. 
+0000f420: 2020 2020 2020 2070 6174 6831 2028 5061         path1 (Pa
+0000f430: 7468 4c69 6b65 293a 2070 6174 6820 746f  thLike): path to
+0000f440: 2074 6865 2066 6972 7374 2066 696c 652e   the first file.
+0000f450: 0a20 2020 2020 2020 2070 6174 6832 2028  .        path2 (
+0000f460: 5061 7468 4c69 6b65 293a 2070 6174 6820  PathLike): path 
+0000f470: 746f 2074 6865 2073 6563 6f6e 6420 6669  to the second fi
+0000f480: 6c65 2e0a 0a20 2020 2052 6574 7572 6e73  le...    Returns
+0000f490: 3a0a 2020 2020 2020 2020 626f 6f6c 3a20  :.        bool: 
+0000f4a0: 5472 7565 2069 6620 7468 6520 6669 6c65  True if the file
+0000f4b0: 7320 6172 6520 6964 656e 7469 6361 6c0a  s are identical.
+0000f4c0: 2020 2020 2222 220a 2020 2020 2320 4368      """.    # Ch
+0000f4d0: 6563 6b20 696e 7075 7420 7061 7261 6d65  eck input parame
+0000f4e0: 7465 7273 0a20 2020 2070 6174 6831 5f70  ters.    path1_p
+0000f4f0: 203d 2050 6174 6828 7061 7468 3129 0a20   = Path(path1). 
+0000f500: 2020 2070 6174 6832 5f70 203d 2050 6174     path2_p = Pat
+0000f510: 6828 7061 7468 3229 0a0a 2020 2020 2320  h(path2)..    # 
+0000f520: 466f 7220 6120 7368 6170 6566 696c 652c  For a shapefile,
+0000f530: 206d 756c 7469 706c 6520 6669 6c65 7320   multiple files 
+0000f540: 6e65 6564 2074 6f20 6265 2063 6f6d 7061  need to be compa
+0000f550: 7265 640a 2020 2020 6966 2070 6174 6831  red.    if path1
+0000f560: 5f70 2e73 7566 6669 782e 6c6f 7765 7228  _p.suffix.lower(
+0000f570: 2920 3d3d 2022 2e73 6870 223a 0a20 2020  ) == ".shp":.   
+0000f580: 2020 2020 2070 6174 6832 5f6e 6f65 7874       path2_noext
+0000f590: 2c20 5f20 3d20 6f73 2e70 6174 682e 7370  , _ = os.path.sp
+0000f5a0: 6c69 7465 7874 2870 6174 6832 5f70 290a  litext(path2_p).
+0000f5b0: 2020 2020 2020 2020 7368 6170 6566 696c          shapefil
+0000f5c0: 655f 6261 7365 5f73 7566 6669 7865 7320  e_base_suffixes 
+0000f5d0: 3d20 5b22 2e73 6870 222c 2022 2e64 6266  = [".shp", ".dbf
+0000f5e0: 222c 2022 2e73 6878 225d 0a20 2020 2020  ", ".shx"].     
+0000f5f0: 2020 2070 6174 6831 5f6e 6f65 7874 203d     path1_noext =
+0000f600: 2070 6174 6831 5f70 2e70 6172 656e 7420   path1_p.parent 
+0000f610: 2f20 7061 7468 315f 702e 7374 656d 0a20  / path1_p.stem. 
+0000f620: 2020 2020 2020 2070 6174 6832 5f6e 6f65         path2_noe
+0000f630: 7874 203d 2070 6174 6832 5f70 2e70 6172  xt = path2_p.par
+0000f640: 656e 7420 2f20 7061 7468 325f 702e 7374  ent / path2_p.st
+0000f650: 656d 0a20 2020 2020 2020 2066 6f72 2065  em.        for e
+0000f660: 7874 2069 6e20 7368 6170 6566 696c 655f  xt in shapefile_
+0000f670: 6261 7365 5f73 7566 6669 7865 733a 0a20  base_suffixes:. 
+0000f680: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+0000f690: 7420 6669 6c65 636d 702e 636d 7028 6622  t filecmp.cmp(f"
+0000f6a0: 7b73 7472 2870 6174 6831 5f6e 6f65 7874  {str(path1_noext
+0000f6b0: 297d 7b65 7874 7d22 2c20 6622 7b73 7472  )}{ext}", f"{str
+0000f6c0: 2870 6174 6832 5f6e 6f65 7874 297d 7b65  (path2_noext)}{e
+0000f6d0: 7874 7d22 293a 0a20 2020 2020 2020 2020  xt}"):.         
+0000f6e0: 2020 2020 2020 206c 6f67 6765 722e 696e         logger.in
+0000f6f0: 666f 280a 2020 2020 2020 2020 2020 2020  fo(.            
+0000f700: 2020 2020 2020 2020 6622 4669 6c65 207b          f"File {
+0000f710: 7061 7468 315f 6e6f 6578 747d 7b65 7874  path1_noext}{ext
+0000f720: 7d20 6973 2064 6966 6665 7265 6e74 2066  } is different f
+0000f730: 726f 6d20 7b70 6174 6832 5f6e 6f65 7874  rom {path2_noext
+0000f740: 7d7b 6578 747d 220a 2020 2020 2020 2020  }{ext}".        
+0000f750: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0000f760: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000f770: 2046 616c 7365 0a20 2020 2020 2020 2072   False.        r
+0000f780: 6574 7572 6e20 5472 7565 0a20 2020 2065  eturn True.    e
+0000f790: 6c73 653a 0a20 2020 2020 2020 2072 6574  lse:.        ret
+0000f7a0: 7572 6e20 6669 6c65 636d 702e 636d 7028  urn filecmp.cmp(
+0000f7b0: 7374 7228 7061 7468 315f 7029 2c20 7374  str(path1_p), st
+0000f7c0: 7228 7061 7468 325f 7029 290a 0a0a 6465  r(path2_p))...de
+0000f7d0: 6620 636f 7079 2873 7263 3a20 556e 696f  f copy(src: Unio
+0000f7e0: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
+0000f7f0: 696b 655b 416e 795d 225d 2c20 6473 743a  ike[Any]"], dst:
+0000f800: 2055 6e69 6f6e 5b73 7472 2c20 226f 732e   Union[str, "os.
+0000f810: 5061 7468 4c69 6b65 5b41 6e79 5d22 5d29  PathLike[Any]"])
+0000f820: 3a0a 2020 2020 2222 220a 2020 2020 436f  :.    """.    Co
+0000f830: 7069 6573 2074 6865 2067 656f 6669 6c65  pies the geofile
+0000f840: 2066 726f 6d20 7372 6320 746f 2064 7374   from src to dst
+0000f850: 2e20 4973 2074 6865 2073 6f75 7263 6520  . Is the source 
+0000f860: 6669 6c65 2069 7320 6120 6765 6f66 696c  file is a geofil
+0000f870: 6520 636f 6e74 6169 6e69 6e67 0a20 2020  e containing.   
+0000f880: 206f 6620 6d75 6c74 6970 6c65 2066 696c   of multiple fil
+0000f890: 6573 2028 6567 2e20 2e73 6870 2920 616c  es (eg. .shp) al
+0000f8a0: 6c20 6669 6c65 7320 6172 6520 636f 7069  l files are copi
+0000f8b0: 6564 2e0a 0a20 2020 2041 7267 733a 0a20  ed...    Args:. 
+0000f8c0: 2020 2020 2020 2073 7263 2028 5061 7468         src (Path
+0000f8d0: 4c69 6b65 293a 2074 6865 2066 696c 6520  Like): the file 
+0000f8e0: 746f 2063 6f70 792e 0a20 2020 2020 2020  to copy..       
+0000f8f0: 2064 7374 2028 5061 7468 4c69 6b65 293a   dst (PathLike):
+0000f900: 2074 6865 206c 6f63 6174 696f 6e20 746f   the location to
+0000f910: 2063 6f70 7920 7468 6520 6669 6c65 2873   copy the file(s
+0000f920: 2920 746f 2e0a 2020 2020 2222 220a 2020  ) to..    """.  
+0000f930: 2020 2320 4368 6563 6b20 696e 7075 7420    # Check input 
+0000f940: 7061 7261 6d65 7465 7273 0a20 2020 2073  parameters.    s
+0000f950: 7263 203d 2050 6174 6828 7372 6329 0a20  rc = Path(src). 
+0000f960: 2020 2064 7374 203d 2050 6174 6828 6473     dst = Path(ds
+0000f970: 7429 0a20 2020 2067 656f 6669 6c65 7479  t).    geofilety
+0000f980: 7065 203d 2047 656f 6669 6c65 5479 7065  pe = GeofileType
+0000f990: 2873 7263 290a 0a20 2020 2023 2043 6f70  (src)..    # Cop
+0000f9a0: 7920 7468 6520 6d61 696e 2066 696c 650a  y the main file.
+0000f9b0: 2020 2020 7368 7574 696c 2e63 6f70 7928      shutil.copy(
+0000f9c0: 7374 7228 7372 6329 2c20 6473 7429 0a0a  str(src), dst)..
+0000f9d0: 2020 2020 2320 466f 7220 736f 6d65 2066      # For some f
+0000f9e0: 696c 6520 7479 7065 732c 2065 7874 7261  ile types, extra
+0000f9f0: 2066 696c 6573 206e 6565 6420 746f 2062   files need to b
+0000fa00: 6520 636f 7069 6564 0a20 2020 2023 2049  e copied.    # I
+0000fa10: 6620 6465 7374 2069 7320 6120 6469 722c  f dest is a dir,
+0000fa20: 206a 7573 7420 7573 6520 6d6f 7665 2e20   just use move. 
+0000fa30: 4f74 6865 7277 6973 6520 636f 6e63 6174  Otherwise concat
+0000fa40: 2064 6573 7420 6669 6c65 7061 7468 730a   dest filepaths.
+0000fa50: 2020 2020 6966 2067 656f 6669 6c65 7479      if geofilety
+0000fa60: 7065 2e73 7566 6669 7865 735f 6578 7472  pe.suffixes_extr
+0000fa70: 6166 696c 6573 2069 7320 6e6f 7420 4e6f  afiles is not No
+0000fa80: 6e65 3a0a 2020 2020 2020 2020 6966 2064  ne:.        if d
+0000fa90: 7374 2e69 735f 6469 7228 293a 0a20 2020  st.is_dir():.   
+0000faa0: 2020 2020 2020 2020 2066 6f72 2073 7566           for suf
+0000fab0: 6669 7820 696e 2067 656f 6669 6c65 7479  fix in geofilety
+0000fac0: 7065 2e73 7566 6669 7865 735f 6578 7472  pe.suffixes_extr
+0000fad0: 6166 696c 6573 3a0a 2020 2020 2020 2020  afiles:.        
+0000fae0: 2020 2020 2020 2020 7372 6366 696c 6520          srcfile 
+0000faf0: 3d20 7372 632e 7061 7265 6e74 202f 2066  = src.parent / f
+0000fb00: 227b 7372 632e 7374 656d 7d7b 7375 6666  "{src.stem}{suff
+0000fb10: 6978 7d22 0a20 2020 2020 2020 2020 2020  ix}".           
+0000fb20: 2020 2020 2069 6620 7372 6366 696c 652e       if srcfile.
+0000fb30: 6578 6973 7473 2829 3a0a 2020 2020 2020  exists():.      
+0000fb40: 2020 2020 2020 2020 2020 2020 2020 7368                sh
+0000fb50: 7574 696c 2e63 6f70 7928 7374 7228 7372  util.copy(str(sr
+0000fb60: 6366 696c 6529 2c20 6473 7429 0a20 2020  cfile), dst).   
+0000fb70: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000fb80: 2020 2020 2020 2066 6f72 2073 7566 6669         for suffi
+0000fb90: 7820 696e 2067 656f 6669 6c65 7479 7065  x in geofiletype
+0000fba0: 2e73 7566 6669 7865 735f 6578 7472 6166  .suffixes_extraf
+0000fbb0: 696c 6573 3a0a 2020 2020 2020 2020 2020  iles:.          
+0000fbc0: 2020 2020 2020 7372 6366 696c 6520 3d20        srcfile = 
+0000fbd0: 7372 632e 7061 7265 6e74 202f 2066 227b  src.parent / f"{
+0000fbe0: 7372 632e 7374 656d 7d7b 7375 6666 6978  src.stem}{suffix
+0000fbf0: 7d22 0a20 2020 2020 2020 2020 2020 2020  }".             
+0000fc00: 2020 2064 7374 6669 6c65 203d 2064 7374     dstfile = dst
+0000fc10: 2e70 6172 656e 7420 2f20 6622 7b64 7374  .parent / f"{dst
+0000fc20: 2e73 7465 6d7d 7b73 7566 6669 787d 220a  .stem}{suffix}".
+0000fc30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fc40: 6966 2073 7263 6669 6c65 2e65 7869 7374  if srcfile.exist
+0000fc50: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
+0000fc60: 2020 2020 2020 2020 2073 6875 7469 6c2e           shutil.
+0000fc70: 636f 7079 2873 7472 2873 7263 6669 6c65  copy(str(srcfile
+0000fc80: 292c 2064 7374 6669 6c65 290a 0a0a 6465  ), dstfile)...de
+0000fc90: 6620 6d6f 7665 2873 7263 3a20 556e 696f  f move(src: Unio
+0000fca0: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
+0000fcb0: 696b 655b 416e 795d 225d 2c20 6473 743a  ike[Any]"], dst:
+0000fcc0: 2055 6e69 6f6e 5b73 7472 2c20 226f 732e   Union[str, "os.
+0000fcd0: 5061 7468 4c69 6b65 5b41 6e79 5d22 5d29  PathLike[Any]"])
+0000fce0: 3a0a 2020 2020 2222 220a 2020 2020 4d6f  :.    """.    Mo
+0000fcf0: 7665 7320 7468 6520 6765 6f66 696c 6520  ves the geofile 
+0000fd00: 6672 6f6d 2073 7263 2074 6f20 6473 742e  from src to dst.
+0000fd10: 2049 6620 7468 6520 736f 7572 6365 2066   If the source f
+0000fd20: 696c 6520 6973 2061 2067 656f 6669 6c65  ile is a geofile
+0000fd30: 2063 6f6e 7461 696e 696e 670a 2020 2020   containing.    
+0000fd40: 6f66 206d 756c 7469 706c 6520 6669 6c65  of multiple file
+0000fd50: 7320 2865 672e 202e 7368 7029 2061 6c6c  s (eg. .shp) all
+0000fd60: 2066 696c 6573 2061 7265 206d 6f76 6564   files are moved
+0000fd70: 2e0a 0a20 2020 2041 7267 733a 0a20 2020  ...    Args:.   
+0000fd80: 2020 2020 2073 7263 2028 5061 7468 4c69       src (PathLi
+0000fd90: 6b65 293a 2074 6865 2066 696c 6520 746f  ke): the file to
+0000fda0: 206d 6f76 650a 2020 2020 2020 2020 6473   move.        ds
+0000fdb0: 7420 2850 6174 684c 696b 6529 3a20 7468  t (PathLike): th
+0000fdc0: 6520 6c6f 6361 7469 6f6e 2074 6f20 6d6f  e location to mo
+0000fdd0: 7665 2074 6865 2066 696c 6528 7329 2074  ve the file(s) t
+0000fde0: 6f0a 2020 2020 2222 220a 2020 2020 2320  o.    """.    # 
+0000fdf0: 4368 6563 6b20 696e 7075 7420 7061 7261  Check input para
+0000fe00: 6d65 7465 7273 0a20 2020 2073 7263 203d  meters.    src =
+0000fe10: 2050 6174 6828 7372 6329 0a20 2020 2064   Path(src).    d
+0000fe20: 7374 203d 2050 6174 6828 6473 7429 0a20  st = Path(dst). 
+0000fe30: 2020 2067 656f 6669 6c65 7479 7065 203d     geofiletype =
+0000fe40: 2047 656f 6669 6c65 5479 7065 2873 7263   GeofileType(src
+0000fe50: 290a 0a20 2020 2023 204d 6f76 6520 7468  )..    # Move th
+0000fe60: 6520 6d61 696e 2066 696c 650a 2020 2020  e main file.    
+0000fe70: 7368 7574 696c 2e6d 6f76 6528 7374 7228  shutil.move(str(
+0000fe80: 7372 6329 2c20 6473 7429 0a0a 2020 2020  src), dst)..    
+0000fe90: 2320 466f 7220 736f 6d65 2066 696c 6520  # For some file 
+0000fea0: 7479 7065 732c 2065 7874 7261 2066 696c  types, extra fil
+0000feb0: 6573 206e 6565 6420 746f 2062 6520 6d6f  es need to be mo
+0000fec0: 7665 640a 2020 2020 2320 4966 2064 6573  ved.    # If des
+0000fed0: 7420 6973 2061 2064 6972 2c20 6a75 7374  t is a dir, just
+0000fee0: 2075 7365 206d 6f76 652e 204f 7468 6572   use move. Other
+0000fef0: 7769 7365 2063 6f6e 6361 7420 6465 7374  wise concat dest
+0000ff00: 2066 696c 6570 6174 6873 0a20 2020 2069   filepaths.    i
+0000ff10: 6620 6765 6f66 696c 6574 7970 652e 7375  f geofiletype.su
+0000ff20: 6666 6978 6573 5f65 7874 7261 6669 6c65  ffixes_extrafile
+0000ff30: 7320 6973 206e 6f74 204e 6f6e 653a 0a20  s is not None:. 
+0000ff40: 2020 2020 2020 2069 6620 6473 742e 6973         if dst.is
+0000ff50: 5f64 6972 2829 3a0a 2020 2020 2020 2020  _dir():.        
+0000ff60: 2020 2020 666f 7220 7375 6666 6978 2069      for suffix i
+0000ff70: 6e20 6765 6f66 696c 6574 7970 652e 7375  n geofiletype.su
+0000ff80: 6666 6978 6573 5f65 7874 7261 6669 6c65  ffixes_extrafile
+0000ff90: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+0000ffa0: 2020 2073 7263 6669 6c65 203d 2073 7263     srcfile = src
+0000ffb0: 2e70 6172 656e 7420 2f20 6622 7b73 7263  .parent / f"{src
+0000ffc0: 2e73 7465 6d7d 7b73 7566 6669 787d 220a  .stem}{suffix}".
+0000ffd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ffe0: 6966 2073 7263 6669 6c65 2e65 7869 7374  if srcfile.exist
+0000fff0: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
+00010000: 2020 2020 2020 2020 2073 6875 7469 6c2e           shutil.
+00010010: 6d6f 7665 2873 7472 2873 7263 6669 6c65  move(str(srcfile
+00010020: 292c 2064 7374 290a 2020 2020 2020 2020  ), dst).        
+00010030: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00010040: 2020 666f 7220 7375 6666 6978 2069 6e20    for suffix in 
+00010050: 6765 6f66 696c 6574 7970 652e 7375 6666  geofiletype.suff
+00010060: 6978 6573 5f65 7874 7261 6669 6c65 733a  ixes_extrafiles:
+00010070: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010080: 2073 7263 6669 6c65 203d 2073 7263 2e70   srcfile = src.p
+00010090: 6172 656e 7420 2f20 6622 7b73 7263 2e73  arent / f"{src.s
+000100a0: 7465 6d7d 7b73 7566 6669 787d 220a 2020  tem}{suffix}".  
+000100b0: 2020 2020 2020 2020 2020 2020 2020 6473                ds
+000100c0: 7466 696c 6520 3d20 6473 742e 7061 7265  tfile = dst.pare
+000100d0: 6e74 202f 2066 227b 6473 742e 7374 656d  nt / f"{dst.stem
+000100e0: 7d7b 7375 6666 6978 7d22 0a20 2020 2020  }{suffix}".     
+000100f0: 2020 2020 2020 2020 2020 2069 6620 7372             if sr
+00010100: 6366 696c 652e 6578 6973 7473 2829 3a0a  cfile.exists():.
+00010110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010120: 2020 2020 7368 7574 696c 2e6d 6f76 6528      shutil.move(
+00010130: 7374 7228 7372 6366 696c 6529 2c20 6473  str(srcfile), ds
+00010140: 7466 696c 6529 0a0a 0a64 6566 2072 656d  tfile)...def rem
+00010150: 6f76 6528 7061 7468 3a20 556e 696f 6e5b  ove(path: Union[
+00010160: 7374 722c 2022 6f73 2e50 6174 684c 696b  str, "os.PathLik
+00010170: 655b 416e 795d 225d 2c20 6d69 7373 696e  e[Any]"], missin
+00010180: 675f 6f6b 3a20 626f 6f6c 203d 2046 616c  g_ok: bool = Fal
+00010190: 7365 293a 0a20 2020 2022 2222 0a20 2020  se):.    """.   
+000101a0: 2052 656d 6f76 6573 2074 6865 2067 656f   Removes the geo
+000101b0: 6669 6c65 2e20 4973 2069 7420 6973 2061  file. Is it is a
+000101c0: 2067 656f 6669 6c65 2063 6f6d 706f 7365   geofile compose
+000101d0: 6420 6f66 206d 756c 7469 706c 6520 6669  d of multiple fi
+000101e0: 6c65 730a 2020 2020 2865 672e 202e 7368  les.    (eg. .sh
+000101f0: 7029 2061 6c6c 2066 696c 6573 2061 7265  p) all files are
+00010200: 2072 656d 6f76 6564 2e0a 2020 2020 4966   removed..    If
+00010210: 202e 6c6f 636b 2066 696c 6573 2061 7265   .lock files are
+00010220: 2070 7265 7365 6e74 2c20 7468 6579 2061   present, they a
+00010230: 7265 2072 656d 6f76 6564 2061 7320 7765  re removed as we
+00010240: 6c6c 2e0a 0a20 2020 2041 7267 733a 0a20  ll...    Args:. 
+00010250: 2020 2020 2020 2070 6174 6820 2850 6174         path (Pat
+00010260: 684c 696b 6529 3a20 7468 6520 6669 6c65  hLike): the file
+00010270: 2074 6f20 7265 6d6f 7665 0a20 2020 2022   to remove.    "
+00010280: 2222 0a20 2020 2023 2043 6865 636b 2069  "".    # Check i
+00010290: 6e70 7574 2070 6172 616d 6574 6572 730a  nput parameters.
+000102a0: 2020 2020 7061 7468 203d 2050 6174 6828      path = Path(
+000102b0: 7061 7468 290a 2020 2020 6765 6f66 696c  path).    geofil
+000102c0: 6574 7970 6520 3d20 4765 6f66 696c 6554  etype = GeofileT
+000102d0: 7970 6528 7061 7468 290a 0a20 2020 2023  ype(path)..    #
+000102e0: 2049 6620 7468 6572 6520 6973 2061 206c   If there is a l
+000102f0: 6f63 6b20 6669 6c65 2c20 7265 6d6f 7665  ock file, remove
+00010300: 2069 740a 2020 2020 6c6f 636b 6669 6c65   it.    lockfile
+00010310: 5f70 6174 6820 3d20 7061 7468 2e70 6172  _path = path.par
+00010320: 656e 7420 2f20 6622 7b70 6174 682e 6e61  ent / f"{path.na
+00010330: 6d65 7d2e 6c6f 636b 220a 2020 2020 6c6f  me}.lock".    lo
+00010340: 636b 6669 6c65 5f70 6174 682e 756e 6c69  ckfile_path.unli
+00010350: 6e6b 286d 6973 7369 6e67 5f6f 6b3d 5472  nk(missing_ok=Tr
+00010360: 7565 290a 0a20 2020 2023 2052 656d 6f76  ue)..    # Remov
+00010370: 6520 7468 6520 6d61 696e 2066 696c 650a  e the main file.
+00010380: 2020 2020 6966 2070 6174 682e 6578 6973      if path.exis
+00010390: 7473 2829 3a0a 2020 2020 2020 2020 7061  ts():.        pa
+000103a0: 7468 2e75 6e6c 696e 6b28 6d69 7373 696e  th.unlink(missin
+000103b0: 675f 6f6b 3d6d 6973 7369 6e67 5f6f 6b29  g_ok=missing_ok)
+000103c0: 0a0a 2020 2020 2320 466f 7220 736f 6d65  ..    # For some
+000103d0: 2066 696c 6520 7479 7065 732c 2065 7874   file types, ext
+000103e0: 7261 2066 696c 6573 206e 6565 6420 746f  ra files need to
+000103f0: 2062 6520 7265 6d6f 7665 640a 2020 2020   be removed.    
+00010400: 6966 2067 656f 6669 6c65 7479 7065 2e73  if geofiletype.s
+00010410: 7566 6669 7865 735f 6578 7472 6166 696c  uffixes_extrafil
+00010420: 6573 2069 7320 6e6f 7420 4e6f 6e65 3a0a  es is not None:.
+00010430: 2020 2020 2020 2020 666f 7220 7375 6666          for suff
+00010440: 6978 2069 6e20 6765 6f66 696c 6574 7970  ix in geofiletyp
+00010450: 652e 7375 6666 6978 6573 5f65 7874 7261  e.suffixes_extra
+00010460: 6669 6c65 733a 0a20 2020 2020 2020 2020  files:.         
+00010470: 2020 2063 7572 725f 7061 7468 203d 2070     curr_path = p
+00010480: 6174 682e 7061 7265 6e74 202f 2066 227b  ath.parent / f"{
+00010490: 7061 7468 2e73 7465 6d7d 7b73 7566 6669  path.stem}{suffi
+000104a0: 787d 220a 2020 2020 2020 2020 2020 2020  x}".            
+000104b0: 6375 7272 5f70 6174 682e 756e 6c69 6e6b  curr_path.unlink
+000104c0: 286d 6973 7369 6e67 5f6f 6b3d 5472 7565  (missing_ok=True
+000104d0: 290a 0a0a 6465 6620 6170 7065 6e64 5f74  )...def append_t
+000104e0: 6f28 0a20 2020 2073 7263 3a20 556e 696f  o(.    src: Unio
+000104f0: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
+00010500: 696b 655b 416e 795d 225d 2c0a 2020 2020  ike[Any]"],.    
+00010510: 6473 743a 2055 6e69 6f6e 5b73 7472 2c20  dst: Union[str, 
+00010520: 226f 732e 5061 7468 4c69 6b65 5b41 6e79  "os.PathLike[Any
+00010530: 5d22 5d2c 0a20 2020 2073 7263 5f6c 6179  ]"],.    src_lay
+00010540: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
+00010550: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 6473  ] = None,.    ds
+00010560: 745f 6c61 7965 723a 204f 7074 696f 6e61  t_layer: Optiona
+00010570: 6c5b 7374 725d 203d 204e 6f6e 652c 0a20  l[str] = None,. 
+00010580: 2020 2073 7263 5f63 7273 3a20 556e 696f     src_crs: Unio
+00010590: 6e5b 696e 742c 2073 7472 2c20 4e6f 6e65  n[int, str, None
+000105a0: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 6473  ] = None,.    ds
+000105b0: 745f 6372 733a 2055 6e69 6f6e 5b69 6e74  t_crs: Union[int
+000105c0: 2c20 7374 722c 204e 6f6e 655d 203d 204e  , str, None] = N
+000105d0: 6f6e 652c 0a20 2020 2072 6570 726f 6a65  one,.    reproje
+000105e0: 6374 3a20 626f 6f6c 203d 2046 616c 7365  ct: bool = False
+000105f0: 2c0a 2020 2020 6578 706c 6f64 6563 6f6c  ,.    explodecol
+00010600: 6c65 6374 696f 6e73 3a20 626f 6f6c 203d  lections: bool =
+00010610: 2046 616c 7365 2c0a 2020 2020 666f 7263   False,.    forc
+00010620: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+00010630: 7974 7970 653a 2055 6e69 6f6e 5b47 656f  ytype: Union[Geo
+00010640: 6d65 7472 7954 7970 652c 2073 7472 2c20  metryType, str, 
+00010650: 4e6f 6e65 5d20 3d20 4e6f 6e65 2c0a 2020  None] = None,.  
+00010660: 2020 6372 6561 7465 5f73 7061 7469 616c    create_spatial
+00010670: 5f69 6e64 6578 3a20 4f70 7469 6f6e 616c  _index: Optional
+00010680: 5b62 6f6f 6c5d 203d 2054 7275 652c 0a20  [bool] = True,. 
+00010690: 2020 2061 7070 656e 645f 7469 6d65 6f75     append_timeou
+000106a0: 745f 733a 2069 6e74 203d 2036 3030 2c0a  t_s: int = 600,.
+000106b0: 2020 2020 7472 616e 7361 6374 696f 6e5f      transaction_
+000106c0: 7369 7a65 3a20 696e 7420 3d20 3530 3030  size: int = 5000
+000106d0: 302c 0a20 2020 2070 7265 7365 7276 655f  0,.    preserve_
+000106e0: 6669 643a 204f 7074 696f 6e61 6c5b 626f  fid: Optional[bo
+000106f0: 6f6c 5d20 3d20 4e6f 6e65 2c0a 2020 2020  ol] = None,.    
+00010700: 6f70 7469 6f6e 733a 2064 6963 7420 3d20  options: dict = 
+00010710: 7b7d 2c0a 293a 0a20 2020 2022 2222 0a20  {},.):.    """. 
+00010720: 2020 2041 7070 656e 6420 7372 6320 6669     Append src fi
+00010730: 6c65 2074 6f20 7468 6520 6473 7420 6669  le to the dst fi
+00010740: 6c65 2e0a 0a20 2020 2052 656d 6172 6b3a  le...    Remark:
+00010750: 2061 7070 656e 6420 6973 206e 6f74 2073   append is not s
+00010760: 7570 706f 7274 6564 2066 6f72 2061 6c6c  upported for all
+00010770: 2066 696c 6574 7970 6573 2069 6e20 6669   filetypes in fi
+00010780: 6f6e 612f 6765 6f70 616e 6461 7320 2830  ona/geopandas (0
+00010790: 2e38 290a 2020 2020 736f 2077 6f72 6b61  .8).    so worka
+000107a0: 726f 756e 6420 7669 6120 6764 616c 206e  round via gdal n
+000107b0: 6565 6465 642e 0a0a 2020 2020 5468 6520  eeded...    The 
+000107c0: 6f70 7469 6f6e 7320 7061 7261 6d65 7465  options paramete
+000107d0: 7220 6361 6e20 6265 2075 7365 6420 746f  r can be used to
+000107e0: 2070 6173 7320 616e 7920 7479 7065 206f   pass any type o
+000107f0: 6620 6f70 7469 6f6e 7320 746f 2047 4441  f options to GDA
+00010800: 4c20 696e 0a20 2020 2074 6865 2066 6f6c  L in.    the fol
+00010810: 6c6f 7769 6e67 2066 6f72 6d3a 0a20 2020  lowing form:.   
+00010820: 2020 2020 207b 2022 3c6f 7074 696f 6e5f       { "<option_
+00010830: 7479 7065 3e2e 3c6f 7074 696f 6e5f 6e61  type>.<option_na
+00010840: 6d65 3e22 3a20 3c6f 7074 696f 6e5f 7661  me>": <option_va
+00010850: 6c75 653e 207d 0a0a 2020 2020 5468 6520  lue> }..    The 
+00010860: 6f70 7469 6f6e 2074 7970 6573 2063 616e  option types can
+00010870: 2062 6520 616e 7920 6f66 2074 6865 2066   be any of the f
+00010880: 6f6c 6c6f 7769 6e67 3a0a 2020 2020 2020  ollowing:.      
+00010890: 2020 2d20 4c41 5945 525f 4352 4541 5449    - LAYER_CREATI
+000108a0: 4f4e 3a20 6c61 7965 7220 6372 6561 7469  ON: layer creati
+000108b0: 6f6e 206f 7074 696f 6e20 286c 636f 290a  on option (lco).
+000108c0: 2020 2020 2020 2020 2d20 4441 5441 5345          - DATASE
+000108d0: 545f 4352 4541 5449 4f4e 3a20 6461 7461  T_CREATION: data
+000108e0: 7365 7420 6372 6561 7469 6f6e 206f 7074  set creation opt
+000108f0: 696f 6e20 2864 7363 6f29 0a20 2020 2020  ion (dsco).     
+00010900: 2020 202d 2049 4e50 5554 5f4f 5045 4e3a     - INPUT_OPEN:
+00010910: 2069 6e70 7574 2064 6174 6173 6574 206f   input dataset o
+00010920: 7065 6e20 6f70 7469 6f6e 2028 6f6f 290a  pen option (oo).
+00010930: 2020 2020 2020 2020 2d20 4445 5354 494e          - DESTIN
+00010940: 4154 494f 4e5f 4f50 454e 3a20 6465 7374  ATION_OPEN: dest
+00010950: 696e 6174 696f 6e20 6461 7461 7365 7420  ination dataset 
+00010960: 6f70 656e 206f 7074 696f 6e20 2864 6f6f  open option (doo
+00010970: 290a 2020 2020 2020 2020 2d20 434f 4e46  ).        - CONF
+00010980: 4947 3a20 636f 6e66 6967 206f 7074 696f  IG: config optio
+00010990: 6e20 2863 6f6e 6669 6729 0a0a 2020 2020  n (config)..    
+000109a0: 5468 6520 6f70 7469 6f6e 7320 6361 6e20  The options can 
+000109b0: 6265 2066 6f75 6e64 2069 6e20 7468 6520  be found in the 
+000109c0: 5b47 4441 4c20 7665 6374 6f72 2064 7269  [GDAL vector dri
+000109d0: 7665 7220 646f 6375 6d65 6e74 6174 696f  ver documentatio
+000109e0: 6e5d 0a20 2020 2028 6874 7470 733a 2f2f  n].    (https://
+000109f0: 6764 616c 2e6f 7267 2f64 7269 7665 7273  gdal.org/drivers
+00010a00: 2f76 6563 746f 722f 696e 6465 782e 6874  /vector/index.ht
+00010a10: 6d6c 292e 0a0a 2020 2020 4172 6773 3a0a  ml)...    Args:.
+00010a20: 2020 2020 2020 2020 7372 6320 2855 6e69          src (Uni
+00010a30: 6f6e 5b73 7472 2c29 3a20 736f 7572 6365  on[str,): source
+00010a40: 2066 696c 6520 7061 7468 2e0a 2020 2020   file path..    
+00010a50: 2020 2020 6473 7420 2855 6e69 6f6e 5b73      dst (Union[s
+00010a60: 7472 2c29 3a20 6465 7374 696e 6174 696f  tr,): destinatio
+00010a70: 6e20 6669 6c65 2070 6174 682e 0a20 2020  n file path..   
+00010a80: 2020 2020 2073 7263 5f6c 6179 6572 2028       src_layer (
+00010a90: 7374 722c 206f 7074 696f 6e61 6c29 3a20  str, optional): 
+00010aa0: 736f 7572 6365 206c 6179 6572 2e20 4465  source layer. De
+00010ab0: 6661 756c 7473 2074 6f20 4e6f 6e65 2e0a  faults to None..
+00010ac0: 2020 2020 2020 2020 6473 745f 6c61 7965          dst_laye
+00010ad0: 7220 2873 7472 2c20 6f70 7469 6f6e 616c  r (str, optional
+00010ae0: 293a 2064 6573 7469 6e61 7469 6f6e 206c  ): destination l
+00010af0: 6179 6572 2e20 4465 6661 756c 7473 2074  ayer. Defaults t
+00010b00: 6f20 4e6f 6e65 2e0a 2020 2020 2020 2020  o None..        
+00010b10: 7372 635f 6372 7320 2873 7472 2c20 6f70  src_crs (str, op
+00010b20: 7469 6f6e 616c 293a 2061 6e20 6570 7367  tional): an epsg
+00010b30: 2069 6e74 206f 7220 616e 7974 6869 6e67   int or anything
+00010b40: 2073 7570 706f 7274 6564 0a20 2020 2020   supported.     
+00010b50: 2020 2020 2020 2062 7920 7468 6520 4f47         by the OG
+00010b60: 5253 7061 7469 616c 5265 6665 7265 6e63  RSpatialReferenc
+00010b70: 652e 5365 7446 726f 6d55 7365 7249 6e70  e.SetFromUserInp
+00010b80: 7574 2829 2063 616c 6c2c 2077 6869 6368  ut() call, which
+00010b90: 2069 6e63 6c75 6465 730a 2020 2020 2020   includes.      
+00010ba0: 2020 2020 2020 616e 2045 5053 4720 7374        an EPSG st
+00010bb0: 7269 6e67 2028 6567 2e20 2245 5053 473a  ring (eg. "EPSG:
+00010bc0: 3433 3236 2229 2c20 6120 7765 6c6c 206b  4326"), a well k
+00010bd0: 6e6f 776e 2074 6578 7420 2857 4b54 2920  nown text (WKT) 
+00010be0: 4352 530a 2020 2020 2020 2020 2020 2020  CRS.            
+00010bf0: 6465 6669 6e69 7469 6f6e 2c2e 2e2e 2044  definition,... D
+00010c00: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
+00010c10: 0a20 2020 2020 2020 2064 7374 5f63 7273  .        dst_crs
+00010c20: 2028 7374 722c 206f 7074 696f 6e61 6c29   (str, optional)
+00010c30: 3a20 616e 2065 7073 6720 696e 7420 6f72  : an epsg int or
+00010c40: 2061 6e79 7468 696e 6720 7375 7070 6f72   anything suppor
+00010c50: 7465 640a 2020 2020 2020 2020 2020 2020  ted.            
+00010c60: 6279 2074 6865 204f 4752 5370 6174 6961  by the OGRSpatia
+00010c70: 6c52 6566 6572 656e 6365 2e53 6574 4672  lReference.SetFr
+00010c80: 6f6d 5573 6572 496e 7075 7428 2920 6361  omUserInput() ca
+00010c90: 6c6c 2c20 7768 6963 6820 696e 636c 7564  ll, which includ
+00010ca0: 6573 0a20 2020 2020 2020 2020 2020 2061  es.            a
+00010cb0: 6e20 4550 5347 2073 7472 696e 6720 2865  n EPSG string (e
+00010cc0: 672e 2022 4550 5347 3a34 3332 3622 292c  g. "EPSG:4326"),
+00010cd0: 2061 2077 656c 6c20 6b6e 6f77 6e20 7465   a well known te
+00010ce0: 7874 2028 574b 5429 2043 5253 0a20 2020  xt (WKT) CRS.   
+00010cf0: 2020 2020 2020 2020 2064 6566 696e 6974           definit
+00010d00: 696f 6e2c 2e2e 2e20 4465 6661 756c 7473  ion,... Defaults
+00010d10: 2074 6f20 4e6f 6e65 2e0a 2020 2020 2020   to None..      
+00010d20: 2020 7265 7072 6f6a 6563 7420 2862 6f6f    reproject (boo
+00010d30: 6c2c 206f 7074 696f 6e61 6c29 3a20 5472  l, optional): Tr
+00010d40: 7565 2074 6f20 7265 7072 6f6a 6563 7420  ue to reproject 
+00010d50: 7768 696c 6520 636f 6e76 6572 7469 6e67  while converting
+00010d60: 2074 6865 0a20 2020 2020 2020 2020 2020   the.           
+00010d70: 2066 696c 652e 2044 6566 6175 6c74 7320   file. Defaults 
+00010d80: 746f 2046 616c 7365 2e0a 2020 2020 2020  to False..      
+00010d90: 2020 6578 706c 6f64 6563 6f6c 6c65 6374    explodecollect
+00010da0: 696f 6e73 2028 626f 6f6c 292c 206f 7074  ions (bool), opt
+00010db0: 696f 6e61 6c29 3a20 5472 7565 2074 6f20  ional): True to 
+00010dc0: 6f75 7470 7574 206f 6e6c 7920 7369 6d70  output only simp
+00010dd0: 6c65 2067 656f 6d65 7472 6965 732e 0a20  le geometries.. 
+00010de0: 2020 2020 2020 2020 2020 2044 6566 6175             Defau
+00010df0: 6c74 7320 746f 2046 616c 7365 2e0a 2020  lts to False..  
+00010e00: 2020 2020 2020 666f 7263 655f 6f75 7470        force_outp
+00010e10: 7574 5f67 656f 6d65 7472 7974 7970 6520  ut_geometrytype 
+00010e20: 2855 6e69 6f6e 5b47 656f 6d65 7472 7954  (Union[GeometryT
+00010e30: 7970 652c 2073 7472 5d2c 206f 7074 696f  ype, str], optio
+00010e40: 6e61 6c29 3a20 4765 6f6d 6574 7279 2074  nal): Geometry t
+00010e50: 7970 652e 0a20 2020 2020 2020 2020 2020  ype..           
+00010e60: 2074 6f20 2874 7279 2074 6f29 2066 6f72   to (try to) for
+00010e70: 6365 2074 6865 206f 7574 7075 7420 746f  ce the output to
+00010e80: 2e20 4465 6661 756c 7473 2074 6f20 4e6f  . Defaults to No
+00010e90: 6e65 2e0a 2020 2020 2020 2020 6372 6561  ne..        crea
+00010ea0: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
+00010eb0: 2028 626f 6f6c 2c20 6f70 7469 6f6e 616c   (bool, optional
+00010ec0: 293a 2054 7275 6520 746f 2063 7265 6174  ): True to creat
+00010ed0: 6520 6120 7370 6174 6961 6c20 696e 6465  e a spatial inde
+00010ee0: 780a 2020 2020 2020 2020 2020 2020 6f6e  x.            on
+00010ef0: 2074 6865 2064 6573 7469 6e61 7469 6f6e   the destination
+00010f00: 2066 696c 652f 6c61 7965 722e 2049 6620   file/layer. If 
+00010f10: 4e6f 6e65 2c20 7468 6520 6465 6661 756c  None, the defaul
+00010f20: 7420 6265 6861 7669 6f75 7220 6279 2067  t behaviour by g
+00010f30: 6461 6c20 666f 720a 2020 2020 2020 2020  dal for.        
+00010f40: 2020 2020 7468 6174 2066 696c 6520 7479      that file ty
+00010f50: 7065 2069 7320 7265 7370 6563 7465 642e  pe is respected.
+00010f60: 2049 6620 7468 6520 4c41 5945 525f 4352   If the LAYER_CR
+00010f70: 4541 5449 4f4e 2e53 5041 5449 414c 5f49  EATION.SPATIAL_I
+00010f80: 4e44 4558 0a20 2020 2020 2020 2020 2020  NDEX.           
+00010f90: 2070 6172 616d 6574 6572 2069 7320 7370   parameter is sp
+00010fa0: 6563 6966 6965 6420 696e 206f 7074 696f  ecified in optio
+00010fb0: 6e73 2c20 6372 6561 7465 5f73 7061 7469  ns, create_spati
+00010fc0: 616c 5f69 6e64 6578 2069 7320 6967 6e6f  al_index is igno
+00010fd0: 7265 642e 0a20 2020 2020 2020 2020 2020  red..           
+00010fe0: 2044 6566 6175 6c74 7320 746f 2054 7275   Defaults to Tru
+00010ff0: 652e 0a20 2020 2020 2020 2061 7070 656e  e..        appen
+00011000: 645f 7469 6d65 6f75 745f 7320 2869 6e74  d_timeout_s (int
+00011010: 2c20 6f70 7469 6f6e 616c 293a 2074 696d  , optional): tim
+00011020: 656f 7574 2074 6f20 7573 6520 6966 2074  eout to use if t
+00011030: 6865 206f 7574 7075 7420 6669 6c65 2069  he output file i
+00011040: 730a 2020 2020 2020 2020 2020 2020 6265  s.            be
+00011050: 696e 6720 7772 6974 7465 6e20 746f 2062  ing written to b
+00011060: 7920 616e 6f74 6865 7220 7072 6f63 6573  y another proces
+00011070: 7320 616c 7265 6164 792e 2044 6566 6175  s already. Defau
+00011080: 6c74 7320 746f 2036 3030 2e0a 2020 2020  lts to 600..    
+00011090: 2020 2020 7472 616e 7361 6374 696f 6e5f      transaction_
+000110a0: 7369 7a65 2028 696e 742c 206f 7074 696f  size (int, optio
+000110b0: 6e61 6c29 3a20 5472 616e 7361 6374 696f  nal): Transactio
+000110c0: 6e20 7369 7a65 2e0a 2020 2020 2020 2020  n size..        
+000110d0: 2020 2020 4465 6661 756c 7473 2074 6f20      Defaults to 
+000110e0: 3530 3030 302e 0a20 2020 2020 2020 2070  50000..        p
+000110f0: 7265 7365 7276 655f 6669 6420 2862 6f6f  reserve_fid (boo
+00011100: 6c2c 206f 7074 696f 6e61 6c29 3a20 5472  l, optional): Tr
+00011110: 7565 2074 6f20 6d61 6b65 2061 6e20 6578  ue to make an ex
+00011120: 7472 6120 6566 666f 7274 2074 6f20 7072  tra effort to pr
+00011130: 6573 6572 7665 2066 6964 2773 206f 660a  eserve fid's of.
+00011140: 2020 2020 2020 2020 2020 2020 7468 6520              the 
+00011150: 736f 7572 6365 206c 6179 6572 2074 6f20  source layer to 
+00011160: 7468 6520 6465 7374 696e 6174 696f 6e20  the destination 
+00011170: 6c61 7965 722e 2046 616c 7365 206e 6f74  layer. False not
+00011180: 2074 6f20 646f 2061 6e79 2065 6666 6f72   to do any effor
+00011190: 742e 204e 6f6e 650a 2020 2020 2020 2020  t. None.        
+000111a0: 2020 2020 746f 2075 7365 2074 6865 2064      to use the d
+000111b0: 6566 6175 6c74 2062 6568 6176 696f 7572  efault behaviour
+000111c0: 206f 6620 6764 616c 2c20 7468 6174 2061   of gdal, that a
+000111d0: 6c72 6561 6479 2070 7265 7365 7276 6573  lready preserves
+000111e0: 2069 6e20 736f 6d65 2063 6173 6573 2e0a   in some cases..
+000111f0: 2020 2020 2020 2020 2020 2020 536f 6d65              Some
+00011200: 2066 696c 6520 666f 726d 6174 7320 646f   file formats do
+00011210: 6e27 7420 6578 706c 6963 6974 6c79 2073  n't explicitly s
+00011220: 746f 7265 2074 6865 2066 6964 2028 652e  tore the fid (e.
+00011230: 672e 2073 6861 7065 6669 6c65 292c 2073  g. shapefile), s
+00011240: 6f20 7468 6579 0a20 2020 2020 2020 2020  o they.         
+00011250: 2020 2077 696c 6c20 6e65 7665 7220 6265     will never be
+00011260: 2061 626c 6520 746f 2070 7265 7365 7276   able to preserv
+00011270: 6520 6669 6473 2e20 4465 6661 756c 7473  e fids. Defaults
+00011280: 2074 6f20 4e6f 6e65 2e0a 2020 2020 2020   to None..      
+00011290: 2020 6f70 7469 6f6e 7320 2864 6963 742c    options (dict,
+000112a0: 206f 7074 696f 6e61 6c29 3a20 6f70 7469   optional): opti
+000112b0: 6f6e 7320 746f 2070 6173 7320 746f 2067  ons to pass to g
+000112c0: 6461 6c2e 0a0a 2020 2020 5261 6973 6573  dal...    Raises
+000112d0: 3a0a 2020 2020 2020 2020 5661 6c75 6545  :.        ValueE
+000112e0: 7272 6f72 3a20 616e 2069 6e76 616c 6964  rror: an invalid
+000112f0: 2070 6172 616d 6574 6572 2076 616c 7565   parameter value
+00011300: 2077 6173 2070 6173 7365 642e 0a20 2020   was passed..   
+00011310: 2020 2020 2052 756e 7469 6d65 4572 726f       RuntimeErro
+00011320: 723a 2074 696d 656f 7574 2077 6173 2072  r: timeout was r
+00011330: 6561 6368 6564 2077 6869 6c65 2074 7279  eached while try
+00011340: 696e 6720 746f 2061 7070 656e 6420 6461  ing to append da
+00011350: 7461 2074 6f20 7061 7468 2e0a 2020 2020  ta to path..    
+00011360: 2222 220a 2020 2020 2320 4368 6563 6b2f  """.    # Check/
+00011370: 636c 6561 6e20 696e 7075 7420 7061 7261  clean input para
+00011380: 6d73 0a20 2020 2073 7263 203d 2050 6174  ms.    src = Pat
+00011390: 6828 7372 6329 0a20 2020 2064 7374 203d  h(src).    dst =
+000113a0: 2050 6174 6828 6473 7429 0a20 2020 2069   Path(dst).    i
+000113b0: 6620 666f 7263 655f 6f75 7470 7574 5f67  f force_output_g
+000113c0: 656f 6d65 7472 7974 7970 6520 6973 206e  eometrytype is n
+000113d0: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+000113e0: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
+000113f0: 6f6d 6574 7279 7479 7065 203d 2047 656f  ometrytype = Geo
+00011400: 6d65 7472 7954 7970 6528 666f 7263 655f  metryType(force_
+00011410: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
+00011420: 7970 6529 0a0a 2020 2020 2320 4669 6c65  ype)..    # File
+00011430: 7320 646f 6e27 7420 7479 7069 6361 6c6c  s don't typicall
+00011440: 7920 7375 7070 6f72 7420 6861 7669 6e67  y support having
+00011450: 206d 756c 7469 706c 6520 7072 6f63 6573   multiple proces
+00011460: 7365 7320 7772 6974 696e 670a 2020 2020  ses writing.    
+00011470: 2320 7369 6d75 6c74 616e 6f75 736c 7920  # simultanously 
+00011480: 746f 2074 6865 6d2c 2073 6f20 7573 6520  to them, so use 
+00011490: 6c6f 636b 2066 696c 6520 746f 2073 796e  lock file to syn
+000114a0: 6368 726f 6e69 7a65 2061 6363 6573 732e  chronize access.
+000114b0: 0a20 2020 206c 6f63 6b66 696c 6520 3d20  .    lockfile = 
+000114c0: 5061 7468 2866 227b 7374 7228 6473 7429  Path(f"{str(dst)
+000114d0: 7d2e 6c6f 636b 2229 0a0a 2020 2020 2320  }.lock")..    # 
+000114e0: 4966 2074 6865 2064 6573 7469 6e61 7469  If the destinati
+000114f0: 6f6e 2066 696c 6520 646f 6573 6e27 7420  on file doesn't 
+00011500: 6578 6973 7420 7965 742c 2062 7574 2074  exist yet, but t
+00011510: 6865 206c 6f63 6b66 696c 6520 646f 6573  he lockfile does
+00011520: 2c0a 2020 2020 2320 7472 7920 7265 6d6f  ,.    # try remo
+00011530: 7669 6e67 2074 6865 206c 6f63 6b66 696c  ving the lockfil
+00011540: 6520 6173 2069 7420 6d69 6768 7420 6265  e as it might be
+00011550: 2061 2067 686f 7374 206c 6f63 6b66 696c   a ghost lockfil
+00011560: 652e 0a20 2020 2069 6620 6e6f 7420 6473  e..    if not ds
+00011570: 742e 6578 6973 7473 2829 2061 6e64 206c  t.exists() and l
+00011580: 6f63 6b66 696c 652e 6578 6973 7473 2829  ockfile.exists()
+00011590: 3a0a 2020 2020 2020 2020 7472 793a 0a20  :.        try:. 
+000115a0: 2020 2020 2020 2020 2020 206c 6f63 6b66             lockf
+000115b0: 696c 652e 756e 6c69 6e6b 2829 0a20 2020  ile.unlink().   
+000115c0: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
+000115d0: 7074 696f 6e3a 0a20 2020 2020 2020 2020  ption:.         
+000115e0: 2020 205f 203d 204e 6f6e 650a 0a20 2020     _ = None..   
+000115f0: 2023 2043 7265 6174 696e 6720 6c6f 636b   # Creating lock
+00011600: 6669 6c65 2061 6e64 2061 7070 656e 640a  file and append.
+00011610: 2020 2020 7374 6172 745f 7469 6d65 203d      start_time =
+00011620: 2064 6174 6574 696d 652e 6461 7465 7469   datetime.dateti
+00011630: 6d65 2e6e 6f77 2829 0a20 2020 2072 6561  me.now().    rea
+00011640: 6479 203d 2046 616c 7365 0a20 2020 2077  dy = False.    w
+00011650: 6869 6c65 206e 6f74 2072 6561 6479 3a0a  hile not ready:.
+00011660: 2020 2020 2020 2020 6966 205f 696f 5f75          if _io_u
+00011670: 7469 6c2e 6372 6561 7465 5f66 696c 655f  til.create_file_
+00011680: 6174 6f6d 6963 286c 6f63 6b66 696c 6529  atomic(lockfile)
+00011690: 2069 7320 5472 7565 3a0a 2020 2020 2020   is True:.      
+000116a0: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+000116b0: 2020 2020 2020 2020 2020 2023 2061 7070             # app
+000116c0: 656e 640a 2020 2020 2020 2020 2020 2020  end.            
+000116d0: 2020 2020 5f61 7070 656e 645f 746f 5f6e      _append_to_n
+000116e0: 6f6c 6f63 6b28 0a20 2020 2020 2020 2020  olock(.         
+000116f0: 2020 2020 2020 2020 2020 2073 7263 3d73             src=s
+00011700: 7263 2c0a 2020 2020 2020 2020 2020 2020  rc,.            
+00011710: 2020 2020 2020 2020 6473 743d 6473 742c          dst=dst,
+00011720: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011730: 2020 2020 2073 7263 5f6c 6179 6572 3d73       src_layer=s
+00011740: 7263 5f6c 6179 6572 2c0a 2020 2020 2020  rc_layer,.      
+00011750: 2020 2020 2020 2020 2020 2020 2020 6473                ds
+00011760: 745f 6c61 7965 723d 6473 745f 6c61 7965  t_layer=dst_laye
+00011770: 722c 0a20 2020 2020 2020 2020 2020 2020  r,.             
+00011780: 2020 2020 2020 2073 7263 5f63 7273 3d73         src_crs=s
+00011790: 7263 5f63 7273 2c0a 2020 2020 2020 2020  rc_crs,.        
+000117a0: 2020 2020 2020 2020 2020 2020 6473 745f              dst_
+000117b0: 6372 733d 6473 745f 6372 732c 0a20 2020  crs=dst_crs,.   
+000117c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000117d0: 2072 6570 726f 6a65 6374 3d72 6570 726f   reproject=repro
+000117e0: 6a65 6374 2c0a 2020 2020 2020 2020 2020  ject,.          
+000117f0: 2020 2020 2020 2020 2020 6578 706c 6f64            explod
+00011800: 6563 6f6c 6c65 6374 696f 6e73 3d65 7870  ecollections=exp
+00011810: 6c6f 6465 636f 6c6c 6563 7469 6f6e 732c  lodecollections,
+00011820: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011830: 2020 2020 2066 6f72 6365 5f6f 7574 7075       force_outpu
+00011840: 745f 6765 6f6d 6574 7279 7479 7065 3d66  t_geometrytype=f
+00011850: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+00011860: 6574 7279 7479 7065 2c0a 2020 2020 2020  etrytype,.      
+00011870: 2020 2020 2020 2020 2020 2020 2020 6372                cr
+00011880: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
+00011890: 6578 3d63 7265 6174 655f 7370 6174 6961  ex=create_spatia
+000118a0: 6c5f 696e 6465 782c 0a20 2020 2020 2020  l_index,.       
+000118b0: 2020 2020 2020 2020 2020 2020 2074 7261               tra
+000118c0: 6e73 6163 7469 6f6e 5f73 697a 653d 7472  nsaction_size=tr
+000118d0: 616e 7361 6374 696f 6e5f 7369 7a65 2c0a  ansaction_size,.
+000118e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000118f0: 2020 2020 7072 6573 6572 7665 5f66 6964      preserve_fid
+00011900: 3d70 7265 7365 7276 655f 6669 642c 0a20  =preserve_fid,. 
+00011910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011920: 2020 206f 7074 696f 6e73 3d6f 7074 696f     options=optio
+00011930: 6e73 2c0a 2020 2020 2020 2020 2020 2020  ns,.            
+00011940: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+00011950: 2020 6669 6e61 6c6c 793a 0a20 2020 2020    finally:.     
+00011960: 2020 2020 2020 2020 2020 2072 6561 6479             ready
+00011970: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
+00011980: 2020 2020 2020 2020 6c6f 636b 6669 6c65          lockfile
+00011990: 2e75 6e6c 696e 6b28 290a 2020 2020 2020  .unlink().      
+000119a0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000119b0: 2020 2020 7469 6d65 5f77 6169 7469 6e67      time_waiting
+000119c0: 203d 2028 6461 7465 7469 6d65 2e64 6174   = (datetime.dat
+000119d0: 6574 696d 652e 6e6f 7728 2920 2d20 7374  etime.now() - st
+000119e0: 6172 745f 7469 6d65 292e 746f 7461 6c5f  art_time).total_
+000119f0: 7365 636f 6e64 7328 290a 2020 2020 2020  seconds().      
+00011a00: 2020 2020 2020 6966 2074 696d 655f 7761        if time_wa
+00011a10: 6974 696e 6720 3e20 6170 7065 6e64 5f74  iting > append_t
+00011a20: 696d 656f 7574 5f73 3a0a 2020 2020 2020  imeout_s:.      
+00011a30: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00011a40: 5275 6e74 696d 6545 7272 6f72 280a 2020  RuntimeError(.  
+00011a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011a60: 2020 6622 6170 7065 6e64 5f74 6f20 7469    f"append_to ti
+00011a70: 6d65 6f75 7420 6f66 207b 6170 7065 6e64  meout of {append
+00011a80: 5f74 696d 656f 7574 5f73 7d20 7265 6163  _timeout_s} reac
+00011a90: 6865 642c 2073 6f20 7374 6f70 2077 7269  hed, so stop wri
+00011aa0: 7465 2022 0a20 2020 2020 2020 2020 2020  te ".           
+00011ab0: 2020 2020 2020 2020 2066 2274 6f20 7b64           f"to {d
+00011ac0: 7374 7d21 220a 2020 2020 2020 2020 2020  st}!".          
+00011ad0: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+00011ae0: 2023 2053 6c65 6570 2066 6f72 2061 2073   # Sleep for a s
+00011af0: 6563 6f6e 6420 6265 666f 7265 2074 7279  econd before try
+00011b00: 696e 6720 6167 6169 6e0a 2020 2020 2020  ing again.      
+00011b10: 2020 7469 6d65 2e73 6c65 6570 2831 290a    time.sleep(1).
+00011b20: 0a0a 6465 6620 5f61 7070 656e 645f 746f  ..def _append_to
+00011b30: 5f6e 6f6c 6f63 6b28 0a20 2020 2073 7263  _nolock(.    src
+00011b40: 3a20 5061 7468 2c0a 2020 2020 6473 743a  : Path,.    dst:
+00011b50: 2050 6174 682c 0a20 2020 2073 7263 5f6c   Path,.    src_l
+00011b60: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
+00011b70: 7472 5d20 3d20 4e6f 6e65 2c0a 2020 2020  tr] = None,.    
+00011b80: 6473 745f 6c61 7965 723a 204f 7074 696f  dst_layer: Optio
+00011b90: 6e61 6c5b 7374 725d 203d 204e 6f6e 652c  nal[str] = None,
+00011ba0: 0a20 2020 2073 7263 5f63 7273 3a20 556e  .    src_crs: Un
+00011bb0: 696f 6e5b 696e 742c 2073 7472 2c20 4e6f  ion[int, str, No
+00011bc0: 6e65 5d20 3d20 4e6f 6e65 2c0a 2020 2020  ne] = None,.    
+00011bd0: 6473 745f 6372 733a 2055 6e69 6f6e 5b69  dst_crs: Union[i
+00011be0: 6e74 2c20 7374 722c 204e 6f6e 655d 203d  nt, str, None] =
+00011bf0: 204e 6f6e 652c 0a20 2020 2072 6570 726f   None,.    repro
+00011c00: 6a65 6374 3a20 626f 6f6c 203d 2046 616c  ject: bool = Fal
+00011c10: 7365 2c0a 2020 2020 6578 706c 6f64 6563  se,.    explodec
+00011c20: 6f6c 6c65 6374 696f 6e73 3a20 626f 6f6c  ollections: bool
+00011c30: 203d 2046 616c 7365 2c0a 2020 2020 6372   = False,.    cr
+00011c40: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
+00011c50: 6578 3a20 4f70 7469 6f6e 616c 5b62 6f6f  ex: Optional[boo
+00011c60: 6c5d 203d 2054 7275 652c 0a20 2020 2066  l] = True,.    f
+00011c70: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+00011c80: 6574 7279 7479 7065 3a20 556e 696f 6e5b  etrytype: Union[
+00011c90: 4765 6f6d 6574 7279 5479 7065 2c20 7374  GeometryType, st
+00011ca0: 722c 204e 6f6e 655d 203d 204e 6f6e 652c  r, None] = None,
+00011cb0: 0a20 2020 2074 7261 6e73 6163 7469 6f6e  .    transaction
+00011cc0: 5f73 697a 653a 2069 6e74 203d 2035 3030  _size: int = 500
+00011cd0: 3030 2c0a 2020 2020 7072 6573 6572 7665  00,.    preserve
+00011ce0: 5f66 6964 3a20 4f70 7469 6f6e 616c 5b62  _fid: Optional[b
+00011cf0: 6f6f 6c5d 203d 204e 6f6e 652c 0a20 2020  ool] = None,.   
+00011d00: 206f 7074 696f 6e73 3a20 6469 6374 203d   options: dict =
+00011d10: 207b 7d2c 0a29 3a0a 2020 2020 2320 4368   {},.):.    # Ch
+00011d20: 6563 6b2f 636c 6561 6e20 696e 7075 7420  eck/clean input 
+00011d30: 7061 7261 6d73 0a20 2020 206f 7074 696f  params.    optio
+00011d40: 6e73 203d 205f 6f67 725f 7574 696c 2e5f  ns = _ogr_util._
+00011d50: 7072 6570 6172 655f 6764 616c 5f6f 7074  prepare_gdal_opt
+00011d60: 696f 6e73 286f 7074 696f 6e73 290a 2020  ions(options).  
+00011d70: 2020 6966 2028 0a20 2020 2020 2020 2063    if (.        c
+00011d80: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
+00011d90: 6465 7820 6973 206e 6f74 204e 6f6e 650a  dex is not None.
+00011da0: 2020 2020 2020 2020 616e 6420 224c 4159          and "LAY
+00011db0: 4552 5f43 5245 4154 494f 4e2e 5350 4154  ER_CREATION.SPAT
+00011dc0: 4941 4c5f 494e 4445 5822 206e 6f74 2069  IAL_INDEX" not i
+00011dd0: 6e20 6f70 7469 6f6e 730a 2020 2020 293a  n options.    ):
+00011de0: 0a20 2020 2020 2020 206f 7074 696f 6e73  .        options
+00011df0: 5b22 4c41 5945 525f 4352 4541 5449 4f4e  ["LAYER_CREATION
+00011e00: 2e53 5041 5449 414c 5f49 4e44 4558 225d  .SPATIAL_INDEX"]
+00011e10: 203d 2063 7265 6174 655f 7370 6174 6961   = create_spatia
+00011e20: 6c5f 696e 6465 780a 0a20 2020 2023 2057  l_index..    # W
+00011e30: 6865 6e20 6372 6561 7469 6e67 2f61 7070  hen creating/app
+00011e40: 656e 6469 6e67 2074 6f20 6120 7368 6170  ending to a shap
+00011e50: 6566 696c 652c 206c 6175 6e64 6572 2074  efile, launder t
+00011e60: 6865 2063 6f6c 756d 6e73 206e 616d 6573  he columns names
+00011e70: 2076 6961 0a20 2020 2023 2061 2073 716c   via.    # a sql
+00011e80: 2073 7461 7465 6d65 6e74 2c20 6f74 6865   statement, othe
+00011e90: 7277 6973 6520 7768 656e 2061 7070 656e  rwise when appen
+00011ea0: 6469 6e67 2074 6865 206c 6175 6e64 6572  ding the launder
+00011eb0: 6564 2063 6f6c 756d 6e73 2077 696c 6c0a  ed columns will.
+00011ec0: 2020 2020 2320 6765 7420 4e55 4c4c 2076      # get NULL v
+00011ed0: 616c 7565 7320 696e 7374 6561 6420 6f66  alues instead of
+00011ee0: 2074 6865 2064 6174 612e 0a20 2020 2073   the data..    s
+00011ef0: 716c 5f73 746d 7420 3d20 4e6f 6e65 0a20  ql_stmt = None. 
+00011f00: 2020 2073 7263 5f6c 6179 6572 696e 666f     src_layerinfo
+00011f10: 203d 204e 6f6e 650a 2020 2020 6966 2064   = None.    if d
+00011f20: 7374 2e73 7566 6669 782e 6c6f 7765 7228  st.suffix.lower(
+00011f30: 2920 3d3d 2022 2e73 6870 223a 0a20 2020  ) == ".shp":.   
+00011f40: 2020 2020 2073 7263 5f6c 6179 6572 696e       src_layerin
+00011f50: 666f 203d 2067 6574 5f6c 6179 6572 696e  fo = get_layerin
+00011f60: 666f 2873 7263 2c20 7372 635f 6c61 7965  fo(src, src_laye
+00011f70: 7229 0a20 2020 2020 2020 2073 7263 5f63  r).        src_c
+00011f80: 6f6c 756d 6e73 203d 2073 7263 5f6c 6179  olumns = src_lay
+00011f90: 6572 696e 666f 2e63 6f6c 756d 6e73 0a20  erinfo.columns. 
+00011fa0: 2020 2020 2020 2063 6f6c 756d 6e73 5f6c         columns_l
+00011fb0: 6175 6e64 6572 6564 203d 205f 6c61 756e  aundered = _laun
+00011fc0: 6465 725f 636f 6c75 6d6e 5f6e 616d 6573  der_column_names
+00011fd0: 2873 7263 5f63 6f6c 756d 6e73 290a 2020  (src_columns).  
+00011fe0: 2020 2020 2020 636f 6c75 6d6e 735f 616c        columns_al
+00011ff0: 6961 7365 6420 3d20 5b0a 2020 2020 2020  iased = [.      
+00012000: 2020 2020 2020 6627 227b 636f 6c75 6d6e        f'"{column
+00012010: 7d22 2041 5320 227b 6c61 756e 6465 7265  }" AS "{laundere
+00012020: 647d 2227 2066 6f72 2063 6f6c 756d 6e2c  d}"' for column,
+00012030: 206c 6175 6e64 6572 6564 2069 6e20 636f   laundered in co
+00012040: 6c75 6d6e 735f 6c61 756e 6465 7265 640a  lumns_laundered.
+00012050: 2020 2020 2020 2020 5d0a 2020 2020 2020          ].      
+00012060: 2020 6c61 7965 7220 3d20 7372 635f 6c61    layer = src_la
+00012070: 7965 7220 6966 2073 7263 5f6c 6179 6572  yer if src_layer
+00012080: 2069 7320 6e6f 7420 4e6f 6e65 2065 6c73   is not None els
+00012090: 6520 6765 745f 6f6e 6c79 5f6c 6179 6572  e get_only_layer
+000120a0: 2873 7263 290a 2020 2020 2020 2020 7371  (src).        sq
+000120b0: 6c5f 7374 6d74 203d 2066 2753 454c 4543  l_stmt = f'SELEC
+000120c0: 5420 7b22 2c20 222e 6a6f 696e 2863 6f6c  T {", ".join(col
+000120d0: 756d 6e73 5f61 6c69 6173 6564 297d 2046  umns_aliased)} F
+000120e0: 524f 4d20 227b 6c61 7965 727d 2227 0a0a  ROM "{layer}"'..
+000120f0: 2020 2020 2320 5768 656e 2064 7374 2066      # When dst f
+00012100: 696c 6520 646f 6573 6e27 7420 6578 6973  ile doesn't exis
+00012110: 7420 616e 6420 7372 6320 6973 2065 6d70  t and src is emp
+00012120: 7479 2066 6f72 6365 5f6f 7574 7075 745f  ty force_output_
+00012130: 6765 6f6d 6574 7279 7479 7065 2073 686f  geometrytype sho
+00012140: 756c 6420 6265 0a20 2020 2023 2073 7065  uld be.    # spe
+00012150: 6369 6669 6564 2c20 6f74 6865 7277 6973  cified, otherwis
+00012160: 6520 696e 7661 6c69 6420 6f75 7470 7574  e invalid output
+00012170: 2e0a 2020 2020 6966 2066 6f72 6365 5f6f  ..    if force_o
+00012180: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
+00012190: 7065 2069 7320 4e6f 6e65 2061 6e64 206e  pe is None and n
+000121a0: 6f74 2064 7374 2e65 7869 7374 7328 293a  ot dst.exists():
+000121b0: 0a20 2020 2020 2020 2069 6620 7372 635f  .        if src_
+000121c0: 6c61 7965 7269 6e66 6f20 6973 204e 6f6e  layerinfo is Non
+000121d0: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
+000121e0: 7263 5f6c 6179 6572 696e 666f 203d 2067  rc_layerinfo = g
+000121f0: 6574 5f6c 6179 6572 696e 666f 2873 7263  et_layerinfo(src
+00012200: 2c20 7372 635f 6c61 7965 7229 0a20 2020  , src_layer).   
+00012210: 2020 2020 2066 6f72 6365 5f6f 7574 7075       force_outpu
+00012220: 745f 6765 6f6d 6574 7279 7479 7065 203d  t_geometrytype =
+00012230: 2073 7263 5f6c 6179 6572 696e 666f 2e67   src_layerinfo.g
+00012240: 656f 6d65 7472 7974 7970 650a 0a20 2020  eometrytype..   
+00012250: 2023 2047 6f21 0a20 2020 2074 7261 6e73   # Go!.    trans
+00012260: 6c61 7465 5f69 6e66 6f20 3d20 5f6f 6772  late_info = _ogr
+00012270: 5f75 7469 6c2e 5665 6374 6f72 5472 616e  _util.VectorTran
+00012280: 736c 6174 6549 6e66 6f28 0a20 2020 2020  slateInfo(.     
+00012290: 2020 2069 6e70 7574 5f70 6174 683d 7372     input_path=sr
+000122a0: 632c 0a20 2020 2020 2020 206f 7574 7075  c,.        outpu
+000122b0: 745f 7061 7468 3d64 7374 2c0a 2020 2020  t_path=dst,.    
+000122c0: 2020 2020 696e 7075 745f 6c61 7965 7273      input_layers
+000122d0: 3d73 7263 5f6c 6179 6572 2c0a 2020 2020  =src_layer,.    
+000122e0: 2020 2020 6f75 7470 7574 5f6c 6179 6572      output_layer
+000122f0: 3d64 7374 5f6c 6179 6572 2c0a 2020 2020  =dst_layer,.    
+00012300: 2020 2020 696e 7075 745f 7372 733d 7372      input_srs=sr
+00012310: 635f 6372 732c 0a20 2020 2020 2020 206f  c_crs,.        o
+00012320: 7574 7075 745f 7372 733d 6473 745f 6372  utput_srs=dst_cr
+00012330: 732c 0a20 2020 2020 2020 2073 716c 5f73  s,.        sql_s
+00012340: 746d 743d 7371 6c5f 7374 6d74 2c0a 2020  tmt=sql_stmt,.  
+00012350: 2020 2020 2020 7371 6c5f 6469 616c 6563        sql_dialec
+00012360: 743d 224f 4752 5351 4c22 2c0a 2020 2020  t="OGRSQL",.    
+00012370: 2020 2020 7265 7072 6f6a 6563 743d 7265      reproject=re
+00012380: 7072 6f6a 6563 742c 0a20 2020 2020 2020  project,.       
+00012390: 2074 7261 6e73 6163 7469 6f6e 5f73 697a   transaction_siz
+000123a0: 653d 7472 616e 7361 6374 696f 6e5f 7369  e=transaction_si
+000123b0: 7a65 2c0a 2020 2020 2020 2020 6170 7065  ze,.        appe
+000123c0: 6e64 3d54 7275 652c 0a20 2020 2020 2020  nd=True,.       
+000123d0: 2075 7064 6174 653d 5472 7565 2c0a 2020   update=True,.  
+000123e0: 2020 2020 2020 6578 706c 6f64 6563 6f6c        explodecol
+000123f0: 6c65 6374 696f 6e73 3d65 7870 6c6f 6465  lections=explode
+00012400: 636f 6c6c 6563 7469 6f6e 732c 0a20 2020  collections,.   
+00012410: 2020 2020 2066 6f72 6365 5f6f 7574 7075       force_outpu
+00012420: 745f 6765 6f6d 6574 7279 7479 7065 3d66  t_geometrytype=f
+00012430: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+00012440: 6574 7279 7479 7065 2c0a 2020 2020 2020  etrytype,.      
+00012450: 2020 6f70 7469 6f6e 733d 6f70 7469 6f6e    options=option
+00012460: 732c 0a20 2020 2020 2020 2070 7265 7365  s,.        prese
+00012470: 7276 655f 6669 643d 7072 6573 6572 7665  rve_fid=preserve
+00012480: 5f66 6964 2c0a 2020 2020 290a 2020 2020  _fid,.    ).    
+00012490: 5f6f 6772 5f75 7469 6c2e 7665 6374 6f72  _ogr_util.vector
+000124a0: 5f74 7261 6e73 6c61 7465 5f62 795f 696e  _translate_by_in
+000124b0: 666f 2869 6e66 6f3d 7472 616e 736c 6174  fo(info=translat
+000124c0: 655f 696e 666f 290a 0a0a 6465 6620 636f  e_info)...def co
+000124d0: 6e76 6572 7428 0a20 2020 2073 7263 3a20  nvert(.    src: 
+000124e0: 556e 696f 6e5b 7374 722c 2022 6f73 2e50  Union[str, "os.P
+000124f0: 6174 684c 696b 655b 416e 795d 225d 2c0a  athLike[Any]"],.
+00012500: 2020 2020 6473 743a 2055 6e69 6f6e 5b73      dst: Union[s
+00012510: 7472 2c20 226f 732e 5061 7468 4c69 6b65  tr, "os.PathLike
+00012520: 5b41 6e79 5d22 5d2c 0a20 2020 2073 7263  [Any]"],.    src
+00012530: 5f6c 6179 6572 3a20 4f70 7469 6f6e 616c  _layer: Optional
+00012540: 5b73 7472 5d20 3d20 4e6f 6e65 2c0a 2020  [str] = None,.  
+00012550: 2020 6473 745f 6c61 7965 723a 204f 7074    dst_layer: Opt
+00012560: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
+00012570: 652c 0a20 2020 2073 7263 5f63 7273 3a20  e,.    src_crs: 
+00012580: 556e 696f 6e5b 7374 722c 2069 6e74 2c20  Union[str, int, 
+00012590: 4e6f 6e65 5d20 3d20 4e6f 6e65 2c0a 2020  None] = None,.  
+000125a0: 2020 6473 745f 6372 733a 2055 6e69 6f6e    dst_crs: Union
+000125b0: 5b73 7472 2c20 696e 742c 204e 6f6e 655d  [str, int, None]
+000125c0: 203d 204e 6f6e 652c 0a20 2020 2072 6570   = None,.    rep
+000125d0: 726f 6a65 6374 3a20 626f 6f6c 203d 2046  roject: bool = F
+000125e0: 616c 7365 2c0a 2020 2020 6578 706c 6f64  alse,.    explod
+000125f0: 6563 6f6c 6c65 6374 696f 6e73 3a20 626f  ecollections: bo
+00012600: 6f6c 203d 2046 616c 7365 2c0a 2020 2020  ol = False,.    
+00012610: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
+00012620: 6d65 7472 7974 7970 653a 2055 6e69 6f6e  metrytype: Union
+00012630: 5b47 656f 6d65 7472 7954 7970 652c 2073  [GeometryType, s
+00012640: 7472 2c20 4e6f 6e65 5d20 3d20 4e6f 6e65  tr, None] = None
+00012650: 2c0a 2020 2020 6372 6561 7465 5f73 7061  ,.    create_spa
+00012660: 7469 616c 5f69 6e64 6578 3a20 4f70 7469  tial_index: Opti
+00012670: 6f6e 616c 5b62 6f6f 6c5d 203d 2054 7275  onal[bool] = Tru
+00012680: 652c 0a20 2020 2070 7265 7365 7276 655f  e,.    preserve_
+00012690: 6669 643a 204f 7074 696f 6e61 6c5b 626f  fid: Optional[bo
+000126a0: 6f6c 5d20 3d20 4e6f 6e65 2c0a 2020 2020  ol] = None,.    
+000126b0: 6f70 7469 6f6e 733a 2064 6963 7420 3d20  options: dict = 
+000126c0: 7b7d 2c0a 2020 2020 6170 7065 6e64 3a20  {},.    append: 
+000126d0: 626f 6f6c 203d 2046 616c 7365 2c0a 2020  bool = False,.  
+000126e0: 2020 666f 7263 653a 2062 6f6f 6c20 3d20    force: bool = 
+000126f0: 4661 6c73 652c 0a29 3a0a 2020 2020 2222  False,.):.    ""
+00012700: 220a 2020 2020 5265 6164 2061 206c 6179  ".    Read a lay
+00012710: 6572 2066 726f 6d20 6120 736f 7572 6365  er from a source
+00012720: 2066 696c 6520 616e 6420 7772 6974 6520   file and write 
+00012730: 6974 2074 6f20 6120 6e65 7720 6465 7374  it to a new dest
+00012740: 696e 6174 696f 6e20 6669 6c65 2e0a 0a20  ination file... 
+00012750: 2020 2054 7970 6963 616c 6c79 2075 7365     Typically use
+00012760: 6420 746f 2063 6f6e 7665 7274 2066 726f  d to convert fro
+00012770: 6d20 6f6e 6520 6669 6c65 666f 726d 6174  m one fileformat
+00012780: 2074 6f20 616e 6f74 6865 7220 6f72 2074   to another or t
+00012790: 6f20 7265 7072 6f6a 6563 742e 0a0a 2020  o reproject...  
+000127a0: 2020 5468 6520 6f70 7469 6f6e 7320 7061    The options pa
+000127b0: 7261 6d65 7465 7220 6361 6e20 6265 2075  rameter can be u
+000127c0: 7365 6420 746f 2070 6173 7320 616e 7920  sed to pass any 
+000127d0: 7479 7065 206f 6620 6f70 7469 6f6e 7320  type of options 
+000127e0: 746f 2047 4441 4c20 696e 0a20 2020 2074  to GDAL in.    t
+000127f0: 6865 2066 6f6c 6c6f 7769 6e67 2066 6f72  he following for
+00012800: 6d3a 0a20 2020 2020 2020 207b 2022 3c6f  m:.        { "<o
+00012810: 7074 696f 6e5f 7479 7065 3e2e 3c6f 7074  ption_type>.<opt
+00012820: 696f 6e5f 6e61 6d65 3e22 3a20 3c6f 7074  ion_name>": <opt
+00012830: 696f 6e5f 7661 6c75 653e 207d 0a0a 2020  ion_value> }..  
+00012840: 2020 5468 6520 6f70 7469 6f6e 2074 7970    The option typ
+00012850: 6573 2063 616e 2062 6520 616e 7920 6f66  es can be any of
+00012860: 2074 6865 2066 6f6c 6c6f 7769 6e67 3a0a   the following:.
+00012870: 2020 2020 2020 2020 2d20 4c41 5945 525f          - LAYER_
+00012880: 4352 4541 5449 4f4e 3a20 6c61 7965 7220  CREATION: layer 
+00012890: 6372 6561 7469 6f6e 206f 7074 696f 6e20  creation option 
+000128a0: 286c 636f 290a 2020 2020 2020 2020 2d20  (lco).        - 
+000128b0: 4441 5441 5345 545f 4352 4541 5449 4f4e  DATASET_CREATION
+000128c0: 3a20 6461 7461 7365 7420 6372 6561 7469  : dataset creati
+000128d0: 6f6e 206f 7074 696f 6e20 2864 7363 6f29  on option (dsco)
+000128e0: 0a20 2020 2020 2020 202d 2049 4e50 5554  .        - INPUT
+000128f0: 5f4f 5045 4e3a 2069 6e70 7574 2064 6174  _OPEN: input dat
+00012900: 6173 6574 206f 7065 6e20 6f70 7469 6f6e  aset open option
+00012910: 2028 6f6f 290a 2020 2020 2020 2020 2d20   (oo).        - 
+00012920: 4445 5354 494e 4154 494f 4e5f 4f50 454e  DESTINATION_OPEN
+00012930: 3a20 6465 7374 696e 6174 696f 6e20 6461  : destination da
+00012940: 7461 7365 7420 6f70 656e 206f 7074 696f  taset open optio
+00012950: 6e20 2864 6f6f 290a 2020 2020 2020 2020  n (doo).        
+00012960: 2d20 434f 4e46 4947 3a20 636f 6e66 6967  - CONFIG: config
+00012970: 206f 7074 696f 6e20 2863 6f6e 6669 6729   option (config)
+00012980: 0a0a 2020 2020 5468 6520 6f70 7469 6f6e  ..    The option
+00012990: 7320 6361 6e20 6265 2066 6f75 6e64 2069  s can be found i
+000129a0: 6e20 7468 6520 5b47 4441 4c20 7665 6374  n the [GDAL vect
+000129b0: 6f72 2064 7269 7665 7220 646f 6375 6d65  or driver docume
+000129c0: 6e74 6174 696f 6e5d 0a20 2020 2028 6874  ntation].    (ht
+000129d0: 7470 733a 2f2f 6764 616c 2e6f 7267 2f64  tps://gdal.org/d
+000129e0: 7269 7665 7273 2f76 6563 746f 722f 696e  rivers/vector/in
+000129f0: 6465 782e 6874 6d6c 292e 0a0a 2020 2020  dex.html)...    
+00012a00: 4172 6773 3a0a 2020 2020 2020 2020 7372  Args:.        sr
+00012a10: 6320 2850 6174 684c 696b 6529 3a20 5468  c (PathLike): Th
+00012a20: 6520 736f 7572 6365 2066 696c 6520 7061  e source file pa
+00012a30: 7468 2e0a 2020 2020 2020 2020 6473 7420  th..        dst 
+00012a40: 2850 6174 684c 696b 6529 3a20 5468 6520  (PathLike): The 
+00012a50: 6465 7374 696e 6174 696f 6e20 6669 6c65  destination file
+00012a60: 2070 6174 682e 0a20 2020 2020 2020 2073   path..        s
+00012a70: 7263 5f6c 6179 6572 2028 7374 722c 206f  rc_layer (str, o
+00012a80: 7074 696f 6e61 6c29 3a20 5468 6520 736f  ptional): The so
+00012a90: 7572 6365 206c 6179 6572 2e20 4966 204e  urce layer. If N
+00012aa0: 6f6e 6520 616e 6420 7468 6572 6520 6973  one and there is
+00012ab0: 206f 6e6c 790a 2020 2020 2020 2020 2020   only.          
+00012ac0: 2020 6f6e 6520 6c61 7965 7220 696e 2074    one layer in t
+00012ad0: 6865 2073 7263 2066 696c 652c 2074 6861  he src file, tha
+00012ae0: 7420 6c61 7965 7220 6973 2074 616b 656e  t layer is taken
+00012af0: 2e20 4465 6661 756c 7473 2074 6f20 4e6f  . Defaults to No
+00012b00: 6e65 2e0a 2020 2020 2020 2020 6473 745f  ne..        dst_
+00012b10: 6c61 7965 7220 2873 7472 2c20 6f70 7469  layer (str, opti
+00012b20: 6f6e 616c 293a 2054 6865 2064 6573 7469  onal): The desti
+00012b30: 6e61 7469 6f6e 206c 6179 6572 2e20 4966  nation layer. If
+00012b40: 204e 6f6e 652c 2074 6865 2066 696c 650a   None, the file.
+00012b50: 2020 2020 2020 2020 2020 2020 7374 656d              stem
+00012b60: 2069 7320 7461 6b65 6e20 6173 206c 6179   is taken as lay
+00012b70: 6572 206e 616d 652e 2044 6566 6175 6c74  er name. Default
+00012b80: 7320 746f 204e 6f6e 652e 0a20 2020 2020  s to None..     
+00012b90: 2020 2073 7263 5f63 7273 2028 556e 696f     src_crs (Unio
+00012ba0: 6e5b 7374 722c 2069 6e74 5d2c 206f 7074  n[str, int], opt
+00012bb0: 696f 6e61 6c29 3a20 616e 2065 7073 6720  ional): an epsg 
+00012bc0: 696e 7420 6f72 2061 6e79 7468 696e 6720  int or anything 
+00012bd0: 7375 7070 6f72 7465 640a 2020 2020 2020  supported.      
+00012be0: 2020 2020 2020 6279 2074 6865 204f 4752        by the OGR
+00012bf0: 5370 6174 6961 6c52 6566 6572 656e 6365  SpatialReference
+00012c00: 2e53 6574 4672 6f6d 5573 6572 496e 7075  .SetFromUserInpu
+00012c10: 7428 2920 6361 6c6c 2c20 7768 6963 6820  t() call, which 
+00012c20: 696e 636c 7564 6573 0a20 2020 2020 2020  includes.       
+00012c30: 2020 2020 2061 6e20 4550 5347 2073 7472       an EPSG str
+00012c40: 696e 6720 2865 672e 2022 4550 5347 3a34  ing (eg. "EPSG:4
+00012c50: 3332 3622 292c 2061 2077 656c 6c20 6b6e  326"), a well kn
+00012c60: 6f77 6e20 7465 7874 2028 574b 5429 2043  own text (WKT) C
+00012c70: 5253 0a20 2020 2020 2020 2020 2020 2064  RS.            d
+00012c80: 6566 696e 6974 696f 6e2c 2e2e 2e20 4465  efinition,... De
+00012c90: 6661 756c 7473 2074 6f20 4e6f 6e65 2e0a  faults to None..
+00012ca0: 2020 2020 2020 2020 6473 745f 6372 7320          dst_crs 
+00012cb0: 2855 6e69 6f6e 5b73 7472 2c20 696e 745d  (Union[str, int]
+00012cc0: 2c20 6f70 7469 6f6e 616c 293a 2061 6e20  , optional): an 
+00012cd0: 6570 7367 2069 6e74 206f 7220 616e 7974  epsg int or anyt
+00012ce0: 6869 6e67 2073 7570 706f 7274 6564 0a20  hing supported. 
+00012cf0: 2020 2020 2020 2020 2020 2062 7920 7468             by th
+00012d00: 6520 4f47 5253 7061 7469 616c 5265 6665  e OGRSpatialRefe
+00012d10: 7265 6e63 652e 5365 7446 726f 6d55 7365  rence.SetFromUse
+00012d20: 7249 6e70 7574 2829 2063 616c 6c2c 2077  rInput() call, w
+00012d30: 6869 6368 2069 6e63 6c75 6465 730a 2020  hich includes.  
+00012d40: 2020 2020 2020 2020 2020 616e 2045 5053            an EPS
+00012d50: 4720 7374 7269 6e67 2028 6567 2e20 2245  G string (eg. "E
+00012d60: 5053 473a 3433 3236 2229 2c20 6120 7765  PSG:4326"), a we
+00012d70: 6c6c 206b 6e6f 776e 2074 6578 7420 2857  ll known text (W
+00012d80: 4b54 2920 4352 530a 2020 2020 2020 2020  KT) CRS.        
+00012d90: 2020 2020 6465 6669 6e69 7469 6f6e 2c2e      definition,.
+00012da0: 2e2e 2044 6566 6175 6c74 7320 746f 204e  .. Defaults to N
+00012db0: 6f6e 652e 0a20 2020 2020 2020 2072 6570  one..        rep
+00012dc0: 726f 6a65 6374 2028 626f 6f6c 2c20 6f70  roject (bool, op
+00012dd0: 7469 6f6e 616c 293a 2054 7275 6520 746f  tional): True to
+00012de0: 2072 6570 726f 6a65 6374 2077 6869 6c65   reproject while
+00012df0: 2063 6f6e 7665 7274 696e 6720 7468 650a   converting the.
+00012e00: 2020 2020 2020 2020 2020 2020 6669 6c65              file
+00012e10: 2e20 4465 6661 756c 7473 2074 6f20 4661  . Defaults to Fa
+00012e20: 6c73 652e 0a20 2020 2020 2020 2065 7870  lse..        exp
+00012e30: 6c6f 6465 636f 6c6c 6563 7469 6f6e 7320  lodecollections 
+00012e40: 2862 6f6f 6c2c 206f 7074 696f 6e61 6c29  (bool, optional)
+00012e50: 3a20 5472 7565 2074 6f20 6f75 7470 7574  : True to output
+00012e60: 206f 6e6c 7920 7369 6d70 6c65 0a20 2020   only simple.   
+00012e70: 2020 2020 2020 2020 2067 656f 6d65 7472           geometr
+00012e80: 6965 732e 2044 6566 6175 6c74 7320 746f  ies. Defaults to
+00012e90: 2046 616c 7365 2e0a 2020 2020 2020 2020   False..        
+00012ea0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
+00012eb0: 6d65 7472 7974 7970 6520 2855 6e69 6f6e  metrytype (Union
+00012ec0: 5b47 656f 6d65 7472 7954 7970 652c 2073  [GeometryType, s
+00012ed0: 7472 5d2c 206f 7074 696f 6e61 6c29 3a20  tr], optional): 
+00012ee0: 4765 6f6d 6574 7279 2074 7970 652e 0a20  Geometry type.. 
+00012ef0: 2020 2020 2020 2020 2020 2074 6f20 2874             to (t
+00012f00: 7279 2074 6f29 2066 6f72 6365 2074 6865  ry to) force the
+00012f10: 206f 7574 7075 7420 746f 2e20 4465 6661   output to. Defa
+00012f20: 756c 7473 2074 6f20 4e6f 6e65 2e0a 2020  ults to None..  
+00012f30: 2020 2020 2020 6372 6561 7465 5f73 7061        create_spa
+00012f40: 7469 616c 5f69 6e64 6578 2028 626f 6f6c  tial_index (bool
+00012f50: 2c20 6f70 7469 6f6e 616c 293a 2054 7275  , optional): Tru
+00012f60: 6520 746f 2063 7265 6174 6520 6120 7370  e to create a sp
+00012f70: 6174 6961 6c20 696e 6465 780a 2020 2020  atial index.    
+00012f80: 2020 2020 2020 2020 6f6e 2074 6865 2064          on the d
+00012f90: 6573 7469 6e61 7469 6f6e 2066 696c 652f  estination file/
+00012fa0: 6c61 7965 722e 2049 6620 4e6f 6e65 2c20  layer. If None, 
+00012fb0: 7468 6520 6465 6661 756c 7420 6265 6861  the default beha
+00012fc0: 7669 6f75 7220 6279 2067 6461 6c20 666f  viour by gdal fo
+00012fd0: 720a 2020 2020 2020 2020 2020 2020 7468  r.            th
+00012fe0: 6174 2066 696c 6520 7479 7065 2069 7320  at file type is 
+00012ff0: 7265 7370 6563 7465 642e 2049 6620 7468  respected. If th
+00013000: 6520 4c41 5945 525f 4352 4541 5449 4f4e  e LAYER_CREATION
+00013010: 2e53 5041 5449 414c 5f49 4e44 4558 0a20  .SPATIAL_INDEX. 
+00013020: 2020 2020 2020 2020 2020 2070 6172 616d             param
+00013030: 6574 6572 2069 7320 7370 6563 6966 6965  eter is specifie
+00013040: 6420 696e 206f 7074 696f 6e73 2c20 6372  d in options, cr
+00013050: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
+00013060: 6578 2069 7320 6967 6e6f 7265 642e 0a20  ex is ignored.. 
+00013070: 2020 2020 2020 2020 2020 2044 6566 6175             Defau
+00013080: 6c74 7320 746f 2054 7275 652e 0a20 2020  lts to True..   
+00013090: 2020 2020 2070 7265 7365 7276 655f 6669       preserve_fi
+000130a0: 6420 2862 6f6f 6c2c 206f 7074 696f 6e61  d (bool, optiona
+000130b0: 6c29 3a20 5472 7565 2074 6f20 6d61 6b65  l): True to make
+000130c0: 2061 6e20 6578 7472 6120 6566 666f 7274   an extra effort
+000130d0: 2074 6f20 7072 6573 6572 7665 2066 6964   to preserve fid
+000130e0: 2773 206f 660a 2020 2020 2020 2020 2020  's of.          
+000130f0: 2020 7468 6520 736f 7572 6365 206c 6179    the source lay
+00013100: 6572 2074 6f20 7468 6520 6465 7374 696e  er to the destin
+00013110: 6174 696f 6e20 6c61 7965 722e 2046 616c  ation layer. Fal
+00013120: 7365 206e 6f74 2074 6f20 646f 2061 6e79  se not to do any
+00013130: 2065 6666 6f72 742e 204e 6f6e 650a 2020   effort. None.  
+00013140: 2020 2020 2020 2020 2020 746f 2075 7365            to use
+00013150: 2074 6865 2064 6566 6175 6c74 2062 6568   the default beh
+00013160: 6176 696f 7572 206f 6620 6764 616c 2c20  aviour of gdal, 
+00013170: 7468 6174 2061 6c72 6561 6479 2070 7265  that already pre
+00013180: 7365 7276 6573 2069 6e20 736f 6d65 2063  serves in some c
+00013190: 6173 6573 2e0a 2020 2020 2020 2020 2020  ases..          
+000131a0: 2020 536f 6d65 2066 696c 6520 666f 726d    Some file form
+000131b0: 6174 7320 646f 6e27 7420 6578 706c 6963  ats don't explic
+000131c0: 6974 6c79 2073 746f 7265 2074 6865 2066  itly store the f
+000131d0: 6964 2028 652e 672e 2073 6861 7065 6669  id (e.g. shapefi
+000131e0: 6c65 292c 2073 6f20 7468 6579 0a20 2020  le), so they.   
+000131f0: 2020 2020 2020 2020 2077 696c 6c20 6e65           will ne
+00013200: 7665 7220 6265 2061 626c 6520 746f 2070  ver be able to p
+00013210: 7265 7365 7276 6520 6669 6473 2e20 4465  reserve fids. De
+00013220: 6661 756c 7473 2074 6f20 4e6f 6e65 2e0a  faults to None..
+00013230: 2020 2020 2020 2020 6f70 7469 6f6e 7320          options 
+00013240: 2864 6963 742c 206f 7074 696f 6e61 6c29  (dict, optional)
+00013250: 3a20 6f70 7469 6f6e 7320 746f 2070 6173  : options to pas
+00013260: 7320 746f 2067 6461 6c2e 0a20 2020 2020  s to gdal..     
+00013270: 2020 2061 7070 656e 6420 2862 6f6f 6c2c     append (bool,
+00013280: 206f 7074 696f 6e61 6c29 3a20 5472 7565   optional): True
+00013290: 2074 6f20 6170 7065 6e64 2074 6f20 7468   to append to th
+000132a0: 6520 6f75 7470 7574 2066 696c 6520 6966  e output file if
+000132b0: 2069 7420 6578 6973 7473 2e0a 2020 2020   it exists..    
+000132c0: 2020 2020 2020 2020 4465 6661 756c 7473          Defaults
+000132d0: 2074 6f20 4661 6c73 652e 0a20 2020 2020   to False..     
+000132e0: 2020 2066 6f72 6365 2028 626f 6f6c 2c20     force (bool, 
+000132f0: 6f70 7469 6f6e 616c 293a 206f 7665 7277  optional): overw
+00013300: 7269 7465 2065 7869 7374 696e 6720 6f75  rite existing ou
+00013310: 7470 7574 2066 696c 6528 7329 0a20 2020  tput file(s).   
+00013320: 2020 2020 2020 2020 2044 6566 6175 6c74           Default
+00013330: 7320 746f 2046 616c 7365 2e0a 2020 2020  s to False..    
+00013340: 2222 220a 2020 2020 2320 496e 6974 0a20  """.    # Init. 
+00013350: 2020 2073 7263 203d 2050 6174 6828 7372     src = Path(sr
+00013360: 6329 0a20 2020 2064 7374 203d 2050 6174  c).    dst = Pat
+00013370: 6828 6473 7429 0a0a 2020 2020 2320 4966  h(dst)..    # If
+00013380: 2073 6f75 7263 6520 6669 6c65 2064 6f65   source file doe
+00013390: 736e 2774 2065 7869 7374 2c20 7261 6973  sn't exist, rais
+000133a0: 6520 6572 726f 720a 2020 2020 6966 206e  e error.    if n
+000133b0: 6f74 2073 7263 2e65 7869 7374 7328 293a  ot src.exists():
+000133c0: 0a20 2020 2020 2020 2072 6169 7365 2056  .        raise V
+000133d0: 616c 7565 4572 726f 7228 6622 7372 6320  alueError(f"src 
+000133e0: 6669 6c65 2064 6f65 736e 2774 2065 7869  file doesn't exi
+000133f0: 7374 3a20 7b73 7263 7d22 290a 2020 2020  st: {src}").    
+00013400: 2320 4966 2064 6573 7420 6669 6c65 2065  # If dest file e
+00013410: 7869 7374 7320 616c 7265 6164 792c 2072  xists already, r
+00013420: 656d 6f76 6520 6974 0a20 2020 2069 6620  emove it.    if 
+00013430: 6e6f 7420 6170 7065 6e64 2061 6e64 2064  not append and d
+00013440: 7374 2e65 7869 7374 7328 293a 0a20 2020  st.exists():.   
+00013450: 2020 2020 2069 6620 666f 7263 6520 6973       if force is
+00013460: 2054 7275 653a 0a20 2020 2020 2020 2020   True:.         
+00013470: 2020 2072 656d 6f76 6528 6473 7429 0a20     remove(dst). 
+00013480: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00013490: 2020 2020 2020 2020 206c 6f67 6765 722e           logger.
+000134a0: 696e 666f 2866 224f 7574 7075 7420 6669  info(f"Output fi
+000134b0: 6c65 2065 7869 7374 7320 616c 7265 6164  le exists alread
+000134c0: 792c 2073 6f20 7374 6f70 3a20 7b64 7374  y, so stop: {dst
+000134d0: 7d22 290a 2020 2020 2020 2020 2020 2020  }").            
+000134e0: 7265 7475 726e 0a0a 2020 2020 2320 436f  return..    # Co
+000134f0: 6e76 6572 740a 2020 2020 6c6f 6767 6572  nvert.    logger
+00013500: 2e69 6e66 6f28 6622 436f 6e76 6572 7420  .info(f"Convert 
+00013510: 7b73 7263 7d20 746f 207b 6473 747d 2229  {src} to {dst}")
+00013520: 0a20 2020 205f 6170 7065 6e64 5f74 6f5f  .    _append_to_
+00013530: 6e6f 6c6f 636b 280a 2020 2020 2020 2020  nolock(.        
+00013540: 7372 632c 0a20 2020 2020 2020 2064 7374  src,.        dst
+00013550: 2c0a 2020 2020 2020 2020 7372 635f 6c61  ,.        src_la
+00013560: 7965 722c 0a20 2020 2020 2020 2064 7374  yer,.        dst
+00013570: 5f6c 6179 6572 2c0a 2020 2020 2020 2020  _layer,.        
+00013580: 7372 635f 6372 733d 7372 635f 6372 732c  src_crs=src_crs,
+00013590: 0a20 2020 2020 2020 2064 7374 5f63 7273  .        dst_crs
+000135a0: 3d64 7374 5f63 7273 2c0a 2020 2020 2020  =dst_crs,.      
+000135b0: 2020 7265 7072 6f6a 6563 743d 7265 7072    reproject=repr
+000135c0: 6f6a 6563 742c 0a20 2020 2020 2020 2065  oject,.        e
+000135d0: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
+000135e0: 733d 6578 706c 6f64 6563 6f6c 6c65 6374  s=explodecollect
+000135f0: 696f 6e73 2c0a 2020 2020 2020 2020 666f  ions,.        fo
+00013600: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
+00013610: 7472 7974 7970 653d 666f 7263 655f 6f75  trytype=force_ou
+00013620: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+00013630: 652c 0a20 2020 2020 2020 2063 7265 6174  e,.        creat
+00013640: 655f 7370 6174 6961 6c5f 696e 6465 783d  e_spatial_index=
+00013650: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
+00013660: 6e64 6578 2c0a 2020 2020 2020 2020 7072  ndex,.        pr
+00013670: 6573 6572 7665 5f66 6964 3d70 7265 7365  eserve_fid=prese
+00013680: 7276 655f 6669 642c 0a20 2020 2020 2020  rve_fid,.       
+00013690: 206f 7074 696f 6e73 3d6f 7074 696f 6e73   options=options
+000136a0: 2c0a 2020 2020 290a 0a0a 6465 6620 5f6c  ,.    )...def _l
+000136b0: 6175 6e64 6572 5f63 6f6c 756d 6e5f 6e61  aunder_column_na
+000136c0: 6d65 7328 636f 6c75 6d6e 733a 2049 7465  mes(columns: Ite
+000136d0: 7261 626c 6529 202d 3e20 4c69 7374 5b54  rable) -> List[T
+000136e0: 7570 6c65 5b73 7472 2c20 7374 725d 5d3a  uple[str, str]]:
+000136f0: 0a20 2020 2022 2222 0a20 2020 204c 6175  .    """.    Lau
+00013700: 6e64 6572 7320 7468 6520 636f 6c75 6d6e  nders the column
+00013710: 206e 616d 6573 2070 6173 7365 6420 746f   names passed to
+00013720: 2063 6f6d 706c 7920 7769 7468 2073 6861   comply with sha
+00013730: 7065 6669 6c65 2072 6573 7472 6963 7469  pefile restricti
+00013740: 6f6e 732e 0a0a 2020 2020 5261 7469 6f6e  ons...    Ration
+00013750: 616c 653a 206e 6f72 6d61 6c6c 7920 6764  ale: normally gd
+00013760: 616c 206c 6175 6e64 6572 7320 7468 656d  al launders them
+00013770: 2069 6620 6e65 6564 6564 2c20 6275 7420   if needed, but 
+00013780: 7768 656e 2079 6f75 2061 7070 656e 640a  when you append.
+00013790: 2020 2020 6d75 6c74 6970 6c65 2066 696c      multiple fil
+000137a0: 6573 2074 6f20 6120 7368 6170 6566 696c  es to a shapefil
+000137b0: 6520 7769 7468 2063 6f6c 756d 6e73 2074  e with columns t
+000137c0: 6861 7420 6e65 6564 2074 6f20 6265 206c  hat need to be l
+000137d0: 6175 6e64 6572 6564 0a20 2020 2074 6865  aundered.    the
+000137e0: 7920 6172 6520 6e6f 7420 6d61 7463 6865  y are not matche
+000137f0: 6420 616e 6420 736f 2061 7265 2061 7070  d and so are app
+00013800: 656e 6465 6420 7769 7468 204e 554c 4c20  ended with NULL 
+00013810: 7661 6c75 6573 2066 6f72 2074 6865 7365  values for these
+00013820: 0a20 2020 2063 6f6c 756d 6e73 2e20 4e6f  .    columns. No
+00013830: 726d 616c 6c79 2074 6865 202d 7265 6c61  rmally the -rela
+00013840: 7865 6446 6965 6c64 4e61 6d65 4d61 7463  xedFieldNameMatc
+00013850: 6820 7061 7261 6d65 7465 7220 696e 206f  h parameter in o
+00013860: 6772 326f 6772 0a20 2020 2073 686f 756c  gr2ogr.    shoul
+00013870: 6420 6669 7820 7468 6973 2c20 6275 7420  d fix this, but 
+00013880: 6974 2073 6565 6d73 2074 6861 7420 7468  it seems that th
+00013890: 6973 2069 736e 2774 2073 7570 706f 7274  is isn't support
+000138a0: 6564 2066 6f72 2073 6861 7065 6669 6c65  ed for shapefile
+000138b0: 732e 0a0a 2020 2020 4c61 756e 6465 7269  s...    Launderi
+000138c0: 6e67 2069 7320 6261 7365 6420 6f6e 2074  ng is based on t
+000138d0: 6869 7320 7465 7874 2066 726f 6d20 7468  his text from th
+000138e0: 6520 6764 616c 2073 6861 7065 6669 6c65  e gdal shapefile
+000138f0: 2064 7269 7665 720a 2020 2020 646f 6375   driver.    docu
+00013900: 6d65 6e74 6174 696f 6e3a 0a0a 2020 2020  mentation:..    
+00013910: 5368 6170 6566 696c 6520 6665 6174 7572  Shapefile featur
+00013920: 6520 6174 7472 6962 7574 6573 2061 7265  e attributes are
+00013930: 2073 746f 7265 6420 696e 2061 6e20 6173   stored in an as
+00013940: 736f 6369 6174 6564 202e 6462 6620 6669  sociated .dbf fi
+00013950: 6c65 2c20 616e 640a 2020 2020 736f 2061  le, and.    so a
+00013960: 7474 7269 6275 7465 7320 7375 6666 6572  ttributes suffer
+00013970: 2061 206e 756d 6265 7220 6f66 206c 696d   a number of lim
+00013980: 6974 6174 696f 6e73 3a0a 2020 2020 2d20  itations:.    - 
+00013990: 2020 4174 7472 6962 7574 6520 6e61 6d65    Attribute name
+000139a0: 7320 6361 6e20 6f6e 6c79 2062 6520 7570  s can only be up
+000139b0: 2074 6f20 3130 2063 6861 7261 6374 6572   to 10 character
+000139c0: 7320 6c6f 6e67 2e0a 2020 2020 2020 2020  s long..        
+000139d0: 5468 6520 4f47 5220 5368 6170 6566 696c  The OGR Shapefil
+000139e0: 6520 6472 6976 6572 2074 7269 6573 2074  e driver tries t
+000139f0: 6f20 6765 6e65 7261 7465 2075 6e69 7175  o generate uniqu
+00013a00: 6520 6669 656c 640a 2020 2020 2020 2020  e field.        
+00013a10: 6e61 6d65 732e 2053 7563 6365 7373 6976  names. Successiv
+00013a20: 6520 6475 706c 6963 6174 6520 6669 656c  e duplicate fiel
+00013a30: 6420 6e61 6d65 732c 2069 6e63 6c75 6469  d names, includi
+00013a40: 6e67 2074 686f 7365 2063 7265 6174 6564  ng those created
+00013a50: 2062 790a 2020 2020 2020 2020 7472 756e   by.        trun
+00013a60: 6361 7469 6f6e 2074 6f20 3130 2063 6861  cation to 10 cha
+00013a70: 7261 6374 6572 732c 2077 696c 6c20 6265  racters, will be
+00013a80: 2074 7275 6e63 6174 6564 2074 6f20 3820   truncated to 8 
+00013a90: 6368 6172 6163 7465 7273 2061 6e64 0a20  characters and. 
+00013aa0: 2020 2020 2020 2061 7070 656e 6465 6420         appended 
+00013ab0: 7769 7468 2061 2073 6572 6961 6c20 6e75  with a serial nu
+00013ac0: 6d62 6572 2066 726f 6d20 3120 746f 2039  mber from 1 to 9
+00013ad0: 392e 0a0a 2020 2020 2020 2020 466f 7220  9...        For 
+00013ae0: 6578 616d 706c 653a 0a0a 2020 2020 2020  example:..      
+00013af0: 2020 2d20 2061 20e2 8692 2061 2c20 6120    -  a ... a, a 
+00013b00: e286 9220 615f 312c 2041 20e2 8692 2041  ... a_1, A ... A
+00013b10: 5f32 3b0a 2020 2020 2020 2020 2d20 2061  _2;.        -  a
+00013b20: 6263 6465 6667 6869 6a6b 20e2 8692 2061  bcdefghijk ... a
+00013b30: 6263 6465 6667 6869 6a2c 2061 6263 6465  bcdefghij, abcde
+00013b40: 6667 6869 6a6b 6c20 e286 9220 6162 6364  fghijkl ... abcd
+00013b50: 6566 6768 5f31 0a0a 2020 2020 2d20 2020  efgh_1..    -   
+00013b60: 4f6e 6c79 2049 6e74 6567 6572 2c20 496e  Only Integer, In
+00013b70: 7465 6765 7236 342c 2052 6561 6c2c 2053  teger64, Real, S
+00013b80: 7472 696e 6720 616e 6420 4461 7465 2028  tring and Date (
+00013b90: 6e6f 7420 4461 7465 5469 6d65 2c20 6a75  not DateTime, ju
+00013ba0: 7374 0a20 2020 2020 2020 2079 6561 722f  st.        year/
+00013bb0: 6d6f 6e74 682f 6461 7929 2066 6965 6c64  month/day) field
+00013bc0: 2074 7970 6573 2061 7265 2073 7570 706f   types are suppo
+00013bd0: 7274 6564 2e20 5468 6520 7661 7269 6f75  rted. The variou
+00013be0: 7320 6c69 7374 2c20 616e 640a 2020 2020  s list, and.    
+00013bf0: 2020 2020 6269 6e61 7279 2066 6965 6c64      binary field
+00013c00: 2074 7970 6573 2063 616e 6e6f 7420 6265   types cannot be
+00013c10: 2063 7265 6174 6564 2e0a 2020 2020 2d20   created..    - 
+00013c20: 2020 5468 6520 6669 656c 6420 7769 6474    The field widt
+00013c30: 6820 616e 6420 7072 6563 6973 696f 6e20  h and precision 
+00013c40: 6172 6520 6469 7265 6374 6c79 2075 7365  are directly use
+00013c50: 6420 746f 2065 7374 6162 6c69 7368 2073  d to establish s
+00013c60: 746f 7261 6765 0a20 2020 2020 2020 2073  torage.        s
+00013c70: 697a 6520 696e 2074 6865 202e 6462 6620  ize in the .dbf 
+00013c80: 6669 6c65 2e20 5468 6973 206d 6561 6e73  file. This means
+00013c90: 2074 6861 7420 7374 7269 6e67 7320 6c6f   that strings lo
+00013ca0: 6e67 6572 2074 6861 6e20 7468 6520 6669  nger than the fi
+00013cb0: 656c 640a 2020 2020 2020 2020 7769 6474  eld.        widt
+00013cc0: 682c 206f 7220 6e75 6d62 6572 7320 7468  h, or numbers th
+00013cd0: 6174 2064 6f6e 2774 2066 6974 2069 6e74  at don't fit int
+00013ce0: 6f20 7468 6520 696e 6469 6361 7465 6420  o the indicated 
+00013cf0: 6669 656c 6420 666f 726d 6174 2077 696c  field format wil
+00013d00: 6c0a 2020 2020 2020 2020 7375 6666 6572  l.        suffer
+00013d10: 2074 7275 6e63 6174 696f 6e2e 0a20 2020   truncation..   
+00013d20: 202d 2020 2049 6e74 6567 6572 2066 6965   -   Integer fie
+00013d30: 6c64 7320 7769 7468 6f75 7420 616e 2065  lds without an e
+00013d40: 7870 6c69 6369 7420 7769 6474 6820 6172  xplicit width ar
+00013d50: 6520 7472 6561 7465 6420 6173 2077 6964  e treated as wid
+00013d60: 7468 2039 2c20 616e 640a 2020 2020 2020  th 9, and.      
+00013d70: 2020 6578 7465 6e64 6564 2074 6f20 3130    extended to 10
+00013d80: 206f 7220 3131 2069 6620 6e65 6564 6564   or 11 if needed
+00013d90: 2e0a 2020 2020 2d20 2020 496e 7465 6765  ..    -   Intege
+00013da0: 7236 3420 6669 656c 6473 2077 6974 686f  r64 fields witho
+00013db0: 7574 2061 6e20 6578 706c 6963 6974 2077  ut an explicit w
+00013dc0: 6964 7468 2061 7265 2074 7265 6174 6564  idth are treated
+00013dd0: 2061 7320 7769 6474 6820 3138 2c0a 2020   as width 18,.  
+00013de0: 2020 2020 2020 616e 6420 6578 7465 6e64        and extend
+00013df0: 6564 2074 6f20 3139 206f 7220 3230 2069  ed to 19 or 20 i
+00013e00: 6620 6e65 6564 6564 2e0a 2020 2020 2d20  f needed..    - 
+00013e10: 2020 5265 616c 2028 666c 6f61 7469 6e67    Real (floating
+00013e20: 2070 6f69 6e74 2920 6669 656c 6473 2077   point) fields w
+00013e30: 6974 686f 7574 2061 6e20 6578 706c 6963  ithout an explic
+00013e40: 6974 2077 6964 7468 2061 7265 2074 7265  it width are tre
+00013e50: 6174 6564 2061 730a 2020 2020 2020 2020  ated as.        
+00013e60: 7769 6474 6820 3234 2077 6974 6820 3135  width 24 with 15
+00013e70: 2064 6563 696d 616c 2070 6c61 6365 7320   decimal places 
+00013e80: 6f66 2070 7265 6369 7369 6f6e 2e0a 2020  of precision..  
+00013e90: 2020 2d20 2020 5374 7269 6e67 2066 6965    -   String fie
+00013ea0: 6c64 7320 7769 7468 6f75 7420 616e 2061  lds without an a
+00013eb0: 7373 6967 6e65 6420 7769 6474 6820 6172  ssigned width ar
+00013ec0: 6520 7472 6561 7465 6420 6173 2038 3020  e treated as 80 
+00013ed0: 6368 6172 6163 7465 7273 2e0a 0a20 2020  characters...   
+00013ee0: 2041 7267 733a 0a20 2020 2020 2020 2063   Args:.        c
+00013ef0: 6f6c 756d 6e73 2028 4974 6572 6162 6c65  olumns (Iterable
+00013f00: 293a 2074 6865 2063 6f6c 756d 6e73 2074  ): the columns t
+00013f10: 6f20 6c61 756e 6465 722e 0a0a 2020 2020  o launder...    
+00013f20: 5265 7475 726e 733a 2061 204c 6973 7420  Returns: a List 
+00013f30: 6f66 2074 7570 706c 6573 2077 6974 6820  of tupples with 
+00013f40: 7468 6520 6f72 6967 696e 616c 2061 6e64  the original and
+00013f50: 206c 6175 6e64 6572 6564 2063 6f6c 756d   laundered colum
+00013f60: 6e20 6e61 6d65 732e 0a20 2020 2022 2222  n names..    """
+00013f70: 0a20 2020 206c 6175 6e64 6572 6564 203d  .    laundered =
+00013f80: 205b 5d0a 2020 2020 6c61 756e 6465 7265   [].    laundere
+00013f90: 645f 7570 7065 7220 3d20 5b5d 0a20 2020  d_upper = [].   
+00013fa0: 2066 6f72 2063 6f6c 756d 6e20 696e 2063   for column in c
+00013fb0: 6f6c 756d 6e73 3a0a 2020 2020 2020 2020  olumns:.        
+00013fc0: 2320 446f 7562 6c65 7320 696e 2063 6173  # Doubles in cas
+00013fd0: 696e 6720 6172 6565 206e 6f74 2061 6c6c  ing aree not all
+00013fe0: 6f77 6564 2065 6974 6865 720a 2020 2020  owed either.    
+00013ff0: 2020 2020 6966 206c 656e 2863 6f6c 756d      if len(colum
+00014000: 6e29 203c 3d20 3130 3a0a 2020 2020 2020  n) <= 10:.      
+00014010: 2020 2020 2020 6966 2063 6f6c 756d 6e2e        if column.
+00014020: 7570 7065 7228 2920 6e6f 7420 696e 206c  upper() not in l
+00014030: 6175 6e64 6572 6564 5f75 7070 6572 3a0a  aundered_upper:.
+00014040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014050: 6c61 756e 6465 7265 645f 7570 7065 722e  laundered_upper.
+00014060: 6170 7065 6e64 2863 6f6c 756d 6e2e 7570  append(column.up
+00014070: 7065 7228 2929 0a20 2020 2020 2020 2020  per()).         
+00014080: 2020 2020 2020 206c 6175 6e64 6572 6564         laundered
+00014090: 2e61 7070 656e 6428 2863 6f6c 756d 6e2c  .append((column,
+000140a0: 2063 6f6c 756d 6e29 290a 2020 2020 2020   column)).      
+000140b0: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
+000140c0: 7565 0a0a 2020 2020 2020 2020 2320 4c61  ue..        # La
+000140d0: 756e 6465 7269 6e67 2069 7320 6e65 6564  undering is need
+000140e0: 6564 0a20 2020 2020 2020 2063 6f6c 756d  ed.        colum
+000140f0: 6e5f 6c61 756e 6465 7265 6420 3d20 636f  n_laundered = co
+00014100: 6c75 6d6e 5b3a 3130 5d0a 2020 2020 2020  lumn[:10].      
+00014110: 2020 6966 2063 6f6c 756d 6e5f 6c61 756e    if column_laun
+00014120: 6465 7265 642e 7570 7065 7228 2920 6e6f  dered.upper() no
+00014130: 7420 696e 206c 6175 6e64 6572 6564 5f75  t in laundered_u
+00014140: 7070 6572 3a0a 2020 2020 2020 2020 2020  pper:.          
+00014150: 2020 6c61 756e 6465 7265 645f 7570 7065    laundered_uppe
+00014160: 722e 6170 7065 6e64 2863 6f6c 756d 6e5f  r.append(column_
+00014170: 6c61 756e 6465 7265 642e 7570 7065 7228  laundered.upper(
+00014180: 2929 0a20 2020 2020 2020 2020 2020 206c  )).            l
+00014190: 6175 6e64 6572 6564 2e61 7070 656e 6428  aundered.append(
+000141a0: 2863 6f6c 756d 6e2c 2063 6f6c 756d 6e5f  (column, column_
+000141b0: 6c61 756e 6465 7265 6429 290a 2020 2020  laundered)).    
+000141c0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+000141d0: 2020 2020 2020 2320 4a75 7374 2074 616b        # Just tak
+000141e0: 696e 6720 6669 7273 7420 3130 2063 6861  ing first 10 cha
+000141f0: 7261 6374 6572 7320 6469 646e 2774 2068  racters didn't h
+00014200: 656c 700a 2020 2020 2020 2020 2020 2020  elp.            
+00014210: 666f 7220 696e 6465 7820 696e 2072 616e  for index in ran
+00014220: 6765 2831 2c20 3130 3129 3a0a 2020 2020  ge(1, 101):.    
+00014230: 2020 2020 2020 2020 2020 2020 6966 2069              if i
+00014240: 6e64 6578 203e 3d20 3130 303a 0a20 2020  ndex >= 100:.   
+00014250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014260: 2072 6169 7365 204e 6f74 496d 706c 656d   raise NotImplem
+00014270: 656e 7465 6445 7272 6f72 280a 2020 2020  entedError(.    
+00014280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014290: 2020 2020 224e 6f74 2073 7570 706f 7274      "Not support
+000142a0: 6564 2074 6f20 6c61 756e 6465 7220 3e20  ed to launder > 
+000142b0: 3939 2063 6f6c 756d 6e73 2073 7461 7274  99 columns start
+000142c0: 696e 6720 220a 2020 2020 2020 2020 2020  ing ".          
+000142d0: 2020 2020 2020 2020 2020 2020 2020 6622                f"
+000142e0: 7769 7468 207b 636f 6c75 6d6e 5f6c 6175  with {column_lau
+000142f0: 6e64 6572 6564 5b3a 385d 7d22 0a20 2020  ndered[:8]}".   
+00014300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014310: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+00014320: 2020 2069 6620 696e 6465 7820 3c3d 2039     if index <= 9
+00014330: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00014340: 2020 2020 2020 636f 6c75 6d6e 5f6c 6175        column_lau
+00014350: 6e64 6572 6564 203d 2066 227b 636f 6c75  ndered = f"{colu
+00014360: 6d6e 5f6c 6175 6e64 6572 6564 5b3a 385d  mn_laundered[:8]
+00014370: 7d5f 7b69 6e64 6578 7d22 0a20 2020 2020  }_{index}".     
+00014380: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00014390: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000143a0: 2020 2020 2063 6f6c 756d 6e5f 6c61 756e       column_laun
+000143b0: 6465 7265 6420 3d20 6622 7b63 6f6c 756d  dered = f"{colum
+000143c0: 6e5f 6c61 756e 6465 7265 645b 3a38 5d7d  n_laundered[:8]}
+000143d0: 7b69 6e64 6578 7d22 0a20 2020 2020 2020  {index}".       
+000143e0: 2020 2020 2020 2020 2069 6620 636f 6c75           if colu
+000143f0: 6d6e 5f6c 6175 6e64 6572 6564 2e75 7070  mn_laundered.upp
+00014400: 6572 2829 206e 6f74 2069 6e20 6c61 756e  er() not in laun
+00014410: 6465 7265 645f 7570 7065 723a 0a20 2020  dered_upper:.   
+00014420: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014430: 206c 6175 6e64 6572 6564 5f75 7070 6572   laundered_upper
+00014440: 2e61 7070 656e 6428 636f 6c75 6d6e 5f6c  .append(column_l
+00014450: 6175 6e64 6572 6564 2e75 7070 6572 2829  aundered.upper()
+00014460: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00014470: 2020 2020 2020 6c61 756e 6465 7265 642e        laundered.
+00014480: 6170 7065 6e64 2828 636f 6c75 6d6e 2c20  append((column, 
+00014490: 636f 6c75 6d6e 5f6c 6175 6e64 6572 6564  column_laundered
+000144a0: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+000144b0: 2020 2020 2020 2062 7265 616b 0a0a 2020         break..  
+000144c0: 2020 7265 7475 726e 206c 6175 6e64 6572    return launder
+000144d0: 6564 0a                                  ed.
```

### Comparing `geofileops-0.8.0a1/geofileops/geoops.py` & `geofileops-0.8.0a2/geofileops/geoops.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,2065 +1,2079 @@
-# -*- coding: utf-8 -*-
-"""
-Module exposing all supported operations on geomatries in geofiles.
-"""
-
-import logging
-import logging.config
-import os
-from pathlib import Path
-from typing import Any, Callable, List, Literal, Optional, Tuple, Union
-import warnings
-
-from geofileops.util import _geoops_gpd
-from geofileops.util import _geoops_sql
-from geofileops.util import _geoops_ogr
-from geofileops.util.geometry_util import (
-    BufferEndCapStyle,
-    BufferJoinStyle,
-    SimplifyAlgorithm,
-    GeometryType,
-)
-
-################################################################################
-# Some init
-################################################################################
-
-logger = logging.getLogger(__name__)
-
-################################################################################
-# Operations on a single layer
-################################################################################
-
-
-def apply(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    func: Callable[[Any], Any],
-    only_geom_input: bool = True,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Union[GeometryType, str, None] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Apply a python lambda function on the geometry column of the input file.
-
-    The result is written to the output file specified.
-
-    Examples for the func parameter:
-        * if only_geom_input is True:
-            ``func=lambda geom: geometry_util.remove_inner_rings(``
-                    ``geom, min_area_to_keep=1)``
-
-        * if only_geom_input is False:
-            ``func=lambda row: geometry_util.remove_inner_rings(``
-                    ``row.geometry, min_area_to_keep=1)``
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        func (Callable): lambda function to apply to the geometry column.
-        only_geom_input (bool, optional): If True, only the geometry
-            column is available. If False, the entire row is input.
-            Remark: when False, the operation is 50% slower. Defaults to True.
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        force_output_geometrytype (GeometryType, optional): The output geometry type to
-            force. If None, a best-effort guess is made and will always result in a
-            multi-type. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(f"Start apply on {input_path}")
-    return _geoops_gpd.apply(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        func=func,
-        only_geom_input=only_geom_input,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def buffer(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    distance: float,
-    quadrantsegments: int = 5,
-    endcap_style: BufferEndCapStyle = BufferEndCapStyle.ROUND,
-    join_style: BufferJoinStyle = BufferJoinStyle.ROUND,
-    mitre_limit: float = 5.0,
-    single_sided: bool = False,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Applies a buffer operation on geometry column of the input file.
-
-    The result is written to the output file specified.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        distance (float): the buffer size to apply. In projected coordinate
-            systems this is typically in meter, in geodetic systems this is
-            typically in degrees.
-        quadrantsegments (int): the number of points a quadrant needs to be
-            approximated with for rounded styles. Defaults to 5.
-        endcap_style (BufferEndCapStyle, optional): buffer style to use for a
-            point or the end points of a line. Defaults to ROUND.
-
-              * ROUND: for points and lines the ends are buffered rounded.
-              * FLAT: a point stays a point, a buffered line will end flat
-                at the end points
-              * SQUARE: a point becomes a square, a buffered line will end
-                flat at the end points, but elongated by "distance"
-        join_style (BufferJoinStyle, optional): buffer style to use for
-            corners in a line or a polygon boundary. Defaults to ROUND.
-
-              * ROUND: corners in the result are rounded
-              * MITRE: corners in the result are sharp
-              * BEVEL: are flattened
-        mitre_limit (float, optional): in case of join_style MITRE, if the
-            spiky result for a sharp angle becomes longer than this limit, it
-            is "beveled" at this distance. Defaults to 5.0.
-        single_sided (bool, optional): only one side of the line is buffered,
-            if distance is negative, the left side, if distance is positive,
-            the right hand side. Only relevant for line geometries.
-            Defaults to False.
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    **Buffer style options**
-
-    Using the different buffer style option parameters you can control how the
-    buffer is created:
-
-    - **quadrantsegments** *(int)*
-
-      .. list-table::
-         :header-rows: 1
-
-         * - 5 (default)
-           - 2
-           - 1
-         * - |buffer_quadrantsegm_5|
-           - |buffer_quadrantsegm_2|
-           - |buffer_quadrantsegm_1|
-
-    - **endcap_style** *(BufferEndCapStyle)*
-
-      .. list-table::
-         :header-rows: 1
-
-         * - ROUND (default)
-           - FLAT
-           - SQUARE
-         * - |buffer_endcap_round|
-           - |buffer_endcap_flat|
-           - |buffer_endcap_square|
-
-    - **join_style** *(BufferJoinStyle)*
-
-      .. list-table::
-         :header-rows: 1
-
-         * - ROUND (default)
-           - MITRE
-           - BEVEL
-         * - |buffer_joinstyle_round|
-           - |buffer_joinstyle_mitre|
-           - |buffer_joinstyle_bevel|
-
-    - **mitre** *(float)*
-
-      .. list-table::
-         :header-rows: 1
-
-         * - 5.0 (default)
-           - 2.5
-           - 1.0
-         * - |buffer_mitre_50|
-           - |buffer_mitre_25|
-           - |buffer_mitre_10|
-
-    .. |buffer_quadrantsegm_5| image:: ../_static/images/buffer_quadrantsegments_5.png
-        :alt: Buffer with quadrantsegments=5
-    .. |buffer_quadrantsegm_2| image:: ../_static/images/buffer_quadrantsegments_2.png
-        :alt: Buffer with quadrantsegments=2
-    .. |buffer_quadrantsegm_1| image:: ../_static/images/buffer_quadrantsegments_1.png
-        :alt: Buffer with quadrantsegments=1
-    .. |buffer_endcap_round| image:: ../_static/images/buffer_endcap_round.png
-        :alt: Buffer with endcap_style=BufferEndCapStyle.ROUND (default)
-    .. |buffer_endcap_flat| image:: ../_static/images/buffer_endcap_flat.png
-        :alt: Buffer with endcap_style=BufferEndCapStyle.FLAT
-    .. |buffer_endcap_square| image:: ../_static/images/buffer_endcap_square.png
-        :alt: Buffer with endcap_style=BufferEndCapStyle.SQUARE
-    .. |buffer_joinstyle_round| image:: ../_static/images/buffer_joinstyle_round.png
-        :alt: Buffer with joinstyle=BufferJoinStyle.ROUND (default)
-    .. |buffer_joinstyle_mitre| image:: ../_static/images/buffer_joinstyle_mitre.png
-        :alt: Buffer with joinstyle=BufferJoinStyle.MITRE
-    .. |buffer_joinstyle_bevel| image:: ../_static/images/buffer_joinstyle_bevel.png
-        :alt: Buffer with joinstyle=BufferJoinStyle.BEVEL
-    .. |buffer_mitre_50| image:: ../_static/images/buffer_mitre_50.png
-        :alt: Buffer with mitre=5.0
-    .. |buffer_mitre_25| image:: ../_static/images/buffer_mitre_25.png
-        :alt: Buffer with mitre=2.5
-    .. |buffer_mitre_10| image:: ../_static/images/buffer_mitre_10.png
-        :alt: Buffer with mitre=1.0
-
-    """
-    logger.info(
-        f"Start buffer on {input_path} "
-        f"(distance: {distance}, quadrantsegments: {quadrantsegments})"
-    )
-    if (
-        endcap_style == BufferEndCapStyle.ROUND
-        and join_style == BufferJoinStyle.ROUND
-        and single_sided is False
-    ):
-        # If default buffer options for spatialite, use the faster sql version
-        return _geoops_sql.buffer(
-            input_path=Path(input_path),
-            output_path=Path(output_path),
-            distance=distance,
-            quadrantsegments=quadrantsegments,
-            input_layer=input_layer,
-            output_layer=output_layer,
-            columns=columns,
-            explodecollections=explodecollections,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-        )
-    else:
-        # If special buffer options, use geopandas version
-        return _geoops_gpd.buffer(
-            input_path=Path(input_path),
-            output_path=Path(output_path),
-            distance=distance,
-            quadrantsegments=quadrantsegments,
-            endcap_style=endcap_style,
-            join_style=join_style,
-            mitre_limit=mitre_limit,
-            single_sided=single_sided,
-            input_layer=input_layer,
-            output_layer=output_layer,
-            columns=columns,
-            explodecollections=explodecollections,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-        )
-
-
-def clip_by_geometry(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    clip_geometry: Union[Tuple[float, float, float, float], str],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    """
-    Clip all geometries in the imput file by the geometry provided.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        clip_geometry (Union[Tuple[float, float, float, float], str]): the bounds
-            or WKT geometry to clip with.
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-       force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    return _geoops_ogr.clip_by_geometry(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        clip_geometry=clip_geometry,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force=force,
-    )
-
-
-def convexhull(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Applies a convexhull operation on the input file.
-
-    The result is written to the output file specified.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(f"Start convexhull on {input_path}")
-    return _geoops_sql.convexhull(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def delete_duplicate_geometries(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    """
-    Copy all rows to the output file, except for duplicate geometries.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(f"Start delete_duplicate_geometries on {input_path}")
-    return _geoops_sql.delete_duplicate_geometries(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force=force,
-    )
-
-
-def dissolve(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    explodecollections: bool,
-    groupby_columns: Union[List[str], str, None] = None,
-    agg_columns: Optional[dict] = None,
-    tiles_path: Union[str, "os.PathLike[Any]", None] = None,
-    nb_squarish_tiles: int = 1,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Applies a dissolve operation on the input file.
-
-    If columns are specified with ``groupby_columns``, the data is first grouped
-    on those columns before the geometries are merged.
-
-    Data in other columns can be retained in the output by specifying the
-    ``agg_columns`` parameter.
-
-    This is an example of how data in the columns that isn't grouped on can be
-    aggregated to be added to the output file:
-    ::
-
-        import geofileops as gfo
-
-        gfo.dissolve(
-            input_path=...,
-            output_path=...,
-            groupby_columns=["cropgroup"],
-            agg_columns={
-                "columns": [
-                    {"column": "crop", "agg": "max", "as": "crop_max"},
-                    {"column": "crop", "agg": "count", "as": "crop_count"},
-                    {
-                        "column": "crop",
-                        "agg": "concat",
-                        "distinct": True,
-                        "sep": ";",
-                        "as": "crop_concat",
-                    },
-                    {"column": "area", "agg": "mean", "as": "area_mean"},
-                ]
-            },
-            explodecollections=False,
-        )
-
-    The following example will save all detailed data for the columns
-    "crop_label" and "area" in the output file. The detailed data is encoded
-    per group/row in a "json" text field. Shapefiles only support up to 254
-    characters in a text field, so this format won't be very suited as output
-    format for this option.
-    ::
-
-        import geofileops as gfo
-
-        gfo.dissolve(
-            input_path=...,
-            output_path=...,
-            groupby_columns=["cropgroup"],
-            agg_columns={"json": ["crop", "area"]},
-            explodecollections=False,
-        )
-
-    This results in this type of output:
-    ::
-
-        cropgroup  json
-        Grasses    ["{"crop":"Meadow","area":1290,"fid_orig":5}","{"crop":"Pasture",...
-        Maize      ["{"crop":"Silo","area":3889.29,"fid_orig":2}","{"crop":"Fodder",...
-
-    If the output is tiled (by specifying ``tiles_path`` or ``nb_squarish_tiles`` > 1),
-    the result will be clipped on the output tiles and the tile borders are
-    never crossed.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        explodecollections (bool): True to output only simple geometries. If
-            False, this can result in huge geometries for large files,
-            especially if no groupby_columns are specified.
-        groupby_columns (Union[List[str], str], optional): columns (case insensitive) to
-            group on while aggregating. Defaults to None, resulting in a spatial union
-            of all geometries that touch.
-        agg_columns (dict, optional): columns to aggregate based on
-            the groupings by groupby columns. Depending on the top-level key
-            value of the dict, the output for the aggregation is different:
-
-                - "json": dump all data per group to one "json" column. The
-                  value can be None (= all columns) or a list of columns to include.
-                - "columns": aggregate to seperate columns. The value should
-                  be a list of dicts with the following keys:
-
-                    - "column": column name (case insensitive) in the input file. In
-                      addition to standard columns, it is also possible to specify
-                      "fid", a unique index available in all input files.
-                    - "agg": aggregation to use:
-
-                        - count: the number of items
-                        - sum:
-                        - mean
-                        - min
-                        - max
-                        - median
-                        - concat
-
-                    - "as": column name in the output file. Note: using "fid" as alias
-                      is not recommended: it can cause errors or odd behaviour.
-                    - "distinct" (optional): True to distinct the values before
-                      aggregation.
-
-        tiles_path (PathLike, optional): a path to a geofile containing tiles.
-            If specified, the output will be dissolved/unioned only within the
-            tiles provided.
-            Can be used to evade huge geometries being created if the input
-            geometries are very interconnected.
-            Defaults to None (= the output is not tiled).
-        nb_squarish_tiles (int, optional): the approximate number of tiles the
-            output should be dissolved/unioned to. If > 1, a tiling grid is
-            automatically created based on the total bounds of the input file.
-            The input geometries will be dissolved/unioned only within the
-            tiles generated.
-            Can be used to evade huge geometries being created if the input
-            geometries are very interconnected.
-            Defaults to 1 (= the output is not tiled).
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    # Init
-    if tiles_path is not None:
-        tiles_path = Path(tiles_path)
-
-    # Standardize parameter to simplify the rest of the code
-    if groupby_columns is not None:
-        if isinstance(groupby_columns, str):
-            # If a string is passed, convert to list
-            groupby_columns = [groupby_columns]
-        elif len(groupby_columns) == 0:
-            # If an empty list of geometry columns is passed, convert it to None
-            groupby_columns = None
-
-    logger.info(f"Start dissolve on {input_path} to {output_path}")
-    return _geoops_gpd.dissolve(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        explodecollections=explodecollections,
-        groupby_columns=groupby_columns,
-        agg_columns=agg_columns,
-        tiles_path=tiles_path,
-        nb_squarish_tiles=nb_squarish_tiles,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def export_by_bounds(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    bounds: Tuple[float, float, float, float],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    """
-    Export the rows that intersect with the bounds specified.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        bounds (Tuple[float, float, float, float]): the bounds to filter on.
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    return _geoops_ogr.export_by_bounds(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        bounds=bounds,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force=force,
-    )
-
-
-def isvalid(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]", None] = None,
-    only_invalid: bool = True,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    validate_attribute_data: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-) -> bool:
-    """
-    Checks for all geometries in the geofile if they are valid, and writes the
-    results to the output file
-
-    Args:
-        input_path (PathLike): The input file.
-        output_path (PathLike, optional): The output file path. If not
-            specified the result will be written in a new file alongside the
-            input file. Defaults to None.
-        only_invalid (bool, optional): if True, only put invalid results in the
-            output file. Deprecated: always treated as True.
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        validate_attribute_data (bool, optional): True to validate if all attribute data
-            can be read. Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    Returns:
-        bool: True if all geometries were valid.
-    """
-
-    # Check parameters
-    if output_path is not None:
-        output_path = Path(output_path)
-    else:
-        input_path = Path(input_path)
-        output_path = (
-            input_path.parent / f"{input_path.stem}_isvalid{input_path.suffix}"
-        )
-
-    # Go!
-    logger.info(f"Start isvalid on {input_path}")
-    return _geoops_sql.isvalid(
-        input_path=Path(input_path),
-        output_path=output_path,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        validate_attribute_data=validate_attribute_data,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def makevalid(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Optional[GeometryType] = None,
-    precision: Optional[float] = None,
-    validate_attribute_data: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Makes all geometries in the input file valid and writes the result to the
-    output path.
-
-    Alternative names:
-        - QGIS: fix geometries
-        - shapely: make_valid
-
-    Args:
-        input_path (PathLike): The input file.
-        output_path (PathLike): The file to write the result to.
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        force_output_geometrytype (GeometryType, optional): The output geometry type to
-            force. Defaults to None, and then the geometry type of the input is used
-        precision (float, optional): the precision to keep in the coordinates.
-            Eg. 0.001 to keep 3 decimals. None doesn't change the precision.
-            Defaults to None.
-        validate_attribute_data (bool, optional): True to validate if all attribute data
-            can be read. Raises an exception if an error is found, as this type of error
-            cannot be fixed using makevalid. Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-
-    logger.info(f"Start makevalid on {input_path}")
-    _geoops_sql.makevalid(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        precision=precision,
-        validate_attribute_data=validate_attribute_data,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def warp(
-    input_path: Path,
-    output_path: Path,
-    gcps: List[Tuple[float, float, float, float, Optional[float]]],
-    algorithm: str = "polynomial",
-    order: Optional[int] = None,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    """
-    Warp all input features to the output file according to the gcps specified.
-
-    Alternative names:
-        - rubbersheet, rubbersheeting
-
-    Args:
-        input_path (PathLike): The input file.
-        output_path (PathLike): The file to write the result to.
-        gcps (List[Tuple[float, float, float, float]]): ground control points to
-            use to warp the input geometries. This is a list of tuples like this:
-            [(x_orig, y_orig, x_dest, y_dest, elevation), ...].
-        algorithm (str, optional): algorithm to use to warp:
-            - "polynomial": use a polynomial transformation
-            - "tps": use a thin plate spline transformer
-            Defaults to "polynomial".
-        order (int, optional): if algorithm is "polynomial", the order of the
-            polynomial to use for warping.
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-
-    logger.info(f"Start warp on {input_path}")
-    _geoops_ogr.warp(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        gcps=gcps,
-        algorithm=algorithm,
-        order=order,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force=force,
-    )
-
-
-def select(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    sql_stmt: str,
-    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = "SQLITE",
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Union[GeometryType, str, None] = None,
-    nb_parallel: int = 1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Execute an SQL query on the file.
-
-    By convention, the sqlite query can contain following placeholders that
-    will be automatically replaced for you:
-
-      * {geometrycolumn}: the column where the primary geometry is stored.
-      * {columns_to_select_str}: if 'columns' is not None, those columns,
-        otherwise all columns of the layer.
-      * {input_layer}: the layer name of the input layer.
-      * {batch_filter}: the filter used to process in parallel per batch.
-
-    Example: Copy all rows with a certain minimum area to the output file.
-    ::
-
-        import geofileops as gfo
-
-        minimum_area = 100
-        sql_stmt = f'''
-                SELECT {{geometrycolumn}}
-                      {{columns_to_select_str}}
-                  FROM "{{input_layer}}" layer
-                 WHERE 1=1
-                   {{batch_filter}}
-                   AND ST_Area({{geometrycolumn}}) > {minimum_area}
-                '''
-        gfo.select(
-                input_path=...,
-                output_path=...,
-                sql_stmt=sql_stmt)
-
-    Some important remarks:
-
-    * Some sql statements won't give correct results when parallellized/ran in
-      multiple batches, e.g. when using a group by statement. This is why the default
-      value for nb_parallel is 1. If you want to parallellize or run the query in
-      multiple batches (by specifying nb_parallel != 1 or batchsize > 0), you should
-      make sure your query will give correct results if it is executed per batch of
-      rows instead of once on the entire layer.
-      Additionally, if you do so, make sure to include the placeholder {batch_filter}
-      in your sql_stmt. This placeholder will be replaced with a filter of the form
-      'AND rowid >= x AND rowid < y' and will ensure every row is only treated once.
-    * Table names are best double quoted as in the example, because some
-      characters are otherwise not supported in the table name, eg. '-'.
-    * It is recommend to give the table you select from "layer" as alias. If
-      you use the {batch_filter} placeholder this is even mandatory.
-    * When using the (default) "SQLITE" sql dialect, you can also use the spatialite
-      functions as documented here: |spatialite_reference_link|
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>  # noqa: E501
-
-    The result is written to the output file specified.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        sql_stmt (str): the statement to execute
-        sql_dialect (str, optional): the sql dialect to use. If None, the default sql
-            dialect of the underlying source is used. Defaults to "SQLITE".
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain, if
-            {columns_to_select_str} is used. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        force_output_geometrytype (GeometryType, optional): The output geometry type to
-            force. Defaults to None, and then the geometry type of the input is used
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to 1. If nb_parallel != 1, make sure your query still returns
-            correct results if it is executed per batch of rows instead of in one go
-            on the entire layer. To use all available cores, pass -1.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage. If batchsize != -1,
-            make sure your query still returns correct results if it is executed per
-            batch of rows instead of in one go on the entire layer.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s). Defaults to False.
-    """
-    logger.info(f"Start select on {input_path}")
-
-    # Convert force_output_geometrytype to GeometryType (if necessary)
-    if force_output_geometrytype is not None:
-        force_output_geometrytype = GeometryType(force_output_geometrytype)
-
-    return _geoops_sql.select(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        sql_stmt=sql_stmt,
-        sql_dialect=sql_dialect,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def simplify(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    tolerance: float,
-    algorithm: SimplifyAlgorithm = SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
-    lookahead: int = 8,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Applies a simplify operation on geometry column of the input file.
-
-    The result is written to the output file specified.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        tolerance (float): mandatory for the following algorithms:
-
-                * RAMER_DOUGLAS_PEUCKER: distance to use as tolerance.
-                * LANG: distance to use as tolerance.
-                * VISVALINGAM_WHYATT: area to use as tolerance.
-
-            In projected coordinate systems this tolerance will typically be
-            in meter, in geodetic systems this is typically in degrees.
-        algorithm (SimplifyAlgorithm, optional): algorithm to use.
-            Defaults to SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER.
-        lookahead (int, optional): used for LANG algorithm. Defaults to 8.
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(f"Start simplify on {input_path} with tolerance {tolerance}")
-    if algorithm == SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER:
-        return _geoops_sql.simplify(
-            input_path=Path(input_path),
-            output_path=Path(output_path),
-            tolerance=tolerance,
-            input_layer=input_layer,
-            output_layer=output_layer,
-            columns=columns,
-            explodecollections=explodecollections,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-        )
-    else:
-        return _geoops_gpd.simplify(
-            input_path=Path(input_path),
-            output_path=Path(output_path),
-            tolerance=tolerance,
-            algorithm=algorithm,
-            lookahead=lookahead,
-            input_layer=input_layer,
-            output_layer=output_layer,
-            columns=columns,
-            explodecollections=explodecollections,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-        )
-
-
-################################################################################
-# Operations on two layers
-################################################################################
-
-
-def clip(
-    input_path: Union[str, "os.PathLike[Any]"],
-    clip_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input_layer: Optional[str] = None,
-    input_columns: Optional[List[str]] = None,
-    clip_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Clip the input layer with the clip layer.
-
-    The resulting layer will contain the parts of the geometries in the
-    input layer that overlap with the dissolved geometries in the clip layer.
-
-    Clarifications:
-        - every row in the input layer will result in maximum one row in the
-          output layer.
-        - geometries in the input layer that overlap with multiple adjacent
-          geometries in the clip layer won't result in the input geometries
-          getting split.
-
-    This is the result you can expect when clipping a polygon layer (yellow)
-    with another polygon layer (purple):
-
-    .. list-table::
-       :header-rows: 1
-
-       * - Input
-         - Clip result
-       * - |clip_input|
-         - |clip_result|
-
-    Args:
-        input_path (PathLike): The file to clip.
-        clip_path (PathLike): The file with the geometries to clip with.
-        output_path (PathLike): the file to write the result to
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        input_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
-        clip_layer (str, optional): clip layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): output layer name. Optional if the
-            file only contains one layer.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |clip_input| image:: ../_static/images/clip_input.png
-        :alt: Clip input
-    .. |clip_result| image:: ../_static/images/clip_result.png
-        :alt: Clip result
-    """
-
-    logger.info(f"Start clip on {input_path} with {clip_path} to {output_path}")
-    return _geoops_sql.clip(
-        input_path=Path(input_path),
-        clip_path=Path(clip_path),
-        output_path=Path(output_path),
-        input_layer=input_layer,
-        input_columns=input_columns,
-        clip_layer=clip_layer,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def erase(
-    input_path: Union[str, "os.PathLike[Any]"],
-    erase_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input_layer: Optional[str] = None,
-    input_columns: Optional[List[str]] = None,
-    erase_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Erase all geometries in the erase layer from the input layer.
-
-    Clarifications:
-        - every row in the input layer will result in maximum one row in the
-          output layer.
-        - columns from the erase layer cannot be retained.
-
-    Alternative names:
-        - QGIS: difference
-
-    Args:
-        input_path (PathLike): The file to erase from.
-        erase_path (PathLike): The file with the geometries to erase with.
-        output_path (PathLike): the file to write the result to
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        input_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
-        erase_layer (str, optional): erase layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): output layer name. Optional if the
-            file only contains one layer.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-
-    logger.info(f"Start erase on {input_path} with {erase_path} to {output_path}")
-    return _geoops_sql.erase(
-        input_path=Path(input_path),
-        erase_path=Path(erase_path),
-        output_path=Path(output_path),
-        input_layer=input_layer,
-        input_columns=input_columns,
-        erase_layer=erase_layer,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def export_by_location(
-    input_to_select_from_path: Union[str, "os.PathLike[Any]"],
-    input_to_compare_with_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    min_area_intersect: Optional[float] = None,
-    area_inters_column_name: Optional[str] = "area_inters",
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input2_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Exports all features in input_to_select_from_path that intersect with any
-    features in input_to_compare_with_path.
-
-    Alternative names:
-        - QGIS: extract by location
-
-    Args:
-        input_to_select_from_path (PathLike): the 1st input file
-        input_to_compare_with_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        min_area_intersect (float, optional): minimum area of the intersection.
-            Defaults to None.
-        area_inters_column_name (str, optional): column name of the intersect
-            area. Defaults to 'area_inters'. In None, no area column is added.
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        input2_columns (List[str], optional): NA.
-        output_layer (str, optional): output layer name. Optional if the
-            file only contains one layer.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(
-        f"Start export_by_location: select from {input_to_select_from_path} "
-        f"interacting with {input_to_compare_with_path} to {output_path}"
-    )
-    return _geoops_sql.export_by_location(
-        input_path=Path(input_to_select_from_path),
-        input_to_compare_with_path=Path(input_to_compare_with_path),
-        output_path=Path(output_path),
-        min_area_intersect=min_area_intersect,
-        area_inters_column_name=area_inters_column_name,
-        input_layer=input1_layer,
-        input_columns=input1_columns,
-        input_to_compare_with_layer=input2_layer,
-        output_layer=output_layer,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def export_by_distance(
-    input_to_select_from_path: Union[str, "os.PathLike[Any]"],
-    input_to_compare_with_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    max_distance: float,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input2_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Exports all features in input_to_select_from_path that are within the
-    distance specified of any features in input_to_compare_with_path.
-
-    Args:
-        input_to_select_from_path (PathLike): the 1st input file
-        input_to_compare_with_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        max_distance (float): maximum distance
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): output layer name. Optional if the
-            file only contains one layer.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(
-        f"Start export_by_distance: select from {input_to_select_from_path} within "
-        f"max_distance of {max_distance} from {input_to_compare_with_path} "
-        f"to {output_path}"
-    )
-    return _geoops_sql.export_by_distance(
-        input_to_select_from_path=Path(input_to_select_from_path),
-        input_to_compare_with_path=Path(input_to_compare_with_path),
-        output_path=Path(output_path),
-        max_distance=max_distance,
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input2_layer=input2_layer,
-        output_layer=output_layer,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def intersect(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    warnings.warn(
-        "intersect() is deprecated because it was renamed intersection(). "
-        "Will be removed in a future version",
-        FutureWarning,
-    )
-    return intersection(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def intersection(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Calculate the pairwise intersection of alle features in input1 with all
-    features in input2.
-
-    Alternative names:
-        - GeoPandas: overlay(how="intersection")
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
-            "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for input1_columns, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2_".
-        output_layer (str, optional): output layer name. If None, the output_path stem
-            is used. Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(
-        f"Start intersection between {input1_path} and {input2_path} to {output_path}"
-    )
-    return _geoops_sql.intersection(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def join_by_location(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    spatial_relations_query: str = "intersects is True",
-    discard_nonmatching: bool = True,
-    min_area_intersect: Optional[float] = None,
-    area_inters_column_name: Optional[str] = None,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Joins all features in input1 with all features in input2.
-
-    The output will contain the geometries of input1. The spatial_relations_query and
-    min_area_intersect parameters will determine which geometries of input1 will be
-    matched with input2.
-
-    The spatial_relations_query is a filter string where you can use the following
-    "named spatial predicates": equals, touches, within, overlaps, crosses, intersects,
-    contains, covers, coveredby.
-
-    If you want even more control, you can also use "spatial masks" as defined by the
-    [DE-9IM](https://en.wikipedia.org/wiki/DE-9IM) model.
-
-    Examples for valid spatial_relations_query values:
-
-        - "overlaps is True and contains is False"
-        - "(T*T***T** is True or 1*T***T** is True) and T*****FF* is False"
-
-
-    Alternative names:
-        - GeoPandas: sjoin
-        - ArcGIS: spatial join
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        spatial_relations_query (str, optional): a query that specifies the
-            spatial relations to match between the 2 layers.
-            Defaults to "intersects is True".
-        discard_nonmatching (bool, optional): True to only keep rows that
-            match with the spatial_relations_query. False to keep rows all
-            rows in the input1_layer (=left outer join). Defaults to True
-            (=inner join).
-        min_area_intersect (float, optional): minimum area of the intersection
-            to match. Defaults to None.
-        area_inters_column_name (str, optional): column name of the intersect
-            area. If None no area column is added. Defaults to None.
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
-            "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for input1_columns, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2_".
-        output_layer (str, optional): output layer name. If None, the output_path stem
-            is used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(
-        f"Start join_by_location: select from {input1_path} joined with "
-        f"{input2_path} to {output_path}"
-    )
-    return _geoops_sql.join_by_location(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        spatial_relations_query=spatial_relations_query,
-        discard_nonmatching=discard_nonmatching,
-        min_area_intersect=min_area_intersect,
-        area_inters_column_name=area_inters_column_name,
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=False,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def join_nearest(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    nb_nearest: int,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Joins features in input1 with the nb_nearest features that are closest to
-    them in input2.
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        nb_nearest (int): the number of nearest features from input 2 to join
-            to input1.
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
-            "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for input1_columns, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2_".
-        output_layer (str, optional): output layer name. If None, the output_path stem
-            is used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(
-        f"Start join_nearest: select from {input1_path} joined with "
-        f"{input2_path} to {output_path}"
-    )
-    return _geoops_sql.join_nearest(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        nb_nearest=nb_nearest,
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=False,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def select_two_layers(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    sql_stmt: str,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Optional[GeometryType] = None,
-    nb_parallel: int = 1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Executes the sqlite query specified on the 2 input layers specified.
-
-    By convention, the sqlite query can contain following placeholders that
-    will be automatically replaced for you:
-
-      * {input1_layer}: name of input layer 1
-      * {input1_geometrycolumn}: name of input geometry column 1
-      * {layer1_columns_prefix_str}: komma seperated columns of
-        layer 1, prefixed with "layer1"
-      * {layer1_columns_prefix_alias_str}: komma seperated columns of
-        layer 1, prefixed with "layer1" and with column name aliases
-      * {layer1_columns_from_subselect_str}: komma seperated columns of
-        layer 1, prefixed with "sub"
-      * {input1_databasename}: the database alias for input 1
-      * {input2_layer}: name of input layer 1
-      * {input2_geometrycolumn}: name of input geometry column 2
-      * {layer2_columns_prefix_str}: komma seperated columns of
-        layer 2, prefixed with "layer2"
-      * {layer2_columns_prefix_alias_str}: komma seperated columns of
-        layer 2, prefixed with "layer2" and with column name aliases
-      * {layer2_columns_from_subselect_str}: komma seperated columns of
-        layer 2, prefixed with "sub"
-      * {layer2_columns_prefix_alias_null_str}: komma seperated columns of
-        layer 2, but with NULL for all values and with column aliases
-      * {input2_databasename}: the database alias for input 2
-      * {batch_filter}: the filter to be applied per batch when using
-        parallel processing
-
-    Example: left outer join all features in input1 layer with all rows
-    in input2 on join_id.
-    ::
-
-        import geofileops as gfo
-
-        minimum_area = 100
-        sql_stmt = f'''
-                SELECT layer1.{{input1_geometrycolumn}}
-                      {{layer1_columns_prefix_alias_str}}
-                      {{layer2_columns_prefix_alias_str}}
-                  FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                  LEFT OUTER JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                    ON layer1.join_id = layer2.join_id
-                 WHERE 1=1
-                   {{batch_filter}}
-                   AND ST_Area(layer1.{{input1_geometrycolumn}}) > {minimum_area}
-                '''
-        gfo.select_two_layers(
-                input1_path=...,
-                input2_path=...,
-                output_path=...,
-                sql_stmt=sql_stmt)
-
-    Some important remarks:
-
-    * Because some sql statement won't give the same result when parallellized
-      (eg. when using a group by statement), nb_parallel is 1 by default.
-      If you do want to use parallel processing, specify nb_parallel + make
-      sure to include the placeholder {batch_filter} in your sql_stmt.
-      This placeholder will be replaced with a filter of the form
-      'AND rowid >= x AND rowid < y'.
-    * Table names are best double quoted as in the example, because some
-      characters are otherwise not supported in the table name, eg. '-'.
-    * When using supported placeholders, make sure you give the tables you
-      select from the appropriate table aliases (layer1, layer2).
-    * Besides the standard sqlite sql syntacs, you can use the spatialite
-      functions as documented here: |sqlite_reference_link|
-
-    .. |sqlite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>  # noqa: E501
-
-    The result is written to the output file specified.
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain if one of the
-            {layer1_columns_...} placeholders is used in sql_stmt. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
-            "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): list of columns to retain if one of the
-            {layer2_columns_...} placeholders is used in sql_stmt. If None is specified,
-            all columns are selected. As explained for input1_columns, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2_".
-        output_layer (str, optional): output layer name. If None, the output_path stem
-            is used. Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        force_output_geometrytype (GeometryType, optional): The output geometry
-            type to force. Defaults to None, and then the geometry type of the
-            input1 layer is used.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    **Some more advanced example queries**
-
-    An ideal place to get inspiration to write you own advanced queries
-    is in the following source code file: |geofileops_sql_link|.
-
-    Additionally, there are some examples listed here that highlight
-    other features/possibilities.
-
-    .. |geofileops_sql_link| raw:: html
-
-        <a href="https://github.com/geofileops/geofileops/blob/main/geofileops/util/geofileops_sql.py" target="_blank">geofileops_sql.py</a>
-
-    *Join nearest features*
-
-    For each feature in layer1, get the nearest feature of layer2 with the
-    same values for the column join_id.
-
-        .. code-block:: sqlite3
-
-            WITH join_with_dist AS (
-                SELECT layer2.{{input2_geometrycolumn}}
-                      {{layer1_columns_prefix_alias_str}}
-                      {{layer2_columns_prefix_alias_str}}
-                      ,ST_Distance(layer2.{{input2_geometrycolumn}}
-                      ,layer1.{{input1_geometrycolumn}}) AS distance
-                 FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                 JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                   ON layer1.join_id = layer2.join_id
-                )
-            SELECT *
-              FROM join_with_dist jwd
-             WHERE distance = (
-                   SELECT MIN(distance) FROM join_with_dist jwd_sub
-                    WHERE jwd_sub.l1_join_id = jwd.l1_join_id)
-             ORDER BY distance DESC
-    """
-    logger.info(
-        f"Start select_two_layers: select from {input1_path} and {input2_path} "
-        f"to {output_path}"
-    )
-    return _geoops_sql.select_two_layers(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        sql_stmt=sql_stmt,
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def symmetric_difference(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Calculates the "symmetric difference" of the two input layers.
-
-    Alternative names:
-        - GeoPandas: overlay(how="symmetric_difference")
-        - QGIS, ArcMap: symmetrical difference
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
-            "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for input1_columns, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2_".
-        output_layer (str, optional): output layer name. If None, the output_path stem
-            is used. Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduc
-            e the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(
-        f"Start symmetric_difference of {input1_path} and {input2_path} "
-        f"to {output_path}"
-    )
-    return _geoops_sql.symmetric_difference(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def split(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Split the features in input1 with all features in input2.
-
-    The result is the equivalent of an intersect between the two layers + layer
-    1 erased with layer 2.
-
-    Alternative names:
-        - ArcMap, SAGA: identity
-        - GeoPandas: overlay(how="identity")
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
-            "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for input1_columns, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2_".
-        output_layer (str, optional): output layer name. If None, the output_path stem
-            is used. Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(f"Start split between {input1_path} and {input2_path} to {output_path}")
-    return _geoops_sql.split(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def union(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Calculates the pairwise "union" of the two input layers.
-
-    Alternative names:
-        - GeoPandas: overlay(how="union")
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
-            "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for input1_columns, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2_".
-        output_layer (str, optional): output layer name. If None, the output_path stem
-            is used. Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available processors.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger.info(
-        f"Start union: select from {input1_path} and {input2_path} to {output_path}"
-    )
-    return _geoops_sql.union(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
+# -*- coding: utf-8 -*-
+"""
+Module exposing all supported operations on geomatries in geofiles.
+"""
+
+import logging
+import logging.config
+import os
+from pathlib import Path
+from typing import Any, Callable, List, Literal, Optional, Tuple, Union
+import warnings
+
+from geofileops.util import _geoops_gpd
+from geofileops.util import _geoops_sql
+from geofileops.util import _geoops_ogr
+from geofileops.util.geometry_util import (
+    BufferEndCapStyle,
+    BufferJoinStyle,
+    SimplifyAlgorithm,
+    GeometryType,
+)
+
+################################################################################
+# Some init
+################################################################################
+
+logger = logging.getLogger(__name__)
+
+################################################################################
+# Operations on a single layer
+################################################################################
+
+
+def apply(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    func: Callable[[Any], Any],
+    only_geom_input: bool = True,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Union[GeometryType, str, None] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Apply a python lambda function on the geometry column of the input file.
+
+    The result is written to the output file specified.
+
+    Examples for the func parameter:
+        * if only_geom_input is True:
+            ``func=lambda geom: geometry_util.remove_inner_rings(``
+                    ``geom, min_area_to_keep=1)``
+
+        * if only_geom_input is False:
+            ``func=lambda row: geometry_util.remove_inner_rings(``
+                    ``row.geometry, min_area_to_keep=1)``
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        func (Callable): lambda function to apply to the geometry column.
+        only_geom_input (bool, optional): If True, only the geometry
+            column is available. If False, the entire row is input.
+            Remark: when False, the operation is 50% slower. Defaults to True.
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        force_output_geometrytype (GeometryType, optional): The output geometry type to
+            force. If None, a best-effort guess is made and will always result in a
+            multi-type. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(f"Start apply on {input_path}")
+    return _geoops_gpd.apply(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        func=func,
+        only_geom_input=only_geom_input,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def buffer(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    distance: float,
+    quadrantsegments: int = 5,
+    endcap_style: BufferEndCapStyle = BufferEndCapStyle.ROUND,
+    join_style: BufferJoinStyle = BufferJoinStyle.ROUND,
+    mitre_limit: float = 5.0,
+    single_sided: bool = False,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Applies a buffer operation on geometry column of the input file.
+
+    The result is written to the output file specified.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        distance (float): the buffer size to apply. In projected coordinate
+            systems this is typically in meter, in geodetic systems this is
+            typically in degrees.
+        quadrantsegments (int): the number of points a quadrant needs to be
+            approximated with for rounded styles. Defaults to 5.
+        endcap_style (BufferEndCapStyle, optional): buffer style to use for a
+            point or the end points of a line. Defaults to ROUND.
+
+              * ROUND: for points and lines the ends are buffered rounded.
+              * FLAT: a point stays a point, a buffered line will end flat
+                at the end points
+              * SQUARE: a point becomes a square, a buffered line will end
+                flat at the end points, but elongated by "distance"
+        join_style (BufferJoinStyle, optional): buffer style to use for
+            corners in a line or a polygon boundary. Defaults to ROUND.
+
+              * ROUND: corners in the result are rounded
+              * MITRE: corners in the result are sharp
+              * BEVEL: are flattened
+        mitre_limit (float, optional): in case of join_style MITRE, if the
+            spiky result for a sharp angle becomes longer than this limit, it
+            is "beveled" at this distance. Defaults to 5.0.
+        single_sided (bool, optional): only one side of the line is buffered,
+            if distance is negative, the left side, if distance is positive,
+            the right hand side. Only relevant for line geometries.
+            Defaults to False.
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    **Buffer style options**
+
+    Using the different buffer style option parameters you can control how the
+    buffer is created:
+
+    - **quadrantsegments** *(int)*
+
+      .. list-table::
+         :header-rows: 1
+
+         * - 5 (default)
+           - 2
+           - 1
+         * - |buffer_quadrantsegm_5|
+           - |buffer_quadrantsegm_2|
+           - |buffer_quadrantsegm_1|
+
+    - **endcap_style** *(BufferEndCapStyle)*
+
+      .. list-table::
+         :header-rows: 1
+
+         * - ROUND (default)
+           - FLAT
+           - SQUARE
+         * - |buffer_endcap_round|
+           - |buffer_endcap_flat|
+           - |buffer_endcap_square|
+
+    - **join_style** *(BufferJoinStyle)*
+
+      .. list-table::
+         :header-rows: 1
+
+         * - ROUND (default)
+           - MITRE
+           - BEVEL
+         * - |buffer_joinstyle_round|
+           - |buffer_joinstyle_mitre|
+           - |buffer_joinstyle_bevel|
+
+    - **mitre** *(float)*
+
+      .. list-table::
+         :header-rows: 1
+
+         * - 5.0 (default)
+           - 2.5
+           - 1.0
+         * - |buffer_mitre_50|
+           - |buffer_mitre_25|
+           - |buffer_mitre_10|
+
+    .. |buffer_quadrantsegm_5| image:: ../_static/images/buffer_quadrantsegments_5.png
+        :alt: Buffer with quadrantsegments=5
+    .. |buffer_quadrantsegm_2| image:: ../_static/images/buffer_quadrantsegments_2.png
+        :alt: Buffer with quadrantsegments=2
+    .. |buffer_quadrantsegm_1| image:: ../_static/images/buffer_quadrantsegments_1.png
+        :alt: Buffer with quadrantsegments=1
+    .. |buffer_endcap_round| image:: ../_static/images/buffer_endcap_round.png
+        :alt: Buffer with endcap_style=BufferEndCapStyle.ROUND (default)
+    .. |buffer_endcap_flat| image:: ../_static/images/buffer_endcap_flat.png
+        :alt: Buffer with endcap_style=BufferEndCapStyle.FLAT
+    .. |buffer_endcap_square| image:: ../_static/images/buffer_endcap_square.png
+        :alt: Buffer with endcap_style=BufferEndCapStyle.SQUARE
+    .. |buffer_joinstyle_round| image:: ../_static/images/buffer_joinstyle_round.png
+        :alt: Buffer with joinstyle=BufferJoinStyle.ROUND (default)
+    .. |buffer_joinstyle_mitre| image:: ../_static/images/buffer_joinstyle_mitre.png
+        :alt: Buffer with joinstyle=BufferJoinStyle.MITRE
+    .. |buffer_joinstyle_bevel| image:: ../_static/images/buffer_joinstyle_bevel.png
+        :alt: Buffer with joinstyle=BufferJoinStyle.BEVEL
+    .. |buffer_mitre_50| image:: ../_static/images/buffer_mitre_50.png
+        :alt: Buffer with mitre=5.0
+    .. |buffer_mitre_25| image:: ../_static/images/buffer_mitre_25.png
+        :alt: Buffer with mitre=2.5
+    .. |buffer_mitre_10| image:: ../_static/images/buffer_mitre_10.png
+        :alt: Buffer with mitre=1.0
+
+    """
+    logger.info(
+        f"Start buffer on {input_path} "
+        f"(distance: {distance}, quadrantsegments: {quadrantsegments})"
+    )
+    if (
+        endcap_style == BufferEndCapStyle.ROUND
+        and join_style == BufferJoinStyle.ROUND
+        and single_sided is False
+    ):
+        # If default buffer options for spatialite, use the faster sql version
+        return _geoops_sql.buffer(
+            input_path=Path(input_path),
+            output_path=Path(output_path),
+            distance=distance,
+            quadrantsegments=quadrantsegments,
+            input_layer=input_layer,
+            output_layer=output_layer,
+            columns=columns,
+            explodecollections=explodecollections,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+        )
+    else:
+        # If special buffer options, use geopandas version
+        return _geoops_gpd.buffer(
+            input_path=Path(input_path),
+            output_path=Path(output_path),
+            distance=distance,
+            quadrantsegments=quadrantsegments,
+            endcap_style=endcap_style,
+            join_style=join_style,
+            mitre_limit=mitre_limit,
+            single_sided=single_sided,
+            input_layer=input_layer,
+            output_layer=output_layer,
+            columns=columns,
+            explodecollections=explodecollections,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+        )
+
+
+def clip_by_geometry(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    clip_geometry: Union[Tuple[float, float, float, float], str],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    """
+    Clip all geometries in the imput file by the geometry provided.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        clip_geometry (Union[Tuple[float, float, float, float], str]): the bounds
+            or WKT geometry to clip with.
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+       force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    return _geoops_ogr.clip_by_geometry(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        clip_geometry=clip_geometry,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force=force,
+    )
+
+
+def convexhull(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Applies a convexhull operation on the input file.
+
+    The result is written to the output file specified.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(f"Start convexhull on {input_path}")
+    return _geoops_sql.convexhull(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def delete_duplicate_geometries(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    """
+    Copy all rows to the output file, except for duplicate geometries.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(f"Start delete_duplicate_geometries on {input_path}")
+    return _geoops_sql.delete_duplicate_geometries(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force=force,
+    )
+
+
+def dissolve(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    explodecollections: bool,
+    groupby_columns: Union[List[str], str, None] = None,
+    agg_columns: Optional[dict] = None,
+    tiles_path: Union[str, "os.PathLike[Any]", None] = None,
+    nb_squarish_tiles: int = 1,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Applies a dissolve operation on the input file.
+
+    If columns are specified with ``groupby_columns``, the data is first grouped
+    on those columns before the geometries are merged.
+
+    Data in other columns can be retained in the output by specifying the
+    ``agg_columns`` parameter.
+
+    This is an example of how data in the columns that isn't grouped on can be
+    aggregated to be added to the output file:
+    ::
+
+        import geofileops as gfo
+
+        gfo.dissolve(
+            input_path=...,
+            output_path=...,
+            groupby_columns=["cropgroup"],
+            agg_columns={
+                "columns": [
+                    {"column": "crop", "agg": "max", "as": "crop_max"},
+                    {"column": "crop", "agg": "count", "as": "crop_count"},
+                    {
+                        "column": "crop",
+                        "agg": "concat",
+                        "distinct": True,
+                        "sep": ";",
+                        "as": "crop_concat",
+                    },
+                    {"column": "area", "agg": "mean", "as": "area_mean"},
+                ]
+            },
+            explodecollections=False,
+        )
+
+    The following example will save all detailed data for the columns
+    "crop_label" and "area" in the output file. The detailed data is encoded
+    per group/row in a "json" text field. Shapefiles only support up to 254
+    characters in a text field, so this format won't be very suited as output
+    format for this option.
+    ::
+
+        import geofileops as gfo
+
+        gfo.dissolve(
+            input_path=...,
+            output_path=...,
+            groupby_columns=["cropgroup"],
+            agg_columns={"json": ["crop", "area"]},
+            explodecollections=False,
+        )
+
+    This results in this type of output:
+    ::
+
+        cropgroup  json
+        Grasses    ["{"crop":"Meadow","area":1290,"fid_orig":5}","{"crop":"Pasture",...
+        Maize      ["{"crop":"Silo","area":3889.29,"fid_orig":2}","{"crop":"Fodder",...
+
+    If the output is tiled (by specifying ``tiles_path`` or ``nb_squarish_tiles`` > 1),
+    the result will be clipped on the output tiles and the tile borders are
+    never crossed.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        explodecollections (bool): True to output only simple geometries. If
+            False, this can result in huge geometries for large files,
+            especially if no groupby_columns are specified.
+        groupby_columns (Union[List[str], str], optional): columns (case insensitive) to
+            group on while aggregating. Defaults to None, resulting in a spatial union
+            of all geometries that touch.
+        agg_columns (dict, optional): columns to aggregate based on
+            the groupings by groupby columns. Depending on the top-level key
+            value of the dict, the output for the aggregation is different:
+
+                - "json": dump all data per group to one "json" column. The
+                  value can be None (= all columns) or a list of columns to include.
+                - "columns": aggregate to seperate columns. The value should
+                  be a list of dicts with the following keys:
+
+                    - "column": column name (case insensitive) in the input file. In
+                      addition to standard columns, it is also possible to specify
+                      "fid", a unique index available in all input files.
+                    - "agg": aggregation to use:
+
+                        - count: the number of items
+                        - sum:
+                        - mean
+                        - min
+                        - max
+                        - median
+                        - concat
+
+                    - "as": column name in the output file. Note: using "fid" as alias
+                      is not recommended: it can cause errors or odd behaviour.
+                    - "distinct" (optional): True to distinct the values before
+                      aggregation.
+
+        tiles_path (PathLike, optional): a path to a geofile containing tiles.
+            If specified, the output will be dissolved/unioned only within the
+            tiles provided.
+            Can be used to evade huge geometries being created if the input
+            geometries are very interconnected.
+            Defaults to None (= the output is not tiled).
+        nb_squarish_tiles (int, optional): the approximate number of tiles the
+            output should be dissolved/unioned to. If > 1, a tiling grid is
+            automatically created based on the total bounds of the input file.
+            The input geometries will be dissolved/unioned only within the
+            tiles generated.
+            Can be used to evade huge geometries being created if the input
+            geometries are very interconnected.
+            Defaults to 1 (= the output is not tiled).
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    # Init
+    if tiles_path is not None:
+        tiles_path = Path(tiles_path)
+
+    # Standardize parameter to simplify the rest of the code
+    if groupby_columns is not None:
+        if isinstance(groupby_columns, str):
+            # If a string is passed, convert to list
+            groupby_columns = [groupby_columns]
+        elif len(groupby_columns) == 0:
+            # If an empty list of geometry columns is passed, convert it to None
+            groupby_columns = None
+
+    logger.info(f"Start dissolve on {input_path} to {output_path}")
+    return _geoops_gpd.dissolve(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        explodecollections=explodecollections,
+        groupby_columns=groupby_columns,
+        agg_columns=agg_columns,
+        tiles_path=tiles_path,
+        nb_squarish_tiles=nb_squarish_tiles,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def export_by_bounds(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    bounds: Tuple[float, float, float, float],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    """
+    Export the rows that intersect with the bounds specified.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        bounds (Tuple[float, float, float, float]): the bounds to filter on.
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    return _geoops_ogr.export_by_bounds(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        bounds=bounds,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force=force,
+    )
+
+
+def isvalid(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]", None] = None,
+    only_invalid: bool = True,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    validate_attribute_data: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+) -> bool:
+    """
+    Checks for all geometries in the geofile if they are valid, and writes the
+    results to the output file
+
+    Args:
+        input_path (PathLike): The input file.
+        output_path (PathLike, optional): The output file path. If not
+            specified the result will be written in a new file alongside the
+            input file. Defaults to None.
+        only_invalid (bool, optional): if True, only put invalid results in the
+            output file. Deprecated: always treated as True.
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        validate_attribute_data (bool, optional): True to validate if all attribute data
+            can be read. Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    Returns:
+        bool: True if all geometries were valid.
+    """
+
+    # Check parameters
+    if output_path is not None:
+        output_path = Path(output_path)
+    else:
+        input_path = Path(input_path)
+        output_path = (
+            input_path.parent / f"{input_path.stem}_isvalid{input_path.suffix}"
+        )
+
+    # Go!
+    logger.info(f"Start isvalid on {input_path}")
+    return _geoops_sql.isvalid(
+        input_path=Path(input_path),
+        output_path=output_path,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        validate_attribute_data=validate_attribute_data,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def makevalid(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Optional[GeometryType] = None,
+    gridsize: Optional[float] = None,
+    precision: Optional[float] = None,
+    validate_attribute_data: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Makes all geometries in the input file valid and writes the result to the
+    output path.
+
+    Alternative names:
+        - QGIS: fix geometries
+        - shapely: make_valid
+
+    Args:
+        input_path (PathLike): The input file.
+        output_path (PathLike): The file to write the result to.
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        force_output_geometrytype (GeometryType, optional): The output geometry type to
+            force the output to. If None, the geometry type of the input is used.
+            Defaults to None.
+        gridsize (float, optional): the size of the grid the coordinates will be rounded
+            to. Eg. 0.001 to keep 3 decimals. None doesn't change the precision.
+            Defaults to None.
+        validate_attribute_data (bool, optional): True to validate if all attribute data
+            can be read. Raises an exception if an error is found, as this type of error
+            cannot be fixed using makevalid. Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+
+    logger.info(f"Start makevalid on {input_path}")
+    if precision is not None and gridsize is not None:
+        raise ValueError(
+            "the precision parameter is deprecated and cannot be combined with gridsize"
+        )
+    if precision is not None:
+        gridsize = precision
+        warnings.warn(
+            "the precision parameter is deprecated and will be removed in a future "
+            "version: please use gridsize",
+            FutureWarning,
+        )
+
+    _geoops_sql.makevalid(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        gridsize=gridsize,
+        validate_attribute_data=validate_attribute_data,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def warp(
+    input_path: Path,
+    output_path: Path,
+    gcps: List[Tuple[float, float, float, float, Optional[float]]],
+    algorithm: str = "polynomial",
+    order: Optional[int] = None,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    """
+    Warp all input features to the output file according to the gcps specified.
+
+    Alternative names:
+        - rubbersheet, rubbersheeting
+
+    Args:
+        input_path (PathLike): The input file.
+        output_path (PathLike): The file to write the result to.
+        gcps (List[Tuple[float, float, float, float]]): ground control points to
+            use to warp the input geometries. This is a list of tuples like this:
+            [(x_orig, y_orig, x_dest, y_dest, elevation), ...].
+        algorithm (str, optional): algorithm to use to warp:
+            - "polynomial": use a polynomial transformation
+            - "tps": use a thin plate spline transformer
+            Defaults to "polynomial".
+        order (int, optional): if algorithm is "polynomial", the order of the
+            polynomial to use for warping.
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+
+    logger.info(f"Start warp on {input_path}")
+    _geoops_ogr.warp(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        gcps=gcps,
+        algorithm=algorithm,
+        order=order,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force=force,
+    )
+
+
+def select(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    sql_stmt: str,
+    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = "SQLITE",
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Union[GeometryType, str, None] = None,
+    nb_parallel: int = 1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Execute an SQL query on the file.
+
+    By convention, the sqlite query can contain following placeholders that
+    will be automatically replaced for you:
+
+      * {geometrycolumn}: the column where the primary geometry is stored.
+      * {columns_to_select_str}: if 'columns' is not None, those columns,
+        otherwise all columns of the layer.
+      * {input_layer}: the layer name of the input layer.
+      * {batch_filter}: the filter used to process in parallel per batch.
+
+    Example: Copy all rows with a certain minimum area to the output file.
+    ::
+
+        import geofileops as gfo
+
+        minimum_area = 100
+        sql_stmt = f'''
+                SELECT {{geometrycolumn}}
+                      {{columns_to_select_str}}
+                  FROM "{{input_layer}}" layer
+                 WHERE 1=1
+                   {{batch_filter}}
+                   AND ST_Area({{geometrycolumn}}) > {minimum_area}
+                '''
+        gfo.select(
+                input_path=...,
+                output_path=...,
+                sql_stmt=sql_stmt)
+
+    Some important remarks:
+
+    * Some sql statements won't give correct results when parallellized/ran in
+      multiple batches, e.g. when using a group by statement. This is why the default
+      value for nb_parallel is 1. If you want to parallellize or run the query in
+      multiple batches (by specifying nb_parallel != 1 or batchsize > 0), you should
+      make sure your query will give correct results if it is executed per batch of
+      rows instead of once on the entire layer.
+      Additionally, if you do so, make sure to include the placeholder {batch_filter}
+      in your sql_stmt. This placeholder will be replaced with a filter of the form
+      'AND rowid >= x AND rowid < y' and will ensure every row is only treated once.
+    * Table names are best double quoted as in the example, because some
+      characters are otherwise not supported in the table name, eg. '-'.
+    * It is recommend to give the table you select from "layer" as alias. If
+      you use the {batch_filter} placeholder this is even mandatory.
+    * When using the (default) "SQLITE" sql dialect, you can also use the spatialite
+      functions as documented here: |spatialite_reference_link|
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>  # noqa: E501
+
+    The result is written to the output file specified.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        sql_stmt (str): the statement to execute
+        sql_dialect (str, optional): the sql dialect to use. If None, the default sql
+            dialect of the underlying source is used. Defaults to "SQLITE".
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain, if
+            {columns_to_select_str} is used. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        force_output_geometrytype (GeometryType, optional): The output geometry type to
+            force. Defaults to None, and then the geometry type of the input is used
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to 1. If nb_parallel != 1, make sure your query still returns
+            correct results if it is executed per batch of rows instead of in one go
+            on the entire layer. To use all available cores, pass -1.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage. If batchsize != -1,
+            make sure your query still returns correct results if it is executed per
+            batch of rows instead of in one go on the entire layer.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s). Defaults to False.
+    """
+    logger.info(f"Start select on {input_path}")
+
+    # Convert force_output_geometrytype to GeometryType (if necessary)
+    if force_output_geometrytype is not None:
+        force_output_geometrytype = GeometryType(force_output_geometrytype)
+
+    return _geoops_sql.select(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        sql_stmt=sql_stmt,
+        sql_dialect=sql_dialect,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def simplify(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    tolerance: float,
+    algorithm: SimplifyAlgorithm = SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
+    lookahead: int = 8,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Applies a simplify operation on geometry column of the input file.
+
+    The result is written to the output file specified.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        tolerance (float): mandatory for the following algorithms:
+
+                * RAMER_DOUGLAS_PEUCKER: distance to use as tolerance.
+                * LANG: distance to use as tolerance.
+                * VISVALINGAM_WHYATT: area to use as tolerance.
+
+            In projected coordinate systems this tolerance will typically be
+            in meter, in geodetic systems this is typically in degrees.
+        algorithm (SimplifyAlgorithm, optional): algorithm to use.
+            Defaults to SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER.
+        lookahead (int, optional): used for LANG algorithm. Defaults to 8.
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(f"Start simplify on {input_path} with tolerance {tolerance}")
+    if algorithm == SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER:
+        return _geoops_sql.simplify(
+            input_path=Path(input_path),
+            output_path=Path(output_path),
+            tolerance=tolerance,
+            input_layer=input_layer,
+            output_layer=output_layer,
+            columns=columns,
+            explodecollections=explodecollections,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+        )
+    else:
+        return _geoops_gpd.simplify(
+            input_path=Path(input_path),
+            output_path=Path(output_path),
+            tolerance=tolerance,
+            algorithm=algorithm,
+            lookahead=lookahead,
+            input_layer=input_layer,
+            output_layer=output_layer,
+            columns=columns,
+            explodecollections=explodecollections,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+        )
+
+
+################################################################################
+# Operations on two layers
+################################################################################
+
+
+def clip(
+    input_path: Union[str, "os.PathLike[Any]"],
+    clip_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input_layer: Optional[str] = None,
+    input_columns: Optional[List[str]] = None,
+    clip_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Clip the input layer with the clip layer.
+
+    The resulting layer will contain the parts of the geometries in the
+    input layer that overlap with the dissolved geometries in the clip layer.
+
+    Clarifications:
+        - every row in the input layer will result in maximum one row in the
+          output layer.
+        - geometries in the input layer that overlap with multiple adjacent
+          geometries in the clip layer won't result in the input geometries
+          getting split.
+
+    This is the result you can expect when clipping a polygon layer (yellow)
+    with another polygon layer (purple):
+
+    .. list-table::
+       :header-rows: 1
+
+       * - Input
+         - Clip result
+       * - |clip_input|
+         - |clip_result|
+
+    Args:
+        input_path (PathLike): The file to clip.
+        clip_path (PathLike): The file with the geometries to clip with.
+        output_path (PathLike): the file to write the result to
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        input_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
+        clip_layer (str, optional): clip layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): output layer name. Optional if the
+            file only contains one layer.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |clip_input| image:: ../_static/images/clip_input.png
+        :alt: Clip input
+    .. |clip_result| image:: ../_static/images/clip_result.png
+        :alt: Clip result
+    """
+
+    logger.info(f"Start clip on {input_path} with {clip_path} to {output_path}")
+    return _geoops_sql.clip(
+        input_path=Path(input_path),
+        clip_path=Path(clip_path),
+        output_path=Path(output_path),
+        input_layer=input_layer,
+        input_columns=input_columns,
+        clip_layer=clip_layer,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def erase(
+    input_path: Union[str, "os.PathLike[Any]"],
+    erase_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input_layer: Optional[str] = None,
+    input_columns: Optional[List[str]] = None,
+    erase_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Erase all geometries in the erase layer from the input layer.
+
+    Clarifications:
+        - every row in the input layer will result in maximum one row in the
+          output layer.
+        - columns from the erase layer cannot be retained.
+
+    Alternative names:
+        - QGIS: difference
+
+    Args:
+        input_path (PathLike): The file to erase from.
+        erase_path (PathLike): The file with the geometries to erase with.
+        output_path (PathLike): the file to write the result to
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        input_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
+        erase_layer (str, optional): erase layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): output layer name. Optional if the
+            file only contains one layer.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+
+    logger.info(f"Start erase on {input_path} with {erase_path} to {output_path}")
+    return _geoops_sql.erase(
+        input_path=Path(input_path),
+        erase_path=Path(erase_path),
+        output_path=Path(output_path),
+        input_layer=input_layer,
+        input_columns=input_columns,
+        erase_layer=erase_layer,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def export_by_location(
+    input_to_select_from_path: Union[str, "os.PathLike[Any]"],
+    input_to_compare_with_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    min_area_intersect: Optional[float] = None,
+    area_inters_column_name: Optional[str] = "area_inters",
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input2_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Exports all features in input_to_select_from_path that intersect with any
+    features in input_to_compare_with_path.
+
+    Alternative names:
+        - QGIS: extract by location
+
+    Args:
+        input_to_select_from_path (PathLike): the 1st input file
+        input_to_compare_with_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        min_area_intersect (float, optional): minimum area of the intersection.
+            Defaults to None.
+        area_inters_column_name (str, optional): column name of the intersect
+            area. Defaults to 'area_inters'. In None, no area column is added.
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        input2_columns (List[str], optional): NA.
+        output_layer (str, optional): output layer name. Optional if the
+            file only contains one layer.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(
+        f"Start export_by_location: select from {input_to_select_from_path} "
+        f"interacting with {input_to_compare_with_path} to {output_path}"
+    )
+    return _geoops_sql.export_by_location(
+        input_path=Path(input_to_select_from_path),
+        input_to_compare_with_path=Path(input_to_compare_with_path),
+        output_path=Path(output_path),
+        min_area_intersect=min_area_intersect,
+        area_inters_column_name=area_inters_column_name,
+        input_layer=input1_layer,
+        input_columns=input1_columns,
+        input_to_compare_with_layer=input2_layer,
+        output_layer=output_layer,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def export_by_distance(
+    input_to_select_from_path: Union[str, "os.PathLike[Any]"],
+    input_to_compare_with_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    max_distance: float,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input2_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Exports all features in input_to_select_from_path that are within the
+    distance specified of any features in input_to_compare_with_path.
+
+    Args:
+        input_to_select_from_path (PathLike): the 1st input file
+        input_to_compare_with_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        max_distance (float): maximum distance
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): output layer name. Optional if the
+            file only contains one layer.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(
+        f"Start export_by_distance: select from {input_to_select_from_path} within "
+        f"max_distance of {max_distance} from {input_to_compare_with_path} "
+        f"to {output_path}"
+    )
+    return _geoops_sql.export_by_distance(
+        input_to_select_from_path=Path(input_to_select_from_path),
+        input_to_compare_with_path=Path(input_to_compare_with_path),
+        output_path=Path(output_path),
+        max_distance=max_distance,
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input2_layer=input2_layer,
+        output_layer=output_layer,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def intersect(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    warnings.warn(
+        "intersect() is deprecated because it was renamed intersection(). "
+        "Will be removed in a future version",
+        FutureWarning,
+    )
+    return intersection(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def intersection(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Calculate the pairwise intersection of alle features in input1 with all
+    features in input2.
+
+    Alternative names:
+        - GeoPandas: overlay(how="intersection")
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
+            "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for input1_columns, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2_".
+        output_layer (str, optional): output layer name. If None, the output_path stem
+            is used. Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(
+        f"Start intersection between {input1_path} and {input2_path} to {output_path}"
+    )
+    return _geoops_sql.intersection(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def join_by_location(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    spatial_relations_query: str = "intersects is True",
+    discard_nonmatching: bool = True,
+    min_area_intersect: Optional[float] = None,
+    area_inters_column_name: Optional[str] = None,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Joins all features in input1 with all features in input2.
+
+    The output will contain the geometries of input1. The spatial_relations_query and
+    min_area_intersect parameters will determine which geometries of input1 will be
+    matched with input2.
+
+    The spatial_relations_query is a filter string where you can use the following
+    "named spatial predicates": equals, touches, within, overlaps, crosses, intersects,
+    contains, covers, coveredby.
+
+    If you want even more control, you can also use "spatial masks" as defined by the
+    [DE-9IM](https://en.wikipedia.org/wiki/DE-9IM) model.
+
+    Examples for valid spatial_relations_query values:
+
+        - "overlaps is True and contains is False"
+        - "(T*T***T** is True or 1*T***T** is True) and T*****FF* is False"
+
+
+    Alternative names:
+        - GeoPandas: sjoin
+        - ArcGIS: spatial join
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        spatial_relations_query (str, optional): a query that specifies the
+            spatial relations to match between the 2 layers.
+            Defaults to "intersects is True".
+        discard_nonmatching (bool, optional): True to only keep rows that
+            match with the spatial_relations_query. False to keep rows all
+            rows in the input1_layer (=left outer join). Defaults to True
+            (=inner join).
+        min_area_intersect (float, optional): minimum area of the intersection
+            to match. Defaults to None.
+        area_inters_column_name (str, optional): column name of the intersect
+            area. If None no area column is added. Defaults to None.
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
+            "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for input1_columns, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2_".
+        output_layer (str, optional): output layer name. If None, the output_path stem
+            is used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(
+        f"Start join_by_location: select from {input1_path} joined with "
+        f"{input2_path} to {output_path}"
+    )
+    return _geoops_sql.join_by_location(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        spatial_relations_query=spatial_relations_query,
+        discard_nonmatching=discard_nonmatching,
+        min_area_intersect=min_area_intersect,
+        area_inters_column_name=area_inters_column_name,
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=False,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def join_nearest(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    nb_nearest: int,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Joins features in input1 with the nb_nearest features that are closest to
+    them in input2.
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        nb_nearest (int): the number of nearest features from input 2 to join
+            to input1.
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
+            "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for input1_columns, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2_".
+        output_layer (str, optional): output layer name. If None, the output_path stem
+            is used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(
+        f"Start join_nearest: select from {input1_path} joined with "
+        f"{input2_path} to {output_path}"
+    )
+    return _geoops_sql.join_nearest(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        nb_nearest=nb_nearest,
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=False,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def select_two_layers(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    sql_stmt: str,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Optional[GeometryType] = None,
+    nb_parallel: int = 1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Executes the sqlite query specified on the 2 input layers specified.
+
+    By convention, the sqlite query can contain following placeholders that
+    will be automatically replaced for you:
+
+      * {input1_layer}: name of input layer 1
+      * {input1_geometrycolumn}: name of input geometry column 1
+      * {layer1_columns_prefix_str}: komma seperated columns of
+        layer 1, prefixed with "layer1"
+      * {layer1_columns_prefix_alias_str}: komma seperated columns of
+        layer 1, prefixed with "layer1" and with column name aliases
+      * {layer1_columns_from_subselect_str}: komma seperated columns of
+        layer 1, prefixed with "sub"
+      * {input1_databasename}: the database alias for input 1
+      * {input2_layer}: name of input layer 1
+      * {input2_geometrycolumn}: name of input geometry column 2
+      * {layer2_columns_prefix_str}: komma seperated columns of
+        layer 2, prefixed with "layer2"
+      * {layer2_columns_prefix_alias_str}: komma seperated columns of
+        layer 2, prefixed with "layer2" and with column name aliases
+      * {layer2_columns_from_subselect_str}: komma seperated columns of
+        layer 2, prefixed with "sub"
+      * {layer2_columns_prefix_alias_null_str}: komma seperated columns of
+        layer 2, but with NULL for all values and with column aliases
+      * {input2_databasename}: the database alias for input 2
+      * {batch_filter}: the filter to be applied per batch when using
+        parallel processing
+
+    Example: left outer join all features in input1 layer with all rows
+    in input2 on join_id.
+    ::
+
+        import geofileops as gfo
+
+        minimum_area = 100
+        sql_stmt = f'''
+                SELECT layer1.{{input1_geometrycolumn}}
+                      {{layer1_columns_prefix_alias_str}}
+                      {{layer2_columns_prefix_alias_str}}
+                  FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                  LEFT OUTER JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                    ON layer1.join_id = layer2.join_id
+                 WHERE 1=1
+                   {{batch_filter}}
+                   AND ST_Area(layer1.{{input1_geometrycolumn}}) > {minimum_area}
+                '''
+        gfo.select_two_layers(
+                input1_path=...,
+                input2_path=...,
+                output_path=...,
+                sql_stmt=sql_stmt)
+
+    Some important remarks:
+
+    * Because some sql statement won't give the same result when parallellized
+      (eg. when using a group by statement), nb_parallel is 1 by default.
+      If you do want to use parallel processing, specify nb_parallel + make
+      sure to include the placeholder {batch_filter} in your sql_stmt.
+      This placeholder will be replaced with a filter of the form
+      'AND rowid >= x AND rowid < y'.
+    * Table names are best double quoted as in the example, because some
+      characters are otherwise not supported in the table name, eg. '-'.
+    * When using supported placeholders, make sure you give the tables you
+      select from the appropriate table aliases (layer1, layer2).
+    * Besides the standard sqlite sql syntacs, you can use the spatialite
+      functions as documented here: |sqlite_reference_link|
+
+    .. |sqlite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>  # noqa: E501
+
+    The result is written to the output file specified.
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain if one of the
+            {layer1_columns_...} placeholders is used in sql_stmt. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
+            "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): list of columns to retain if one of the
+            {layer2_columns_...} placeholders is used in sql_stmt. If None is specified,
+            all columns are selected. As explained for input1_columns, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2_".
+        output_layer (str, optional): output layer name. If None, the output_path stem
+            is used. Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        force_output_geometrytype (GeometryType, optional): The output geometry
+            type to force. Defaults to None, and then the geometry type of the
+            input1 layer is used.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    **Some more advanced example queries**
+
+    An ideal place to get inspiration to write you own advanced queries
+    is in the following source code file: |geofileops_sql_link|.
+
+    Additionally, there are some examples listed here that highlight
+    other features/possibilities.
+
+    .. |geofileops_sql_link| raw:: html
+
+        <a href="https://github.com/geofileops/geofileops/blob/main/geofileops/util/geofileops_sql.py" target="_blank">geofileops_sql.py</a>
+
+    *Join nearest features*
+
+    For each feature in layer1, get the nearest feature of layer2 with the
+    same values for the column join_id.
+
+        .. code-block:: sqlite3
+
+            WITH join_with_dist AS (
+                SELECT layer2.{{input2_geometrycolumn}}
+                      {{layer1_columns_prefix_alias_str}}
+                      {{layer2_columns_prefix_alias_str}}
+                      ,ST_Distance(layer2.{{input2_geometrycolumn}}
+                      ,layer1.{{input1_geometrycolumn}}) AS distance
+                 FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                 JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                   ON layer1.join_id = layer2.join_id
+                )
+            SELECT *
+              FROM join_with_dist jwd
+             WHERE distance = (
+                   SELECT MIN(distance) FROM join_with_dist jwd_sub
+                    WHERE jwd_sub.l1_join_id = jwd.l1_join_id)
+             ORDER BY distance DESC
+    """
+    logger.info(
+        f"Start select_two_layers: select from {input1_path} and {input2_path} "
+        f"to {output_path}"
+    )
+    return _geoops_sql.select_two_layers(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        sql_stmt=sql_stmt,
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def symmetric_difference(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Calculates the "symmetric difference" of the two input layers.
+
+    Alternative names:
+        - GeoPandas: overlay(how="symmetric_difference")
+        - QGIS, ArcMap: symmetrical difference
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
+            "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for input1_columns, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2_".
+        output_layer (str, optional): output layer name. If None, the output_path stem
+            is used. Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduc
+            e the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(
+        f"Start symmetric_difference of {input1_path} and {input2_path} "
+        f"to {output_path}"
+    )
+    return _geoops_sql.symmetric_difference(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def split(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Split the features in input1 with all features in input2.
+
+    The result is the equivalent of an intersect between the two layers + layer
+    1 erased with layer 2.
+
+    Alternative names:
+        - ArcMap, SAGA: identity
+        - GeoPandas: overlay(how="identity")
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
+            "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for input1_columns, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2_".
+        output_layer (str, optional): output layer name. If None, the output_path stem
+            is used. Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(f"Start split between {input1_path} and {input2_path} to {output_path}")
+    return _geoops_sql.split(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def union(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Calculates the pairwise "union" of the two input layers.
+
+    Alternative names:
+        - GeoPandas: overlay(how="union")
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
+            "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for input1_columns, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2_".
+        output_layer (str, optional): output layer name. If None, the output_path stem
+            is used. Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available processors.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger.info(
+        f"Start union: select from {input1_path} and {input2_path} to {output_path}"
+    )
+    return _geoops_sql.union(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
```

### Comparing `geofileops-0.8.0a1/geofileops/helpers/_parameter_helper.py` & `geofileops-0.8.0a2/geofileops/helpers/_parameter_helper.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,99 +1,99 @@
-# -*- coding: utf-8 -*-
-"""
-Module with some helpers functions to validate, parse,... parameters with a complex
-structure that are typically reused in different functions in geofileops.
-"""
-
-
-def validate_agg_columns(agg_columns: dict):
-    """
-    Validates if the agg_columns parameter is properly formed.
-
-    If an problem is found, an error is raised.
-
-    Typically used in dissolve functions.
-
-    Args:
-        agg_columns (dict): the agg_columns parameter value dict to check.
-
-    Raises:
-        ValueError: if any error is encountered.
-    """
-    # Check agg_columns param
-    if agg_columns is None:
-        return
-
-    base_message = (
-        '{"json": [<list_columns>]} '
-        'or {"columns": [{"column": "...", "agg": "...", "as": "..."}, ...]}'
-    )
-
-    # It should be a dict with one key
-    if (
-        agg_columns is None
-        or not isinstance(agg_columns, dict)
-        or len(agg_columns) != 1
-    ):
-        message = "agg_columns must be a dict with exactly one top-level key"
-        raise ValueError(f"{message}: {base_message}")
-
-    if "json" in agg_columns:
-        # The value should be a list or None
-        if agg_columns["json"] is None:
-            return
-        if not isinstance(agg_columns["json"], list):
-            message = 'agg_columns["json"] does not contain a list of strings'
-            raise ValueError(f"{message}: {agg_columns['json']}: {base_message}")
-
-        # Loop through all elements
-        for agg_column in agg_columns["json"]:
-            # It should be a str
-            if not isinstance(agg_column, str):
-                message = 'agg_columns["json"] list contains a non-string element'
-                raise ValueError(f"{message}: {agg_column}: {base_message}")
-    elif "columns" in agg_columns:
-        supported_aggfuncs = [
-            "count",
-            "sum",
-            "mean",
-            "min",
-            "max",
-            "median",
-            "concat",
-        ]
-        # The value should be a list
-        if not isinstance(agg_columns["columns"], list):
-            message = 'agg_columns["columns"] does not contain a list of dicts'
-            raise ValueError(f"{message}: {agg_columns['columns']}: {base_message}")
-
-        # Loop through all elements
-        for agg_column in agg_columns["columns"]:
-            # It should be a dict
-            if not isinstance(agg_column, dict):
-                message = 'agg_columns["columns"] list contains a non-dict element'
-                raise ValueError(f"{message}: {agg_column}: {base_message}")
-
-            # Check if column exists + set casing same as in data
-            if "column" not in agg_column:
-                message = 'each dict in agg_columns["columns"] needs a "column" element'
-                raise ValueError(f"{message}: {agg_column}")
-            if "agg" not in agg_column:
-                message = 'each dict in agg_columns["columns"] needs an "agg" element'
-                raise ValueError(f"{message}: {agg_column}")
-            if "as" not in agg_column:
-                message = 'each dict in agg_columns["columns"] needs an "as" element'
-                raise ValueError(f"{message}: {agg_column}")
-            if agg_column["agg"].lower() not in supported_aggfuncs:
-                raise ValueError(
-                    'agg_columns["columns"] contains unsupported aggregation '
-                    f'{agg_column["agg"]}, use one of {supported_aggfuncs}'
-                )
-            if not isinstance(agg_column["as"], str):
-                raise ValueError(
-                    f'agg_columns["columns"], "as" value should be string: {agg_column}'
-                )
-    else:
-        message = (
-            f"agg_columns has invalid top-level key: {list(agg_columns.keys())[0]}"
-        )
-        raise ValueError(f"{message}: {base_message}")
+# -*- coding: utf-8 -*-
+"""
+Module with some helpers functions to validate, parse,... parameters with a complex
+structure that are typically reused in different functions in geofileops.
+"""
+
+
+def validate_agg_columns(agg_columns: dict):
+    """
+    Validates if the agg_columns parameter is properly formed.
+
+    If an problem is found, an error is raised.
+
+    Typically used in dissolve functions.
+
+    Args:
+        agg_columns (dict): the agg_columns parameter value dict to check.
+
+    Raises:
+        ValueError: if any error is encountered.
+    """
+    # Check agg_columns param
+    if agg_columns is None:
+        return
+
+    base_message = (
+        '{"json": [<list_columns>]} '
+        'or {"columns": [{"column": "...", "agg": "...", "as": "..."}, ...]}'
+    )
+
+    # It should be a dict with one key
+    if (
+        agg_columns is None
+        or not isinstance(agg_columns, dict)
+        or len(agg_columns) != 1
+    ):
+        message = "agg_columns must be a dict with exactly one top-level key"
+        raise ValueError(f"{message}: {base_message}")
+
+    if "json" in agg_columns:
+        # The value should be a list or None
+        if agg_columns["json"] is None:
+            return
+        if not isinstance(agg_columns["json"], list):
+            message = 'agg_columns["json"] does not contain a list of strings'
+            raise ValueError(f"{message}: {agg_columns['json']}: {base_message}")
+
+        # Loop through all elements
+        for agg_column in agg_columns["json"]:
+            # It should be a str
+            if not isinstance(agg_column, str):
+                message = 'agg_columns["json"] list contains a non-string element'
+                raise ValueError(f"{message}: {agg_column}: {base_message}")
+    elif "columns" in agg_columns:
+        supported_aggfuncs = [
+            "count",
+            "sum",
+            "mean",
+            "min",
+            "max",
+            "median",
+            "concat",
+        ]
+        # The value should be a list
+        if not isinstance(agg_columns["columns"], list):
+            message = 'agg_columns["columns"] does not contain a list of dicts'
+            raise ValueError(f"{message}: {agg_columns['columns']}: {base_message}")
+
+        # Loop through all elements
+        for agg_column in agg_columns["columns"]:
+            # It should be a dict
+            if not isinstance(agg_column, dict):
+                message = 'agg_columns["columns"] list contains a non-dict element'
+                raise ValueError(f"{message}: {agg_column}: {base_message}")
+
+            # Check if column exists + set casing same as in data
+            if "column" not in agg_column:
+                message = 'each dict in agg_columns["columns"] needs a "column" element'
+                raise ValueError(f"{message}: {agg_column}")
+            if "agg" not in agg_column:
+                message = 'each dict in agg_columns["columns"] needs an "agg" element'
+                raise ValueError(f"{message}: {agg_column}")
+            if "as" not in agg_column:
+                message = 'each dict in agg_columns["columns"] needs an "as" element'
+                raise ValueError(f"{message}: {agg_column}")
+            if agg_column["agg"].lower() not in supported_aggfuncs:
+                raise ValueError(
+                    'agg_columns["columns"] contains unsupported aggregation '
+                    f'{agg_column["agg"]}, use one of {supported_aggfuncs}'
+                )
+            if not isinstance(agg_column["as"], str):
+                raise ValueError(
+                    f'agg_columns["columns"], "as" value should be string: {agg_column}'
+                )
+    else:
+        message = (
+            f"agg_columns has invalid top-level key: {list(agg_columns.keys())[0]}"
+        )
+        raise ValueError(f"{message}: {base_message}")
```

### Comparing `geofileops-0.8.0a1/geofileops/helpers/layer_styles.py` & `geofileops-0.8.0a2/geofileops/helpers/layerstyles.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,229 +1,229 @@
-from pathlib import Path
-from typing import Optional
-
-from osgeo import gdal
-from osgeo import ogr
-import pandas as pd
-
-from geofileops import fileops
-
-gdal.UseExceptions()
-ogr.UseExceptions()
-
-
-def get_layerstyles(
-    path: Path, layer: Optional[str] = None, name: Optional[str] = None
-) -> pd.DataFrame:
-    """
-    Get the layer styles saved in the geofile.
-
-    Only styles saved according to the QGIS Geopackage styling extension are read:
-    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
-
-    Args:
-        path (Path): path to the geofile.
-        layer (str, optional): the layer to get the styles for. If None, all styles
-            regardless of the layer they belong to are returned. Defaults to None.
-        name (str, optional): the name of the style to get. If None, all styles
-            regardless of their name are returned. Defaults to None.
-
-    Returns:
-        pd.DataFrame: the styles found.
-    """
-    layer_styles_df = fileops.read_file(path, layer="layer_styles", fid_as_index=True)
-    layer_styles_df.index.name = "id"
-    if layer is not None:
-        layer_styles_df = layer_styles_df.loc[
-            layer_styles_df["f_table_name"] == layer  # type: ignore
-        ]
-    if name is not None:
-        layer_styles_df = layer_styles_df.loc[
-            layer_styles_df["styleName"] == name  # type: ignore
-        ]
-
-    return layer_styles_df
-
-
-def add_layerstyle(
-    path: Path,
-    layer: str,
-    name: str,
-    qml: str,
-    sld: str = "",
-    use_as_default: bool = False,
-    description: str = "",
-    owner: str = "",
-    ui: str = "",
-):
-    """
-    Add the layer style to the geofile.
-
-    Remark: at the time of writing, QGIS only uses the qml field to interprete the
-    style, so this field is mandatory and sld is not.
-
-    The style is saved according to the QGIS Geopackage styling extension:
-    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
-
-    Args:
-        path (Path): path to the geofile.
-        layer (str): the layer the style is meant for.
-        name (str): the name of the style.
-        qml (str): the styling in qml format.
-        sld (str, optional): the styling in sld format. Defaults to "" as it is not used
-            by QGIS at the time of writing.
-        use_as_default(bool, optional): True to use the style by default when opening
-            the layer in QGIS.
-        description (str, optional): description of the style, Defaults to "".
-        owner (str, optional): owner of the style, Defaults to "".
-        ui (str, optional): ui specification in ui format, Defaults to "".
-    """
-    # Make sure the layer_styles table exists
-    _init_layerstyles(path, exist_ok=True)
-    if use_as_default:
-        use_as_default_str = 1
-    else:
-        use_as_default_str = 0
-
-    # Get existing layer styles
-    layer_styles_df = get_layerstyles(path, layer=layer, name=name)
-
-    # If the layer style already exists: error
-    if len(layer_styles_df) > 0:
-        styles_found = (
-            layer_styles_df[["f_table_name", "styleName"]]
-            .reset_index()
-            .to_dict(orient="records")
-        )
-        raise ValueError(f"layer style exists already: {styles_found}")
-
-    try:
-        datasource = gdal.OpenEx(str(path), nOpenFlags=gdal.OF_UPDATE)
-
-        sql = f"""
-            INSERT INTO layer_styles (
-                    id, f_table_catalog, f_table_schema, f_table_name,
-                    f_geometry_column, styleName, styleQML, styleSLD, useAsDefault,
-                    description, owner, ui
-                )
-                VALUES (
-                    NULL, '', '', '{layer}',
-                    'geom', '{name}', '{qml}', '{sld}', {use_as_default_str},
-                    '{description}', '{owner}', '{ui}'
-                )
-        """
-        result = datasource.ExecuteSQL(sql, dialect="SQLITE")
-        datasource.ReleaseResultSet(result)
-
-    finally:
-        datasource = None
-
-
-def remove_layerstyle(path: Path, id: int):
-    """
-    Remove a layer style.
-
-    Only styles saved according to the QGIS Geopackage styling extension are removed:
-    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
-
-    Args:
-        path (Path): path to the geo file.
-        id (int): the id of the layer style to remove.
-    """
-    if not _has_layerstyles_table(path):
-        return
-
-    try:
-        datasource = gdal.OpenEx(str(path), nOpenFlags=gdal.OF_UPDATE)
-
-        sql = f"DELETE FROM layer_styles WHERE id = {id}"
-        result = datasource.ExecuteSQL(sql, dialect="SQLITE")
-        datasource.ReleaseResultSet(result)
-
-    finally:
-        datasource = None
-
-
-def _has_layerstyles_table(path: Path) -> bool:
-    """
-    Check if the layer_styles table exists for the geo file specified.
-
-    Args:
-        path (Path): the path to the geofile.
-
-    Returns:
-        bool: True of the layer_styles table exists, False if not.
-    """
-    try:
-        datasource = gdal.OpenEx(str(path))
-        sql = """
-            SELECT count(1) FROM sqlite_master
-             WHERE name = 'layer_styles'
-               AND type = 'table'
-        """
-        result = datasource.ExecuteSQL(sql, dialect="SQLITE")
-        table_exists = result.GetNextFeature().GetField(0) == 1
-        datasource.ReleaseResultSet(result)
-    finally:
-        datasource = None
-
-    return table_exists
-
-
-def _init_layerstyles(path: Path, exist_ok: bool = False):
-    """
-    Create a layer_styles attribute table to store style information in the QGIS way.
-
-    The table is created according to the QGIS Geopackage styling extension:
-    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
-
-    Args:
-        path (Path): the file to create the table in.
-        exist_ok (bool, options): If True and the index exists already, don't
-            throw an error.
-    """
-    try:
-        # First check if it exists already
-        if _has_layerstyles_table(path):
-            if exist_ok:
-                return
-            else:
-                raise ValueError(f"layer_styles table exists already in {path}")
-
-        # Doesn't exist yet, so create the table
-        datasource = gdal.OpenEx(str(path), nOpenFlags=gdal.OF_UPDATE)
-        layer = datasource.CreateLayer(
-            "layer_styles", geom_type=ogr.wkbNone, options=["FID=id"]
-        )
-
-        # Add the fields we're interested in
-        field_name = ogr.FieldDefn("f_table_catalog", ogr.OFTString)
-        field_name.SetWidth(256)
-        layer.CreateField(field_name)
-        field_region = ogr.FieldDefn("f_table_schema", ogr.OFTString)
-        field_region.SetWidth(256)
-        layer.CreateField(field_region)
-        field_region = ogr.FieldDefn("f_table_name", ogr.OFTString)
-        field_region.SetWidth(256)
-        layer.CreateField(field_region)
-        field_region = ogr.FieldDefn("f_geometry_column", ogr.OFTString)
-        field_region.SetWidth(256)
-        layer.CreateField(field_region)
-        field_region = ogr.FieldDefn("styleName", ogr.OFTString)
-        field_region.SetWidth(30)
-        layer.CreateField(field_region)
-        layer.CreateField(ogr.FieldDefn("styleQML", ogr.OFTString))
-        layer.CreateField(ogr.FieldDefn("styleSLD", ogr.OFTString))
-        layer.CreateField(ogr.FieldDefn("useAsDefault", ogr.OFSTBoolean))
-        layer.CreateField(ogr.FieldDefn("description", ogr.OFTString))
-        field_region = ogr.FieldDefn("owner", ogr.OFTString)
-        field_region.SetWidth(30)
-        layer.CreateField(field_region)
-        field_region = ogr.FieldDefn("ui", ogr.OFTString)
-        field_region.SetWidth(30)
-        layer.CreateField(field_region)
-        field_region = ogr.FieldDefn("update_time", ogr.OFTDateTime)
-        field_region.SetDefault("CURRENT_TIMESTAMP")
-        layer.CreateField(field_region)
-    finally:
-        datasource = None
-        layer = None
+from pathlib import Path
+from typing import Optional
+
+from osgeo import gdal
+from osgeo import ogr
+import pandas as pd
+
+from geofileops import fileops
+
+gdal.UseExceptions()
+ogr.UseExceptions()
+
+
+def get_layerstyles(
+    path: Path, layer: Optional[str] = None, name: Optional[str] = None
+) -> pd.DataFrame:
+    """
+    Get the layer styles saved in the geofile.
+
+    Only styles saved according to the QGIS Geopackage styling extension are read:
+    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
+
+    Args:
+        path (Path): path to the geofile.
+        layer (str, optional): the layer to get the styles for. If None, all styles
+            regardless of the layer they belong to are returned. Defaults to None.
+        name (str, optional): the name of the style to get. If None, all styles
+            regardless of their name are returned. Defaults to None.
+
+    Returns:
+        pd.DataFrame: the styles found.
+    """
+    layer_styles_df = fileops.read_file(path, layer="layer_styles", fid_as_index=True)
+    layer_styles_df.index.name = "id"
+    if layer is not None:
+        layer_styles_df = layer_styles_df.loc[
+            layer_styles_df["f_table_name"] == layer  # type: ignore
+        ]
+    if name is not None:
+        layer_styles_df = layer_styles_df.loc[
+            layer_styles_df["styleName"] == name  # type: ignore
+        ]
+
+    return layer_styles_df
+
+
+def add_layerstyle(
+    path: Path,
+    layer: str,
+    name: str,
+    qml: str,
+    sld: str = "",
+    use_as_default: bool = False,
+    description: str = "",
+    owner: str = "",
+    ui: str = "",
+):
+    """
+    Add the layer style to the geofile.
+
+    Remark: at the time of writing, QGIS only uses the qml field to interprete the
+    style, so this field is mandatory and sld is not.
+
+    The style is saved according to the QGIS Geopackage styling extension:
+    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
+
+    Args:
+        path (Path): path to the geofile.
+        layer (str): the layer the style is meant for.
+        name (str): the name of the style.
+        qml (str): the styling in qml format.
+        sld (str, optional): the styling in sld format. Defaults to "" as it is not used
+            by QGIS at the time of writing.
+        use_as_default(bool, optional): True to use the style by default when opening
+            the layer in QGIS.
+        description (str, optional): description of the style, Defaults to "".
+        owner (str, optional): owner of the style, Defaults to "".
+        ui (str, optional): ui specification in ui format, Defaults to "".
+    """
+    # Make sure the layer_styles table exists
+    _init_layerstyles(path, exist_ok=True)
+    if use_as_default:
+        use_as_default_str = 1
+    else:
+        use_as_default_str = 0
+
+    # Get existing layer styles
+    layer_styles_df = get_layerstyles(path, layer=layer, name=name)
+
+    # If the layer style already exists: error
+    if len(layer_styles_df) > 0:
+        styles_found = (
+            layer_styles_df[["f_table_name", "styleName"]]
+            .reset_index()
+            .to_dict(orient="records")
+        )
+        raise ValueError(f"layer style exists already: {styles_found}")
+
+    try:
+        datasource = gdal.OpenEx(str(path), nOpenFlags=gdal.OF_UPDATE)
+
+        sql = f"""
+            INSERT INTO layer_styles (
+                    id, f_table_catalog, f_table_schema, f_table_name,
+                    f_geometry_column, styleName, styleQML, styleSLD, useAsDefault,
+                    description, owner, ui
+                )
+                VALUES (
+                    NULL, '', '', '{layer}',
+                    'geom', '{name}', '{qml}', '{sld}', {use_as_default_str},
+                    '{description}', '{owner}', '{ui}'
+                )
+        """
+        result = datasource.ExecuteSQL(sql, dialect="SQLITE")
+        datasource.ReleaseResultSet(result)
+
+    finally:
+        datasource = None
+
+
+def remove_layerstyle(path: Path, id: int):
+    """
+    Remove a layer style.
+
+    Only styles saved according to the QGIS Geopackage styling extension are removed:
+    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
+
+    Args:
+        path (Path): path to the geo file.
+        id (int): the id of the layer style to remove.
+    """
+    if not _has_layerstyles_table(path):
+        return
+
+    try:
+        datasource = gdal.OpenEx(str(path), nOpenFlags=gdal.OF_UPDATE)
+
+        sql = f"DELETE FROM layer_styles WHERE id = {id}"
+        result = datasource.ExecuteSQL(sql, dialect="SQLITE")
+        datasource.ReleaseResultSet(result)
+
+    finally:
+        datasource = None
+
+
+def _has_layerstyles_table(path: Path) -> bool:
+    """
+    Check if the layer_styles table exists for the geo file specified.
+
+    Args:
+        path (Path): the path to the geofile.
+
+    Returns:
+        bool: True of the layer_styles table exists, False if not.
+    """
+    try:
+        datasource = gdal.OpenEx(str(path))
+        sql = """
+            SELECT count(1) FROM sqlite_master
+             WHERE name = 'layer_styles'
+               AND type = 'table'
+        """
+        result = datasource.ExecuteSQL(sql, dialect="SQLITE")
+        table_exists = result.GetNextFeature().GetField(0) == 1
+        datasource.ReleaseResultSet(result)
+    finally:
+        datasource = None
+
+    return table_exists
+
+
+def _init_layerstyles(path: Path, exist_ok: bool = False):
+    """
+    Create a layer_styles attribute table to store style information in the QGIS way.
+
+    The table is created according to the QGIS Geopackage styling extension:
+    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
+
+    Args:
+        path (Path): the file to create the table in.
+        exist_ok (bool, options): If True and the index exists already, don't
+            throw an error.
+    """
+    try:
+        # First check if it exists already
+        if _has_layerstyles_table(path):
+            if exist_ok:
+                return
+            else:
+                raise ValueError(f"layer_styles table exists already in {path}")
+
+        # Doesn't exist yet, so create the table
+        datasource = gdal.OpenEx(str(path), nOpenFlags=gdal.OF_UPDATE)
+        layer = datasource.CreateLayer(
+            "layer_styles", geom_type=ogr.wkbNone, options=["FID=id"]
+        )
+
+        # Add the fields we're interested in
+        field_name = ogr.FieldDefn("f_table_catalog", ogr.OFTString)
+        field_name.SetWidth(256)
+        layer.CreateField(field_name)
+        field_region = ogr.FieldDefn("f_table_schema", ogr.OFTString)
+        field_region.SetWidth(256)
+        layer.CreateField(field_region)
+        field_region = ogr.FieldDefn("f_table_name", ogr.OFTString)
+        field_region.SetWidth(256)
+        layer.CreateField(field_region)
+        field_region = ogr.FieldDefn("f_geometry_column", ogr.OFTString)
+        field_region.SetWidth(256)
+        layer.CreateField(field_region)
+        field_region = ogr.FieldDefn("styleName", ogr.OFTString)
+        field_region.SetWidth(30)
+        layer.CreateField(field_region)
+        layer.CreateField(ogr.FieldDefn("styleQML", ogr.OFTString))
+        layer.CreateField(ogr.FieldDefn("styleSLD", ogr.OFTString))
+        layer.CreateField(ogr.FieldDefn("useAsDefault", ogr.OFSTBoolean))
+        layer.CreateField(ogr.FieldDefn("description", ogr.OFTString))
+        field_region = ogr.FieldDefn("owner", ogr.OFTString)
+        field_region.SetWidth(30)
+        layer.CreateField(field_region)
+        field_region = ogr.FieldDefn("ui", ogr.OFTString)
+        field_region.SetWidth(30)
+        layer.CreateField(field_region)
+        field_region = ogr.FieldDefn("update_time", ogr.OFTDateTime)
+        field_region.SetDefault("CURRENT_TIMESTAMP")
+        layer.CreateField(field_region)
+    finally:
+        datasource = None
+        layer = None
```

### Comparing `geofileops-0.8.0a1/geofileops/util/_general_util.py` & `geofileops-0.8.0a2/geofileops/util/_general_util.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,168 +1,168 @@
-# -*- coding: utf-8 -*-
-"""
-Module containing some general utilities.
-"""
-
-import datetime
-import logging
-from typing import Iterable, List, Optional
-
-logger = logging.getLogger(__name__)
-
-
-class MissingRuntimeDependencyError(Exception):
-    """
-    Exception raised when an unsupported SQL statement is passed.
-
-    Attributes:
-        message (str): Exception message
-    """
-
-    def __init__(self, message):
-        self.message = message
-        super().__init__(self.message)
-
-
-def align_casing(string_to_align: str, strings_to_align_to: Iterable) -> str:
-    """
-    Align the casing of a string to the strings in strings_to_align_to so they
-    have the same casing.
-
-    If the string is not found in strings_to_align_to, a ValueError is thrown.
-
-    Args:
-        string_to_align (str): string to align the casing of to strings_to_align_to.
-        strings_to_align_to (Iterable): strings to align the casing with.
-
-    Raises:
-        ValueError: the string was not found in strings_to_align_to.
-
-    Returns:
-        str: the aligned string.
-    """
-    return align_casing_list([string_to_align], strings_to_align_to)[0]
-
-
-def align_casing_list(
-    strings_to_align: List[str], strings_to_align_to: Iterable
-) -> List[str]:
-    """
-    Align the strings in strings_to_align to the strings in strings_to_align_to so they
-    have the same casing.
-
-    If a string is not found in strings_to_align_to, a ValueError is thrown.
-
-    Args:
-        strings_to_align (List[str]): strings to align the casing of to
-            strings_to_align_to.
-        strings_to_align_to (Iterable): strings to align the casing with.
-
-    Raises:
-        ValueError: a string in strings_to_align was nog found in strings_to_align_to.
-
-    Returns:
-        List[str]: the aligned list of strings.
-    """
-    strings_to_align_to_upper_dict = {
-        string.upper(): string for string in strings_to_align_to
-    }
-    strings_aligned = []
-    for string in strings_to_align:
-        string_aligned = strings_to_align_to_upper_dict.get(string.upper())
-        if string_aligned is not None:
-            strings_aligned.append(string_aligned)
-        else:
-            raise ValueError(f"{string} not available in: {strings_to_align_to}")
-    return strings_aligned
-
-
-def report_progress(
-    start_time: datetime.datetime,
-    nb_done: int,
-    nb_todo: int,
-    operation: Optional[str] = None,
-    nb_parallel: int = 1,
-):
-    # If logging level not enabled for INFO, no progress reporting...
-    if logger.isEnabledFor(logging.INFO) is False:
-        return
-
-    message = format_progress(
-        start_time=start_time,
-        nb_done=nb_done,
-        nb_todo=nb_todo,
-        operation=operation,
-        nb_parallel=nb_parallel,
-    )
-    if message is not None:
-        if nb_done >= nb_todo:
-            message += "\n"
-        print(f"\r{message}", end="", flush=True)
-
-
-def format_progress(
-    start_time: datetime.datetime,
-    nb_done: int,
-    nb_todo: int,
-    operation: Optional[str] = None,
-    nb_parallel: int = 1,
-) -> Optional[str]:
-    # Init
-    time_passed = (datetime.datetime.now() - start_time).total_seconds()
-    pct_progress = 100.0 - (nb_todo - nb_done) * 100 / nb_todo
-    nb_todo_str = f"{nb_todo:n}"
-    nb_decimal = len(nb_todo_str)
-
-    # If we haven't really started yet, don't report time estimate yet
-    if nb_done == 0:
-        return (
-            f" ?: ?: ? left, {operation} done on {nb_done:{nb_decimal}n} of "
-            f"{nb_todo:{nb_decimal}n} ({pct_progress:3.2f}%)    "
-        )
-    else:
-        pct_progress = 100.0 - (nb_todo - nb_done) * 100 / nb_todo
-        if time_passed > 0:
-            # Else, report progress properly...
-            processed_per_hour = (nb_done / time_passed) * 3600
-            # Correct the nb processed per hour if running parallel
-            if nb_done < nb_parallel:
-                processed_per_hour = round(processed_per_hour * nb_parallel / nb_done)
-            hours_to_go = (int)((nb_todo - nb_done) / processed_per_hour)
-            min_to_go = (int)((((nb_todo - nb_done) / processed_per_hour) % 1) * 60)
-            secs_to_go = (int)(
-                ((((nb_todo - nb_done) / processed_per_hour) % 1) * 3600) % 60
-            )
-            time_left_str = f"{hours_to_go:02d}:{min_to_go:02d}:{secs_to_go:02d}"
-            nb_left_str = f"{nb_done:{nb_decimal}n} of {nb_todo:{nb_decimal}n}"
-            pct_str = f"({pct_progress:3.2f}%)    "
-        elif pct_progress >= 100:
-            time_left_str = "00:00:00"
-            nb_left_str = f"{nb_done:{nb_decimal}n} of {nb_todo:{nb_decimal}n}"
-            pct_str = f"({pct_progress:3.2f}%)    "
-        else:
-            return None
-        message = f"{time_left_str} left, {operation} done on {nb_left_str} {pct_str}"
-        return message
-
-
-def formatbytes(bytes: float):
-    """
-    Return the given bytes as a human friendly KB, MB, GB, or TB string
-    """
-
-    bytes_float = float(bytes)
-    KB = float(1024)
-    MB = float(KB**2)  # 1,048,576
-    GB = float(KB**3)  # 1,073,741,824
-    TB = float(KB**4)  # 1,099,511,627,776
-
-    if bytes_float < KB:
-        return "{0} {1}".format(bytes_float, "Bytes" if bytes_float > 1 else "Byte")
-    elif KB <= bytes_float < MB:
-        return "{0:.2f} KB".format(bytes_float / KB)
-    elif MB <= bytes_float < GB:
-        return "{0:.2f} MB".format(bytes_float / MB)
-    elif GB <= bytes_float < TB:
-        return "{0:.2f} GB".format(bytes_float / GB)
-    elif TB <= bytes_float:
-        return "{0:.2f} TB".format(bytes_float / TB)
+# -*- coding: utf-8 -*-
+"""
+Module containing some general utilities.
+"""
+
+import datetime
+import logging
+from typing import Iterable, List, Optional
+
+logger = logging.getLogger(__name__)
+
+
+class MissingRuntimeDependencyError(Exception):
+    """
+    Exception raised when an unsupported SQL statement is passed.
+
+    Attributes:
+        message (str): Exception message
+    """
+
+    def __init__(self, message):
+        self.message = message
+        super().__init__(self.message)
+
+
+def align_casing(string_to_align: str, strings_to_align_to: Iterable) -> str:
+    """
+    Align the casing of a string to the strings in strings_to_align_to so they
+    have the same casing.
+
+    If the string is not found in strings_to_align_to, a ValueError is thrown.
+
+    Args:
+        string_to_align (str): string to align the casing of to strings_to_align_to.
+        strings_to_align_to (Iterable): strings to align the casing with.
+
+    Raises:
+        ValueError: the string was not found in strings_to_align_to.
+
+    Returns:
+        str: the aligned string.
+    """
+    return align_casing_list([string_to_align], strings_to_align_to)[0]
+
+
+def align_casing_list(
+    strings_to_align: List[str], strings_to_align_to: Iterable
+) -> List[str]:
+    """
+    Align the strings in strings_to_align to the strings in strings_to_align_to so they
+    have the same casing.
+
+    If a string is not found in strings_to_align_to, a ValueError is thrown.
+
+    Args:
+        strings_to_align (List[str]): strings to align the casing of to
+            strings_to_align_to.
+        strings_to_align_to (Iterable): strings to align the casing with.
+
+    Raises:
+        ValueError: a string in strings_to_align was nog found in strings_to_align_to.
+
+    Returns:
+        List[str]: the aligned list of strings.
+    """
+    strings_to_align_to_upper_dict = {
+        string.upper(): string for string in strings_to_align_to
+    }
+    strings_aligned = []
+    for string in strings_to_align:
+        string_aligned = strings_to_align_to_upper_dict.get(string.upper())
+        if string_aligned is not None:
+            strings_aligned.append(string_aligned)
+        else:
+            raise ValueError(f"{string} not available in: {strings_to_align_to}")
+    return strings_aligned
+
+
+def report_progress(
+    start_time: datetime.datetime,
+    nb_done: int,
+    nb_todo: int,
+    operation: Optional[str] = None,
+    nb_parallel: int = 1,
+):
+    # If logging level not enabled for INFO, no progress reporting...
+    if logger.isEnabledFor(logging.INFO) is False:
+        return
+
+    message = format_progress(
+        start_time=start_time,
+        nb_done=nb_done,
+        nb_todo=nb_todo,
+        operation=operation,
+        nb_parallel=nb_parallel,
+    )
+    if message is not None:
+        if nb_done >= nb_todo:
+            message += "\n"
+        print(f"\r{message}", end="", flush=True)
+
+
+def format_progress(
+    start_time: datetime.datetime,
+    nb_done: int,
+    nb_todo: int,
+    operation: Optional[str] = None,
+    nb_parallel: int = 1,
+) -> Optional[str]:
+    # Init
+    time_passed = (datetime.datetime.now() - start_time).total_seconds()
+    pct_progress = 100.0 - (nb_todo - nb_done) * 100 / nb_todo
+    nb_todo_str = f"{nb_todo:n}"
+    nb_decimal = len(nb_todo_str)
+
+    # If we haven't really started yet, don't report time estimate yet
+    if nb_done == 0:
+        return (
+            f" ?: ?: ? left, {operation} done on {nb_done:{nb_decimal}n} of "
+            f"{nb_todo:{nb_decimal}n} ({pct_progress:3.2f}%)    "
+        )
+    else:
+        pct_progress = 100.0 - (nb_todo - nb_done) * 100 / nb_todo
+        if time_passed > 0:
+            # Else, report progress properly...
+            processed_per_hour = (nb_done / time_passed) * 3600
+            # Correct the nb processed per hour if running parallel
+            if nb_done < nb_parallel:
+                processed_per_hour = round(processed_per_hour * nb_parallel / nb_done)
+            hours_to_go = (int)((nb_todo - nb_done) / processed_per_hour)
+            min_to_go = (int)((((nb_todo - nb_done) / processed_per_hour) % 1) * 60)
+            secs_to_go = (int)(
+                ((((nb_todo - nb_done) / processed_per_hour) % 1) * 3600) % 60
+            )
+            time_left_str = f"{hours_to_go:02d}:{min_to_go:02d}:{secs_to_go:02d}"
+            nb_left_str = f"{nb_done:{nb_decimal}n} of {nb_todo:{nb_decimal}n}"
+            pct_str = f"({pct_progress:3.2f}%)    "
+        elif pct_progress >= 100:
+            time_left_str = "00:00:00"
+            nb_left_str = f"{nb_done:{nb_decimal}n} of {nb_todo:{nb_decimal}n}"
+            pct_str = f"({pct_progress:3.2f}%)    "
+        else:
+            return None
+        message = f"{time_left_str} left, {operation} done on {nb_left_str} {pct_str}"
+        return message
+
+
+def formatbytes(bytes: float):
+    """
+    Return the given bytes as a human friendly KB, MB, GB, or TB string
+    """
+
+    bytes_float = float(bytes)
+    KB = float(1024)
+    MB = float(KB**2)  # 1,048,576
+    GB = float(KB**3)  # 1,073,741,824
+    TB = float(KB**4)  # 1,099,511,627,776
+
+    if bytes_float < KB:
+        return "{0} {1}".format(bytes_float, "Bytes" if bytes_float > 1 else "Byte")
+    elif KB <= bytes_float < MB:
+        return "{0:.2f} KB".format(bytes_float / KB)
+    elif MB <= bytes_float < GB:
+        return "{0:.2f} MB".format(bytes_float / MB)
+    elif GB <= bytes_float < TB:
+        return "{0:.2f} GB".format(bytes_float / GB)
+    elif TB <= bytes_float:
+        return "{0:.2f} TB".format(bytes_float / TB)
```

### Comparing `geofileops-0.8.0a1/geofileops/util/_geoops_gpd.py` & `geofileops-0.8.0a2/geofileops/util/_geoops_gpd.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,4567 +1,4458 @@
 00000000: 2320 2d2a 2d20 636f 6469 6e67 3a20 7574  # -*- coding: ut
-00000010: 662d 3820 2d2a 2d0d 0a22 2222 0d0a 4d6f  f-8 -*-.."""..Mo
-00000020: 6475 6c65 2063 6f6e 7461 696e 696e 6720  dule containing 
-00000030: 7468 6520 696d 706c 656d 656e 7461 7469  the implementati
-00000040: 6f6e 206f 6620 4765 6f66 696c 6520 6f70  on of Geofile op
-00000050: 6572 6174 696f 6e73 2075 7369 6e67 2047  erations using G
-00000060: 656f 5061 6e64 6173 2e0d 0a22 2222 0d0a  eoPandas..."""..
-00000070: 0d0a 6672 6f6d 2063 6f6e 6375 7272 656e  ..from concurren
-00000080: 7420 696d 706f 7274 2066 7574 7572 6573  t import futures
-00000090: 0d0a 6672 6f6d 2064 6174 6574 696d 6520  ..from datetime 
-000000a0: 696d 706f 7274 2064 6174 6574 696d 650d  import datetime.
-000000b0: 0a69 6d70 6f72 7420 656e 756d 0d0a 696d  .import enum..im
-000000c0: 706f 7274 206a 736f 6e0d 0a69 6d70 6f72  port json..impor
-000000d0: 7420 6c6f 6767 696e 670d 0a69 6d70 6f72  t logging..impor
-000000e0: 7420 6c6f 6767 696e 672e 636f 6e66 6967  t logging.config
-000000f0: 0d0a 696d 706f 7274 206d 6174 680d 0a69  ..import math..i
-00000100: 6d70 6f72 7420 6d75 6c74 6970 726f 6365  mport multiproce
-00000110: 7373 696e 670d 0a66 726f 6d20 7061 7468  ssing..from path
-00000120: 6c69 6220 696d 706f 7274 2050 6174 680d  lib import Path.
-00000130: 0a69 6d70 6f72 7420 7069 636b 6c65 0d0a  .import pickle..
-00000140: 696d 706f 7274 2072 650d 0a69 6d70 6f72  import re..impor
-00000150: 7420 7368 7574 696c 0d0a 696d 706f 7274  t shutil..import
-00000160: 2074 696d 650d 0a66 726f 6d20 7479 7069   time..from typi
-00000170: 6e67 2069 6d70 6f72 7420 280d 0a20 2020  ng import (..   
-00000180: 2041 6e79 2c0d 0a20 2020 2043 616c 6c61   Any,..    Calla
-00000190: 626c 652c 0d0a 2020 2020 4974 6572 6162  ble,..    Iterab
-000001a0: 6c65 2c0d 0a20 2020 204c 6973 742c 0d0a  le,..    List,..
-000001b0: 2020 2020 4e61 6d65 6454 7570 6c65 2c0d      NamedTuple,.
-000001c0: 0a20 2020 204f 7074 696f 6e61 6c2c 0d0a  .    Optional,..
-000001d0: 2020 2020 5475 706c 652c 0d0a 2020 2020      Tuple,..    
-000001e0: 556e 696f 6e2c 0d0a 290d 0a69 6d70 6f72  Union,..)..impor
-000001f0: 7420 7761 726e 696e 6773 0d0a 0d0a 696d  t warnings....im
-00000200: 706f 7274 2063 6c6f 7564 7069 636b 6c65  port cloudpickle
-00000210: 0d0a 696d 706f 7274 2067 656f 7061 6e64  ..import geopand
-00000220: 6173 2061 7320 6770 640d 0a69 6d70 6f72  as as gpd..impor
-00000230: 7420 6e75 6d70 7920 6173 206e 700d 0a69  t numpy as np..i
-00000240: 6d70 6f72 7420 7061 6e64 6173 2061 7320  mport pandas as 
-00000250: 7064 0d0a 696d 706f 7274 2070 7375 7469  pd..import psuti
-00000260: 6c0d 0a69 6d70 6f72 7420 7368 6170 656c  l..import shapel
-00000270: 792e 6765 6f6d 6574 7279 2061 7320 7368  y.geometry as sh
-00000280: 5f67 656f 6d0d 0a0d 0a69 6d70 6f72 7420  _geom....import 
-00000290: 6765 6f66 696c 656f 7073 2061 7320 6766  geofileops as gf
-000002a0: 6f0d 0a66 726f 6d20 6765 6f66 696c 656f  o..from geofileo
-000002b0: 7073 2069 6d70 6f72 7420 6669 6c65 6f70  ps import fileop
-000002c0: 730d 0a66 726f 6d20 6765 6f66 696c 656f  s..from geofileo
-000002d0: 7073 2e75 7469 6c20 696d 706f 7274 205f  ps.util import _
-000002e0: 6765 6e65 7261 6c5f 7574 696c 0d0a 6672  general_util..fr
+00000010: 662d 3820 2d2a 2d0a 2222 220a 4d6f 6475  f-8 -*-.""".Modu
+00000020: 6c65 2063 6f6e 7461 696e 696e 6720 7468  le containing th
+00000030: 6520 696d 706c 656d 656e 7461 7469 6f6e  e implementation
+00000040: 206f 6620 4765 6f66 696c 6520 6f70 6572   of Geofile oper
+00000050: 6174 696f 6e73 2075 7369 6e67 2047 656f  ations using Geo
+00000060: 5061 6e64 6173 2e0a 2222 220a 0a66 726f  Pandas.."""..fro
+00000070: 6d20 636f 6e63 7572 7265 6e74 2069 6d70  m concurrent imp
+00000080: 6f72 7420 6675 7475 7265 730a 6672 6f6d  ort futures.from
+00000090: 2064 6174 6574 696d 6520 696d 706f 7274   datetime import
+000000a0: 2064 6174 6574 696d 650a 696d 706f 7274   datetime.import
+000000b0: 2065 6e75 6d0a 696d 706f 7274 206a 736f   enum.import jso
+000000c0: 6e0a 696d 706f 7274 206c 6f67 6769 6e67  n.import logging
+000000d0: 0a69 6d70 6f72 7420 6c6f 6767 696e 672e  .import logging.
+000000e0: 636f 6e66 6967 0a69 6d70 6f72 7420 6d61  config.import ma
+000000f0: 7468 0a69 6d70 6f72 7420 6d75 6c74 6970  th.import multip
+00000100: 726f 6365 7373 696e 670a 6672 6f6d 2070  rocessing.from p
+00000110: 6174 686c 6962 2069 6d70 6f72 7420 5061  athlib import Pa
+00000120: 7468 0a69 6d70 6f72 7420 7069 636b 6c65  th.import pickle
+00000130: 0a69 6d70 6f72 7420 7265 0a69 6d70 6f72  .import re.impor
+00000140: 7420 7368 7574 696c 0a69 6d70 6f72 7420  t shutil.import 
+00000150: 7469 6d65 0a66 726f 6d20 7479 7069 6e67  time.from typing
+00000160: 2069 6d70 6f72 7420 280a 2020 2020 416e   import (.    An
+00000170: 792c 0a20 2020 2043 616c 6c61 626c 652c  y,.    Callable,
+00000180: 0a20 2020 2049 7465 7261 626c 652c 0a20  .    Iterable,. 
+00000190: 2020 204c 6973 742c 0a20 2020 204e 616d     List,.    Nam
+000001a0: 6564 5475 706c 652c 0a20 2020 204f 7074  edTuple,.    Opt
+000001b0: 696f 6e61 6c2c 0a20 2020 2054 7570 6c65  ional,.    Tuple
+000001c0: 2c0a 2020 2020 556e 696f 6e2c 0a29 0a69  ,.    Union,.).i
+000001d0: 6d70 6f72 7420 7761 726e 696e 6773 0a0a  mport warnings..
+000001e0: 696d 706f 7274 2063 6c6f 7564 7069 636b  import cloudpick
+000001f0: 6c65 0a69 6d70 6f72 7420 6765 6f70 616e  le.import geopan
+00000200: 6461 7320 6173 2067 7064 0a69 6d70 6f72  das as gpd.impor
+00000210: 7420 6e75 6d70 7920 6173 206e 700a 696d  t numpy as np.im
+00000220: 706f 7274 2070 616e 6461 7320 6173 2070  port pandas as p
+00000230: 640a 696d 706f 7274 2070 7375 7469 6c0a  d.import psutil.
+00000240: 696d 706f 7274 2073 6861 7065 6c79 2e67  import shapely.g
+00000250: 656f 6d65 7472 7920 6173 2073 685f 6765  eometry as sh_ge
+00000260: 6f6d 0a0a 696d 706f 7274 2067 656f 6669  om..import geofi
+00000270: 6c65 6f70 7320 6173 2067 666f 0a66 726f  leops as gfo.fro
+00000280: 6d20 6765 6f66 696c 656f 7073 2069 6d70  m geofileops imp
+00000290: 6f72 7420 6669 6c65 6f70 730a 6672 6f6d  ort fileops.from
+000002a0: 2067 656f 6669 6c65 6f70 732e 7574 696c   geofileops.util
+000002b0: 2069 6d70 6f72 7420 5f67 656e 6572 616c   import _general
+000002c0: 5f75 7469 6c0a 6672 6f6d 2067 656f 6669  _util.from geofi
+000002d0: 6c65 6f70 732e 7574 696c 2069 6d70 6f72  leops.util impor
+000002e0: 7420 5f67 656f 6f70 735f 7371 6c0a 6672  t _geoops_sql.fr
 000002f0: 6f6d 2067 656f 6669 6c65 6f70 732e 7574  om geofileops.ut
-00000300: 696c 2069 6d70 6f72 7420 5f67 656f 6f70  il import _geoop
-00000310: 735f 7371 6c0d 0a66 726f 6d20 6765 6f66  s_sql..from geof
-00000320: 696c 656f 7073 2e75 7469 6c20 696d 706f  ileops.util impo
-00000330: 7274 205f 696f 5f75 7469 6c0d 0a66 726f  rt _io_util..fro
-00000340: 6d20 6765 6f66 696c 656f 7073 2e68 656c  m geofileops.hel
-00000350: 7065 7273 2069 6d70 6f72 7420 5f70 6172  pers import _par
-00000360: 616d 6574 6572 5f68 656c 7065 720d 0a66  ameter_helper..f
-00000370: 726f 6d20 6765 6f66 696c 656f 7073 2e75  rom geofileops.u
-00000380: 7469 6c20 696d 706f 7274 205f 7072 6f63  til import _proc
-00000390: 6573 7369 6e67 5f75 7469 6c0d 0a66 726f  essing_util..fro
-000003a0: 6d20 6765 6f66 696c 656f 7073 2e75 7469  m geofileops.uti
-000003b0: 6c2e 6765 6f6d 6574 7279 5f75 7469 6c20  l.geometry_util 
-000003c0: 696d 706f 7274 2047 656f 6d65 7472 7954  import GeometryT
-000003d0: 7970 652c 2050 7269 6d69 7469 7665 5479  ype, PrimitiveTy
-000003e0: 7065 2c20 5369 6d70 6c69 6679 416c 676f  pe, SimplifyAlgo
-000003f0: 7269 7468 6d0d 0a66 726f 6d20 6765 6f66  rithm..from geof
-00000400: 696c 656f 7073 2e75 7469 6c2e 6765 6f6d  ileops.util.geom
-00000410: 6574 7279 5f75 7469 6c20 696d 706f 7274  etry_util import
-00000420: 2042 7566 6665 7245 6e64 4361 7053 7479   BufferEndCapSty
-00000430: 6c65 2c20 4275 6666 6572 4a6f 696e 5374  le, BufferJoinSt
-00000440: 796c 650d 0a66 726f 6d20 6765 6f66 696c  yle..from geofil
-00000450: 656f 7073 2e75 7469 6c20 696d 706f 7274  eops.util import
-00000460: 2067 656f 7365 7269 6573 5f75 7469 6c0d   geoseries_util.
-00000470: 0a66 726f 6d20 6765 6f66 696c 656f 7073  .from geofileops
-00000480: 2e75 7469 6c20 696d 706f 7274 2067 7269  .util import gri
-00000490: 645f 7574 696c 0d0a 0d0a 2323 2323 2323  d_util....######
+00000300: 696c 2069 6d70 6f72 7420 5f69 6f5f 7574  il import _io_ut
+00000310: 696c 0a66 726f 6d20 6765 6f66 696c 656f  il.from geofileo
+00000320: 7073 2e68 656c 7065 7273 2069 6d70 6f72  ps.helpers impor
+00000330: 7420 5f70 6172 616d 6574 6572 5f68 656c  t _parameter_hel
+00000340: 7065 720a 6672 6f6d 2067 656f 6669 6c65  per.from geofile
+00000350: 6f70 732e 7574 696c 2069 6d70 6f72 7420  ops.util import 
+00000360: 5f70 726f 6365 7373 696e 675f 7574 696c  _processing_util
+00000370: 0a66 726f 6d20 6765 6f66 696c 656f 7073  .from geofileops
+00000380: 2e75 7469 6c2e 6765 6f6d 6574 7279 5f75  .util.geometry_u
+00000390: 7469 6c20 696d 706f 7274 2047 656f 6d65  til import Geome
+000003a0: 7472 7954 7970 652c 2050 7269 6d69 7469  tryType, Primiti
+000003b0: 7665 5479 7065 2c20 5369 6d70 6c69 6679  veType, Simplify
+000003c0: 416c 676f 7269 7468 6d0a 6672 6f6d 2067  Algorithm.from g
+000003d0: 656f 6669 6c65 6f70 732e 7574 696c 2e67  eofileops.util.g
+000003e0: 656f 6d65 7472 795f 7574 696c 2069 6d70  eometry_util imp
+000003f0: 6f72 7420 4275 6666 6572 456e 6443 6170  ort BufferEndCap
+00000400: 5374 796c 652c 2042 7566 6665 724a 6f69  Style, BufferJoi
+00000410: 6e53 7479 6c65 0a66 726f 6d20 6765 6f66  nStyle.from geof
+00000420: 696c 656f 7073 2e75 7469 6c20 696d 706f  ileops.util impo
+00000430: 7274 2067 656f 7365 7269 6573 5f75 7469  rt geoseries_uti
+00000440: 6c0a 6672 6f6d 2067 656f 6669 6c65 6f70  l.from geofileop
+00000450: 732e 7574 696c 2069 6d70 6f72 7420 6772  s.util import gr
+00000460: 6964 5f75 7469 6c0a 0a23 2323 2323 2323  id_util..#######
+00000470: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000480: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000490: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000004a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000004b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000004c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000004b0: 2323 2323 2323 2323 230a 2320 536f 6d65  #########.# Some
+000004c0: 2069 6e69 740a 2323 2323 2323 2323 2323   init.##########
 000004d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000004e0: 2323 2323 2323 2323 2323 0d0a 2320 536f  ##########..# So
-000004f0: 6d65 2069 6e69 740d 0a23 2323 2323 2323  me init..#######
+000004e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000004f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000500: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000510: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000520: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000530: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000540: 2323 2323 2323 2323 230d 0a0d 0a23 2044  #########....# D
-00000550: 6f6e 2774 2073 686f 7720 7468 6973 2067  on't show this g
-00000560: 656f 7061 6e64 6173 2077 6172 6e69 6e67  eopandas warning
-00000570: 2e2e 2e0d 0a77 6172 6e69 6e67 732e 6669  .....warnings.fi
-00000580: 6c74 6572 7761 726e 696e 6773 2822 6967  lterwarnings("ig
-00000590: 6e6f 7265 222c 2022 4765 6f53 6572 6965  nore", "GeoSerie
-000005a0: 732e 6973 6e61 222c 2055 7365 7257 6172  s.isna", UserWar
-000005b0: 6e69 6e67 290d 0a0d 0a6c 6f67 6765 7220  ning)....logger 
-000005c0: 3d20 6c6f 6767 696e 672e 6765 744c 6f67  = logging.getLog
-000005d0: 6765 7228 5f5f 6e61 6d65 5f5f 290d 0a0d  ger(__name__)...
-000005e0: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
-000005f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000600: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000510: 2323 2323 2323 0a0a 2320 446f 6e27 7420  ######..# Don't 
+00000520: 7368 6f77 2074 6869 7320 6765 6f70 616e  show this geopan
+00000530: 6461 7320 7761 726e 696e 672e 2e2e 0a77  das warning....w
+00000540: 6172 6e69 6e67 732e 6669 6c74 6572 7761  arnings.filterwa
+00000550: 726e 696e 6773 2822 6967 6e6f 7265 222c  rnings("ignore",
+00000560: 2022 4765 6f53 6572 6965 732e 6973 6e61   "GeoSeries.isna
+00000570: 222c 2055 7365 7257 6172 6e69 6e67 290a  ", UserWarning).
+00000580: 0a6c 6f67 6765 7220 3d20 6c6f 6767 696e  .logger = loggin
+00000590: 672e 6765 744c 6f67 6765 7228 5f5f 6e61  g.getLogger(__na
+000005a0: 6d65 5f5f 290a 0a23 2323 2323 2323 2323  me__)..#########
+000005b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000005c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000005d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000005e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000005f0: 2323 2323 2323 230a 2320 536f 6d65 2068  #######.# Some h
+00000600: 656c 7065 7220 6675 6e63 7469 6f6e 730a  elper functions.
 00000610: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000620: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000630: 230d 0a23 2053 6f6d 6520 6865 6c70 6572  #..# Some helper
-00000640: 2066 756e 6374 696f 6e73 0d0a 2323 2323   functions..####
+00000630: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000640: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000650: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000660: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000670: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000680: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000690: 2323 2323 2323 2323 2323 2323 0d0a 0d0a  ############....
-000006a0: 0d0a 636c 6173 7320 5061 7261 6c6c 656c  ..class Parallel
-000006b0: 697a 6174 696f 6e43 6f6e 6669 673a 0d0a  izationConfig:..
-000006c0: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
-000006d0: 280d 0a20 2020 2020 2020 2073 656c 662c  (..        self,
-000006e0: 0d0a 2020 2020 2020 2020 6279 7465 735f  ..        bytes_
-000006f0: 6261 7365 666f 6f74 7072 696e 743a 2069  basefootprint: i
-00000700: 6e74 203d 2035 3020 2a20 3130 3234 202a  nt = 50 * 1024 *
-00000710: 2031 3032 342c 0d0a 2020 2020 2020 2020   1024,..        
-00000720: 6279 7465 735f 7065 725f 726f 773a 2069  bytes_per_row: i
-00000730: 6e74 203d 2031 3030 2c0d 0a20 2020 2020  nt = 100,..     
-00000740: 2020 206d 696e 5f61 7667 5f72 6f77 735f     min_avg_rows_
-00000750: 7065 725f 6261 7463 683a 2069 6e74 203d  per_batch: int =
-00000760: 2031 3030 302c 0d0a 2020 2020 2020 2020   1000,..        
-00000770: 6d61 785f 6176 675f 726f 7773 5f70 6572  max_avg_rows_per
-00000780: 5f62 6174 6368 3a20 696e 7420 3d20 3130  _batch: int = 10
-00000790: 3030 302c 0d0a 2020 2020 2020 2020 6279  000,..        by
-000007a0: 7465 735f 6d69 6e5f 7065 725f 7072 6f63  tes_min_per_proc
-000007b0: 6573 733d 4e6f 6e65 2c0d 0a20 2020 2020  ess=None,..     
-000007c0: 2020 2062 7974 6573 5f75 7361 626c 653d     bytes_usable=
-000007d0: 4e6f 6e65 2c0d 0a20 2020 2029 3a0d 0a20  None,..    ):.. 
-000007e0: 2020 2020 2020 2073 656c 662e 6279 7465         self.byte
-000007f0: 735f 6261 7365 666f 6f74 7072 696e 7420  s_basefootprint 
-00000800: 3d20 6279 7465 735f 6261 7365 666f 6f74  = bytes_basefoot
-00000810: 7072 696e 740d 0a20 2020 2020 2020 2073  print..        s
-00000820: 656c 662e 6279 7465 735f 7065 725f 726f  elf.bytes_per_ro
-00000830: 7720 3d20 6279 7465 735f 7065 725f 726f  w = bytes_per_ro
-00000840: 770d 0a20 2020 2020 2020 2073 656c 662e  w..        self.
-00000850: 6d69 6e5f 6176 675f 726f 7773 5f70 6572  min_avg_rows_per
-00000860: 5f62 6174 6368 203d 206d 696e 5f61 7667  _batch = min_avg
-00000870: 5f72 6f77 735f 7065 725f 6261 7463 680d  _rows_per_batch.
-00000880: 0a20 2020 2020 2020 2073 656c 662e 6d61  .        self.ma
-00000890: 785f 6176 675f 726f 7773 5f70 6572 5f62  x_avg_rows_per_b
-000008a0: 6174 6368 203d 206d 6178 5f61 7667 5f72  atch = max_avg_r
-000008b0: 6f77 735f 7065 725f 6261 7463 680d 0a20  ows_per_batch.. 
-000008c0: 2020 2020 2020 2069 6620 6279 7465 735f         if bytes_
-000008d0: 6d69 6e5f 7065 725f 7072 6f63 6573 7320  min_per_process 
-000008e0: 6973 204e 6f6e 653a 0d0a 2020 2020 2020  is None:..      
-000008f0: 2020 2020 2020 7365 6c66 2e62 7974 6573        self.bytes
-00000900: 5f6d 696e 5f70 6572 5f70 726f 6365 7373  _min_per_process
-00000910: 203d 2028 0d0a 2020 2020 2020 2020 2020   = (..          
-00000920: 2020 2020 2020 6279 7465 735f 6261 7365        bytes_base
-00000930: 666f 6f74 7072 696e 7420 2b20 6279 7465  footprint + byte
-00000940: 735f 7065 725f 726f 7720 2a20 6d69 6e5f  s_per_row * min_
-00000950: 6176 675f 726f 7773 5f70 6572 5f62 6174  avg_rows_per_bat
-00000960: 6368 0d0a 2020 2020 2020 2020 2020 2020  ch..            
-00000970: 290d 0a20 2020 2020 2020 2065 6c73 653a  )..        else:
-00000980: 0d0a 2020 2020 2020 2020 2020 2020 7365  ..            se
-00000990: 6c66 2e62 7974 6573 5f6d 696e 5f70 6572  lf.bytes_min_per
-000009a0: 5f70 726f 6365 7373 203d 2062 7974 6573  _process = bytes
-000009b0: 5f6d 696e 5f70 6572 5f70 726f 6365 7373  _min_per_process
-000009c0: 0d0a 2020 2020 2020 2020 6966 2062 7974  ..        if byt
-000009d0: 6573 5f75 7361 626c 6520 6973 204e 6f6e  es_usable is Non
-000009e0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-000009f0: 7365 6c66 2e62 7974 6573 5f75 7361 626c  self.bytes_usabl
-00000a00: 6520 3d20 7073 7574 696c 2e76 6972 7475  e = psutil.virtu
-00000a10: 616c 5f6d 656d 6f72 7928 292e 6176 6169  al_memory().avai
-00000a20: 6c61 626c 6520 2a20 302e 390d 0a20 2020  lable * 0.9..   
-00000a30: 2020 2020 2065 6c73 653a 0d0a 2020 2020       else:..    
-00000a40: 2020 2020 2020 2020 7365 6c66 2e62 7974          self.byt
-00000a50: 6573 5f75 7361 626c 6520 3d20 6279 7465  es_usable = byte
-00000a60: 735f 7573 6162 6c65 0d0a 0d0a 0d0a 7061  s_usable......pa
-00000a70: 7261 6c6c 656c 697a 6174 696f 6e50 6172  rallelizationPar
-00000a80: 616d 7320 3d20 4e61 6d65 6454 7570 6c65  ams = NamedTuple
-00000a90: 280d 0a20 2020 2022 7265 7375 6c74 222c  (..    "result",
-00000aa0: 0d0a 2020 2020 5b28 226e 625f 7061 7261  ..    [("nb_para
-00000ab0: 6c6c 656c 222c 2069 6e74 292c 2028 226e  llel", int), ("n
-00000ac0: 625f 6261 7463 6865 735f 7265 636f 6d6d  b_batches_recomm
-00000ad0: 656e 6465 6422 2c20 696e 7429 2c20 2822  ended", int), ("
-00000ae0: 6e62 5f72 6f77 735f 7065 725f 6261 7463  nb_rows_per_batc
-00000af0: 6822 2c20 696e 7429 5d2c 0d0a 290d 0a0d  h", int)],..)...
-00000b00: 0a0d 0a64 6566 2067 6574 5f70 6172 616c  ...def get_paral
-00000b10: 6c65 6c69 7a61 7469 6f6e 5f70 6172 616d  lelization_param
-00000b20: 7328 0d0a 2020 2020 6e62 5f72 6f77 735f  s(..    nb_rows_
-00000b30: 746f 7461 6c3a 2069 6e74 2c0d 0a20 2020  total: int,..   
-00000b40: 206e 625f 7061 7261 6c6c 656c 3a20 696e   nb_parallel: in
-00000b50: 7420 3d20 2d31 2c0d 0a20 2020 206e 625f  t = -1,..    nb_
-00000b60: 6261 7463 6865 735f 7072 6576 696f 7573  batches_previous
-00000b70: 5f70 6173 733a 204f 7074 696f 6e61 6c5b  _pass: Optional[
-00000b80: 696e 745d 203d 204e 6f6e 652c 0d0a 2020  int] = None,..  
-00000b90: 2020 7061 7261 6c6c 656c 697a 6174 696f    parallelizatio
-00000ba0: 6e5f 636f 6e66 6967 3a20 4f70 7469 6f6e  n_config: Option
-00000bb0: 616c 5b50 6172 616c 6c65 6c69 7a61 7469  al[Parallelizati
-00000bc0: 6f6e 436f 6e66 6967 5d20 3d20 4e6f 6e65  onConfig] = None
-00000bd0: 2c0d 0a29 202d 3e20 7061 7261 6c6c 656c  ,..) -> parallel
-00000be0: 697a 6174 696f 6e50 6172 616d 733a 0d0a  izationParams:..
-00000bf0: 2020 2020 2222 220d 0a20 2020 2044 6574      """..    Det
-00000c00: 6572 6d69 6e65 7320 7265 636f 6d6d 656e  ermines recommen
-00000c10: 6465 6420 7061 7261 6c6c 656c 697a 6174  ded parallelizat
-00000c20: 696f 6e20 7061 7261 6d73 2e0d 0a0d 0a20  ion params..... 
-00000c30: 2020 2041 7267 733a 0d0a 2020 2020 2020     Args:..      
-00000c40: 2020 6e62 5f72 6f77 735f 746f 7461 6c20    nb_rows_total 
-00000c50: 2869 6e74 293a 2054 6865 2074 6f74 616c  (int): The total
-00000c60: 206e 756d 6265 7220 6f66 2072 6f77 7320   number of rows 
-00000c70: 7468 6174 2077 696c 6c20 6265 2070 726f  that will be pro
-00000c80: 6365 7373 6564 0d0a 2020 2020 2020 2020  cessed..        
-00000c90: 6e62 5f70 6172 616c 6c65 6c20 2869 6e74  nb_parallel (int
-00000ca0: 2c20 6f70 7469 6f6e 616c 293a 2054 6865  , optional): The
-00000cb0: 206c 6576 656c 206f 6620 7061 7261 6c6c   level of parall
-00000cc0: 656c 697a 6174 696f 6e20 7265 7175 6573  elization reques
-00000cd0: 7465 642e 0d0a 2020 2020 2020 2020 2020  ted...          
-00000ce0: 2020 4966 202d 312c 2074 7269 6573 2074    If -1, tries t
-00000cf0: 6f20 7573 6520 616c 6c20 7265 736f 7572  o use all resour
-00000d00: 6365 7320 6176 6169 6c61 626c 652e 2044  ces available. D
-00000d10: 6566 6175 6c74 7320 746f 202d 312e 0d0a  efaults to -1...
-00000d20: 2020 2020 2020 2020 6e62 5f62 6174 6368          nb_batch
-00000d30: 6573 5f70 7265 7669 6f75 735f 7061 7373  es_previous_pass
-00000d40: 2028 696e 742c 206f 7074 696f 6e61 6c29   (int, optional)
-00000d50: 3a20 4966 2061 7070 6c69 6361 626c 652c  : If applicable,
-00000d60: 2074 6865 206e 756d 6265 7220 6f66 2062   the number of b
-00000d70: 6174 6368 6573 0d0a 2020 2020 2020 2020  atches..        
-00000d80: 2020 2020 7573 6564 2069 6e20 6120 7072      used in a pr
-00000d90: 6576 696f 7573 2070 6173 7320 6f66 2074  evious pass of t
-00000da0: 6865 2063 616c 6375 6c61 7469 6f6e 2e20  he calculation. 
-00000db0: 4465 6661 756c 7473 2074 6f20 4e6f 6e65  Defaults to None
-00000dc0: 2e0d 0a0d 0a20 2020 2052 6574 7572 6e73  .....    Returns
-00000dd0: 3a0d 0a20 2020 2020 2020 2070 6172 616c  :..        paral
-00000de0: 6c65 6c69 7a61 7469 6f6e 5061 7261 6d73  lelizationParams
-00000df0: 3a20 5468 6520 7265 636f 6d6d 656e 6465  : The recommende
-00000e00: 6420 7061 7261 6d65 7465 7273 2e0d 0a20  d parameters... 
-00000e10: 2020 2022 2222 0d0a 2020 2020 2320 496e     """..    # In
-00000e20: 6974 2070 6172 616c 6c65 6c69 7a61 7469  it parallelizati
-00000e30: 6f6e 2063 6f6e 6669 670d 0a0d 0a20 2020  on config....   
-00000e40: 2023 2049 6620 636f 6e66 6967 2069 7320   # If config is 
-00000e50: 4e6f 6e65 2c20 7365 7420 746f 2065 6d70  None, set to emp
-00000e60: 7479 2064 6963 740d 0a20 2020 2069 6620  ty dict..    if 
-00000e70: 7061 7261 6c6c 656c 697a 6174 696f 6e5f  parallelization_
-00000e80: 636f 6e66 6967 2069 7320 6e6f 7420 4e6f  config is not No
-00000e90: 6e65 3a0d 0a20 2020 2020 2020 2070 6172  ne:..        par
-00000ea0: 616c 6c65 6c69 7a61 7469 6f6e 5f63 6f6e  allelization_con
-00000eb0: 6669 675f 6c6f 6361 6c20 3d20 7061 7261  fig_local = para
-00000ec0: 6c6c 656c 697a 6174 696f 6e5f 636f 6e66  llelization_conf
-00000ed0: 6967 0d0a 2020 2020 656c 7365 3a0d 0a20  ig..    else:.. 
-00000ee0: 2020 2020 2020 2070 6172 616c 6c65 6c69         paralleli
-00000ef0: 7a61 7469 6f6e 5f63 6f6e 6669 675f 6c6f  zation_config_lo
-00000f00: 6361 6c20 3d20 5061 7261 6c6c 656c 697a  cal = Paralleliz
-00000f10: 6174 696f 6e43 6f6e 6669 6728 290d 0a0d  ationConfig()...
-00000f20: 0a20 2020 2023 2049 6620 7468 6520 6e75  .    # If the nu
-00000f30: 6d62 6572 206f 6620 726f 7773 2069 7320  mber of rows is 
-00000f40: 7265 616c 6c79 206c 6f77 2c20 6a75 7374  really low, just
-00000f50: 2075 7365 206f 6e65 2062 6174 6368 0d0a   use one batch..
-00000f60: 2020 2020 2320 544f 444f 3a20 666f 7220      # TODO: for 
-00000f70: 7665 7279 2063 6f6d 706c 6578 2066 6561  very complex fea
-00000f80: 7475 7265 732c 2070 6f73 7369 626c 7920  tures, possibly 
-00000f90: 7468 6973 206c 696d 6974 2069 7320 6e6f  this limit is no
-00000fa0: 7420 6120 676f 6f64 2069 6465 610d 0a20  t a good idea.. 
-00000fb0: 2020 2069 6620 6e62 5f72 6f77 735f 746f     if nb_rows_to
-00000fc0: 7461 6c20 3c20 7061 7261 6c6c 656c 697a  tal < paralleliz
-00000fd0: 6174 696f 6e5f 636f 6e66 6967 5f6c 6f63  ation_config_loc
-00000fe0: 616c 2e6d 696e 5f61 7667 5f72 6f77 735f  al.min_avg_rows_
-00000ff0: 7065 725f 6261 7463 683a 0d0a 2020 2020  per_batch:..    
-00001000: 2020 2020 7265 7475 726e 2070 6172 616c      return paral
-00001010: 6c65 6c69 7a61 7469 6f6e 5061 7261 6d73  lelizationParams
-00001020: 2831 2c20 312c 206e 625f 726f 7773 5f74  (1, 1, nb_rows_t
-00001030: 6f74 616c 290d 0a0d 0a20 2020 2069 6620  otal)....    if 
-00001040: 6e62 5f70 6172 616c 6c65 6c20 3d3d 202d  nb_parallel == -
-00001050: 313a 0d0a 2020 2020 2020 2020 6e62 5f70  1:..        nb_p
-00001060: 6172 616c 6c65 6c20 3d20 6d75 6c74 6970  arallel = multip
-00001070: 726f 6365 7373 696e 672e 6370 755f 636f  rocessing.cpu_co
-00001080: 756e 7428 290d 0a0d 0a20 2020 206d 656d  unt()....    mem
-00001090: 5f75 7361 626c 6520 3d20 5f67 656e 6572  _usable = _gener
-000010a0: 616c 5f75 7469 6c2e 666f 726d 6174 6279  al_util.formatby
-000010b0: 7465 7328 7061 7261 6c6c 656c 697a 6174  tes(parallelizat
-000010c0: 696f 6e5f 636f 6e66 6967 5f6c 6f63 616c  ion_config_local
-000010d0: 2e62 7974 6573 5f75 7361 626c 6529 0d0a  .bytes_usable)..
-000010e0: 2020 2020 6c6f 6767 6572 2e64 6562 7567      logger.debug
-000010f0: 2866 226d 656d 6f72 795f 7573 6162 6c65  (f"memory_usable
-00001100: 3a20 7b6d 656d 5f75 7361 626c 657d 2c20  : {mem_usable}, 
-00001110: 7769 7468 3a22 290d 0a20 2020 206d 656d  with:")..    mem
-00001120: 5f61 7661 696c 6162 6c65 203d 205f 6765  _available = _ge
-00001130: 6e65 7261 6c5f 7574 696c 2e66 6f72 6d61  neral_util.forma
-00001140: 7462 7974 6573 2870 7375 7469 6c2e 7669  tbytes(psutil.vi
-00001150: 7274 7561 6c5f 6d65 6d6f 7279 2829 2e61  rtual_memory().a
-00001160: 7661 696c 6162 6c65 290d 0a20 2020 206c  vailable)..    l
-00001170: 6f67 6765 722e 6465 6275 6728 6622 2020  ogger.debug(f"  
-00001180: 2d3e 206d 656d 2e61 7661 696c 6162 6c65  -> mem.available
-00001190: 3a20 7b6d 656d 5f61 7661 696c 6162 6c65  : {mem_available
-000011a0: 7d22 290d 0a20 2020 2073 7761 705f 6672  }")..    swap_fr
-000011b0: 6565 203d 205f 6765 6e65 7261 6c5f 7574  ee = _general_ut
-000011c0: 696c 2e66 6f72 6d61 7462 7974 6573 2870  il.formatbytes(p
-000011d0: 7375 7469 6c2e 7377 6170 5f6d 656d 6f72  sutil.swap_memor
-000011e0: 7928 292e 6672 6565 290d 0a20 2020 206c  y().free)..    l
-000011f0: 6f67 6765 722e 6465 6275 6728 6622 2020  ogger.debug(f"  
-00001200: 2d3e 2073 7761 702e 6672 6565 3a20 7b73  -> swap.free: {s
-00001210: 7761 705f 6672 6565 7d22 290d 0a0d 0a20  wap_free}").... 
-00001220: 2020 2023 2049 6620 6e6f 7420 656e 6f75     # If not enou
-00001230: 6768 206d 656d 6f72 7920 666f 7220 7468  gh memory for th
-00001240: 6520 616d 6f75 6e74 206f 6620 7061 7261  e amount of para
-00001250: 6c6c 656c 6c69 736d 2061 736b 6564 2c20  llellism asked, 
-00001260: 7265 6475 6365 0d0a 2020 2020 6966 2028  reduce..    if (
-00001270: 0d0a 2020 2020 2020 2020 6e62 5f70 6172  ..        nb_par
-00001280: 616c 6c65 6c20 2a20 7061 7261 6c6c 656c  allel * parallel
-00001290: 697a 6174 696f 6e5f 636f 6e66 6967 5f6c  ization_config_l
-000012a0: 6f63 616c 2e62 7974 6573 5f6d 696e 5f70  ocal.bytes_min_p
-000012b0: 6572 5f70 726f 6365 7373 0d0a 2020 2020  er_process..    
-000012c0: 2920 3e20 7061 7261 6c6c 656c 697a 6174  ) > parallelizat
-000012d0: 696f 6e5f 636f 6e66 6967 5f6c 6f63 616c  ion_config_local
-000012e0: 2e62 7974 6573 5f75 7361 626c 653a 0d0a  .bytes_usable:..
-000012f0: 2020 2020 2020 2020 6e62 5f70 6172 616c          nb_paral
-00001300: 6c65 6c20 3d20 696e 7428 0d0a 2020 2020  lel = int(..    
-00001310: 2020 2020 2020 2020 7061 7261 6c6c 656c          parallel
-00001320: 697a 6174 696f 6e5f 636f 6e66 6967 5f6c  ization_config_l
-00001330: 6f63 616c 2e62 7974 6573 5f75 7361 626c  ocal.bytes_usabl
-00001340: 650d 0a20 2020 2020 2020 2020 2020 202f  e..            /
-00001350: 2070 6172 616c 6c65 6c69 7a61 7469 6f6e   parallelization
-00001360: 5f63 6f6e 6669 675f 6c6f 6361 6c2e 6279  _config_local.by
-00001370: 7465 735f 6d69 6e5f 7065 725f 7072 6f63  tes_min_per_proc
-00001380: 6573 730d 0a20 2020 2020 2020 2029 0d0a  ess..        )..
-00001390: 2020 2020 2020 2020 6c6f 6767 6572 2e64          logger.d
-000013a0: 6562 7567 2866 224e 625f 7061 7261 6c6c  ebug(f"Nb_parall
-000013b0: 656c 2072 6564 7563 6564 2074 6f20 7b6e  el reduced to {n
-000013c0: 625f 7061 7261 6c6c 656c 7d20 746f 2072  b_parallel} to r
-000013d0: 6564 7563 6520 6d65 6d6f 7279 2075 7361  educe memory usa
-000013e0: 6765 2229 0d0a 0d0a 2020 2020 2320 4f70  ge")....    # Op
-000013f0: 7469 6d61 6c20 6e75 6d62 6572 206f 6620  timal number of 
-00001400: 6261 7463 6865 7320 616e 6420 726f 7773  batches and rows
-00001410: 2070 6572 2062 6174 6368 2062 6173 6564   per batch based
-00001420: 206f 6e20 6d65 6d6f 7279 2075 7361 6765   on memory usage
-00001430: 0d0a 2020 2020 6e62 5f62 6174 6368 6573  ..    nb_batches
-00001440: 203d 206d 6174 682e 6365 696c 280d 0a20   = math.ceil(.. 
-00001450: 2020 2020 2020 2028 6e62 5f72 6f77 735f         (nb_rows_
-00001460: 746f 7461 6c20 2a20 7061 7261 6c6c 656c  total * parallel
-00001470: 697a 6174 696f 6e5f 636f 6e66 6967 5f6c  ization_config_l
-00001480: 6f63 616c 2e62 7974 6573 5f70 6572 5f72  ocal.bytes_per_r
-00001490: 6f77 202a 206e 625f 7061 7261 6c6c 656c  ow * nb_parallel
-000014a0: 290d 0a20 2020 2020 2020 202f 2028 0d0a  )..        / (..
-000014b0: 2020 2020 2020 2020 2020 2020 7061 7261              para
-000014c0: 6c6c 656c 697a 6174 696f 6e5f 636f 6e66  llelization_conf
-000014d0: 6967 5f6c 6f63 616c 2e62 7974 6573 5f75  ig_local.bytes_u
-000014e0: 7361 626c 650d 0a20 2020 2020 2020 2020  sable..         
-000014f0: 2020 202d 2070 6172 616c 6c65 6c69 7a61     - paralleliza
-00001500: 7469 6f6e 5f63 6f6e 6669 675f 6c6f 6361  tion_config_loca
-00001510: 6c2e 6279 7465 735f 6261 7365 666f 6f74  l.bytes_basefoot
-00001520: 7072 696e 7420 2a20 6e62 5f70 6172 616c  print * nb_paral
-00001530: 6c65 6c0d 0a20 2020 2020 2020 2029 0d0a  lel..        )..
-00001540: 2020 2020 290d 0a0d 0a20 2020 2023 204d      )....    # M
-00001550: 616b 6520 7375 7265 2074 6865 2061 7665  ake sure the ave
-00001560: 7261 6765 2062 6174 6368 2064 6f65 736e  rage batch doesn
-00001570: 2774 2063 6f6e 7461 696e 203e 206d 6178  't contain > max
-00001580: 5f61 7667 5f72 6f77 735f 7065 725f 6261  _avg_rows_per_ba
-00001590: 7463 680d 0a20 2020 2062 6174 6368 5f73  tch..    batch_s
-000015a0: 697a 6520 3d20 6d61 7468 2e63 6569 6c28  ize = math.ceil(
-000015b0: 6e62 5f72 6f77 735f 746f 7461 6c20 2f20  nb_rows_total / 
-000015c0: 6e62 5f62 6174 6368 6573 290d 0a20 2020  nb_batches)..   
-000015d0: 2069 6620 6261 7463 685f 7369 7a65 203e   if batch_size >
-000015e0: 2070 6172 616c 6c65 6c69 7a61 7469 6f6e   parallelization
-000015f0: 5f63 6f6e 6669 675f 6c6f 6361 6c2e 6d61  _config_local.ma
-00001600: 785f 6176 675f 726f 7773 5f70 6572 5f62  x_avg_rows_per_b
-00001610: 6174 6368 3a0d 0a20 2020 2020 2020 2062  atch:..        b
-00001620: 6174 6368 5f73 697a 6520 3d20 7061 7261  atch_size = para
-00001630: 6c6c 656c 697a 6174 696f 6e5f 636f 6e66  llelization_conf
-00001640: 6967 5f6c 6f63 616c 2e6d 6178 5f61 7667  ig_local.max_avg
-00001650: 5f72 6f77 735f 7065 725f 6261 7463 680d  _rows_per_batch.
-00001660: 0a20 2020 2020 2020 206e 625f 6261 7463  .        nb_batc
-00001670: 6865 7320 3d20 6d61 7468 2e63 6569 6c28  hes = math.ceil(
-00001680: 6e62 5f72 6f77 735f 746f 7461 6c20 2f20  nb_rows_total / 
-00001690: 6261 7463 685f 7369 7a65 290d 0a0d 0a20  batch_size).... 
-000016a0: 2020 206d 656d 5f70 7265 6469 6374 6564     mem_predicted
-000016b0: 203d 2028 0d0a 2020 2020 2020 2020 7061   = (..        pa
-000016c0: 7261 6c6c 656c 697a 6174 696f 6e5f 636f  rallelization_co
-000016d0: 6e66 6967 5f6c 6f63 616c 2e62 7974 6573  nfig_local.bytes
-000016e0: 5f62 6173 6566 6f6f 7470 7269 6e74 0d0a  _basefootprint..
-000016f0: 2020 2020 2020 2020 2b20 6261 7463 685f          + batch_
-00001700: 7369 7a65 202a 2070 6172 616c 6c65 6c69  size * paralleli
-00001710: 7a61 7469 6f6e 5f63 6f6e 6669 675f 6c6f  zation_config_lo
-00001720: 6361 6c2e 6279 7465 735f 7065 725f 726f  cal.bytes_per_ro
-00001730: 770d 0a20 2020 2029 202a 206e 625f 6261  w..    ) * nb_ba
-00001740: 7463 6865 730d 0a0d 0a20 2020 2023 204d  tches....    # M
-00001750: 616b 6520 7375 7265 2074 6865 7265 2061  ake sure there a
-00001760: 7265 2065 6e6f 7567 6820 6261 7463 6865  re enough batche
-00001770: 7320 746f 2075 7365 2061 7320 6d75 6368  s to use as much
-00001780: 2070 6172 616c 6c65 6c69 736d 2061 7320   parallelism as 
-00001790: 706f 7373 6962 6c65 0d0a 2020 2020 6966  possible..    if
-000017a0: 206e 625f 6261 7463 6865 7320 3e20 3120   nb_batches > 1 
-000017b0: 616e 6420 6e62 5f62 6174 6368 6573 203c  and nb_batches <
-000017c0: 206e 625f 7061 7261 6c6c 656c 3a0d 0a20   nb_parallel:.. 
-000017d0: 2020 2020 2020 206d 6178 5f70 6172 616c         max_paral
-000017e0: 6c65 6c5f 6261 7463 6873 697a 6520 3d20  lel_batchsize = 
-000017f0: 696e 7428 0d0a 2020 2020 2020 2020 2020  int(..          
-00001800: 2020 7061 7261 6c6c 656c 697a 6174 696f    parallelizatio
-00001810: 6e5f 636f 6e66 6967 5f6c 6f63 616c 2e6d  n_config_local.m
-00001820: 6178 5f61 7667 5f72 6f77 735f 7065 725f  ax_avg_rows_per_
-00001830: 6261 7463 680d 0a20 2020 2020 2020 2020  batch..         
-00001840: 2020 202a 206e 625f 6261 7463 6865 730d     * nb_batches.
-00001850: 0a20 2020 2020 2020 2020 2020 202f 2062  .            / b
-00001860: 6174 6368 5f73 697a 650d 0a20 2020 2020  atch_size..     
-00001870: 2020 2029 0d0a 2020 2020 2020 2020 6e62     )..        nb
-00001880: 5f70 6172 616c 6c65 6c20 3d20 6d69 6e28  _parallel = min(
-00001890: 6d61 785f 7061 7261 6c6c 656c 5f62 6174  max_parallel_bat
-000018a0: 6368 7369 7a65 2c20 6e62 5f70 6172 616c  chsize, nb_paral
-000018b0: 6c65 6c29 0d0a 2020 2020 2020 2020 6966  lel)..        if
-000018c0: 206e 625f 6261 7463 6865 735f 7072 6576   nb_batches_prev
-000018d0: 696f 7573 5f70 6173 7320 6973 204e 6f6e  ious_pass is Non
-000018e0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-000018f0: 6e62 5f62 6174 6368 6573 203d 2072 6f75  nb_batches = rou
-00001900: 6e64 286e 625f 7061 7261 6c6c 656c 202a  nd(nb_parallel *
-00001910: 2031 2e32 3529 0d0a 2020 2020 2020 2020   1.25)..        
-00001920: 656c 6966 206e 625f 6261 7463 6865 7320  elif nb_batches 
-00001930: 3c20 6e62 5f62 6174 6368 6573 5f70 7265  < nb_batches_pre
-00001940: 7669 6f75 735f 7061 7373 202f 2034 3a0d  vious_pass / 4:.
-00001950: 0a20 2020 2020 2020 2020 2020 206e 625f  .            nb_
-00001960: 6261 7463 6865 7320 3d20 726f 756e 6428  batches = round(
-00001970: 6e62 5f70 6172 616c 6c65 6c20 2a20 312e  nb_parallel * 1.
-00001980: 3235 290d 0a0d 0a20 2020 2062 6174 6368  25)....    batch
-00001990: 5f73 697a 6520 3d20 6d61 7468 2e63 6569  _size = math.cei
-000019a0: 6c28 6e62 5f72 6f77 735f 746f 7461 6c20  l(nb_rows_total 
-000019b0: 2f20 6e62 5f62 6174 6368 6573 290d 0a0d  / nb_batches)...
-000019c0: 0a20 2020 2023 204c 6f67 2072 6573 756c  .    # Log resul
-000019d0: 740d 0a20 2020 206c 6f67 6765 722e 6465  t..    logger.de
-000019e0: 6275 6728 6622 6e62 5f62 6174 6368 6573  bug(f"nb_batches
-000019f0: 5f72 6563 6f6d 6d65 6e64 6564 3a20 7b6e  _recommended: {n
-00001a00: 625f 6261 7463 6865 737d 2c20 726f 7773  b_batches}, rows
-00001a10: 5f70 6572 5f62 6174 6368 3a20 7b62 6174  _per_batch: {bat
-00001a20: 6368 5f73 697a 657d 2229 0d0a 2020 2020  ch_size}")..    
-00001a30: 6c6f 6767 6572 2e64 6562 7567 2866 2220  logger.debug(f" 
-00001a40: 2d3e 206e 625f 726f 7773 5f69 6e70 7574  -> nb_rows_input
-00001a50: 5f6c 6179 6572 3a20 7b6e 625f 726f 7773  _layer: {nb_rows
-00001a60: 5f74 6f74 616c 7d22 290d 0a20 2020 206c  _total}")..    l
-00001a70: 6f67 6765 722e 6465 6275 6728 6622 202d  ogger.debug(f" -
-00001a80: 3e20 6d65 6d5f 7072 6564 6963 7465 643a  > mem_predicted:
-00001a90: 207b 5f67 656e 6572 616c 5f75 7469 6c2e   {_general_util.
-00001aa0: 666f 726d 6174 6279 7465 7328 6d65 6d5f  formatbytes(mem_
-00001ab0: 7072 6564 6963 7465 6429 7d22 290d 0a0d  predicted)}")...
-00001ac0: 0a20 2020 2072 6574 7572 6e20 7061 7261  .    return para
-00001ad0: 6c6c 656c 697a 6174 696f 6e50 6172 616d  llelizationParam
-00001ae0: 7328 6e62 5f70 6172 616c 6c65 6c2c 206e  s(nb_parallel, n
-00001af0: 625f 6261 7463 6865 732c 2062 6174 6368  b_batches, batch
-00001b00: 5f73 697a 6529 0d0a 0d0a 0d0a 636c 6173  _size)......clas
-00001b10: 7320 4765 6f4f 7065 7261 7469 6f6e 2865  s GeoOperation(e
-00001b20: 6e75 6d2e 456e 756d 293a 0d0a 2020 2020  num.Enum):..    
-00001b30: 5349 4d50 4c49 4659 203d 2022 7369 6d70  SIMPLIFY = "simp
-00001b40: 6c69 6679 220d 0a20 2020 2042 5546 4645  lify"..    BUFFE
-00001b50: 5220 3d20 2262 7566 6665 7222 0d0a 2020  R = "buffer"..  
-00001b60: 2020 434f 4e56 4558 4855 4c4c 203d 2022    CONVEXHULL = "
-00001b70: 636f 6e76 6578 6875 6c6c 220d 0a20 2020  convexhull"..   
-00001b80: 2041 5050 4c59 203d 2022 6170 706c 7922   APPLY = "apply"
-00001b90: 0d0a 0d0a 0d0a 2323 2323 2323 2323 2323  ......##########
-00001ba0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001bb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001bc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001bd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001be0: 2323 2323 2323 0d0a 2320 5468 6520 7265  ######..# The re
-00001bf0: 616c 2073 7475 6666 0d0a 2323 2323 2323  al stuff..######
-00001c00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001c10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001c20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001c30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001c40: 2323 2323 2323 2323 2323 0d0a 0d0a 0d0a  ##########......
-00001c50: 6465 6620 6170 706c 7928 0d0a 2020 2020  def apply(..    
-00001c60: 696e 7075 745f 7061 7468 3a20 5061 7468  input_path: Path
-00001c70: 2c0d 0a20 2020 206f 7574 7075 745f 7061  ,..    output_pa
-00001c80: 7468 3a20 5061 7468 2c0d 0a20 2020 2066  th: Path,..    f
-00001c90: 756e 633a 2043 616c 6c61 626c 655b 5b41  unc: Callable[[A
-00001ca0: 6e79 5d2c 2041 6e79 5d2c 0d0a 2020 2020  ny], Any],..    
-00001cb0: 6f6e 6c79 5f67 656f 6d5f 696e 7075 743a  only_geom_input:
-00001cc0: 2062 6f6f 6c20 3d20 5472 7565 2c0d 0a20   bool = True,.. 
-00001cd0: 2020 2069 6e70 7574 5f6c 6179 6572 3a20     input_layer: 
-00001ce0: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
-00001cf0: 4e6f 6e65 2c0d 0a20 2020 206f 7574 7075  None,..    outpu
-00001d00: 745f 6c61 7965 723a 204f 7074 696f 6e61  t_layer: Optiona
-00001d10: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
-00001d20: 2020 2020 636f 6c75 6d6e 733a 204f 7074      columns: Opt
-00001d30: 696f 6e61 6c5b 4c69 7374 5b73 7472 5d5d  ional[List[str]]
-00001d40: 203d 204e 6f6e 652c 0d0a 2020 2020 6578   = None,..    ex
-00001d50: 706c 6f64 6563 6f6c 6c65 6374 696f 6e73  plodecollections
-00001d60: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-00001d70: 0a20 2020 2066 6f72 6365 5f6f 7574 7075  .    force_outpu
-00001d80: 745f 6765 6f6d 6574 7279 7479 7065 3a20  t_geometrytype: 
-00001d90: 556e 696f 6e5b 4765 6f6d 6574 7279 5479  Union[GeometryTy
-00001da0: 7065 2c20 7374 722c 204e 6f6e 655d 203d  pe, str, None] =
-00001db0: 204e 6f6e 652c 0d0a 2020 2020 6e62 5f70   None,..    nb_p
-00001dc0: 6172 616c 6c65 6c3a 2069 6e74 203d 202d  arallel: int = -
-00001dd0: 312c 0d0a 2020 2020 6261 7463 6873 697a  1,..    batchsiz
-00001de0: 653a 2069 6e74 203d 202d 312c 0d0a 2020  e: int = -1,..  
-00001df0: 2020 666f 7263 653a 2062 6f6f 6c20 3d20    force: bool = 
-00001e00: 4661 6c73 652c 0d0a 293a 0d0a 2020 2020  False,..):..    
-00001e10: 2320 496e 6974 0d0a 2020 2020 6f70 6572  # Init..    oper
-00001e20: 6174 696f 6e5f 7061 7261 6d73 203d 207b  ation_params = {
-00001e30: 0d0a 2020 2020 2020 2020 226f 6e6c 795f  ..        "only_
-00001e40: 6765 6f6d 5f69 6e70 7574 223a 206f 6e6c  geom_input": onl
-00001e50: 795f 6765 6f6d 5f69 6e70 7574 2c0d 0a20  y_geom_input,.. 
-00001e60: 2020 2020 2020 2022 7069 636b 6c65 645f         "pickled_
-00001e70: 6675 6e63 223a 2063 6c6f 7564 7069 636b  func": cloudpick
-00001e80: 6c65 2e64 756d 7073 2866 756e 6329 2c0d  le.dumps(func),.
-00001e90: 0a20 2020 207d 0d0a 0d0a 2020 2020 2320  .    }....    # 
-00001ea0: 476f 210d 0a20 2020 2072 6574 7572 6e20  Go!..    return 
-00001eb0: 5f61 7070 6c79 5f67 656f 6f70 6572 6174  _apply_geooperat
-00001ec0: 696f 6e5f 746f 5f6c 6179 6572 280d 0a20  ion_to_layer(.. 
-00001ed0: 2020 2020 2020 2069 6e70 7574 5f70 6174         input_pat
-00001ee0: 683d 696e 7075 745f 7061 7468 2c0d 0a20  h=input_path,.. 
-00001ef0: 2020 2020 2020 206f 7574 7075 745f 7061         output_pa
-00001f00: 7468 3d6f 7574 7075 745f 7061 7468 2c0d  th=output_path,.
-00001f10: 0a20 2020 2020 2020 206f 7065 7261 7469  .        operati
-00001f20: 6f6e 3d47 656f 4f70 6572 6174 696f 6e2e  on=GeoOperation.
-00001f30: 4150 504c 592c 0d0a 2020 2020 2020 2020  APPLY,..        
-00001f40: 6f70 6572 6174 696f 6e5f 7061 7261 6d73  operation_params
-00001f50: 3d6f 7065 7261 7469 6f6e 5f70 6172 616d  =operation_param
-00001f60: 732c 0d0a 2020 2020 2020 2020 696e 7075  s,..        inpu
-00001f70: 745f 6c61 7965 723d 696e 7075 745f 6c61  t_layer=input_la
-00001f80: 7965 722c 0d0a 2020 2020 2020 2020 6f75  yer,..        ou
-00001f90: 7470 7574 5f6c 6179 6572 3d6f 7574 7075  tput_layer=outpu
-00001fa0: 745f 6c61 7965 722c 0d0a 2020 2020 2020  t_layer,..      
-00001fb0: 2020 636f 6c75 6d6e 733d 636f 6c75 6d6e    columns=column
-00001fc0: 732c 0d0a 2020 2020 2020 2020 6578 706c  s,..        expl
-00001fd0: 6f64 6563 6f6c 6c65 6374 696f 6e73 3d65  odecollections=e
-00001fe0: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
-00001ff0: 732c 0d0a 2020 2020 2020 2020 666f 7263  s,..        forc
-00002000: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-00002010: 7974 7970 653d 666f 7263 655f 6f75 7470  ytype=force_outp
-00002020: 7574 5f67 656f 6d65 7472 7974 7970 652c  ut_geometrytype,
-00002030: 0d0a 2020 2020 2020 2020 6e62 5f70 6172  ..        nb_par
-00002040: 616c 6c65 6c3d 6e62 5f70 6172 616c 6c65  allel=nb_paralle
-00002050: 6c2c 0d0a 2020 2020 2020 2020 6261 7463  l,..        batc
-00002060: 6873 697a 653d 6261 7463 6873 697a 652c  hsize=batchsize,
-00002070: 0d0a 2020 2020 2020 2020 666f 7263 653d  ..        force=
-00002080: 666f 7263 652c 0d0a 2020 2020 290d 0a0d  force,..    )...
-00002090: 0a0d 0a64 6566 2062 7566 6665 7228 0d0a  ...def buffer(..
-000020a0: 2020 2020 696e 7075 745f 7061 7468 3a20      input_path: 
-000020b0: 5061 7468 2c0d 0a20 2020 206f 7574 7075  Path,..    outpu
-000020c0: 745f 7061 7468 3a20 5061 7468 2c0d 0a20  t_path: Path,.. 
-000020d0: 2020 2064 6973 7461 6e63 653a 2066 6c6f     distance: flo
-000020e0: 6174 2c0d 0a20 2020 2071 7561 6472 616e  at,..    quadran
-000020f0: 7473 6567 6d65 6e74 733a 2069 6e74 203d  tsegments: int =
-00002100: 2035 2c0d 0a20 2020 2065 6e64 6361 705f   5,..    endcap_
-00002110: 7374 796c 653a 2042 7566 6665 7245 6e64  style: BufferEnd
-00002120: 4361 7053 7479 6c65 203d 2042 7566 6665  CapStyle = Buffe
-00002130: 7245 6e64 4361 7053 7479 6c65 2e52 4f55  rEndCapStyle.ROU
-00002140: 4e44 2c0d 0a20 2020 206a 6f69 6e5f 7374  ND,..    join_st
-00002150: 796c 653a 2042 7566 6665 724a 6f69 6e53  yle: BufferJoinS
-00002160: 7479 6c65 203d 2042 7566 6665 724a 6f69  tyle = BufferJoi
-00002170: 6e53 7479 6c65 2e52 4f55 4e44 2c0d 0a20  nStyle.ROUND,.. 
-00002180: 2020 206d 6974 7265 5f6c 696d 6974 3a20     mitre_limit: 
-00002190: 666c 6f61 7420 3d20 352e 302c 0d0a 2020  float = 5.0,..  
-000021a0: 2020 7369 6e67 6c65 5f73 6964 6564 3a20    single_sided: 
-000021b0: 626f 6f6c 203d 2046 616c 7365 2c0d 0a20  bool = False,.. 
-000021c0: 2020 2069 6e70 7574 5f6c 6179 6572 3a20     input_layer: 
-000021d0: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
-000021e0: 4e6f 6e65 2c0d 0a20 2020 206f 7574 7075  None,..    outpu
-000021f0: 745f 6c61 7965 723a 204f 7074 696f 6e61  t_layer: Optiona
-00002200: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
-00002210: 2020 2020 636f 6c75 6d6e 733a 204f 7074      columns: Opt
-00002220: 696f 6e61 6c5b 4c69 7374 5b73 7472 5d5d  ional[List[str]]
-00002230: 203d 204e 6f6e 652c 0d0a 2020 2020 6578   = None,..    ex
-00002240: 706c 6f64 6563 6f6c 6c65 6374 696f 6e73  plodecollections
-00002250: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-00002260: 0a20 2020 206e 625f 7061 7261 6c6c 656c  .    nb_parallel
-00002270: 3a20 696e 7420 3d20 2d31 2c0d 0a20 2020  : int = -1,..   
-00002280: 2062 6174 6368 7369 7a65 3a20 696e 7420   batchsize: int 
-00002290: 3d20 2d31 2c0d 0a20 2020 2066 6f72 6365  = -1,..    force
-000022a0: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-000022b0: 0a29 3a0d 0a20 2020 2023 2049 6e69 740d  .):..    # Init.
-000022c0: 0a20 2020 206f 7065 7261 7469 6f6e 5f70  .    operation_p
-000022d0: 6172 616d 7320 3d20 7b0d 0a20 2020 2020  arams = {..     
-000022e0: 2020 2022 6469 7374 616e 6365 223a 2064     "distance": d
-000022f0: 6973 7461 6e63 652c 0d0a 2020 2020 2020  istance,..      
-00002300: 2020 2271 7561 6472 616e 7473 6567 6d65    "quadrantsegme
-00002310: 6e74 7322 3a20 7175 6164 7261 6e74 7365  nts": quadrantse
-00002320: 676d 656e 7473 2c0d 0a20 2020 2020 2020  gments,..       
-00002330: 2022 656e 6463 6170 5f73 7479 6c65 223a   "endcap_style":
-00002340: 2065 6e64 6361 705f 7374 796c 652c 0d0a   endcap_style,..
-00002350: 2020 2020 2020 2020 226a 6f69 6e5f 7374          "join_st
-00002360: 796c 6522 3a20 6a6f 696e 5f73 7479 6c65  yle": join_style
-00002370: 2c0d 0a20 2020 2020 2020 2022 6d69 7472  ,..        "mitr
-00002380: 655f 6c69 6d69 7422 3a20 6d69 7472 655f  e_limit": mitre_
-00002390: 6c69 6d69 742c 0d0a 2020 2020 2020 2020  limit,..        
-000023a0: 2273 696e 676c 655f 7369 6465 6422 3a20  "single_sided": 
-000023b0: 7369 6e67 6c65 5f73 6964 6564 2c0d 0a20  single_sided,.. 
-000023c0: 2020 207d 0d0a 0d0a 2020 2020 2320 4275     }....    # Bu
-000023d0: 6666 6572 206f 7065 7261 7469 6f6e 2061  ffer operation a
-000023e0: 6c77 6179 7320 7265 7375 6c74 7320 696e  lways results in
-000023f0: 2070 6f6c 7967 6f6e 732e 2e2e 0d0a 2020   polygons.....  
-00002400: 2020 6966 2065 7870 6c6f 6465 636f 6c6c    if explodecoll
-00002410: 6563 7469 6f6e 733a 0d0a 2020 2020 2020  ections:..      
-00002420: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
-00002430: 656f 6d65 7472 7974 7970 6520 3d20 4765  eometrytype = Ge
-00002440: 6f6d 6574 7279 5479 7065 2e50 4f4c 5947  ometryType.POLYG
-00002450: 4f4e 2e6e 616d 650d 0a20 2020 2065 6c73  ON.name..    els
-00002460: 653a 0d0a 2020 2020 2020 2020 666f 7263  e:..        forc
-00002470: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-00002480: 7974 7970 6520 3d20 4765 6f6d 6574 7279  ytype = Geometry
-00002490: 5479 7065 2e4d 554c 5449 504f 4c59 474f  Type.MULTIPOLYGO
-000024a0: 4e2e 6e61 6d65 0d0a 0d0a 2020 2020 2320  N.name....    # 
-000024b0: 476f 210d 0a20 2020 2072 6574 7572 6e20  Go!..    return 
-000024c0: 5f61 7070 6c79 5f67 656f 6f70 6572 6174  _apply_geooperat
-000024d0: 696f 6e5f 746f 5f6c 6179 6572 280d 0a20  ion_to_layer(.. 
-000024e0: 2020 2020 2020 2069 6e70 7574 5f70 6174         input_pat
-000024f0: 683d 696e 7075 745f 7061 7468 2c0d 0a20  h=input_path,.. 
-00002500: 2020 2020 2020 206f 7574 7075 745f 7061         output_pa
-00002510: 7468 3d6f 7574 7075 745f 7061 7468 2c0d  th=output_path,.
-00002520: 0a20 2020 2020 2020 206f 7065 7261 7469  .        operati
-00002530: 6f6e 3d47 656f 4f70 6572 6174 696f 6e2e  on=GeoOperation.
-00002540: 4255 4646 4552 2c0d 0a20 2020 2020 2020  BUFFER,..       
-00002550: 206f 7065 7261 7469 6f6e 5f70 6172 616d   operation_param
-00002560: 733d 6f70 6572 6174 696f 6e5f 7061 7261  s=operation_para
-00002570: 6d73 2c0d 0a20 2020 2020 2020 2069 6e70  ms,..        inp
-00002580: 7574 5f6c 6179 6572 3d69 6e70 7574 5f6c  ut_layer=input_l
-00002590: 6179 6572 2c0d 0a20 2020 2020 2020 206f  ayer,..        o
-000025a0: 7574 7075 745f 6c61 7965 723d 6f75 7470  utput_layer=outp
-000025b0: 7574 5f6c 6179 6572 2c0d 0a20 2020 2020  ut_layer,..     
-000025c0: 2020 2063 6f6c 756d 6e73 3d63 6f6c 756d     columns=colum
-000025d0: 6e73 2c0d 0a20 2020 2020 2020 2065 7870  ns,..        exp
-000025e0: 6c6f 6465 636f 6c6c 6563 7469 6f6e 733d  lodecollections=
-000025f0: 6578 706c 6f64 6563 6f6c 6c65 6374 696f  explodecollectio
-00002600: 6e73 2c0d 0a20 2020 2020 2020 2066 6f72  ns,..        for
-00002610: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-00002620: 7279 7479 7065 3d66 6f72 6365 5f6f 7574  rytype=force_out
-00002630: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
-00002640: 2c0d 0a20 2020 2020 2020 206e 625f 7061  ,..        nb_pa
-00002650: 7261 6c6c 656c 3d6e 625f 7061 7261 6c6c  rallel=nb_parall
-00002660: 656c 2c0d 0a20 2020 2020 2020 2062 6174  el,..        bat
-00002670: 6368 7369 7a65 3d62 6174 6368 7369 7a65  chsize=batchsize
-00002680: 2c0d 0a20 2020 2020 2020 2066 6f72 6365  ,..        force
-00002690: 3d66 6f72 6365 2c0d 0a20 2020 2029 0d0a  =force,..    )..
-000026a0: 0d0a 0d0a 6465 6620 636f 6e76 6578 6875  ....def convexhu
-000026b0: 6c6c 280d 0a20 2020 2069 6e70 7574 5f70  ll(..    input_p
-000026c0: 6174 683a 2050 6174 682c 0d0a 2020 2020  ath: Path,..    
-000026d0: 6f75 7470 7574 5f70 6174 683a 2050 6174  output_path: Pat
-000026e0: 682c 0d0a 2020 2020 696e 7075 745f 6c61  h,..    input_la
-000026f0: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
-00002700: 725d 203d 204e 6f6e 652c 0d0a 2020 2020  r] = None,..    
-00002710: 6f75 7470 7574 5f6c 6179 6572 3a20 4f70  output_layer: Op
-00002720: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
-00002730: 6e65 2c0d 0a20 2020 2063 6f6c 756d 6e73  ne,..    columns
-00002740: 3a20 4f70 7469 6f6e 616c 5b4c 6973 745b  : Optional[List[
-00002750: 7374 725d 5d20 3d20 4e6f 6e65 2c0d 0a20  str]] = None,.. 
-00002760: 2020 2065 7870 6c6f 6465 636f 6c6c 6563     explodecollec
-00002770: 7469 6f6e 733a 2062 6f6f 6c20 3d20 4661  tions: bool = Fa
-00002780: 6c73 652c 0d0a 2020 2020 6e62 5f70 6172  lse,..    nb_par
-00002790: 616c 6c65 6c3a 2069 6e74 203d 202d 312c  allel: int = -1,
-000027a0: 0d0a 2020 2020 6261 7463 6873 697a 653a  ..    batchsize:
-000027b0: 2069 6e74 203d 202d 312c 0d0a 2020 2020   int = -1,..    
-000027c0: 666f 7263 653a 2062 6f6f 6c20 3d20 4661  force: bool = Fa
-000027d0: 6c73 652c 0d0a 293a 0d0a 2020 2020 2320  lse,..):..    # 
-000027e0: 496e 6974 0d0a 2020 2020 6f70 6572 6174  Init..    operat
-000027f0: 696f 6e5f 7061 7261 6d73 203d 207b 7d0d  ion_params = {}.
-00002800: 0a0d 0a20 2020 2023 2047 6f21 0d0a 2020  ...    # Go!..  
-00002810: 2020 7265 7475 726e 205f 6170 706c 795f    return _apply_
-00002820: 6765 6f6f 7065 7261 7469 6f6e 5f74 6f5f  geooperation_to_
-00002830: 6c61 7965 7228 0d0a 2020 2020 2020 2020  layer(..        
-00002840: 696e 7075 745f 7061 7468 3d69 6e70 7574  input_path=input
-00002850: 5f70 6174 682c 0d0a 2020 2020 2020 2020  _path,..        
-00002860: 6f75 7470 7574 5f70 6174 683d 6f75 7470  output_path=outp
-00002870: 7574 5f70 6174 682c 0d0a 2020 2020 2020  ut_path,..      
-00002880: 2020 6f70 6572 6174 696f 6e3d 4765 6f4f    operation=GeoO
-00002890: 7065 7261 7469 6f6e 2e43 4f4e 5645 5848  peration.CONVEXH
-000028a0: 554c 4c2c 0d0a 2020 2020 2020 2020 6f70  ULL,..        op
-000028b0: 6572 6174 696f 6e5f 7061 7261 6d73 3d6f  eration_params=o
-000028c0: 7065 7261 7469 6f6e 5f70 6172 616d 732c  peration_params,
-000028d0: 0d0a 2020 2020 2020 2020 696e 7075 745f  ..        input_
-000028e0: 6c61 7965 723d 696e 7075 745f 6c61 7965  layer=input_laye
-000028f0: 722c 0d0a 2020 2020 2020 2020 6f75 7470  r,..        outp
-00002900: 7574 5f6c 6179 6572 3d6f 7574 7075 745f  ut_layer=output_
-00002910: 6c61 7965 722c 0d0a 2020 2020 2020 2020  layer,..        
-00002920: 636f 6c75 6d6e 733d 636f 6c75 6d6e 732c  columns=columns,
-00002930: 0d0a 2020 2020 2020 2020 6578 706c 6f64  ..        explod
-00002940: 6563 6f6c 6c65 6374 696f 6e73 3d65 7870  ecollections=exp
-00002950: 6c6f 6465 636f 6c6c 6563 7469 6f6e 732c  lodecollections,
-00002960: 0d0a 2020 2020 2020 2020 6e62 5f70 6172  ..        nb_par
-00002970: 616c 6c65 6c3d 6e62 5f70 6172 616c 6c65  allel=nb_paralle
-00002980: 6c2c 0d0a 2020 2020 2020 2020 6261 7463  l,..        batc
-00002990: 6873 697a 653d 6261 7463 6873 697a 652c  hsize=batchsize,
-000029a0: 0d0a 2020 2020 2020 2020 666f 7263 653d  ..        force=
-000029b0: 666f 7263 652c 0d0a 2020 2020 290d 0a0d  force,..    )...
-000029c0: 0a0d 0a64 6566 2073 696d 706c 6966 7928  ...def simplify(
-000029d0: 0d0a 2020 2020 696e 7075 745f 7061 7468  ..    input_path
-000029e0: 3a20 5061 7468 2c0d 0a20 2020 206f 7574  : Path,..    out
-000029f0: 7075 745f 7061 7468 3a20 5061 7468 2c0d  put_path: Path,.
-00002a00: 0a20 2020 2074 6f6c 6572 616e 6365 3a20  .    tolerance: 
-00002a10: 666c 6f61 742c 0d0a 2020 2020 616c 676f  float,..    algo
-00002a20: 7269 7468 6d3a 2053 696d 706c 6966 7941  rithm: SimplifyA
-00002a30: 6c67 6f72 6974 686d 203d 2053 696d 706c  lgorithm = Simpl
-00002a40: 6966 7941 6c67 6f72 6974 686d 2e52 414d  ifyAlgorithm.RAM
-00002a50: 4552 5f44 4f55 474c 4153 5f50 4555 434b  ER_DOUGLAS_PEUCK
-00002a60: 4552 2c0d 0a20 2020 206c 6f6f 6b61 6865  ER,..    lookahe
-00002a70: 6164 3a20 696e 7420 3d20 382c 0d0a 2020  ad: int = 8,..  
-00002a80: 2020 696e 7075 745f 6c61 7965 723a 204f    input_layer: O
-00002a90: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
-00002aa0: 6f6e 652c 0d0a 2020 2020 6f75 7470 7574  one,..    output
-00002ab0: 5f6c 6179 6572 3a20 4f70 7469 6f6e 616c  _layer: Optional
-00002ac0: 5b73 7472 5d20 3d20 4e6f 6e65 2c0d 0a20  [str] = None,.. 
-00002ad0: 2020 2063 6f6c 756d 6e73 3a20 4f70 7469     columns: Opti
-00002ae0: 6f6e 616c 5b4c 6973 745b 7374 725d 5d20  onal[List[str]] 
-00002af0: 3d20 4e6f 6e65 2c0d 0a20 2020 2065 7870  = None,..    exp
-00002b00: 6c6f 6465 636f 6c6c 6563 7469 6f6e 733a  lodecollections:
-00002b10: 2062 6f6f 6c20 3d20 4661 6c73 652c 0d0a   bool = False,..
-00002b20: 2020 2020 6e62 5f70 6172 616c 6c65 6c3a      nb_parallel:
-00002b30: 2069 6e74 203d 202d 312c 0d0a 2020 2020   int = -1,..    
-00002b40: 6261 7463 6873 697a 653a 2069 6e74 203d  batchsize: int =
-00002b50: 202d 312c 0d0a 2020 2020 666f 7263 653a   -1,..    force:
-00002b60: 2062 6f6f 6c20 3d20 4661 6c73 652c 0d0a   bool = False,..
-00002b70: 293a 0d0a 2020 2020 2320 496e 6974 0d0a  ):..    # Init..
-00002b80: 2020 2020 6f70 6572 6174 696f 6e5f 7061      operation_pa
-00002b90: 7261 6d73 203d 207b 0d0a 2020 2020 2020  rams = {..      
-00002ba0: 2020 2274 6f6c 6572 616e 6365 223a 2074    "tolerance": t
-00002bb0: 6f6c 6572 616e 6365 2c0d 0a20 2020 2020  olerance,..     
-00002bc0: 2020 2022 616c 676f 7269 7468 6d22 3a20     "algorithm": 
-00002bd0: 616c 676f 7269 7468 6d2c 0d0a 2020 2020  algorithm,..    
-00002be0: 2020 2020 2273 7465 7022 3a20 6c6f 6f6b      "step": look
-00002bf0: 6168 6561 642c 0d0a 2020 2020 7d0d 0a0d  ahead,..    }...
-00002c00: 0a20 2020 2023 2047 6f21 0d0a 2020 2020  .    # Go!..    
-00002c10: 7265 7475 726e 205f 6170 706c 795f 6765  return _apply_ge
-00002c20: 6f6f 7065 7261 7469 6f6e 5f74 6f5f 6c61  ooperation_to_la
-00002c30: 7965 7228 0d0a 2020 2020 2020 2020 696e  yer(..        in
-00002c40: 7075 745f 7061 7468 3d69 6e70 7574 5f70  put_path=input_p
-00002c50: 6174 682c 0d0a 2020 2020 2020 2020 6f75  ath,..        ou
-00002c60: 7470 7574 5f70 6174 683d 6f75 7470 7574  tput_path=output
-00002c70: 5f70 6174 682c 0d0a 2020 2020 2020 2020  _path,..        
-00002c80: 6f70 6572 6174 696f 6e3d 4765 6f4f 7065  operation=GeoOpe
-00002c90: 7261 7469 6f6e 2e53 494d 504c 4946 592c  ration.SIMPLIFY,
-00002ca0: 0d0a 2020 2020 2020 2020 6f70 6572 6174  ..        operat
-00002cb0: 696f 6e5f 7061 7261 6d73 3d6f 7065 7261  ion_params=opera
-00002cc0: 7469 6f6e 5f70 6172 616d 732c 0d0a 2020  tion_params,..  
-00002cd0: 2020 2020 2020 696e 7075 745f 6c61 7965        input_laye
-00002ce0: 723d 696e 7075 745f 6c61 7965 722c 0d0a  r=input_layer,..
-00002cf0: 2020 2020 2020 2020 6f75 7470 7574 5f6c          output_l
-00002d00: 6179 6572 3d6f 7574 7075 745f 6c61 7965  ayer=output_laye
-00002d10: 722c 0d0a 2020 2020 2020 2020 636f 6c75  r,..        colu
-00002d20: 6d6e 733d 636f 6c75 6d6e 732c 0d0a 2020  mns=columns,..  
-00002d30: 2020 2020 2020 6578 706c 6f64 6563 6f6c        explodecol
-00002d40: 6c65 6374 696f 6e73 3d65 7870 6c6f 6465  lections=explode
-00002d50: 636f 6c6c 6563 7469 6f6e 732c 0d0a 2020  collections,..  
-00002d60: 2020 2020 2020 6e62 5f70 6172 616c 6c65        nb_paralle
-00002d70: 6c3d 6e62 5f70 6172 616c 6c65 6c2c 0d0a  l=nb_parallel,..
-00002d80: 2020 2020 2020 2020 6261 7463 6873 697a          batchsiz
-00002d90: 653d 6261 7463 6873 697a 652c 0d0a 2020  e=batchsize,..  
-00002da0: 2020 2020 2020 666f 7263 653d 666f 7263        force=forc
-00002db0: 652c 0d0a 2020 2020 290d 0a0d 0a0d 0a64  e,..    )......d
-00002dc0: 6566 205f 6170 706c 795f 6765 6f6f 7065  ef _apply_geoope
-00002dd0: 7261 7469 6f6e 5f74 6f5f 6c61 7965 7228  ration_to_layer(
-00002de0: 0d0a 2020 2020 696e 7075 745f 7061 7468  ..    input_path
-00002df0: 3a20 5061 7468 2c0d 0a20 2020 206f 7574  : Path,..    out
-00002e00: 7075 745f 7061 7468 3a20 5061 7468 2c0d  put_path: Path,.
-00002e10: 0a20 2020 206f 7065 7261 7469 6f6e 3a20  .    operation: 
-00002e20: 4765 6f4f 7065 7261 7469 6f6e 2c0d 0a20  GeoOperation,.. 
-00002e30: 2020 206f 7065 7261 7469 6f6e 5f70 6172     operation_par
-00002e40: 616d 733a 2064 6963 742c 0d0a 2020 2020  ams: dict,..    
-00002e50: 696e 7075 745f 6c61 7965 723a 204f 7074  input_layer: Opt
-00002e60: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
-00002e70: 652c 0d0a 2020 2020 636f 6c75 6d6e 733a  e,..    columns:
-00002e80: 204f 7074 696f 6e61 6c5b 4c69 7374 5b73   Optional[List[s
-00002e90: 7472 5d5d 203d 204e 6f6e 652c 0d0a 2020  tr]] = None,..  
-00002ea0: 2020 6f75 7470 7574 5f6c 6179 6572 3a20    output_layer: 
-00002eb0: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
-00002ec0: 4e6f 6e65 2c0d 0a20 2020 2065 7870 6c6f  None,..    explo
-00002ed0: 6465 636f 6c6c 6563 7469 6f6e 733a 2062  decollections: b
-00002ee0: 6f6f 6c20 3d20 4661 6c73 652c 0d0a 2020  ool = False,..  
-00002ef0: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
-00002f00: 656f 6d65 7472 7974 7970 653a 2055 6e69  eometrytype: Uni
-00002f10: 6f6e 5b47 656f 6d65 7472 7954 7970 652c  on[GeometryType,
-00002f20: 2073 7472 2c20 4e6f 6e65 5d20 3d20 4e6f   str, None] = No
-00002f30: 6e65 2c0d 0a20 2020 206e 625f 7061 7261  ne,..    nb_para
-00002f40: 6c6c 656c 3a20 696e 7420 3d20 2d31 2c0d  llel: int = -1,.
-00002f50: 0a20 2020 2062 6174 6368 7369 7a65 3a20  .    batchsize: 
-00002f60: 696e 7420 3d20 2d31 2c0d 0a20 2020 2066  int = -1,..    f
-00002f70: 6f72 6365 3a20 626f 6f6c 203d 2046 616c  orce: bool = Fal
-00002f80: 7365 2c0d 0a29 3a0d 0a20 2020 2022 2222  se,..):..    """
-00002f90: 0d0a 2020 2020 4170 706c 6965 7320 6120  ..    Applies a 
-00002fa0: 6765 6f20 6f70 6572 6174 696f 6e20 6f6e  geo operation on
-00002fb0: 2061 206c 6179 6572 2e0d 0a0d 0a20 2020   a layer.....   
-00002fc0: 2054 6865 206f 7065 7261 7469 6f6e 2074   The operation t
-00002fd0: 6f20 6170 706c 7920 6361 6e20 6265 206f  o apply can be o
-00002fe0: 6e65 206f 6620 7468 6520 7468 6520 666f  ne of the the fo
-00002ff0: 6c6c 6f77 696e 673a 0d0a 2020 2020 2020  llowing:..      
-00003000: 2d20 4255 4646 4552 3a20 6170 706c 7920  - BUFFER: apply 
-00003010: 6120 6275 6666 6572 2e20 4f70 6572 6174  a buffer. Operat
-00003020: 696f 6e20 7061 7261 6d65 7465 7273 3a0d  ion parameters:.
-00003030: 0a20 2020 2020 2020 2020 202d 2064 6973  .          - dis
-00003040: 7461 6e63 653a 2064 6973 7461 6e63 6520  tance: distance 
-00003050: 746f 2062 7566 6665 720d 0a20 2020 2020  to buffer..     
-00003060: 2020 2020 202d 2071 7561 6472 616e 7473       - quadrants
-00003070: 6567 6d65 6e74 733a 206e 756d 6265 7220  egments: number 
-00003080: 6f66 2070 6f69 6e74 7320 7573 6564 2074  of points used t
-00003090: 6f20 7265 7072 6573 656e 7420 312f 3420  o represent 1/4 
-000030a0: 6f66 2061 2063 6972 636c 650d 0a20 2020  of a circle..   
-000030b0: 2020 2020 2020 202d 2065 6e64 6361 705f         - endcap_
-000030c0: 7374 796c 653a 2062 7566 6665 7220 7374  style: buffer st
-000030d0: 796c 6520 746f 2075 7365 2066 6f72 2061  yle to use for a
-000030e0: 2070 6f69 6e74 206f 7220 7468 6520 656e   point or the en
-000030f0: 6420 706f 696e 7473 206f 660d 0a20 2020  d points of..   
-00003100: 2020 2020 2020 2020 2061 206c 696e 653a           a line:
-00003110: 0d0a 2020 2020 2020 2020 2020 2020 2d20  ..            - 
-00003120: 524f 554e 443a 2066 6f72 2070 6f69 6e74  ROUND: for point
-00003130: 7320 616e 6420 6c69 6e65 7320 7468 6520  s and lines the 
-00003140: 656e 6473 2061 7265 2062 7566 6665 7265  ends are buffere
-00003150: 6420 726f 756e 6465 642e 0d0a 2020 2020  d rounded...    
-00003160: 2020 2020 2020 2020 2d20 464c 4154 3a20          - FLAT: 
-00003170: 6120 706f 696e 7420 7374 6179 7320 6120  a point stays a 
-00003180: 706f 696e 742c 2061 2062 7566 6665 7265  point, a buffere
-00003190: 6420 6c69 6e65 2077 696c 6c20 656e 6420  d line will end 
-000031a0: 666c 6174 0d0a 2020 2020 2020 2020 2020  flat..          
-000031b0: 2020 2020 6174 2074 6865 2065 6e64 2070      at the end p
-000031c0: 6f69 6e74 730d 0a20 2020 2020 2020 2020  oints..         
-000031d0: 2020 202d 2053 5155 4152 453a 2061 2070     - SQUARE: a p
-000031e0: 6f69 6e74 2062 6563 6f6d 6573 2061 2073  oint becomes a s
-000031f0: 7175 6172 652c 2061 2062 7566 6665 7265  quare, a buffere
-00003200: 6420 6c69 6e65 2077 696c 6c20 656e 640d  d line will end.
-00003210: 0a20 2020 2020 2020 2020 2020 2020 2066  .              f
-00003220: 6c61 7420 6174 2074 6865 2065 6e64 2070  lat at the end p
-00003230: 6f69 6e74 732c 2062 7574 2065 6c6f 6e67  oints, but elong
-00003240: 6174 6564 2062 7920 2264 6973 7461 6e63  ated by "distanc
-00003250: 6522 0d0a 2020 2020 2020 2020 2d20 6a6f  e"..        - jo
-00003260: 696e 5f73 7479 6c65 3a20 6275 6666 6572  in_style: buffer
-00003270: 2073 7479 6c65 2074 6f20 7573 6520 666f   style to use fo
-00003280: 7220 636f 726e 6572 7320 696e 2061 206c  r corners in a l
-00003290: 696e 6520 6f72 2061 2070 6f6c 7967 6f6e  ine or a polygon
-000032a0: 0d0a 2020 2020 2020 2020 2020 626f 756e  ..          boun
-000032b0: 6461 7279 3a0d 0a20 2020 2020 2020 2020  dary:..         
-000032c0: 2020 202d 2052 4f55 4e44 3a20 636f 726e     - ROUND: corn
-000032d0: 6572 7320 696e 2074 6865 2072 6573 756c  ers in the resul
-000032e0: 7420 6172 6520 726f 756e 6465 640d 0a20  t are rounded.. 
-000032f0: 2020 2020 2020 2020 2020 202d 204d 4954             - MIT
-00003300: 5245 3a20 636f 726e 6572 7320 696e 2074  RE: corners in t
-00003310: 6865 2072 6573 756c 7420 6172 6520 7368  he result are sh
-00003320: 6172 700d 0a20 2020 2020 2020 2020 2020  arp..           
-00003330: 202d 2042 4556 454c 3a20 6172 6520 666c   - BEVEL: are fl
-00003340: 6174 7465 6e65 640d 0a20 2020 2020 2020  attened..       
-00003350: 202d 206d 6974 7265 5f6c 696d 6974 3a20   - mitre_limit: 
-00003360: 696e 2063 6173 6520 6f66 206a 6f69 6e5f  in case of join_
-00003370: 7374 796c 6520 4d49 5452 452c 2069 6620  style MITRE, if 
-00003380: 7468 650d 0a20 2020 2020 2020 2020 2020  the..           
-00003390: 2073 7069 6b79 2072 6573 756c 7420 666f   spiky result fo
-000033a0: 7220 6120 7368 6172 7020 616e 676c 6520  r a sharp angle 
-000033b0: 6265 636f 6d65 7320 6c6f 6e67 6572 2074  becomes longer t
-000033c0: 6861 6e20 7468 6973 206c 696d 6974 2c20  han this limit, 
-000033d0: 6974 0d0a 2020 2020 2020 2020 2020 2020  it..            
-000033e0: 6973 2022 6265 7665 6c65 6422 2061 7420  is "beveled" at 
-000033f0: 7468 6973 2064 6973 7461 6e63 652e 2044  this distance. D
-00003400: 6566 6175 6c74 7320 746f 2035 2e30 2e0d  efaults to 5.0..
-00003410: 0a20 2020 2020 2020 202d 2073 696e 676c  .        - singl
-00003420: 655f 7369 6465 643a 206f 6e6c 7920 6f6e  e_sided: only on
-00003430: 6520 7369 6465 206f 6620 7468 6520 6c69  e side of the li
-00003440: 6e65 2069 7320 6275 6666 6572 6564 2c0d  ne is buffered,.
-00003450: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00003460: 6469 7374 616e 6365 2069 7320 6e65 6761  distance is nega
-00003470: 7469 7665 2c20 7468 6520 6c65 6674 2073  tive, the left s
-00003480: 6964 652c 2069 6620 6469 7374 616e 6365  ide, if distance
-00003490: 2069 7320 706f 7369 7469 7665 2c0d 0a20   is positive,.. 
-000034a0: 2020 2020 2020 2020 2020 2074 6865 2072             the r
-000034b0: 6967 6874 2068 616e 6420 7369 6465 2e20  ight hand side. 
-000034c0: 4f6e 6c79 2072 656c 6576 616e 7420 666f  Only relevant fo
-000034d0: 7220 6c69 6e65 2067 656f 6d65 7472 6965  r line geometrie
-000034e0: 732e 0d0a 2020 2020 2020 2d20 434f 4e56  s...      - CONV
-000034f0: 4558 4855 4c4c 3a20 6170 7079 2061 2063  EXHULL: appy a c
-00003500: 6f6e 7665 7820 6875 6c6c 2e0d 0a20 2020  onvex hull...   
-00003510: 2020 202d 2053 494d 504c 4946 593a 2073     - SIMPLIFY: s
-00003520: 696d 706c 6966 7920 7468 6520 6765 6f6d  implify the geom
-00003530: 6574 7279 2e20 4f70 6572 6174 696f 6e20  etry. Operation 
-00003540: 7061 7261 6d65 7465 7273 3a0d 0a20 2020  parameters:..   
-00003550: 2020 2020 2020 202d 2061 6c67 6f72 6974         - algorit
-00003560: 686d 3a20 7665 6374 6f72 5f75 7469 6c2e  hm: vector_util.
-00003570: 5369 6d70 6c69 6679 416c 676f 7269 7468  SimplifyAlgorith
-00003580: 6d0d 0a20 2020 2020 2020 2020 202d 2074  m..          - t
-00003590: 6f6c 6572 616e 6365 3a20 6d61 7869 6d75  olerance: maximu
-000035a0: 6d20 6469 7374 616e 6365 2074 6f20 7369  m distance to si
-000035b0: 6d70 6c69 6679 2e0d 0a20 2020 2020 2020  mplify...       
-000035c0: 2020 202d 206c 6f6f 6b61 6865 6164 3a20     - lookahead: 
-000035d0: 666f 7220 4c41 4e47 2c20 7468 6520 6e75  for LANG, the nu
-000035e0: 6d62 6572 206f 6620 706f 696e 7473 2074  mber of points t
-000035f0: 6f20 666f 7277 6172 642d 6c6f 6f6b 0d0a  o forward-look..
-00003600: 2020 2020 2020 2d20 4150 504c 593a 2061        - APPLY: a
-00003610: 7070 6c79 2061 206c 616d 6264 6120 6675  pply a lambda fu
-00003620: 6e63 7469 6f6e 2e20 4f70 6572 6174 696f  nction. Operatio
-00003630: 6e20 7061 7261 6d65 7465 723a 0d0a 2020  n parameter:..  
-00003640: 2020 2020 2020 2020 2d20 7069 636b 6c65          - pickle
-00003650: 645f 6675 6e63 3a20 6c61 6d62 6461 2066  d_func: lambda f
-00003660: 756e 6374 696f 6e20 746f 2061 7070 6c79  unction to apply
-00003670: 2c20 7069 636b 6c65 6420 746f 2062 7974  , pickled to byt
-00003680: 6573 2e0d 0a20 2020 2020 2020 2020 202d  es...          -
-00003690: 206f 6e6c 795f 6765 6f6d 5f69 6e70 7574   only_geom_input
-000036a0: 3a20 6966 2054 7275 652c 206f 6e6c 7920  : if True, only 
-000036b0: 7468 6520 6765 6f6d 6574 7279 2069 7320  the geometry is 
-000036c0: 6176 6169 6c61 626c 6520 6173 0d0a 2020  available as..  
-000036d0: 2020 2020 2020 2020 2020 696e 7075 7420            input 
-000036e0: 666f 7220 7468 6520 6c61 6d62 6461 2066  for the lambda f
-000036f0: 756e 6374 696f 6e2e 2049 6620 6661 6c73  unction. If fals
-00003700: 652c 2074 6865 2072 6f77 2069 7320 7468  e, the row is th
-00003710: 6520 696e 7075 742e 0d0a 0d0a 2020 2020  e input.....    
-00003720: 4172 6773 3a0d 0a20 2020 2020 2020 2069  Args:..        i
-00003730: 6e70 7574 5f70 6174 6820 2850 6174 6829  nput_path (Path)
-00003740: 3a20 5b64 6573 6372 6970 7469 6f6e 5d0d  : [description].
-00003750: 0a20 2020 2020 2020 206f 7574 7075 745f  .        output_
-00003760: 7061 7468 2028 5061 7468 293a 205b 6465  path (Path): [de
-00003770: 7363 7269 7074 696f 6e5d 0d0a 2020 2020  scription]..    
-00003780: 2020 2020 6f70 6572 6174 696f 6e20 2847      operation (G
-00003790: 656f 4f70 6572 6174 696f 6e29 3a20 7468  eoOperation): th
-000037a0: 6520 6765 6f20 6f70 6572 6174 696f 6e20  e geo operation 
-000037b0: 746f 2061 7070 6c79 2e0d 0a20 2020 2020  to apply...     
-000037c0: 2020 206f 7065 7261 7469 6f6e 5f70 6172     operation_par
-000037d0: 616d 7320 2864 6963 742c 206f 7074 696f  ams (dict, optio
-000037e0: 6e61 6c29 3a20 7468 6520 7061 7261 6d65  nal): the parame
-000037f0: 7465 7273 2066 6f72 2074 6865 2067 656f  ters for the geo
-00003800: 206f 7065 7261 7469 6f6e 2e0d 0a20 2020   operation...   
-00003810: 2020 2020 2020 2020 2044 6566 6175 6c74           Default
-00003820: 7320 746f 204e 6f6e 652e 0d0a 2020 2020  s to None...    
-00003830: 2020 2020 696e 7075 745f 6c61 7965 7220      input_layer 
-00003840: 2873 7472 2c20 6f70 7469 6f6e 616c 293a  (str, optional):
-00003850: 205b 6465 7363 7269 7074 696f 6e5d 2e20   [description]. 
-00003860: 4465 6661 756c 7473 2074 6f20 4e6f 6e65  Defaults to None
-00003870: 2e0d 0a20 2020 2020 2020 206f 7574 7075  ...        outpu
-00003880: 745f 6c61 7965 7220 2873 7472 2c20 6f70  t_layer (str, op
-00003890: 7469 6f6e 616c 293a 205b 6465 7363 7269  tional): [descri
-000038a0: 7074 696f 6e5d 2e20 4465 6661 756c 7473  ption]. Defaults
-000038b0: 2074 6f20 4e6f 6e65 2e0d 0a20 2020 2020   to None...     
-000038c0: 2020 2063 6f6c 756d 6e73 2028 4c69 7374     columns (List
-000038d0: 5b73 7472 5d2c 206f 7074 696f 6e61 6c29  [str], optional)
-000038e0: 3a20 4966 206e 6f74 204e 6f6e 652c 206f  : If not None, o
-000038f0: 6e6c 7920 6f75 7470 7574 2074 6865 2063  nly output the c
-00003900: 6f6c 756d 6e73 0d0a 2020 2020 2020 2020  olumns..        
-00003910: 2020 2020 7370 6563 6966 6965 642e 2044      specified. D
-00003920: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
-00003930: 0d0a 2020 2020 2020 2020 6578 706c 6f64  ..        explod
-00003940: 6563 6f6c 6c65 6374 696f 6e73 2028 626f  ecollections (bo
-00003950: 6f6c 2c20 6f70 7469 6f6e 616c 293a 2054  ol, optional): T
-00003960: 7275 6520 746f 2063 6f6e 7665 7274 2061  rue to convert a
-00003970: 6c6c 206d 756c 7469 2d67 656f 6d65 7472  ll multi-geometr
-00003980: 6965 7320 746f 0d0a 2020 2020 2020 2020  ies to..        
-00003990: 2020 2020 7369 6e67 756c 6172 206f 6e65      singular one
-000039a0: 7320 6475 7269 6e67 2074 6865 2067 656f  s during the geo
-000039b0: 6f70 6572 6174 696f 6e2e 2044 6566 6175  operation. Defau
-000039c0: 6c74 7320 746f 2046 616c 7365 2e0d 0a20  lts to False... 
-000039d0: 2020 2020 2020 2066 6f72 6365 5f6f 7574         force_out
-000039e0: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
-000039f0: 2028 4765 6f6d 6574 7279 5479 7065 2c20   (GeometryType, 
-00003a00: 6f70 7469 6f6e 616c 293a 2054 6865 206f  optional): The o
-00003a10: 7574 7075 7420 6765 6f6d 6574 7279 2074  utput geometry t
-00003a20: 7970 6520 746f 0d0a 2020 2020 2020 2020  ype to..        
-00003a30: 2020 2020 666f 7263 652e 2049 6620 4e6f      force. If No
-00003a40: 6e65 2c20 6120 6265 7374 2d65 6666 6f72  ne, a best-effor
-00003a50: 7420 6775 6573 7320 6973 206d 6164 652e  t guess is made.
-00003a60: 2044 6566 6175 6c74 7320 746f 204e 6f6e   Defaults to Non
-00003a70: 652e 0d0a 2020 2020 2020 2020 6e62 5f70  e...        nb_p
-00003a80: 6172 616c 6c65 6c20 2869 6e74 2c20 6f70  arallel (int, op
-00003a90: 7469 6f6e 616c 293a 205b 6465 7363 7269  tional): [descri
-00003aa0: 7074 696f 6e5d 2e20 4465 6661 756c 7473  ption]. Defaults
-00003ab0: 2074 6f20 2d31 2e0d 0a20 2020 2020 2020   to -1...       
-00003ac0: 2062 6174 6368 7369 7a65 2028 696e 742c   batchsize (int,
-00003ad0: 206f 7074 696f 6e61 6c29 3a20 696e 6469   optional): indi
-00003ae0: 6361 7469 7665 206e 756d 6265 7220 6f66  cative number of
-00003af0: 2072 6f77 7320 746f 2070 726f 6365 7373   rows to process
-00003b00: 2070 6572 0d0a 2020 2020 2020 2020 2020   per..          
-00003b10: 2020 6261 7463 682e 2041 2073 6d61 6c6c    batch. A small
-00003b20: 6572 2062 6174 6368 2073 697a 652c 2070  er batch size, p
-00003b30: 6f73 7369 626c 7920 696e 2063 6f6d 6269  ossibly in combi
-00003b40: 6e61 7469 6f6e 2077 6974 6820 610d 0a20  nation with a.. 
-00003b50: 2020 2020 2020 2020 2020 2073 6d61 6c6c             small
-00003b60: 6572 206e 625f 7061 7261 6c6c 656c 2c20  er nb_parallel, 
-00003b70: 7769 6c6c 2072 6564 7563 6520 7468 6520  will reduce the 
-00003b80: 6d65 6d6f 7279 2075 7361 6765 2e0d 0a20  memory usage... 
-00003b90: 2020 2020 2020 2020 2020 2044 6566 6175             Defau
-00003ba0: 6c74 7320 746f 202d 313a 2028 7472 7920  lts to -1: (try 
-00003bb0: 746f 2920 6465 7465 726d 696e 6520 6f70  to) determine op
-00003bc0: 7469 6d61 6c20 7369 7a65 2061 7574 6f6d  timal size autom
-00003bd0: 6174 6963 616c 6c79 2e0d 0a20 2020 2020  atically...     
-00003be0: 2020 2066 6f72 6365 2028 626f 6f6c 2c20     force (bool, 
-00003bf0: 6f70 7469 6f6e 616c 293a 205b 6465 7363  optional): [desc
-00003c00: 7269 7074 696f 6e5d 2e20 4465 6661 756c  ription]. Defaul
-00003c10: 7473 2074 6f20 4661 6c73 652e 0d0a 2020  ts to False...  
-00003c20: 2020 2222 220d 0a20 2020 2023 2049 6e69    """..    # Ini
-00003c30: 740d 0a20 2020 2073 7461 7274 5f74 696d  t..    start_tim
-00003c40: 655f 676c 6f62 616c 203d 2064 6174 6574  e_global = datet
-00003c50: 696d 652e 6e6f 7728 290d 0a0d 0a20 2020  ime.now()....   
-00003c60: 2023 2043 6865 636b 2069 6e70 7574 2070   # Check input p
-00003c70: 6172 616d 6574 6572 732e 2e2e 0d0a 2020  arameters.....  
-00003c80: 2020 6f70 6572 6174 696f 6e5f 6e61 6d65    operation_name
-00003c90: 203d 206f 7065 7261 7469 6f6e 2e6e 616d   = operation.nam
-00003ca0: 652e 6c6f 7765 7228 290d 0a20 2020 2069  e.lower()..    i
-00003cb0: 6620 6e6f 7420 696e 7075 745f 7061 7468  f not input_path
-00003cc0: 2e65 7869 7374 7328 293a 0d0a 2020 2020  .exists():..    
-00003cd0: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-00003ce0: 7272 6f72 2866 227b 6f70 6572 6174 696f  rror(f"{operatio
-00003cf0: 6e5f 6e61 6d65 7d3a 2069 6e70 7574 5f70  n_name}: input_p
-00003d00: 6174 6820 646f 6573 6e27 7420 6578 6973  ath doesn't exis
-00003d10: 743a 207b 696e 7075 745f 7061 7468 7d22  t: {input_path}"
-00003d20: 290d 0a20 2020 2069 6620 696e 7075 745f  )..    if input_
-00003d30: 7061 7468 203d 3d20 6f75 7470 7574 5f70  path == output_p
-00003d40: 6174 683a 0d0a 2020 2020 2020 2020 7261  ath:..        ra
-00003d50: 6973 6520 5661 6c75 6545 7272 6f72 2866  ise ValueError(f
-00003d60: 227b 6f70 6572 6174 696f 6e5f 6e61 6d65  "{operation_name
-00003d70: 7d3a 206f 7574 7075 745f 7061 7468 206d  }: output_path m
-00003d80: 7573 7420 6e6f 7420 6571 7561 6c20 696e  ust not equal in
-00003d90: 7075 745f 7061 7468 2229 0d0a 2020 2020  put_path")..    
-00003da0: 6966 2069 6e70 7574 5f6c 6179 6572 2069  if input_layer i
-00003db0: 7320 4e6f 6e65 3a0d 0a20 2020 2020 2020  s None:..       
-00003dc0: 2069 6e70 7574 5f6c 6179 6572 203d 2067   input_layer = g
-00003dd0: 666f 2e67 6574 5f6f 6e6c 795f 6c61 7965  fo.get_only_laye
-00003de0: 7228 696e 7075 745f 7061 7468 290d 0a20  r(input_path).. 
-00003df0: 2020 2069 6620 6f75 7470 7574 5f70 6174     if output_pat
-00003e00: 682e 6578 6973 7473 2829 3a0d 0a20 2020  h.exists():..   
-00003e10: 2020 2020 2069 6620 666f 7263 6520 6973       if force is
-00003e20: 2046 616c 7365 3a0d 0a20 2020 2020 2020   False:..       
-00003e30: 2020 2020 206c 6f67 6765 722e 696e 666f       logger.info
-00003e40: 2866 2253 746f 7020 7b6f 7065 7261 7469  (f"Stop {operati
-00003e50: 6f6e 5f6e 616d 657d 3a20 6f75 7470 7574  on_name}: output
-00003e60: 2065 7869 7374 7320 616c 7265 6164 7920   exists already 
-00003e70: 7b6f 7574 7075 745f 7061 7468 7d22 290d  {output_path}").
-00003e80: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00003e90: 7572 6e0d 0a20 2020 2020 2020 2065 6c73  urn..        els
-00003ea0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-00003eb0: 6766 6f2e 7265 6d6f 7665 286f 7574 7075  gfo.remove(outpu
-00003ec0: 745f 7061 7468 290d 0a20 2020 2069 6620  t_path)..    if 
-00003ed0: 696e 7075 745f 6c61 7965 7220 6973 204e  input_layer is N
-00003ee0: 6f6e 653a 0d0a 2020 2020 2020 2020 696e  one:..        in
-00003ef0: 7075 745f 6c61 7965 7220 3d20 6766 6f2e  put_layer = gfo.
-00003f00: 6765 745f 6f6e 6c79 5f6c 6179 6572 2869  get_only_layer(i
-00003f10: 6e70 7574 5f70 6174 6829 0d0a 2020 2020  nput_path)..    
-00003f20: 6966 206f 7574 7075 745f 6c61 7965 7220  if output_layer 
-00003f30: 6973 204e 6f6e 653a 0d0a 2020 2020 2020  is None:..      
-00003f40: 2020 6f75 7470 7574 5f6c 6179 6572 203d    output_layer =
-00003f50: 2067 666f 2e67 6574 5f64 6566 6175 6c74   gfo.get_default
-00003f60: 5f6c 6179 6572 286f 7574 7075 745f 7061  _layer(output_pa
-00003f70: 7468 290d 0a20 2020 2069 6620 6973 696e  th)..    if isin
-00003f80: 7374 616e 6365 2866 6f72 6365 5f6f 7574  stance(force_out
-00003f90: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
-00003fa0: 2c20 4765 6f6d 6574 7279 5479 7065 293a  , GeometryType):
-00003fb0: 0d0a 2020 2020 2020 2020 666f 7263 655f  ..        force_
-00003fc0: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-00003fd0: 7970 6520 3d20 666f 7263 655f 6f75 7470  ype = force_outp
-00003fe0: 7574 5f67 656f 6d65 7472 7974 7970 652e  ut_geometrytype.
-00003ff0: 6e61 6d65 0d0a 0d0a 2020 2020 2320 5072  name....    # Pr
-00004000: 6570 6172 6520 746d 7020 6669 6c65 730d  epare tmp files.
-00004010: 0a20 2020 2074 656d 7064 6972 203d 205f  .    tempdir = _
-00004020: 696f 5f75 7469 6c2e 6372 6561 7465 5f74  io_util.create_t
-00004030: 656d 7064 6972 2866 2267 656f 6669 6c65  empdir(f"geofile
-00004040: 6f70 732f 7b6f 7065 7261 7469 6f6e 2e76  ops/{operation.v
-00004050: 616c 7565 7d22 290d 0a20 2020 206c 6f67  alue}")..    log
-00004060: 6765 722e 696e 666f 2866 2253 7461 7274  ger.info(f"Start
-00004070: 2063 616c 6375 6c61 7469 6f6e 2074 6f20   calculation to 
-00004080: 7465 6d70 2066 696c 6573 2069 6e20 7b74  temp files in {t
-00004090: 656d 7064 6972 7d22 290d 0a0d 0a20 2020  empdir}")....   
-000040a0: 2023 2043 616c 6375 6c61 7465 0d0a 2020   # Calculate..  
-000040b0: 2020 7472 793a 0d0a 2020 2020 2020 2020    try:..        
-000040c0: 2320 5265 6d61 726b 3a20 6361 6c63 756c  # Remark: calcul
-000040d0: 6174 696e 6720 6361 6e20 6265 2064 6f6e  ating can be don
-000040e0: 6520 696e 2070 6172 616c 6c65 6c2c 2062  e in parallel, b
-000040f0: 7574 206f 6e6c 7920 6f6e 6520 7072 6f63  ut only one proc
-00004100: 6573 730d 0a20 2020 2020 2020 2023 2063  ess..        # c
-00004110: 616e 2077 7269 7465 2074 6f20 7468 6520  an write to the 
-00004120: 7361 6d65 206f 7574 7075 7420 6669 6c65  same output file
-00004130: 2061 7420 7468 6520 7469 6d65 2e2e 2e0d   at the time....
-00004140: 0a0d 0a20 2020 2020 2020 2023 2043 616c  ...        # Cal
-00004150: 6375 6c61 7465 2074 6865 2062 6573 7420  culate the best 
-00004160: 6e75 6d62 6572 206f 6620 7061 7261 6c6c  number of parall
-00004170: 656c 2070 726f 6365 7373 6573 2061 6e64  el processes and
-00004180: 2062 6174 6368 6573 2066 6f72 0d0a 2020   batches for..  
-00004190: 2020 2020 2020 2320 7468 6520 6176 6169        # the avai
-000041a0: 6c61 626c 6520 7265 736f 7572 6365 730d  lable resources.
-000041b0: 0a20 2020 2020 2020 2069 6e70 7574 5f6c  .        input_l
-000041c0: 6179 6572 696e 666f 203d 2067 666f 2e67  ayerinfo = gfo.g
-000041d0: 6574 5f6c 6179 6572 696e 666f 2869 6e70  et_layerinfo(inp
-000041e0: 7574 5f70 6174 682c 2069 6e70 7574 5f6c  ut_path, input_l
-000041f0: 6179 6572 290d 0a20 2020 2020 2020 206e  ayer)..        n
-00004200: 625f 726f 7773 5f74 6f74 616c 203d 2069  b_rows_total = i
-00004210: 6e70 7574 5f6c 6179 6572 696e 666f 2e66  nput_layerinfo.f
-00004220: 6561 7475 7265 636f 756e 740d 0a20 2020  eaturecount..   
-00004230: 2020 2020 2069 6620 6261 7463 6873 697a       if batchsiz
-00004240: 6520 3e20 303a 0d0a 2020 2020 2020 2020  e > 0:..        
-00004250: 2020 2020 7061 7261 6c6c 656c 6c69 7a61      parallelliza
-00004260: 7469 6f6e 5f63 6f6e 6669 6720 3d20 5061  tion_config = Pa
-00004270: 7261 6c6c 656c 697a 6174 696f 6e43 6f6e  rallelizationCon
-00004280: 6669 6728 0d0a 2020 2020 2020 2020 2020  fig(..          
-00004290: 2020 2020 2020 6d69 6e5f 6176 675f 726f        min_avg_ro
-000042a0: 7773 5f70 6572 5f62 6174 6368 3d6d 6174  ws_per_batch=mat
-000042b0: 682e 6365 696c 2862 6174 6368 7369 7a65  h.ceil(batchsize
-000042c0: 202f 2032 292c 0d0a 2020 2020 2020 2020   / 2),..        
-000042d0: 2020 2020 2020 2020 6d61 785f 6176 675f          max_avg_
-000042e0: 726f 7773 5f70 6572 5f62 6174 6368 3d62  rows_per_batch=b
-000042f0: 6174 6368 7369 7a65 2c0d 0a20 2020 2020  atchsize,..     
-00004300: 2020 2020 2020 2029 0d0a 2020 2020 2020         )..      
-00004310: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-00004320: 2020 2020 2070 6172 616c 6c65 6c6c 697a       parallelliz
-00004330: 6174 696f 6e5f 636f 6e66 6967 203d 2050  ation_config = P
-00004340: 6172 616c 6c65 6c69 7a61 7469 6f6e 436f  arallelizationCo
-00004350: 6e66 6967 280d 0a20 2020 2020 2020 2020  nfig(..         
-00004360: 2020 2020 2020 206d 6178 5f61 7667 5f72         max_avg_r
-00004370: 6f77 735f 7065 725f 6261 7463 683d 3530  ows_per_batch=50
-00004380: 3030 300d 0a20 2020 2020 2020 2020 2020  000..           
-00004390: 2029 0d0a 2020 2020 2020 2020 6e62 5f70   )..        nb_p
-000043a0: 6172 616c 6c65 6c2c 206e 625f 6261 7463  arallel, nb_batc
-000043b0: 6865 732c 2072 6561 6c5f 6261 7463 6873  hes, real_batchs
-000043c0: 697a 6520 3d20 6765 745f 7061 7261 6c6c  ize = get_parall
-000043d0: 656c 697a 6174 696f 6e5f 7061 7261 6d73  elization_params
-000043e0: 280d 0a20 2020 2020 2020 2020 2020 206e  (..            n
-000043f0: 625f 726f 7773 5f74 6f74 616c 3d6e 625f  b_rows_total=nb_
-00004400: 726f 7773 5f74 6f74 616c 2c0d 0a20 2020  rows_total,..   
-00004410: 2020 2020 2020 2020 206e 625f 7061 7261           nb_para
-00004420: 6c6c 656c 3d6e 625f 7061 7261 6c6c 656c  llel=nb_parallel
-00004430: 2c0d 0a20 2020 2020 2020 2020 2020 2070  ,..            p
-00004440: 6172 616c 6c65 6c69 7a61 7469 6f6e 5f63  arallelization_c
-00004450: 6f6e 6669 673d 7061 7261 6c6c 656c 6c69  onfig=parallelli
-00004460: 7a61 7469 6f6e 5f63 6f6e 6669 672c 0d0a  zation_config,..
-00004470: 2020 2020 2020 2020 290d 0a0d 0a20 2020          )....   
-00004480: 2020 2020 2023 2054 4f44 4f3a 2064 6574       # TODO: det
-00004490: 6572 6d69 6e65 2074 6865 206f 7074 696d  ermine the optim
-000044a0: 616c 2062 6174 6368 2073 697a 6573 2077  al batch sizes w
-000044b0: 6974 6820 6d69 6e20 616e 6420 6d61 7820  ith min and max 
-000044c0: 6f66 2072 6f77 6964 2077 696c 6c0d 0a20  of rowid will.. 
-000044d0: 2020 2020 2020 2023 2069 6e20 736f 6d65         # in some
-000044e0: 2063 6173 6520 696d 7072 6f76 6520 7065   case improve pe
-000044f0: 7266 6f72 6d61 6e63 650d 0a20 2020 2020  rformance..     
-00004500: 2020 2022 2222 0d0a 2020 2020 2020 2020     """..        
-00004510: 7371 6c5f 7374 6d74 203d 2066 2727 2753  sql_stmt = f'''S
-00004520: 454c 4543 5420 4d49 4e28 726f 7769 6429  ELECT MIN(rowid)
-00004530: 2061 7320 6d69 6e5f 726f 7769 642c 204d   as min_rowid, M
-00004540: 4158 2872 6f77 6964 2920 6173 206d 6178  AX(rowid) as max
-00004550: 5f72 6f77 6964 0d0a 2020 2020 2020 2020  _rowid..        
-00004560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004570: 2046 524f 4d20 227b 696e 7075 745f 6c61   FROM "{input_la
-00004580: 7965 727d 2227 2727 0d0a 2020 2020 2020  yer}"'''..      
-00004590: 2020 7265 7375 6c74 203d 2067 666f 2e72    result = gfo.r
-000045a0: 6561 645f 6669 6c65 280d 0a20 2020 2020  ead_file(..     
-000045b0: 2020 2020 2020 2070 6174 683d 7465 6d70         path=temp
-000045c0: 5f70 6174 682c 206c 6179 6572 3d69 6e70  _path, layer=inp
-000045d0: 7574 5f6c 6179 6572 2c20 7371 6c5f 7374  ut_layer, sql_st
-000045e0: 6d74 3d73 716c 5f73 746d 742c 2073 716c  mt=sql_stmt, sql
-000045f0: 5f64 6961 6c65 6374 3d22 5351 4c49 5445  _dialect="SQLITE
-00004600: 220d 0a20 2020 2020 2020 2029 0d0a 2020  "..        )..  
-00004610: 2020 2020 2020 6966 206c 656e 2872 6573        if len(res
-00004620: 756c 7429 203d 3d20 313a 0d0a 2020 2020  ult) == 1:..    
-00004630: 2020 2020 2020 2020 6d69 6e5f 726f 7769          min_rowi
-00004640: 6420 3d20 7265 7375 6c74 5b27 6d69 6e5f  d = result['min_
-00004650: 726f 7769 6427 5d2e 7661 6c75 6573 5b30  rowid'].values[0
-00004660: 5d0d 0a20 2020 2020 2020 2020 2020 206d  ]..            m
-00004670: 6178 5f72 6f77 6964 203d 2072 6573 756c  ax_rowid = resul
-00004680: 745b 276d 6178 5f72 6f77 6964 275d 2e76  t['max_rowid'].v
-00004690: 616c 7565 735b 305d 0d0a 2020 2020 2020  alues[0]..      
-000046a0: 2020 2020 2020 6e62 5f72 6f77 6964 735f        nb_rowids_
-000046b0: 7065 725f 6261 7463 6820 3d20 286d 6178  per_batch = (max
-000046c0: 5f72 6f77 6964 202d 206d 696e 5f72 6f77  _rowid - min_row
-000046d0: 6964 292f 6e62 5f62 6174 6368 6573 0d0a  id)/nb_batches..
-000046e0: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-000046f0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-00004700: 2045 7863 6570 7469 6f6e 280d 0a20 2020   Exception(..   
-00004710: 2020 2020 2020 2020 2020 2020 2066 2245               f"E
-00004720: 7272 6f72 2067 6574 7469 6e67 206d 696e  rror getting min
-00004730: 2061 6e64 206d 6178 2072 6f77 6964 2066   and max rowid f
-00004740: 6f72 207b 7465 6d70 5f70 6174 687d 2c20  or {temp_path}, 
-00004750: 6c61 7965 7220 7b69 6e70 7574 5f6c 6179  layer {input_lay
-00004760: 6572 7d22 0d0a 2020 2020 2020 2020 2020  er}"..          
-00004770: 2020 290d 0a20 2020 2020 2020 2022 2222    )..        """
-00004780: 0d0a 0d0a 2020 2020 2020 2020 2320 5072  ....        # Pr
-00004790: 6f63 6573 7369 6e67 2069 6e20 7468 7265  ocessing in thre
-000047a0: 6164 7320 6973 2032 7820 6661 7374 6572  ads is 2x faster
-000047b0: 2066 6f72 2073 6d61 6c6c 2064 6174 6173   for small datas
-000047c0: 6574 7320 286f 6e20 5769 6e64 6f77 7329  ets (on Windows)
-000047d0: 0d0a 2020 2020 2020 2020 6361 6c63 756c  ..        calcul
-000047e0: 6174 655f 696e 5f74 6872 6561 6473 203d  ate_in_threads =
-000047f0: 2054 7275 6520 6966 2069 6e70 7574 5f6c   True if input_l
-00004800: 6179 6572 696e 666f 2e66 6561 7475 7265  ayerinfo.feature
-00004810: 636f 756e 7420 3c3d 2031 3030 2065 6c73  count <= 100 els
-00004820: 6520 4661 6c73 650d 0a20 2020 2020 2020  e False..       
-00004830: 2077 6974 6820 5f70 726f 6365 7373 696e   with _processin
-00004840: 675f 7574 696c 2e50 6f6f 6c65 6445 7865  g_util.PooledExe
-00004850: 6375 746f 7246 6163 746f 7279 280d 0a20  cutorFactory(.. 
-00004860: 2020 2020 2020 2020 2020 2074 6872 6561             threa
-00004870: 6470 6f6f 6c3d 6361 6c63 756c 6174 655f  dpool=calculate_
-00004880: 696e 5f74 6872 6561 6473 2c0d 0a20 2020  in_threads,..   
-00004890: 2020 2020 2020 2020 206d 6178 5f77 6f72           max_wor
-000048a0: 6b65 7273 3d6e 625f 7061 7261 6c6c 656c  kers=nb_parallel
-000048b0: 2c0d 0a20 2020 2020 2020 2020 2020 2069  ,..            i
-000048c0: 6e69 7469 616c 697a 6572 3d5f 7072 6f63  nitializer=_proc
-000048d0: 6573 7369 6e67 5f75 7469 6c2e 696e 6974  essing_util.init
-000048e0: 6961 6c69 7a65 5f77 6f72 6b65 7228 292c  ialize_worker(),
-000048f0: 0d0a 2020 2020 2020 2020 2920 6173 2063  ..        ) as c
-00004900: 616c 6375 6c61 7465 5f70 6f6f 6c3a 0d0a  alculate_pool:..
-00004910: 2020 2020 2020 2020 2020 2020 2320 5072              # Pr
-00004920: 6570 6172 6520 6f75 7470 7574 2066 696c  epare output fil
-00004930: 656e 616d 650d 0a20 2020 2020 2020 2020  ename..         
-00004940: 2020 2074 6d70 5f6f 7574 7075 745f 7061     tmp_output_pa
-00004950: 7468 203d 2074 656d 7064 6972 202f 206f  th = tempdir / o
-00004960: 7574 7075 745f 7061 7468 2e6e 616d 650d  utput_path.name.
-00004970: 0a0d 0a20 2020 2020 2020 2020 2020 2072  ...            r
-00004980: 6f77 5f6f 6666 7365 7420 3d20 300d 0a20  ow_offset = 0.. 
-00004990: 2020 2020 2020 2020 2020 2062 6174 6368             batch
-000049a0: 6573 203d 207b 7d0d 0a20 2020 2020 2020  es = {}..       
-000049b0: 2020 2020 2066 7574 7572 655f 746f 5f62       future_to_b
-000049c0: 6174 6368 5f69 6420 3d20 7b7d 0d0a 2020  atch_id = {}..  
-000049d0: 2020 2020 2020 2020 2020 6e62 5f64 6f6e            nb_don
-000049e0: 6520 3d20 300d 0a0d 0a20 2020 2020 2020  e = 0....       
-000049f0: 2020 2020 2066 6f72 2062 6174 6368 5f69       for batch_i
-00004a00: 6420 696e 2072 616e 6765 286e 625f 6261  d in range(nb_ba
-00004a10: 7463 6865 7329 3a0d 0a20 2020 2020 2020  tches):..       
-00004a20: 2020 2020 2020 2020 2062 6174 6368 6573           batches
-00004a30: 5b62 6174 6368 5f69 645d 203d 207b 7d0d  [batch_id] = {}.
-00004a40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004a50: 2062 6174 6368 6573 5b62 6174 6368 5f69   batches[batch_i
-00004a60: 645d 5b22 6c61 7965 7222 5d20 3d20 6f75  d]["layer"] = ou
-00004a70: 7470 7574 5f6c 6179 6572 0d0a 0d0a 2020  tput_layer....  
-00004a80: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00004a90: 4f75 7470 7574 2065 6163 6820 6261 7463  Output each batc
-00004aa0: 6820 746f 2061 2073 6570 6572 6174 6520  h to a seperate 
-00004ab0: 7465 6d70 6f72 6172 7920 6669 6c65 2c20  temporary file, 
-00004ac0: 6f74 6865 7277 6973 6520 7468 6572 650d  otherwise there.
-00004ad0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004ae0: 2023 2061 7265 2074 696d 656f 7574 2069   # are timeout i
-00004af0: 7373 7565 7320 7768 656e 2070 726f 6365  ssues when proce
-00004b00: 7373 696e 6720 6c61 7267 6520 6669 6c65  ssing large file
-00004b10: 730d 0a20 2020 2020 2020 2020 2020 2020  s..             
-00004b20: 2020 206f 7574 7075 745f 746d 705f 7061     output_tmp_pa
-00004b30: 7274 6961 6c5f 7061 7468 203d 2028 0d0a  rtial_path = (..
-00004b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004b50: 2020 2020 7465 6d70 6469 7220 2f20 6622      tempdir / f"
-00004b60: 7b6f 7574 7075 745f 7061 7468 2e73 7465  {output_path.ste
-00004b70: 6d7d 5f7b 6261 7463 685f 6964 7d7b 6f75  m}_{batch_id}{ou
-00004b80: 7470 7574 5f70 6174 682e 7375 6666 6978  tput_path.suffix
-00004b90: 7d22 0d0a 2020 2020 2020 2020 2020 2020  }"..            
-00004ba0: 2020 2020 290d 0a20 2020 2020 2020 2020      )..         
-00004bb0: 2020 2020 2020 2062 6174 6368 6573 5b62         batches[b
-00004bc0: 6174 6368 5f69 645d 5b22 746d 705f 7061  atch_id]["tmp_pa
-00004bd0: 7274 6961 6c5f 6f75 7470 7574 5f70 6174  rtial_output_pat
-00004be0: 6822 5d20 3d20 6f75 7470 7574 5f74 6d70  h"] = output_tmp
-00004bf0: 5f70 6172 7469 616c 5f70 6174 680d 0a0d  _partial_path...
-00004c00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004c10: 2023 2046 6f72 2074 6865 206c 6173 7420   # For the last 
-00004c20: 7472 616e 736c 6174 655f 6964 2c20 7461  translate_id, ta
-00004c30: 6b65 2061 6c6c 2072 6f77 6964 2773 206c  ke all rowid's l
-00004c40: 6566 742e 2e2e 0d0a 2020 2020 2020 2020  eft.....        
-00004c50: 2020 2020 2020 2020 6966 2062 6174 6368          if batch
-00004c60: 5f69 6420 3c20 6e62 5f62 6174 6368 6573  _id < nb_batches
-00004c70: 202d 2031 3a0d 0a20 2020 2020 2020 2020   - 1:..         
-00004c80: 2020 2020 2020 2020 2020 2072 6f77 7320             rows 
-00004c90: 3d20 736c 6963 6528 726f 775f 6f66 6673  = slice(row_offs
-00004ca0: 6574 2c20 726f 775f 6f66 6673 6574 202b  et, row_offset +
-00004cb0: 2072 6561 6c5f 6261 7463 6873 697a 6529   real_batchsize)
-00004cc0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00004cd0: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-00004ce0: 2020 2020 2020 2020 2020 2020 2072 6f77               row
-00004cf0: 7320 3d20 736c 6963 6528 726f 775f 6f66  s = slice(row_of
-00004d00: 6673 6574 2c20 6e62 5f72 6f77 735f 746f  fset, nb_rows_to
-00004d10: 7461 6c29 0d0a 0d0a 2020 2020 2020 2020  tal)....        
-00004d20: 2020 2020 2020 2020 2320 5265 6d61 726b          # Remark
-00004d30: 3a20 7468 6973 2074 656d 7020 6669 6c65  : this temp file
-00004d40: 2064 6f65 736e 2774 206e 6565 6420 7370   doesn't need sp
-00004d50: 6174 6961 6c20 696e 6465 780d 0a20 2020  atial index..   
-00004d60: 2020 2020 2020 2020 2020 2020 2023 2052               # R
-00004d70: 656d 6172 6b3a 2062 6563 6175 7365 2066  emark: because f
-00004d80: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-00004d90: 6574 7279 7479 7065 2066 6f72 2047 656f  etrytype for Geo
-00004da0: 4461 7461 4672 616d 650d 0a20 2020 2020  DataFrame..     
-00004db0: 2020 2020 2020 2020 2020 2023 206f 7065             # ope
-00004dc0: 7261 7469 6f6e 7320 6973 2028 6120 6c6f  rations is (a lo
-00004dd0: 7429 206d 6f72 6520 6c69 6d69 7465 6420  t) more limited 
-00004de0: 7468 616e 2067 6461 6c2d 6261 7365 642c  than gdal-based,
-00004df0: 2074 6865 2067 6461 6c20 7665 7273 696f   the gdal versio
-00004e00: 6e0d 0a20 2020 2020 2020 2020 2020 2020  n..             
-00004e10: 2020 2023 2069 7320 7573 6564 206c 6174     # is used lat
-00004e20: 6572 206f 6e20 7768 656e 2074 6865 2072  er on when the r
-00004e30: 6573 756c 7473 2061 7265 206d 6572 6765  esults are merge
-00004e40: 6420 746f 2074 6865 2072 6573 756c 7420  d to the result 
-00004e50: 6669 6c65 2e0d 0a20 2020 2020 2020 2020  file...         
-00004e60: 2020 2020 2020 2066 7574 7572 6520 3d20         future = 
-00004e70: 6361 6c63 756c 6174 655f 706f 6f6c 2e73  calculate_pool.s
-00004e80: 7562 6d69 7428 0d0a 2020 2020 2020 2020  ubmit(..        
-00004e90: 2020 2020 2020 2020 2020 2020 5f61 7070              _app
-00004ea0: 6c79 5f67 656f 6f70 6572 6174 696f 6e2c  ly_geooperation,
-00004eb0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00004ec0: 2020 2020 2020 696e 7075 745f 7061 7468        input_path
-00004ed0: 3d69 6e70 7574 5f70 6174 682c 0d0a 2020  =input_path,..  
-00004ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004ef0: 2020 6f75 7470 7574 5f70 6174 683d 6f75    output_path=ou
-00004f00: 7470 7574 5f74 6d70 5f70 6172 7469 616c  tput_tmp_partial
-00004f10: 5f70 6174 682c 0d0a 2020 2020 2020 2020  _path,..        
-00004f20: 2020 2020 2020 2020 2020 2020 6f70 6572              oper
-00004f30: 6174 696f 6e3d 6f70 6572 6174 696f 6e2c  ation=operation,
-00004f40: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00004f50: 2020 2020 2020 6f70 6572 6174 696f 6e5f        operation_
-00004f60: 7061 7261 6d73 3d6f 7065 7261 7469 6f6e  params=operation
-00004f70: 5f70 6172 616d 732c 0d0a 2020 2020 2020  _params,..      
-00004f80: 2020 2020 2020 2020 2020 2020 2020 696e                in
-00004f90: 7075 745f 6c61 7965 723d 696e 7075 745f  put_layer=input_
-00004fa0: 6c61 7965 722c 0d0a 2020 2020 2020 2020  layer,..        
-00004fb0: 2020 2020 2020 2020 2020 2020 636f 6c75              colu
-00004fc0: 6d6e 733d 636f 6c75 6d6e 732c 0d0a 2020  mns=columns,..  
-00004fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004fe0: 2020 6f75 7470 7574 5f6c 6179 6572 3d6f    output_layer=o
-00004ff0: 7574 7075 745f 6c61 7965 722c 0d0a 2020  utput_layer,..  
-00005000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005010: 2020 726f 7773 3d72 6f77 732c 0d0a 2020    rows=rows,..  
-00005020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005030: 2020 6578 706c 6f64 6563 6f6c 6c65 6374    explodecollect
-00005040: 696f 6e73 3d65 7870 6c6f 6465 636f 6c6c  ions=explodecoll
-00005050: 6563 7469 6f6e 732c 0d0a 2020 2020 2020  ections,..      
-00005060: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-00005070: 7263 653d 666f 7263 652c 0d0a 2020 2020  rce=force,..    
-00005080: 2020 2020 2020 2020 2020 2020 290d 0a20              ).. 
-00005090: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-000050a0: 7574 7572 655f 746f 5f62 6174 6368 5f69  uture_to_batch_i
-000050b0: 645b 6675 7475 7265 5d20 3d20 6261 7463  d[future] = batc
-000050c0: 685f 6964 0d0a 2020 2020 2020 2020 2020  h_id..          
-000050d0: 2020 2020 2020 726f 775f 6f66 6673 6574        row_offset
-000050e0: 202b 3d20 7265 616c 5f62 6174 6368 7369   += real_batchsi
-000050f0: 7a65 0d0a 0d0a 2020 2020 2020 2020 2020  ze....          
-00005100: 2020 2320 4c6f 6f70 2074 696c 6c20 616c    # Loop till al
-00005110: 6c20 7061 7261 6c6c 656c 2070 726f 6365  l parallel proce
-00005120: 7373 6573 2061 7265 2072 6561 6479 2c20  sses are ready, 
-00005130: 6275 7420 7072 6f63 6573 7320 6561 6368  but process each
-00005140: 206f 6e65 0d0a 2020 2020 2020 2020 2020   one..          
-00005150: 2020 2320 7468 6174 2069 7320 7265 6164    # that is read
-00005160: 7920 616c 7265 6164 790d 0a20 2020 2020  y already..     
-00005170: 2020 2020 2020 2073 7461 7274 5f74 696d         start_tim
-00005180: 6520 3d20 6461 7465 7469 6d65 2e6e 6f77  e = datetime.now
-00005190: 2829 0d0a 2020 2020 2020 2020 2020 2020  ()..            
-000051a0: 5f67 656e 6572 616c 5f75 7469 6c2e 7265  _general_util.re
-000051b0: 706f 7274 5f70 726f 6772 6573 7328 0d0a  port_progress(..
-000051c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000051d0: 7374 6172 745f 7469 6d65 2c20 6e62 5f64  start_time, nb_d
-000051e0: 6f6e 652c 206e 625f 6261 7463 6865 732c  one, nb_batches,
-000051f0: 206f 7065 7261 7469 6f6e 2e76 616c 7565   operation.value
-00005200: 2c20 6e62 5f70 6172 616c 6c65 6c0d 0a20  , nb_parallel.. 
-00005210: 2020 2020 2020 2020 2020 2029 0d0a 2020             )..  
-00005220: 2020 2020 2020 2020 2020 666f 7220 6675            for fu
-00005230: 7475 7265 2069 6e20 6675 7475 7265 732e  ture in futures.
-00005240: 6173 5f63 6f6d 706c 6574 6564 2866 7574  as_completed(fut
-00005250: 7572 655f 746f 5f62 6174 6368 5f69 6429  ure_to_batch_id)
-00005260: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00005270: 2020 2074 7279 3a0d 0a20 2020 2020 2020     try:..       
-00005280: 2020 2020 2020 2020 2020 2020 206d 6573               mes
-00005290: 7361 6765 203d 2066 7574 7572 652e 7265  sage = future.re
-000052a0: 7375 6c74 2829 0d0a 2020 2020 2020 2020  sult()..        
-000052b0: 2020 2020 2020 2020 2020 2020 6c6f 6767              logg
-000052c0: 6572 2e64 6562 7567 286d 6573 7361 6765  er.debug(message
-000052d0: 290d 0a0d 0a20 2020 2020 2020 2020 2020  )....           
-000052e0: 2020 2020 2020 2020 2023 2049 6620 7468           # If th
-000052f0: 6520 6361 6c63 756c 6174 6520 6761 7665  e calculate gave
-00005300: 2072 6573 756c 7473 2c20 636f 7079 2074   results, copy t
-00005310: 6f20 6f75 7470 7574 0d0a 2020 2020 2020  o output..      
-00005320: 2020 2020 2020 2020 2020 2020 2020 6261                ba
-00005330: 7463 685f 6964 203d 2066 7574 7572 655f  tch_id = future_
-00005340: 746f 5f62 6174 6368 5f69 645b 6675 7475  to_batch_id[futu
-00005350: 7265 5d0d 0a20 2020 2020 2020 2020 2020  re]..           
-00005360: 2020 2020 2020 2020 2074 6d70 5f70 6172           tmp_par
-00005370: 7469 616c 5f6f 7574 7075 745f 7061 7468  tial_output_path
-00005380: 203d 2062 6174 6368 6573 5b62 6174 6368   = batches[batch
-00005390: 5f69 645d 5b0d 0a20 2020 2020 2020 2020  _id][..         
-000053a0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-000053b0: 746d 705f 7061 7274 6961 6c5f 6f75 7470  tmp_partial_outp
-000053c0: 7574 5f70 6174 6822 0d0a 2020 2020 2020  ut_path"..      
-000053d0: 2020 2020 2020 2020 2020 2020 2020 5d0d                ].
-000053e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000053f0: 2020 2020 2069 6620 280d 0a20 2020 2020       if (..     
-00005400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005410: 2020 2074 6d70 5f70 6172 7469 616c 5f6f     tmp_partial_o
-00005420: 7574 7075 745f 7061 7468 2e65 7869 7374  utput_path.exist
-00005430: 7328 290d 0a20 2020 2020 2020 2020 2020  s()..           
-00005440: 2020 2020 2020 2020 2020 2020 2061 6e64               and
-00005450: 2074 6d70 5f70 6172 7469 616c 5f6f 7574   tmp_partial_out
-00005460: 7075 745f 7061 7468 2e73 7461 7428 292e  put_path.stat().
-00005470: 7374 5f73 697a 6520 3e20 300d 0a20 2020  st_size > 0..   
+00000660: 0a0a 0a63 6c61 7373 2050 6172 616c 6c65  ...class Paralle
+00000670: 6c69 7a61 7469 6f6e 436f 6e66 6967 3a0a  lizationConfig:.
+00000680: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
+00000690: 280a 2020 2020 2020 2020 7365 6c66 2c0a  (.        self,.
+000006a0: 2020 2020 2020 2020 6279 7465 735f 6261          bytes_ba
+000006b0: 7365 666f 6f74 7072 696e 743a 2069 6e74  sefootprint: int
+000006c0: 203d 2035 3020 2a20 3130 3234 202a 2031   = 50 * 1024 * 1
+000006d0: 3032 342c 0a20 2020 2020 2020 2062 7974  024,.        byt
+000006e0: 6573 5f70 6572 5f72 6f77 3a20 696e 7420  es_per_row: int 
+000006f0: 3d20 3130 302c 0a20 2020 2020 2020 206d  = 100,.        m
+00000700: 696e 5f61 7667 5f72 6f77 735f 7065 725f  in_avg_rows_per_
+00000710: 6261 7463 683a 2069 6e74 203d 2031 3030  batch: int = 100
+00000720: 302c 0a20 2020 2020 2020 206d 6178 5f61  0,.        max_a
+00000730: 7667 5f72 6f77 735f 7065 725f 6261 7463  vg_rows_per_batc
+00000740: 683a 2069 6e74 203d 2031 3030 3030 2c0a  h: int = 10000,.
+00000750: 2020 2020 2020 2020 6279 7465 735f 6d69          bytes_mi
+00000760: 6e5f 7065 725f 7072 6f63 6573 733d 4e6f  n_per_process=No
+00000770: 6e65 2c0a 2020 2020 2020 2020 6279 7465  ne,.        byte
+00000780: 735f 7573 6162 6c65 3d4e 6f6e 652c 0a20  s_usable=None,. 
+00000790: 2020 2029 3a0a 2020 2020 2020 2020 7365     ):.        se
+000007a0: 6c66 2e62 7974 6573 5f62 6173 6566 6f6f  lf.bytes_basefoo
+000007b0: 7470 7269 6e74 203d 2062 7974 6573 5f62  tprint = bytes_b
+000007c0: 6173 6566 6f6f 7470 7269 6e74 0a20 2020  asefootprint.   
+000007d0: 2020 2020 2073 656c 662e 6279 7465 735f       self.bytes_
+000007e0: 7065 725f 726f 7720 3d20 6279 7465 735f  per_row = bytes_
+000007f0: 7065 725f 726f 770a 2020 2020 2020 2020  per_row.        
+00000800: 7365 6c66 2e6d 696e 5f61 7667 5f72 6f77  self.min_avg_row
+00000810: 735f 7065 725f 6261 7463 6820 3d20 6d69  s_per_batch = mi
+00000820: 6e5f 6176 675f 726f 7773 5f70 6572 5f62  n_avg_rows_per_b
+00000830: 6174 6368 0a20 2020 2020 2020 2073 656c  atch.        sel
+00000840: 662e 6d61 785f 6176 675f 726f 7773 5f70  f.max_avg_rows_p
+00000850: 6572 5f62 6174 6368 203d 206d 6178 5f61  er_batch = max_a
+00000860: 7667 5f72 6f77 735f 7065 725f 6261 7463  vg_rows_per_batc
+00000870: 680a 2020 2020 2020 2020 6966 2062 7974  h.        if byt
+00000880: 6573 5f6d 696e 5f70 6572 5f70 726f 6365  es_min_per_proce
+00000890: 7373 2069 7320 4e6f 6e65 3a0a 2020 2020  ss is None:.    
+000008a0: 2020 2020 2020 2020 7365 6c66 2e62 7974          self.byt
+000008b0: 6573 5f6d 696e 5f70 6572 5f70 726f 6365  es_min_per_proce
+000008c0: 7373 203d 2028 0a20 2020 2020 2020 2020  ss = (.         
+000008d0: 2020 2020 2020 2062 7974 6573 5f62 6173         bytes_bas
+000008e0: 6566 6f6f 7470 7269 6e74 202b 2062 7974  efootprint + byt
+000008f0: 6573 5f70 6572 5f72 6f77 202a 206d 696e  es_per_row * min
+00000900: 5f61 7667 5f72 6f77 735f 7065 725f 6261  _avg_rows_per_ba
+00000910: 7463 680a 2020 2020 2020 2020 2020 2020  tch.            
+00000920: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+00000930: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00000940: 2e62 7974 6573 5f6d 696e 5f70 6572 5f70  .bytes_min_per_p
+00000950: 726f 6365 7373 203d 2062 7974 6573 5f6d  rocess = bytes_m
+00000960: 696e 5f70 6572 5f70 726f 6365 7373 0a20  in_per_process. 
+00000970: 2020 2020 2020 2069 6620 6279 7465 735f         if bytes_
+00000980: 7573 6162 6c65 2069 7320 4e6f 6e65 3a0a  usable is None:.
+00000990: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000009a0: 2e62 7974 6573 5f75 7361 626c 6520 3d20  .bytes_usable = 
+000009b0: 7073 7574 696c 2e76 6972 7475 616c 5f6d  psutil.virtual_m
+000009c0: 656d 6f72 7928 292e 6176 6169 6c61 626c  emory().availabl
+000009d0: 6520 2a20 302e 390a 2020 2020 2020 2020  e * 0.9.        
+000009e0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+000009f0: 2020 7365 6c66 2e62 7974 6573 5f75 7361    self.bytes_usa
+00000a00: 626c 6520 3d20 6279 7465 735f 7573 6162  ble = bytes_usab
+00000a10: 6c65 0a0a 0a70 6172 616c 6c65 6c69 7a61  le...paralleliza
+00000a20: 7469 6f6e 5061 7261 6d73 203d 204e 616d  tionParams = Nam
+00000a30: 6564 5475 706c 6528 0a20 2020 2022 7265  edTuple(.    "re
+00000a40: 7375 6c74 222c 0a20 2020 205b 2822 6e62  sult",.    [("nb
+00000a50: 5f70 6172 616c 6c65 6c22 2c20 696e 7429  _parallel", int)
+00000a60: 2c20 2822 6e62 5f62 6174 6368 6573 5f72  , ("nb_batches_r
+00000a70: 6563 6f6d 6d65 6e64 6564 222c 2069 6e74  ecommended", int
+00000a80: 292c 2028 226e 625f 726f 7773 5f70 6572  ), ("nb_rows_per
+00000a90: 5f62 6174 6368 222c 2069 6e74 295d 2c0a  _batch", int)],.
+00000aa0: 290a 0a0a 6465 6620 6765 745f 7061 7261  )...def get_para
+00000ab0: 6c6c 656c 697a 6174 696f 6e5f 7061 7261  llelization_para
+00000ac0: 6d73 280a 2020 2020 6e62 5f72 6f77 735f  ms(.    nb_rows_
+00000ad0: 746f 7461 6c3a 2069 6e74 2c0a 2020 2020  total: int,.    
+00000ae0: 6e62 5f70 6172 616c 6c65 6c3a 2069 6e74  nb_parallel: int
+00000af0: 203d 202d 312c 0a20 2020 206e 625f 6261   = -1,.    nb_ba
+00000b00: 7463 6865 735f 7072 6576 696f 7573 5f70  tches_previous_p
+00000b10: 6173 733a 204f 7074 696f 6e61 6c5b 696e  ass: Optional[in
+00000b20: 745d 203d 204e 6f6e 652c 0a20 2020 2070  t] = None,.    p
+00000b30: 6172 616c 6c65 6c69 7a61 7469 6f6e 5f63  arallelization_c
+00000b40: 6f6e 6669 673a 204f 7074 696f 6e61 6c5b  onfig: Optional[
+00000b50: 5061 7261 6c6c 656c 697a 6174 696f 6e43  ParallelizationC
+00000b60: 6f6e 6669 675d 203d 204e 6f6e 652c 0a29  onfig] = None,.)
+00000b70: 202d 3e20 7061 7261 6c6c 656c 697a 6174   -> parallelizat
+00000b80: 696f 6e50 6172 616d 733a 0a20 2020 2022  ionParams:.    "
+00000b90: 2222 0a20 2020 2044 6574 6572 6d69 6e65  "".    Determine
+00000ba0: 7320 7265 636f 6d6d 656e 6465 6420 7061  s recommended pa
+00000bb0: 7261 6c6c 656c 697a 6174 696f 6e20 7061  rallelization pa
+00000bc0: 7261 6d73 2e0a 0a20 2020 2041 7267 733a  rams...    Args:
+00000bd0: 0a20 2020 2020 2020 206e 625f 726f 7773  .        nb_rows
+00000be0: 5f74 6f74 616c 2028 696e 7429 3a20 5468  _total (int): Th
+00000bf0: 6520 746f 7461 6c20 6e75 6d62 6572 206f  e total number o
+00000c00: 6620 726f 7773 2074 6861 7420 7769 6c6c  f rows that will
+00000c10: 2062 6520 7072 6f63 6573 7365 640a 2020   be processed.  
+00000c20: 2020 2020 2020 6e62 5f70 6172 616c 6c65        nb_paralle
+00000c30: 6c20 2869 6e74 2c20 6f70 7469 6f6e 616c  l (int, optional
+00000c40: 293a 2054 6865 206c 6576 656c 206f 6620  ): The level of 
+00000c50: 7061 7261 6c6c 656c 697a 6174 696f 6e20  parallelization 
+00000c60: 7265 7175 6573 7465 642e 0a20 2020 2020  requested..     
+00000c70: 2020 2020 2020 2049 6620 2d31 2c20 7472         If -1, tr
+00000c80: 6965 7320 746f 2075 7365 2061 6c6c 2072  ies to use all r
+00000c90: 6573 6f75 7263 6573 2061 7661 696c 6162  esources availab
+00000ca0: 6c65 2e20 4465 6661 756c 7473 2074 6f20  le. Defaults to 
+00000cb0: 2d31 2e0a 2020 2020 2020 2020 6e62 5f62  -1..        nb_b
+00000cc0: 6174 6368 6573 5f70 7265 7669 6f75 735f  atches_previous_
+00000cd0: 7061 7373 2028 696e 742c 206f 7074 696f  pass (int, optio
+00000ce0: 6e61 6c29 3a20 4966 2061 7070 6c69 6361  nal): If applica
+00000cf0: 626c 652c 2074 6865 206e 756d 6265 7220  ble, the number 
+00000d00: 6f66 2062 6174 6368 6573 0a20 2020 2020  of batches.     
+00000d10: 2020 2020 2020 2075 7365 6420 696e 2061         used in a
+00000d20: 2070 7265 7669 6f75 7320 7061 7373 206f   previous pass o
+00000d30: 6620 7468 6520 6361 6c63 756c 6174 696f  f the calculatio
+00000d40: 6e2e 2044 6566 6175 6c74 7320 746f 204e  n. Defaults to N
+00000d50: 6f6e 652e 0a0a 2020 2020 5265 7475 726e  one...    Return
+00000d60: 733a 0a20 2020 2020 2020 2070 6172 616c  s:.        paral
+00000d70: 6c65 6c69 7a61 7469 6f6e 5061 7261 6d73  lelizationParams
+00000d80: 3a20 5468 6520 7265 636f 6d6d 656e 6465  : The recommende
+00000d90: 6420 7061 7261 6d65 7465 7273 2e0a 2020  d parameters..  
+00000da0: 2020 2222 220a 2020 2020 2320 496e 6974    """.    # Init
+00000db0: 2070 6172 616c 6c65 6c69 7a61 7469 6f6e   parallelization
+00000dc0: 2063 6f6e 6669 670a 0a20 2020 2023 2049   config..    # I
+00000dd0: 6620 636f 6e66 6967 2069 7320 4e6f 6e65  f config is None
+00000de0: 2c20 7365 7420 746f 2065 6d70 7479 2064  , set to empty d
+00000df0: 6963 740a 2020 2020 6966 2070 6172 616c  ict.    if paral
+00000e00: 6c65 6c69 7a61 7469 6f6e 5f63 6f6e 6669  lelization_confi
+00000e10: 6720 6973 206e 6f74 204e 6f6e 653a 0a20  g is not None:. 
+00000e20: 2020 2020 2020 2070 6172 616c 6c65 6c69         paralleli
+00000e30: 7a61 7469 6f6e 5f63 6f6e 6669 675f 6c6f  zation_config_lo
+00000e40: 6361 6c20 3d20 7061 7261 6c6c 656c 697a  cal = paralleliz
+00000e50: 6174 696f 6e5f 636f 6e66 6967 0a20 2020  ation_config.   
+00000e60: 2065 6c73 653a 0a20 2020 2020 2020 2070   else:.        p
+00000e70: 6172 616c 6c65 6c69 7a61 7469 6f6e 5f63  arallelization_c
+00000e80: 6f6e 6669 675f 6c6f 6361 6c20 3d20 5061  onfig_local = Pa
+00000e90: 7261 6c6c 656c 697a 6174 696f 6e43 6f6e  rallelizationCon
+00000ea0: 6669 6728 290a 0a20 2020 2023 2049 6620  fig()..    # If 
+00000eb0: 7468 6520 6e75 6d62 6572 206f 6620 726f  the number of ro
+00000ec0: 7773 2069 7320 7265 616c 6c79 206c 6f77  ws is really low
+00000ed0: 2c20 6a75 7374 2075 7365 206f 6e65 2062  , just use one b
+00000ee0: 6174 6368 0a20 2020 2023 2054 4f44 4f3a  atch.    # TODO:
+00000ef0: 2066 6f72 2076 6572 7920 636f 6d70 6c65   for very comple
+00000f00: 7820 6665 6174 7572 6573 2c20 706f 7373  x features, poss
+00000f10: 6962 6c79 2074 6869 7320 6c69 6d69 7420  ibly this limit 
+00000f20: 6973 206e 6f74 2061 2067 6f6f 6420 6964  is not a good id
+00000f30: 6561 0a20 2020 2069 6620 6e62 5f72 6f77  ea.    if nb_row
+00000f40: 735f 746f 7461 6c20 3c20 7061 7261 6c6c  s_total < parall
+00000f50: 656c 697a 6174 696f 6e5f 636f 6e66 6967  elization_config
+00000f60: 5f6c 6f63 616c 2e6d 696e 5f61 7667 5f72  _local.min_avg_r
+00000f70: 6f77 735f 7065 725f 6261 7463 683a 0a20  ows_per_batch:. 
+00000f80: 2020 2020 2020 2072 6574 7572 6e20 7061         return pa
+00000f90: 7261 6c6c 656c 697a 6174 696f 6e50 6172  rallelizationPar
+00000fa0: 616d 7328 312c 2031 2c20 6e62 5f72 6f77  ams(1, 1, nb_row
+00000fb0: 735f 746f 7461 6c29 0a0a 2020 2020 6966  s_total)..    if
+00000fc0: 206e 625f 7061 7261 6c6c 656c 203d 3d20   nb_parallel == 
+00000fd0: 2d31 3a0a 2020 2020 2020 2020 6e62 5f70  -1:.        nb_p
+00000fe0: 6172 616c 6c65 6c20 3d20 6d75 6c74 6970  arallel = multip
+00000ff0: 726f 6365 7373 696e 672e 6370 755f 636f  rocessing.cpu_co
+00001000: 756e 7428 290a 0a20 2020 206d 656d 5f75  unt()..    mem_u
+00001010: 7361 626c 6520 3d20 5f67 656e 6572 616c  sable = _general
+00001020: 5f75 7469 6c2e 666f 726d 6174 6279 7465  _util.formatbyte
+00001030: 7328 7061 7261 6c6c 656c 697a 6174 696f  s(parallelizatio
+00001040: 6e5f 636f 6e66 6967 5f6c 6f63 616c 2e62  n_config_local.b
+00001050: 7974 6573 5f75 7361 626c 6529 0a20 2020  ytes_usable).   
+00001060: 206c 6f67 6765 722e 6465 6275 6728 6622   logger.debug(f"
+00001070: 6d65 6d6f 7279 5f75 7361 626c 653a 207b  memory_usable: {
+00001080: 6d65 6d5f 7573 6162 6c65 7d2c 2077 6974  mem_usable}, wit
+00001090: 683a 2229 0a20 2020 206d 656d 5f61 7661  h:").    mem_ava
+000010a0: 696c 6162 6c65 203d 205f 6765 6e65 7261  ilable = _genera
+000010b0: 6c5f 7574 696c 2e66 6f72 6d61 7462 7974  l_util.formatbyt
+000010c0: 6573 2870 7375 7469 6c2e 7669 7274 7561  es(psutil.virtua
+000010d0: 6c5f 6d65 6d6f 7279 2829 2e61 7661 696c  l_memory().avail
+000010e0: 6162 6c65 290a 2020 2020 6c6f 6767 6572  able).    logger
+000010f0: 2e64 6562 7567 2866 2220 202d 3e20 6d65  .debug(f"  -> me
+00001100: 6d2e 6176 6169 6c61 626c 653a 207b 6d65  m.available: {me
+00001110: 6d5f 6176 6169 6c61 626c 657d 2229 0a20  m_available}"). 
+00001120: 2020 2073 7761 705f 6672 6565 203d 205f     swap_free = _
+00001130: 6765 6e65 7261 6c5f 7574 696c 2e66 6f72  general_util.for
+00001140: 6d61 7462 7974 6573 2870 7375 7469 6c2e  matbytes(psutil.
+00001150: 7377 6170 5f6d 656d 6f72 7928 292e 6672  swap_memory().fr
+00001160: 6565 290a 2020 2020 6c6f 6767 6572 2e64  ee).    logger.d
+00001170: 6562 7567 2866 2220 202d 3e20 7377 6170  ebug(f"  -> swap
+00001180: 2e66 7265 653a 207b 7377 6170 5f66 7265  .free: {swap_fre
+00001190: 657d 2229 0a0a 2020 2020 2320 4966 206e  e}")..    # If n
+000011a0: 6f74 2065 6e6f 7567 6820 6d65 6d6f 7279  ot enough memory
+000011b0: 2066 6f72 2074 6865 2061 6d6f 756e 7420   for the amount 
+000011c0: 6f66 2070 6172 616c 6c65 6c6c 6973 6d20  of parallellism 
+000011d0: 6173 6b65 642c 2072 6564 7563 650a 2020  asked, reduce.  
+000011e0: 2020 6966 2028 0a20 2020 2020 2020 206e    if (.        n
+000011f0: 625f 7061 7261 6c6c 656c 202a 2070 6172  b_parallel * par
+00001200: 616c 6c65 6c69 7a61 7469 6f6e 5f63 6f6e  allelization_con
+00001210: 6669 675f 6c6f 6361 6c2e 6279 7465 735f  fig_local.bytes_
+00001220: 6d69 6e5f 7065 725f 7072 6f63 6573 730a  min_per_process.
+00001230: 2020 2020 2920 3e20 7061 7261 6c6c 656c      ) > parallel
+00001240: 697a 6174 696f 6e5f 636f 6e66 6967 5f6c  ization_config_l
+00001250: 6f63 616c 2e62 7974 6573 5f75 7361 626c  ocal.bytes_usabl
+00001260: 653a 0a20 2020 2020 2020 206e 625f 7061  e:.        nb_pa
+00001270: 7261 6c6c 656c 203d 2069 6e74 280a 2020  rallel = int(.  
+00001280: 2020 2020 2020 2020 2020 7061 7261 6c6c            parall
+00001290: 656c 697a 6174 696f 6e5f 636f 6e66 6967  elization_config
+000012a0: 5f6c 6f63 616c 2e62 7974 6573 5f75 7361  _local.bytes_usa
+000012b0: 626c 650a 2020 2020 2020 2020 2020 2020  ble.            
+000012c0: 2f20 7061 7261 6c6c 656c 697a 6174 696f  / parallelizatio
+000012d0: 6e5f 636f 6e66 6967 5f6c 6f63 616c 2e62  n_config_local.b
+000012e0: 7974 6573 5f6d 696e 5f70 6572 5f70 726f  ytes_min_per_pro
+000012f0: 6365 7373 0a20 2020 2020 2020 2029 0a20  cess.        ). 
+00001300: 2020 2020 2020 206c 6f67 6765 722e 6465         logger.de
+00001310: 6275 6728 6622 4e62 5f70 6172 616c 6c65  bug(f"Nb_paralle
+00001320: 6c20 7265 6475 6365 6420 746f 207b 6e62  l reduced to {nb
+00001330: 5f70 6172 616c 6c65 6c7d 2074 6f20 7265  _parallel} to re
+00001340: 6475 6365 206d 656d 6f72 7920 7573 6167  duce memory usag
+00001350: 6522 290a 0a20 2020 2023 204f 7074 696d  e")..    # Optim
+00001360: 616c 206e 756d 6265 7220 6f66 2062 6174  al number of bat
+00001370: 6368 6573 2061 6e64 2072 6f77 7320 7065  ches and rows pe
+00001380: 7220 6261 7463 6820 6261 7365 6420 6f6e  r batch based on
+00001390: 206d 656d 6f72 7920 7573 6167 650a 2020   memory usage.  
+000013a0: 2020 6e62 5f62 6174 6368 6573 203d 206d    nb_batches = m
+000013b0: 6174 682e 6365 696c 280a 2020 2020 2020  ath.ceil(.      
+000013c0: 2020 286e 625f 726f 7773 5f74 6f74 616c    (nb_rows_total
+000013d0: 202a 2070 6172 616c 6c65 6c69 7a61 7469   * parallelizati
+000013e0: 6f6e 5f63 6f6e 6669 675f 6c6f 6361 6c2e  on_config_local.
+000013f0: 6279 7465 735f 7065 725f 726f 7720 2a20  bytes_per_row * 
+00001400: 6e62 5f70 6172 616c 6c65 6c29 0a20 2020  nb_parallel).   
+00001410: 2020 2020 202f 2028 0a20 2020 2020 2020       / (.       
+00001420: 2020 2020 2070 6172 616c 6c65 6c69 7a61       paralleliza
+00001430: 7469 6f6e 5f63 6f6e 6669 675f 6c6f 6361  tion_config_loca
+00001440: 6c2e 6279 7465 735f 7573 6162 6c65 0a20  l.bytes_usable. 
+00001450: 2020 2020 2020 2020 2020 202d 2070 6172             - par
+00001460: 616c 6c65 6c69 7a61 7469 6f6e 5f63 6f6e  allelization_con
+00001470: 6669 675f 6c6f 6361 6c2e 6279 7465 735f  fig_local.bytes_
+00001480: 6261 7365 666f 6f74 7072 696e 7420 2a20  basefootprint * 
+00001490: 6e62 5f70 6172 616c 6c65 6c0a 2020 2020  nb_parallel.    
+000014a0: 2020 2020 290a 2020 2020 290a 0a20 2020      ).    )..   
+000014b0: 2023 204d 616b 6520 7375 7265 2074 6865   # Make sure the
+000014c0: 2061 7665 7261 6765 2062 6174 6368 2064   average batch d
+000014d0: 6f65 736e 2774 2063 6f6e 7461 696e 203e  oesn't contain >
+000014e0: 206d 6178 5f61 7667 5f72 6f77 735f 7065   max_avg_rows_pe
+000014f0: 725f 6261 7463 680a 2020 2020 6261 7463  r_batch.    batc
+00001500: 685f 7369 7a65 203d 206d 6174 682e 6365  h_size = math.ce
+00001510: 696c 286e 625f 726f 7773 5f74 6f74 616c  il(nb_rows_total
+00001520: 202f 206e 625f 6261 7463 6865 7329 0a20   / nb_batches). 
+00001530: 2020 2069 6620 6261 7463 685f 7369 7a65     if batch_size
+00001540: 203e 2070 6172 616c 6c65 6c69 7a61 7469   > parallelizati
+00001550: 6f6e 5f63 6f6e 6669 675f 6c6f 6361 6c2e  on_config_local.
+00001560: 6d61 785f 6176 675f 726f 7773 5f70 6572  max_avg_rows_per
+00001570: 5f62 6174 6368 3a0a 2020 2020 2020 2020  _batch:.        
+00001580: 6261 7463 685f 7369 7a65 203d 2070 6172  batch_size = par
+00001590: 616c 6c65 6c69 7a61 7469 6f6e 5f63 6f6e  allelization_con
+000015a0: 6669 675f 6c6f 6361 6c2e 6d61 785f 6176  fig_local.max_av
+000015b0: 675f 726f 7773 5f70 6572 5f62 6174 6368  g_rows_per_batch
+000015c0: 0a20 2020 2020 2020 206e 625f 6261 7463  .        nb_batc
+000015d0: 6865 7320 3d20 6d61 7468 2e63 6569 6c28  hes = math.ceil(
+000015e0: 6e62 5f72 6f77 735f 746f 7461 6c20 2f20  nb_rows_total / 
+000015f0: 6261 7463 685f 7369 7a65 290a 0a20 2020  batch_size)..   
+00001600: 206d 656d 5f70 7265 6469 6374 6564 203d   mem_predicted =
+00001610: 2028 0a20 2020 2020 2020 2070 6172 616c   (.        paral
+00001620: 6c65 6c69 7a61 7469 6f6e 5f63 6f6e 6669  lelization_confi
+00001630: 675f 6c6f 6361 6c2e 6279 7465 735f 6261  g_local.bytes_ba
+00001640: 7365 666f 6f74 7072 696e 740a 2020 2020  sefootprint.    
+00001650: 2020 2020 2b20 6261 7463 685f 7369 7a65      + batch_size
+00001660: 202a 2070 6172 616c 6c65 6c69 7a61 7469   * parallelizati
+00001670: 6f6e 5f63 6f6e 6669 675f 6c6f 6361 6c2e  on_config_local.
+00001680: 6279 7465 735f 7065 725f 726f 770a 2020  bytes_per_row.  
+00001690: 2020 2920 2a20 6e62 5f62 6174 6368 6573    ) * nb_batches
+000016a0: 0a0a 2020 2020 2320 4d61 6b65 2073 7572  ..    # Make sur
+000016b0: 6520 7468 6572 6520 6172 6520 656e 6f75  e there are enou
+000016c0: 6768 2062 6174 6368 6573 2074 6f20 7573  gh batches to us
+000016d0: 6520 6173 206d 7563 6820 7061 7261 6c6c  e as much parall
+000016e0: 656c 6973 6d20 6173 2070 6f73 7369 626c  elism as possibl
+000016f0: 650a 2020 2020 6966 206e 625f 6261 7463  e.    if nb_batc
+00001700: 6865 7320 3e20 3120 616e 6420 6e62 5f62  hes > 1 and nb_b
+00001710: 6174 6368 6573 203c 206e 625f 7061 7261  atches < nb_para
+00001720: 6c6c 656c 3a0a 2020 2020 2020 2020 6d61  llel:.        ma
+00001730: 785f 7061 7261 6c6c 656c 5f62 6174 6368  x_parallel_batch
+00001740: 7369 7a65 203d 2069 6e74 280a 2020 2020  size = int(.    
+00001750: 2020 2020 2020 2020 7061 7261 6c6c 656c          parallel
+00001760: 697a 6174 696f 6e5f 636f 6e66 6967 5f6c  ization_config_l
+00001770: 6f63 616c 2e6d 6178 5f61 7667 5f72 6f77  ocal.max_avg_row
+00001780: 735f 7065 725f 6261 7463 680a 2020 2020  s_per_batch.    
+00001790: 2020 2020 2020 2020 2a20 6e62 5f62 6174          * nb_bat
+000017a0: 6368 6573 0a20 2020 2020 2020 2020 2020  ches.           
+000017b0: 202f 2062 6174 6368 5f73 697a 650a 2020   / batch_size.  
+000017c0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+000017d0: 6e62 5f70 6172 616c 6c65 6c20 3d20 6d69  nb_parallel = mi
+000017e0: 6e28 6d61 785f 7061 7261 6c6c 656c 5f62  n(max_parallel_b
+000017f0: 6174 6368 7369 7a65 2c20 6e62 5f70 6172  atchsize, nb_par
+00001800: 616c 6c65 6c29 0a20 2020 2020 2020 2069  allel).        i
+00001810: 6620 6e62 5f62 6174 6368 6573 5f70 7265  f nb_batches_pre
+00001820: 7669 6f75 735f 7061 7373 2069 7320 4e6f  vious_pass is No
+00001830: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00001840: 6e62 5f62 6174 6368 6573 203d 2072 6f75  nb_batches = rou
+00001850: 6e64 286e 625f 7061 7261 6c6c 656c 202a  nd(nb_parallel *
+00001860: 2031 2e32 3529 0a20 2020 2020 2020 2065   1.25).        e
+00001870: 6c69 6620 6e62 5f62 6174 6368 6573 203c  lif nb_batches <
+00001880: 206e 625f 6261 7463 6865 735f 7072 6576   nb_batches_prev
+00001890: 696f 7573 5f70 6173 7320 2f20 343a 0a20  ious_pass / 4:. 
+000018a0: 2020 2020 2020 2020 2020 206e 625f 6261             nb_ba
+000018b0: 7463 6865 7320 3d20 726f 756e 6428 6e62  tches = round(nb
+000018c0: 5f70 6172 616c 6c65 6c20 2a20 312e 3235  _parallel * 1.25
+000018d0: 290a 0a20 2020 2062 6174 6368 5f73 697a  )..    batch_siz
+000018e0: 6520 3d20 6d61 7468 2e63 6569 6c28 6e62  e = math.ceil(nb
+000018f0: 5f72 6f77 735f 746f 7461 6c20 2f20 6e62  _rows_total / nb
+00001900: 5f62 6174 6368 6573 290a 0a20 2020 2023  _batches)..    #
+00001910: 204c 6f67 2072 6573 756c 740a 2020 2020   Log result.    
+00001920: 6c6f 6767 6572 2e64 6562 7567 2866 226e  logger.debug(f"n
+00001930: 625f 6261 7463 6865 735f 7265 636f 6d6d  b_batches_recomm
+00001940: 656e 6465 643a 207b 6e62 5f62 6174 6368  ended: {nb_batch
+00001950: 6573 7d2c 2072 6f77 735f 7065 725f 6261  es}, rows_per_ba
+00001960: 7463 683a 207b 6261 7463 685f 7369 7a65  tch: {batch_size
+00001970: 7d22 290a 2020 2020 6c6f 6767 6572 2e64  }").    logger.d
+00001980: 6562 7567 2866 2220 2d3e 206e 625f 726f  ebug(f" -> nb_ro
+00001990: 7773 5f69 6e70 7574 5f6c 6179 6572 3a20  ws_input_layer: 
+000019a0: 7b6e 625f 726f 7773 5f74 6f74 616c 7d22  {nb_rows_total}"
+000019b0: 290a 2020 2020 6c6f 6767 6572 2e64 6562  ).    logger.deb
+000019c0: 7567 2866 2220 2d3e 206d 656d 5f70 7265  ug(f" -> mem_pre
+000019d0: 6469 6374 6564 3a20 7b5f 6765 6e65 7261  dicted: {_genera
+000019e0: 6c5f 7574 696c 2e66 6f72 6d61 7462 7974  l_util.formatbyt
+000019f0: 6573 286d 656d 5f70 7265 6469 6374 6564  es(mem_predicted
+00001a00: 297d 2229 0a0a 2020 2020 7265 7475 726e  )}")..    return
+00001a10: 2070 6172 616c 6c65 6c69 7a61 7469 6f6e   parallelization
+00001a20: 5061 7261 6d73 286e 625f 7061 7261 6c6c  Params(nb_parall
+00001a30: 656c 2c20 6e62 5f62 6174 6368 6573 2c20  el, nb_batches, 
+00001a40: 6261 7463 685f 7369 7a65 290a 0a0a 636c  batch_size)...cl
+00001a50: 6173 7320 4765 6f4f 7065 7261 7469 6f6e  ass GeoOperation
+00001a60: 2865 6e75 6d2e 456e 756d 293a 0a20 2020  (enum.Enum):.   
+00001a70: 2053 494d 504c 4946 5920 3d20 2273 696d   SIMPLIFY = "sim
+00001a80: 706c 6966 7922 0a20 2020 2042 5546 4645  plify".    BUFFE
+00001a90: 5220 3d20 2262 7566 6665 7222 0a20 2020  R = "buffer".   
+00001aa0: 2043 4f4e 5645 5848 554c 4c20 3d20 2263   CONVEXHULL = "c
+00001ab0: 6f6e 7665 7868 756c 6c22 0a20 2020 2041  onvexhull".    A
+00001ac0: 5050 4c59 203d 2022 6170 706c 7922 0a0a  PPLY = "apply"..
+00001ad0: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
+00001ae0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001af0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001b00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001b10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001b20: 230a 2320 5468 6520 7265 616c 2073 7475  #.# The real stu
+00001b30: 6666 0a23 2323 2323 2323 2323 2323 2323  ff.#############
+00001b40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001b50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001b60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001b70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001b80: 2323 230a 0a0a 6465 6620 6170 706c 7928  ###...def apply(
+00001b90: 0a20 2020 2069 6e70 7574 5f70 6174 683a  .    input_path:
+00001ba0: 2050 6174 682c 0a20 2020 206f 7574 7075   Path,.    outpu
+00001bb0: 745f 7061 7468 3a20 5061 7468 2c0a 2020  t_path: Path,.  
+00001bc0: 2020 6675 6e63 3a20 4361 6c6c 6162 6c65    func: Callable
+00001bd0: 5b5b 416e 795d 2c20 416e 795d 2c0a 2020  [[Any], Any],.  
+00001be0: 2020 6f6e 6c79 5f67 656f 6d5f 696e 7075    only_geom_inpu
+00001bf0: 743a 2062 6f6f 6c20 3d20 5472 7565 2c0a  t: bool = True,.
+00001c00: 2020 2020 696e 7075 745f 6c61 7965 723a      input_layer:
+00001c10: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
+00001c20: 204e 6f6e 652c 0a20 2020 206f 7574 7075   None,.    outpu
+00001c30: 745f 6c61 7965 723a 204f 7074 696f 6e61  t_layer: Optiona
+00001c40: 6c5b 7374 725d 203d 204e 6f6e 652c 0a20  l[str] = None,. 
+00001c50: 2020 2063 6f6c 756d 6e73 3a20 4f70 7469     columns: Opti
+00001c60: 6f6e 616c 5b4c 6973 745b 7374 725d 5d20  onal[List[str]] 
+00001c70: 3d20 4e6f 6e65 2c0a 2020 2020 6578 706c  = None,.    expl
+00001c80: 6f64 6563 6f6c 6c65 6374 696f 6e73 3a20  odecollections: 
+00001c90: 626f 6f6c 203d 2046 616c 7365 2c0a 2020  bool = False,.  
+00001ca0: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
+00001cb0: 656f 6d65 7472 7974 7970 653a 2055 6e69  eometrytype: Uni
+00001cc0: 6f6e 5b47 656f 6d65 7472 7954 7970 652c  on[GeometryType,
+00001cd0: 2073 7472 2c20 4e6f 6e65 5d20 3d20 4e6f   str, None] = No
+00001ce0: 6e65 2c0a 2020 2020 6e62 5f70 6172 616c  ne,.    nb_paral
+00001cf0: 6c65 6c3a 2069 6e74 203d 202d 312c 0a20  lel: int = -1,. 
+00001d00: 2020 2062 6174 6368 7369 7a65 3a20 696e     batchsize: in
+00001d10: 7420 3d20 2d31 2c0a 2020 2020 666f 7263  t = -1,.    forc
+00001d20: 653a 2062 6f6f 6c20 3d20 4661 6c73 652c  e: bool = False,
+00001d30: 0a29 3a0a 2020 2020 2320 496e 6974 0a20  .):.    # Init. 
+00001d40: 2020 206f 7065 7261 7469 6f6e 5f70 6172     operation_par
+00001d50: 616d 7320 3d20 7b0a 2020 2020 2020 2020  ams = {.        
+00001d60: 226f 6e6c 795f 6765 6f6d 5f69 6e70 7574  "only_geom_input
+00001d70: 223a 206f 6e6c 795f 6765 6f6d 5f69 6e70  ": only_geom_inp
+00001d80: 7574 2c0a 2020 2020 2020 2020 2270 6963  ut,.        "pic
+00001d90: 6b6c 6564 5f66 756e 6322 3a20 636c 6f75  kled_func": clou
+00001da0: 6470 6963 6b6c 652e 6475 6d70 7328 6675  dpickle.dumps(fu
+00001db0: 6e63 292c 0a20 2020 207d 0a0a 2020 2020  nc),.    }..    
+00001dc0: 2320 476f 210a 2020 2020 7265 7475 726e  # Go!.    return
+00001dd0: 205f 6170 706c 795f 6765 6f6f 7065 7261   _apply_geoopera
+00001de0: 7469 6f6e 5f74 6f5f 6c61 7965 7228 0a20  tion_to_layer(. 
+00001df0: 2020 2020 2020 2069 6e70 7574 5f70 6174         input_pat
+00001e00: 683d 696e 7075 745f 7061 7468 2c0a 2020  h=input_path,.  
+00001e10: 2020 2020 2020 6f75 7470 7574 5f70 6174        output_pat
+00001e20: 683d 6f75 7470 7574 5f70 6174 682c 0a20  h=output_path,. 
+00001e30: 2020 2020 2020 206f 7065 7261 7469 6f6e         operation
+00001e40: 3d47 656f 4f70 6572 6174 696f 6e2e 4150  =GeoOperation.AP
+00001e50: 504c 592c 0a20 2020 2020 2020 206f 7065  PLY,.        ope
+00001e60: 7261 7469 6f6e 5f70 6172 616d 733d 6f70  ration_params=op
+00001e70: 6572 6174 696f 6e5f 7061 7261 6d73 2c0a  eration_params,.
+00001e80: 2020 2020 2020 2020 696e 7075 745f 6c61          input_la
+00001e90: 7965 723d 696e 7075 745f 6c61 7965 722c  yer=input_layer,
+00001ea0: 0a20 2020 2020 2020 206f 7574 7075 745f  .        output_
+00001eb0: 6c61 7965 723d 6f75 7470 7574 5f6c 6179  layer=output_lay
+00001ec0: 6572 2c0a 2020 2020 2020 2020 636f 6c75  er,.        colu
+00001ed0: 6d6e 733d 636f 6c75 6d6e 732c 0a20 2020  mns=columns,.   
+00001ee0: 2020 2020 2065 7870 6c6f 6465 636f 6c6c       explodecoll
+00001ef0: 6563 7469 6f6e 733d 6578 706c 6f64 6563  ections=explodec
+00001f00: 6f6c 6c65 6374 696f 6e73 2c0a 2020 2020  ollections,.    
+00001f10: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
+00001f20: 5f67 656f 6d65 7472 7974 7970 653d 666f  _geometrytype=fo
+00001f30: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
+00001f40: 7472 7974 7970 652c 0a20 2020 2020 2020  trytype,.       
+00001f50: 206e 625f 7061 7261 6c6c 656c 3d6e 625f   nb_parallel=nb_
+00001f60: 7061 7261 6c6c 656c 2c0a 2020 2020 2020  parallel,.      
+00001f70: 2020 6261 7463 6873 697a 653d 6261 7463    batchsize=batc
+00001f80: 6873 697a 652c 0a20 2020 2020 2020 2066  hsize,.        f
+00001f90: 6f72 6365 3d66 6f72 6365 2c0a 2020 2020  orce=force,.    
+00001fa0: 290a 0a0a 6465 6620 6275 6666 6572 280a  )...def buffer(.
+00001fb0: 2020 2020 696e 7075 745f 7061 7468 3a20      input_path: 
+00001fc0: 5061 7468 2c0a 2020 2020 6f75 7470 7574  Path,.    output
+00001fd0: 5f70 6174 683a 2050 6174 682c 0a20 2020  _path: Path,.   
+00001fe0: 2064 6973 7461 6e63 653a 2066 6c6f 6174   distance: float
+00001ff0: 2c0a 2020 2020 7175 6164 7261 6e74 7365  ,.    quadrantse
+00002000: 676d 656e 7473 3a20 696e 7420 3d20 352c  gments: int = 5,
+00002010: 0a20 2020 2065 6e64 6361 705f 7374 796c  .    endcap_styl
+00002020: 653a 2042 7566 6665 7245 6e64 4361 7053  e: BufferEndCapS
+00002030: 7479 6c65 203d 2042 7566 6665 7245 6e64  tyle = BufferEnd
+00002040: 4361 7053 7479 6c65 2e52 4f55 4e44 2c0a  CapStyle.ROUND,.
+00002050: 2020 2020 6a6f 696e 5f73 7479 6c65 3a20      join_style: 
+00002060: 4275 6666 6572 4a6f 696e 5374 796c 6520  BufferJoinStyle 
+00002070: 3d20 4275 6666 6572 4a6f 696e 5374 796c  = BufferJoinStyl
+00002080: 652e 524f 554e 442c 0a20 2020 206d 6974  e.ROUND,.    mit
+00002090: 7265 5f6c 696d 6974 3a20 666c 6f61 7420  re_limit: float 
+000020a0: 3d20 352e 302c 0a20 2020 2073 696e 676c  = 5.0,.    singl
+000020b0: 655f 7369 6465 643a 2062 6f6f 6c20 3d20  e_sided: bool = 
+000020c0: 4661 6c73 652c 0a20 2020 2069 6e70 7574  False,.    input
+000020d0: 5f6c 6179 6572 3a20 4f70 7469 6f6e 616c  _layer: Optional
+000020e0: 5b73 7472 5d20 3d20 4e6f 6e65 2c0a 2020  [str] = None,.  
+000020f0: 2020 6f75 7470 7574 5f6c 6179 6572 3a20    output_layer: 
+00002100: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
+00002110: 4e6f 6e65 2c0a 2020 2020 636f 6c75 6d6e  None,.    column
+00002120: 733a 204f 7074 696f 6e61 6c5b 4c69 7374  s: Optional[List
+00002130: 5b73 7472 5d5d 203d 204e 6f6e 652c 0a20  [str]] = None,. 
+00002140: 2020 2065 7870 6c6f 6465 636f 6c6c 6563     explodecollec
+00002150: 7469 6f6e 733a 2062 6f6f 6c20 3d20 4661  tions: bool = Fa
+00002160: 6c73 652c 0a20 2020 206e 625f 7061 7261  lse,.    nb_para
+00002170: 6c6c 656c 3a20 696e 7420 3d20 2d31 2c0a  llel: int = -1,.
+00002180: 2020 2020 6261 7463 6873 697a 653a 2069      batchsize: i
+00002190: 6e74 203d 202d 312c 0a20 2020 2066 6f72  nt = -1,.    for
+000021a0: 6365 3a20 626f 6f6c 203d 2046 616c 7365  ce: bool = False
+000021b0: 2c0a 293a 0a20 2020 2023 2049 6e69 740a  ,.):.    # Init.
+000021c0: 2020 2020 6f70 6572 6174 696f 6e5f 7061      operation_pa
+000021d0: 7261 6d73 203d 207b 0a20 2020 2020 2020  rams = {.       
+000021e0: 2022 6469 7374 616e 6365 223a 2064 6973   "distance": dis
+000021f0: 7461 6e63 652c 0a20 2020 2020 2020 2022  tance,.        "
+00002200: 7175 6164 7261 6e74 7365 676d 656e 7473  quadrantsegments
+00002210: 223a 2071 7561 6472 616e 7473 6567 6d65  ": quadrantsegme
+00002220: 6e74 732c 0a20 2020 2020 2020 2022 656e  nts,.        "en
+00002230: 6463 6170 5f73 7479 6c65 223a 2065 6e64  dcap_style": end
+00002240: 6361 705f 7374 796c 652c 0a20 2020 2020  cap_style,.     
+00002250: 2020 2022 6a6f 696e 5f73 7479 6c65 223a     "join_style":
+00002260: 206a 6f69 6e5f 7374 796c 652c 0a20 2020   join_style,.   
+00002270: 2020 2020 2022 6d69 7472 655f 6c69 6d69       "mitre_limi
+00002280: 7422 3a20 6d69 7472 655f 6c69 6d69 742c  t": mitre_limit,
+00002290: 0a20 2020 2020 2020 2022 7369 6e67 6c65  .        "single
+000022a0: 5f73 6964 6564 223a 2073 696e 676c 655f  _sided": single_
+000022b0: 7369 6465 642c 0a20 2020 207d 0a0a 2020  sided,.    }..  
+000022c0: 2020 2320 4275 6666 6572 206f 7065 7261    # Buffer opera
+000022d0: 7469 6f6e 2061 6c77 6179 7320 7265 7375  tion always resu
+000022e0: 6c74 7320 696e 2070 6f6c 7967 6f6e 732e  lts in polygons.
+000022f0: 2e2e 0a20 2020 2069 6620 6578 706c 6f64  ...    if explod
+00002300: 6563 6f6c 6c65 6374 696f 6e73 3a0a 2020  ecollections:.  
+00002310: 2020 2020 2020 666f 7263 655f 6f75 7470        force_outp
+00002320: 7574 5f67 656f 6d65 7472 7974 7970 6520  ut_geometrytype 
+00002330: 3d20 4765 6f6d 6574 7279 5479 7065 2e50  = GeometryType.P
+00002340: 4f4c 5947 4f4e 2e6e 616d 650a 2020 2020  OLYGON.name.    
+00002350: 656c 7365 3a0a 2020 2020 2020 2020 666f  else:.        fo
+00002360: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
+00002370: 7472 7974 7970 6520 3d20 4765 6f6d 6574  trytype = Geomet
+00002380: 7279 5479 7065 2e4d 554c 5449 504f 4c59  ryType.MULTIPOLY
+00002390: 474f 4e2e 6e61 6d65 0a0a 2020 2020 2320  GON.name..    # 
+000023a0: 476f 210a 2020 2020 7265 7475 726e 205f  Go!.    return _
+000023b0: 6170 706c 795f 6765 6f6f 7065 7261 7469  apply_geooperati
+000023c0: 6f6e 5f74 6f5f 6c61 7965 7228 0a20 2020  on_to_layer(.   
+000023d0: 2020 2020 2069 6e70 7574 5f70 6174 683d       input_path=
+000023e0: 696e 7075 745f 7061 7468 2c0a 2020 2020  input_path,.    
+000023f0: 2020 2020 6f75 7470 7574 5f70 6174 683d      output_path=
+00002400: 6f75 7470 7574 5f70 6174 682c 0a20 2020  output_path,.   
+00002410: 2020 2020 206f 7065 7261 7469 6f6e 3d47       operation=G
+00002420: 656f 4f70 6572 6174 696f 6e2e 4255 4646  eoOperation.BUFF
+00002430: 4552 2c0a 2020 2020 2020 2020 6f70 6572  ER,.        oper
+00002440: 6174 696f 6e5f 7061 7261 6d73 3d6f 7065  ation_params=ope
+00002450: 7261 7469 6f6e 5f70 6172 616d 732c 0a20  ration_params,. 
+00002460: 2020 2020 2020 2069 6e70 7574 5f6c 6179         input_lay
+00002470: 6572 3d69 6e70 7574 5f6c 6179 6572 2c0a  er=input_layer,.
+00002480: 2020 2020 2020 2020 6f75 7470 7574 5f6c          output_l
+00002490: 6179 6572 3d6f 7574 7075 745f 6c61 7965  ayer=output_laye
+000024a0: 722c 0a20 2020 2020 2020 2063 6f6c 756d  r,.        colum
+000024b0: 6e73 3d63 6f6c 756d 6e73 2c0a 2020 2020  ns=columns,.    
+000024c0: 2020 2020 6578 706c 6f64 6563 6f6c 6c65      explodecolle
+000024d0: 6374 696f 6e73 3d65 7870 6c6f 6465 636f  ctions=explodeco
+000024e0: 6c6c 6563 7469 6f6e 732c 0a20 2020 2020  llections,.     
+000024f0: 2020 2066 6f72 6365 5f6f 7574 7075 745f     force_output_
+00002500: 6765 6f6d 6574 7279 7479 7065 3d66 6f72  geometrytype=for
+00002510: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
+00002520: 7279 7479 7065 2c0a 2020 2020 2020 2020  rytype,.        
+00002530: 6e62 5f70 6172 616c 6c65 6c3d 6e62 5f70  nb_parallel=nb_p
+00002540: 6172 616c 6c65 6c2c 0a20 2020 2020 2020  arallel,.       
+00002550: 2062 6174 6368 7369 7a65 3d62 6174 6368   batchsize=batch
+00002560: 7369 7a65 2c0a 2020 2020 2020 2020 666f  size,.        fo
+00002570: 7263 653d 666f 7263 652c 0a20 2020 2029  rce=force,.    )
+00002580: 0a0a 0a64 6566 2063 6f6e 7665 7868 756c  ...def convexhul
+00002590: 6c28 0a20 2020 2069 6e70 7574 5f70 6174  l(.    input_pat
+000025a0: 683a 2050 6174 682c 0a20 2020 206f 7574  h: Path,.    out
+000025b0: 7075 745f 7061 7468 3a20 5061 7468 2c0a  put_path: Path,.
+000025c0: 2020 2020 696e 7075 745f 6c61 7965 723a      input_layer:
+000025d0: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
+000025e0: 204e 6f6e 652c 0a20 2020 206f 7574 7075   None,.    outpu
+000025f0: 745f 6c61 7965 723a 204f 7074 696f 6e61  t_layer: Optiona
+00002600: 6c5b 7374 725d 203d 204e 6f6e 652c 0a20  l[str] = None,. 
+00002610: 2020 2063 6f6c 756d 6e73 3a20 4f70 7469     columns: Opti
+00002620: 6f6e 616c 5b4c 6973 745b 7374 725d 5d20  onal[List[str]] 
+00002630: 3d20 4e6f 6e65 2c0a 2020 2020 6578 706c  = None,.    expl
+00002640: 6f64 6563 6f6c 6c65 6374 696f 6e73 3a20  odecollections: 
+00002650: 626f 6f6c 203d 2046 616c 7365 2c0a 2020  bool = False,.  
+00002660: 2020 6e62 5f70 6172 616c 6c65 6c3a 2069    nb_parallel: i
+00002670: 6e74 203d 202d 312c 0a20 2020 2062 6174  nt = -1,.    bat
+00002680: 6368 7369 7a65 3a20 696e 7420 3d20 2d31  chsize: int = -1
+00002690: 2c0a 2020 2020 666f 7263 653a 2062 6f6f  ,.    force: boo
+000026a0: 6c20 3d20 4661 6c73 652c 0a29 3a0a 2020  l = False,.):.  
+000026b0: 2020 2320 496e 6974 0a20 2020 206f 7065    # Init.    ope
+000026c0: 7261 7469 6f6e 5f70 6172 616d 7320 3d20  ration_params = 
+000026d0: 7b7d 0a0a 2020 2020 2320 476f 210a 2020  {}..    # Go!.  
+000026e0: 2020 7265 7475 726e 205f 6170 706c 795f    return _apply_
+000026f0: 6765 6f6f 7065 7261 7469 6f6e 5f74 6f5f  geooperation_to_
+00002700: 6c61 7965 7228 0a20 2020 2020 2020 2069  layer(.        i
+00002710: 6e70 7574 5f70 6174 683d 696e 7075 745f  nput_path=input_
+00002720: 7061 7468 2c0a 2020 2020 2020 2020 6f75  path,.        ou
+00002730: 7470 7574 5f70 6174 683d 6f75 7470 7574  tput_path=output
+00002740: 5f70 6174 682c 0a20 2020 2020 2020 206f  _path,.        o
+00002750: 7065 7261 7469 6f6e 3d47 656f 4f70 6572  peration=GeoOper
+00002760: 6174 696f 6e2e 434f 4e56 4558 4855 4c4c  ation.CONVEXHULL
+00002770: 2c0a 2020 2020 2020 2020 6f70 6572 6174  ,.        operat
+00002780: 696f 6e5f 7061 7261 6d73 3d6f 7065 7261  ion_params=opera
+00002790: 7469 6f6e 5f70 6172 616d 732c 0a20 2020  tion_params,.   
+000027a0: 2020 2020 2069 6e70 7574 5f6c 6179 6572       input_layer
+000027b0: 3d69 6e70 7574 5f6c 6179 6572 2c0a 2020  =input_layer,.  
+000027c0: 2020 2020 2020 6f75 7470 7574 5f6c 6179        output_lay
+000027d0: 6572 3d6f 7574 7075 745f 6c61 7965 722c  er=output_layer,
+000027e0: 0a20 2020 2020 2020 2063 6f6c 756d 6e73  .        columns
+000027f0: 3d63 6f6c 756d 6e73 2c0a 2020 2020 2020  =columns,.      
+00002800: 2020 6578 706c 6f64 6563 6f6c 6c65 6374    explodecollect
+00002810: 696f 6e73 3d65 7870 6c6f 6465 636f 6c6c  ions=explodecoll
+00002820: 6563 7469 6f6e 732c 0a20 2020 2020 2020  ections,.       
+00002830: 206e 625f 7061 7261 6c6c 656c 3d6e 625f   nb_parallel=nb_
+00002840: 7061 7261 6c6c 656c 2c0a 2020 2020 2020  parallel,.      
+00002850: 2020 6261 7463 6873 697a 653d 6261 7463    batchsize=batc
+00002860: 6873 697a 652c 0a20 2020 2020 2020 2066  hsize,.        f
+00002870: 6f72 6365 3d66 6f72 6365 2c0a 2020 2020  orce=force,.    
+00002880: 290a 0a0a 6465 6620 7369 6d70 6c69 6679  )...def simplify
+00002890: 280a 2020 2020 696e 7075 745f 7061 7468  (.    input_path
+000028a0: 3a20 5061 7468 2c0a 2020 2020 6f75 7470  : Path,.    outp
+000028b0: 7574 5f70 6174 683a 2050 6174 682c 0a20  ut_path: Path,. 
+000028c0: 2020 2074 6f6c 6572 616e 6365 3a20 666c     tolerance: fl
+000028d0: 6f61 742c 0a20 2020 2061 6c67 6f72 6974  oat,.    algorit
+000028e0: 686d 3a20 5369 6d70 6c69 6679 416c 676f  hm: SimplifyAlgo
+000028f0: 7269 7468 6d20 3d20 5369 6d70 6c69 6679  rithm = Simplify
+00002900: 416c 676f 7269 7468 6d2e 5241 4d45 525f  Algorithm.RAMER_
+00002910: 444f 5547 4c41 535f 5045 5543 4b45 522c  DOUGLAS_PEUCKER,
+00002920: 0a20 2020 206c 6f6f 6b61 6865 6164 3a20  .    lookahead: 
+00002930: 696e 7420 3d20 382c 0a20 2020 2069 6e70  int = 8,.    inp
+00002940: 7574 5f6c 6179 6572 3a20 4f70 7469 6f6e  ut_layer: Option
+00002950: 616c 5b73 7472 5d20 3d20 4e6f 6e65 2c0a  al[str] = None,.
+00002960: 2020 2020 6f75 7470 7574 5f6c 6179 6572      output_layer
+00002970: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
+00002980: 3d20 4e6f 6e65 2c0a 2020 2020 636f 6c75  = None,.    colu
+00002990: 6d6e 733a 204f 7074 696f 6e61 6c5b 4c69  mns: Optional[Li
+000029a0: 7374 5b73 7472 5d5d 203d 204e 6f6e 652c  st[str]] = None,
+000029b0: 0a20 2020 2065 7870 6c6f 6465 636f 6c6c  .    explodecoll
+000029c0: 6563 7469 6f6e 733a 2062 6f6f 6c20 3d20  ections: bool = 
+000029d0: 4661 6c73 652c 0a20 2020 206e 625f 7061  False,.    nb_pa
+000029e0: 7261 6c6c 656c 3a20 696e 7420 3d20 2d31  rallel: int = -1
+000029f0: 2c0a 2020 2020 6261 7463 6873 697a 653a  ,.    batchsize:
+00002a00: 2069 6e74 203d 202d 312c 0a20 2020 2066   int = -1,.    f
+00002a10: 6f72 6365 3a20 626f 6f6c 203d 2046 616c  orce: bool = Fal
+00002a20: 7365 2c0a 293a 0a20 2020 2023 2049 6e69  se,.):.    # Ini
+00002a30: 740a 2020 2020 6f70 6572 6174 696f 6e5f  t.    operation_
+00002a40: 7061 7261 6d73 203d 207b 0a20 2020 2020  params = {.     
+00002a50: 2020 2022 746f 6c65 7261 6e63 6522 3a20     "tolerance": 
+00002a60: 746f 6c65 7261 6e63 652c 0a20 2020 2020  tolerance,.     
+00002a70: 2020 2022 616c 676f 7269 7468 6d22 3a20     "algorithm": 
+00002a80: 616c 676f 7269 7468 6d2c 0a20 2020 2020  algorithm,.     
+00002a90: 2020 2022 7374 6570 223a 206c 6f6f 6b61     "step": looka
+00002aa0: 6865 6164 2c0a 2020 2020 7d0a 0a20 2020  head,.    }..   
+00002ab0: 2023 2047 6f21 0a20 2020 2072 6574 7572   # Go!.    retur
+00002ac0: 6e20 5f61 7070 6c79 5f67 656f 6f70 6572  n _apply_geooper
+00002ad0: 6174 696f 6e5f 746f 5f6c 6179 6572 280a  ation_to_layer(.
+00002ae0: 2020 2020 2020 2020 696e 7075 745f 7061          input_pa
+00002af0: 7468 3d69 6e70 7574 5f70 6174 682c 0a20  th=input_path,. 
+00002b00: 2020 2020 2020 206f 7574 7075 745f 7061         output_pa
+00002b10: 7468 3d6f 7574 7075 745f 7061 7468 2c0a  th=output_path,.
+00002b20: 2020 2020 2020 2020 6f70 6572 6174 696f          operatio
+00002b30: 6e3d 4765 6f4f 7065 7261 7469 6f6e 2e53  n=GeoOperation.S
+00002b40: 494d 504c 4946 592c 0a20 2020 2020 2020  IMPLIFY,.       
+00002b50: 206f 7065 7261 7469 6f6e 5f70 6172 616d   operation_param
+00002b60: 733d 6f70 6572 6174 696f 6e5f 7061 7261  s=operation_para
+00002b70: 6d73 2c0a 2020 2020 2020 2020 696e 7075  ms,.        inpu
+00002b80: 745f 6c61 7965 723d 696e 7075 745f 6c61  t_layer=input_la
+00002b90: 7965 722c 0a20 2020 2020 2020 206f 7574  yer,.        out
+00002ba0: 7075 745f 6c61 7965 723d 6f75 7470 7574  put_layer=output
+00002bb0: 5f6c 6179 6572 2c0a 2020 2020 2020 2020  _layer,.        
+00002bc0: 636f 6c75 6d6e 733d 636f 6c75 6d6e 732c  columns=columns,
+00002bd0: 0a20 2020 2020 2020 2065 7870 6c6f 6465  .        explode
+00002be0: 636f 6c6c 6563 7469 6f6e 733d 6578 706c  collections=expl
+00002bf0: 6f64 6563 6f6c 6c65 6374 696f 6e73 2c0a  odecollections,.
+00002c00: 2020 2020 2020 2020 6e62 5f70 6172 616c          nb_paral
+00002c10: 6c65 6c3d 6e62 5f70 6172 616c 6c65 6c2c  lel=nb_parallel,
+00002c20: 0a20 2020 2020 2020 2062 6174 6368 7369  .        batchsi
+00002c30: 7a65 3d62 6174 6368 7369 7a65 2c0a 2020  ze=batchsize,.  
+00002c40: 2020 2020 2020 666f 7263 653d 666f 7263        force=forc
+00002c50: 652c 0a20 2020 2029 0a0a 0a64 6566 205f  e,.    )...def _
+00002c60: 6170 706c 795f 6765 6f6f 7065 7261 7469  apply_geooperati
+00002c70: 6f6e 5f74 6f5f 6c61 7965 7228 0a20 2020  on_to_layer(.   
+00002c80: 2069 6e70 7574 5f70 6174 683a 2050 6174   input_path: Pat
+00002c90: 682c 0a20 2020 206f 7574 7075 745f 7061  h,.    output_pa
+00002ca0: 7468 3a20 5061 7468 2c0a 2020 2020 6f70  th: Path,.    op
+00002cb0: 6572 6174 696f 6e3a 2047 656f 4f70 6572  eration: GeoOper
+00002cc0: 6174 696f 6e2c 0a20 2020 206f 7065 7261  ation,.    opera
+00002cd0: 7469 6f6e 5f70 6172 616d 733a 2064 6963  tion_params: dic
+00002ce0: 742c 0a20 2020 2069 6e70 7574 5f6c 6179  t,.    input_lay
+00002cf0: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
+00002d00: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 636f  ] = None,.    co
+00002d10: 6c75 6d6e 733a 204f 7074 696f 6e61 6c5b  lumns: Optional[
+00002d20: 4c69 7374 5b73 7472 5d5d 203d 204e 6f6e  List[str]] = Non
+00002d30: 652c 0a20 2020 206f 7574 7075 745f 6c61  e,.    output_la
+00002d40: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
+00002d50: 725d 203d 204e 6f6e 652c 0a20 2020 2065  r] = None,.    e
+00002d60: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
+00002d70: 733a 2062 6f6f 6c20 3d20 4661 6c73 652c  s: bool = False,
+00002d80: 0a20 2020 2066 6f72 6365 5f6f 7574 7075  .    force_outpu
+00002d90: 745f 6765 6f6d 6574 7279 7479 7065 3a20  t_geometrytype: 
+00002da0: 556e 696f 6e5b 4765 6f6d 6574 7279 5479  Union[GeometryTy
+00002db0: 7065 2c20 7374 722c 204e 6f6e 655d 203d  pe, str, None] =
+00002dc0: 204e 6f6e 652c 0a20 2020 206e 625f 7061   None,.    nb_pa
+00002dd0: 7261 6c6c 656c 3a20 696e 7420 3d20 2d31  rallel: int = -1
+00002de0: 2c0a 2020 2020 6261 7463 6873 697a 653a  ,.    batchsize:
+00002df0: 2069 6e74 203d 202d 312c 0a20 2020 2066   int = -1,.    f
+00002e00: 6f72 6365 3a20 626f 6f6c 203d 2046 616c  orce: bool = Fal
+00002e10: 7365 2c0a 293a 0a20 2020 2022 2222 0a20  se,.):.    """. 
+00002e20: 2020 2041 7070 6c69 6573 2061 2067 656f     Applies a geo
+00002e30: 206f 7065 7261 7469 6f6e 206f 6e20 6120   operation on a 
+00002e40: 6c61 7965 722e 0a0a 2020 2020 5468 6520  layer...    The 
+00002e50: 6f70 6572 6174 696f 6e20 746f 2061 7070  operation to app
+00002e60: 6c79 2063 616e 2062 6520 6f6e 6520 6f66  ly can be one of
+00002e70: 2074 6865 2074 6865 2066 6f6c 6c6f 7769   the the followi
+00002e80: 6e67 3a0a 2020 2020 2020 2d20 4255 4646  ng:.      - BUFF
+00002e90: 4552 3a20 6170 706c 7920 6120 6275 6666  ER: apply a buff
+00002ea0: 6572 2e20 4f70 6572 6174 696f 6e20 7061  er. Operation pa
+00002eb0: 7261 6d65 7465 7273 3a0a 2020 2020 2020  rameters:.      
+00002ec0: 2020 2020 2d20 6469 7374 616e 6365 3a20      - distance: 
+00002ed0: 6469 7374 616e 6365 2074 6f20 6275 6666  distance to buff
+00002ee0: 6572 0a20 2020 2020 2020 2020 202d 2071  er.          - q
+00002ef0: 7561 6472 616e 7473 6567 6d65 6e74 733a  uadrantsegments:
+00002f00: 206e 756d 6265 7220 6f66 2070 6f69 6e74   number of point
+00002f10: 7320 7573 6564 2074 6f20 7265 7072 6573  s used to repres
+00002f20: 656e 7420 312f 3420 6f66 2061 2063 6972  ent 1/4 of a cir
+00002f30: 636c 650a 2020 2020 2020 2020 2020 2d20  cle.          - 
+00002f40: 656e 6463 6170 5f73 7479 6c65 3a20 6275  endcap_style: bu
+00002f50: 6666 6572 2073 7479 6c65 2074 6f20 7573  ffer style to us
+00002f60: 6520 666f 7220 6120 706f 696e 7420 6f72  e for a point or
+00002f70: 2074 6865 2065 6e64 2070 6f69 6e74 7320   the end points 
+00002f80: 6f66 0a20 2020 2020 2020 2020 2020 2061  of.            a
+00002f90: 206c 696e 653a 0a20 2020 2020 2020 2020   line:.         
+00002fa0: 2020 202d 2052 4f55 4e44 3a20 666f 7220     - ROUND: for 
+00002fb0: 706f 696e 7473 2061 6e64 206c 696e 6573  points and lines
+00002fc0: 2074 6865 2065 6e64 7320 6172 6520 6275   the ends are bu
+00002fd0: 6666 6572 6564 2072 6f75 6e64 6564 2e0a  ffered rounded..
+00002fe0: 2020 2020 2020 2020 2020 2020 2d20 464c              - FL
+00002ff0: 4154 3a20 6120 706f 696e 7420 7374 6179  AT: a point stay
+00003000: 7320 6120 706f 696e 742c 2061 2062 7566  s a point, a buf
+00003010: 6665 7265 6420 6c69 6e65 2077 696c 6c20  fered line will 
+00003020: 656e 6420 666c 6174 0a20 2020 2020 2020  end flat.       
+00003030: 2020 2020 2020 2061 7420 7468 6520 656e         at the en
+00003040: 6420 706f 696e 7473 0a20 2020 2020 2020  d points.       
+00003050: 2020 2020 202d 2053 5155 4152 453a 2061       - SQUARE: a
+00003060: 2070 6f69 6e74 2062 6563 6f6d 6573 2061   point becomes a
+00003070: 2073 7175 6172 652c 2061 2062 7566 6665   square, a buffe
+00003080: 7265 6420 6c69 6e65 2077 696c 6c20 656e  red line will en
+00003090: 640a 2020 2020 2020 2020 2020 2020 2020  d.              
+000030a0: 666c 6174 2061 7420 7468 6520 656e 6420  flat at the end 
+000030b0: 706f 696e 7473 2c20 6275 7420 656c 6f6e  points, but elon
+000030c0: 6761 7465 6420 6279 2022 6469 7374 616e  gated by "distan
+000030d0: 6365 220a 2020 2020 2020 2020 2d20 6a6f  ce".        - jo
+000030e0: 696e 5f73 7479 6c65 3a20 6275 6666 6572  in_style: buffer
+000030f0: 2073 7479 6c65 2074 6f20 7573 6520 666f   style to use fo
+00003100: 7220 636f 726e 6572 7320 696e 2061 206c  r corners in a l
+00003110: 696e 6520 6f72 2061 2070 6f6c 7967 6f6e  ine or a polygon
+00003120: 0a20 2020 2020 2020 2020 2062 6f75 6e64  .          bound
+00003130: 6172 793a 0a20 2020 2020 2020 2020 2020  ary:.           
+00003140: 202d 2052 4f55 4e44 3a20 636f 726e 6572   - ROUND: corner
+00003150: 7320 696e 2074 6865 2072 6573 756c 7420  s in the result 
+00003160: 6172 6520 726f 756e 6465 640a 2020 2020  are rounded.    
+00003170: 2020 2020 2020 2020 2d20 4d49 5452 453a          - MITRE:
+00003180: 2063 6f72 6e65 7273 2069 6e20 7468 6520   corners in the 
+00003190: 7265 7375 6c74 2061 7265 2073 6861 7270  result are sharp
+000031a0: 0a20 2020 2020 2020 2020 2020 202d 2042  .            - B
+000031b0: 4556 454c 3a20 6172 6520 666c 6174 7465  EVEL: are flatte
+000031c0: 6e65 640a 2020 2020 2020 2020 2d20 6d69  ned.        - mi
+000031d0: 7472 655f 6c69 6d69 743a 2069 6e20 6361  tre_limit: in ca
+000031e0: 7365 206f 6620 6a6f 696e 5f73 7479 6c65  se of join_style
+000031f0: 204d 4954 5245 2c20 6966 2074 6865 0a20   MITRE, if the. 
+00003200: 2020 2020 2020 2020 2020 2073 7069 6b79             spiky
+00003210: 2072 6573 756c 7420 666f 7220 6120 7368   result for a sh
+00003220: 6172 7020 616e 676c 6520 6265 636f 6d65  arp angle become
+00003230: 7320 6c6f 6e67 6572 2074 6861 6e20 7468  s longer than th
+00003240: 6973 206c 696d 6974 2c20 6974 0a20 2020  is limit, it.   
+00003250: 2020 2020 2020 2020 2069 7320 2262 6576           is "bev
+00003260: 656c 6564 2220 6174 2074 6869 7320 6469  eled" at this di
+00003270: 7374 616e 6365 2e20 4465 6661 756c 7473  stance. Defaults
+00003280: 2074 6f20 352e 302e 0a20 2020 2020 2020   to 5.0..       
+00003290: 202d 2073 696e 676c 655f 7369 6465 643a   - single_sided:
+000032a0: 206f 6e6c 7920 6f6e 6520 7369 6465 206f   only one side o
+000032b0: 6620 7468 6520 6c69 6e65 2069 7320 6275  f the line is bu
+000032c0: 6666 6572 6564 2c0a 2020 2020 2020 2020  ffered,.        
+000032d0: 2020 2020 6966 2064 6973 7461 6e63 6520      if distance 
+000032e0: 6973 206e 6567 6174 6976 652c 2074 6865  is negative, the
+000032f0: 206c 6566 7420 7369 6465 2c20 6966 2064   left side, if d
+00003300: 6973 7461 6e63 6520 6973 2070 6f73 6974  istance is posit
+00003310: 6976 652c 0a20 2020 2020 2020 2020 2020  ive,.           
+00003320: 2074 6865 2072 6967 6874 2068 616e 6420   the right hand 
+00003330: 7369 6465 2e20 4f6e 6c79 2072 656c 6576  side. Only relev
+00003340: 616e 7420 666f 7220 6c69 6e65 2067 656f  ant for line geo
+00003350: 6d65 7472 6965 732e 0a20 2020 2020 202d  metries..      -
+00003360: 2043 4f4e 5645 5848 554c 4c3a 2061 7070   CONVEXHULL: app
+00003370: 7920 6120 636f 6e76 6578 2068 756c 6c2e  y a convex hull.
+00003380: 0a20 2020 2020 202d 2053 494d 504c 4946  .      - SIMPLIF
+00003390: 593a 2073 696d 706c 6966 7920 7468 6520  Y: simplify the 
+000033a0: 6765 6f6d 6574 7279 2e20 4f70 6572 6174  geometry. Operat
+000033b0: 696f 6e20 7061 7261 6d65 7465 7273 3a0a  ion parameters:.
+000033c0: 2020 2020 2020 2020 2020 2d20 616c 676f            - algo
+000033d0: 7269 7468 6d3a 2076 6563 746f 725f 7574  rithm: vector_ut
+000033e0: 696c 2e53 696d 706c 6966 7941 6c67 6f72  il.SimplifyAlgor
+000033f0: 6974 686d 0a20 2020 2020 2020 2020 202d  ithm.          -
+00003400: 2074 6f6c 6572 616e 6365 3a20 6d61 7869   tolerance: maxi
+00003410: 6d75 6d20 6469 7374 616e 6365 2074 6f20  mum distance to 
+00003420: 7369 6d70 6c69 6679 2e0a 2020 2020 2020  simplify..      
+00003430: 2020 2020 2d20 6c6f 6f6b 6168 6561 643a      - lookahead:
+00003440: 2066 6f72 204c 414e 472c 2074 6865 206e   for LANG, the n
+00003450: 756d 6265 7220 6f66 2070 6f69 6e74 7320  umber of points 
+00003460: 746f 2066 6f72 7761 7264 2d6c 6f6f 6b0a  to forward-look.
+00003470: 2020 2020 2020 2d20 4150 504c 593a 2061        - APPLY: a
+00003480: 7070 6c79 2061 206c 616d 6264 6120 6675  pply a lambda fu
+00003490: 6e63 7469 6f6e 2e20 4f70 6572 6174 696f  nction. Operatio
+000034a0: 6e20 7061 7261 6d65 7465 723a 0a20 2020  n parameter:.   
+000034b0: 2020 2020 2020 202d 2070 6963 6b6c 6564         - pickled
+000034c0: 5f66 756e 633a 206c 616d 6264 6120 6675  _func: lambda fu
+000034d0: 6e63 7469 6f6e 2074 6f20 6170 706c 792c  nction to apply,
+000034e0: 2070 6963 6b6c 6564 2074 6f20 6279 7465   pickled to byte
+000034f0: 732e 0a20 2020 2020 2020 2020 202d 206f  s..          - o
+00003500: 6e6c 795f 6765 6f6d 5f69 6e70 7574 3a20  nly_geom_input: 
+00003510: 6966 2054 7275 652c 206f 6e6c 7920 7468  if True, only th
+00003520: 6520 6765 6f6d 6574 7279 2069 7320 6176  e geometry is av
+00003530: 6169 6c61 626c 6520 6173 0a20 2020 2020  ailable as.     
+00003540: 2020 2020 2020 2069 6e70 7574 2066 6f72         input for
+00003550: 2074 6865 206c 616d 6264 6120 6675 6e63   the lambda func
+00003560: 7469 6f6e 2e20 4966 2066 616c 7365 2c20  tion. If false, 
+00003570: 7468 6520 726f 7720 6973 2074 6865 2069  the row is the i
+00003580: 6e70 7574 2e0a 0a20 2020 2041 7267 733a  nput...    Args:
+00003590: 0a20 2020 2020 2020 2069 6e70 7574 5f70  .        input_p
+000035a0: 6174 6820 2850 6174 6829 3a20 5b64 6573  ath (Path): [des
+000035b0: 6372 6970 7469 6f6e 5d0a 2020 2020 2020  cription].      
+000035c0: 2020 6f75 7470 7574 5f70 6174 6820 2850    output_path (P
+000035d0: 6174 6829 3a20 5b64 6573 6372 6970 7469  ath): [descripti
+000035e0: 6f6e 5d0a 2020 2020 2020 2020 6f70 6572  on].        oper
+000035f0: 6174 696f 6e20 2847 656f 4f70 6572 6174  ation (GeoOperat
+00003600: 696f 6e29 3a20 7468 6520 6765 6f20 6f70  ion): the geo op
+00003610: 6572 6174 696f 6e20 746f 2061 7070 6c79  eration to apply
+00003620: 2e0a 2020 2020 2020 2020 6f70 6572 6174  ..        operat
+00003630: 696f 6e5f 7061 7261 6d73 2028 6469 6374  ion_params (dict
+00003640: 2c20 6f70 7469 6f6e 616c 293a 2074 6865  , optional): the
+00003650: 2070 6172 616d 6574 6572 7320 666f 7220   parameters for 
+00003660: 7468 6520 6765 6f20 6f70 6572 6174 696f  the geo operatio
+00003670: 6e2e 0a20 2020 2020 2020 2020 2020 2044  n..            D
+00003680: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
+00003690: 0a20 2020 2020 2020 2069 6e70 7574 5f6c  .        input_l
+000036a0: 6179 6572 2028 7374 722c 206f 7074 696f  ayer (str, optio
+000036b0: 6e61 6c29 3a20 5b64 6573 6372 6970 7469  nal): [descripti
+000036c0: 6f6e 5d2e 2044 6566 6175 6c74 7320 746f  on]. Defaults to
+000036d0: 204e 6f6e 652e 0a20 2020 2020 2020 206f   None..        o
+000036e0: 7574 7075 745f 6c61 7965 7220 2873 7472  utput_layer (str
+000036f0: 2c20 6f70 7469 6f6e 616c 293a 205b 6465  , optional): [de
+00003700: 7363 7269 7074 696f 6e5d 2e20 4465 6661  scription]. Defa
+00003710: 756c 7473 2074 6f20 4e6f 6e65 2e0a 2020  ults to None..  
+00003720: 2020 2020 2020 636f 6c75 6d6e 7320 284c        columns (L
+00003730: 6973 745b 7374 725d 2c20 6f70 7469 6f6e  ist[str], option
+00003740: 616c 293a 2049 6620 6e6f 7420 4e6f 6e65  al): If not None
+00003750: 2c20 6f6e 6c79 206f 7574 7075 7420 7468  , only output th
+00003760: 6520 636f 6c75 6d6e 730a 2020 2020 2020  e columns.      
+00003770: 2020 2020 2020 7370 6563 6966 6965 642e        specified.
+00003780: 2044 6566 6175 6c74 7320 746f 204e 6f6e   Defaults to Non
+00003790: 652e 0a20 2020 2020 2020 2065 7870 6c6f  e..        explo
+000037a0: 6465 636f 6c6c 6563 7469 6f6e 7320 2862  decollections (b
+000037b0: 6f6f 6c2c 206f 7074 696f 6e61 6c29 3a20  ool, optional): 
+000037c0: 5472 7565 2074 6f20 636f 6e76 6572 7420  True to convert 
+000037d0: 616c 6c20 6d75 6c74 692d 6765 6f6d 6574  all multi-geomet
+000037e0: 7269 6573 2074 6f0a 2020 2020 2020 2020  ries to.        
+000037f0: 2020 2020 7369 6e67 756c 6172 206f 6e65      singular one
+00003800: 7320 6475 7269 6e67 2074 6865 2067 656f  s during the geo
+00003810: 6f70 6572 6174 696f 6e2e 2044 6566 6175  operation. Defau
+00003820: 6c74 7320 746f 2046 616c 7365 2e0a 2020  lts to False..  
+00003830: 2020 2020 2020 666f 7263 655f 6f75 7470        force_outp
+00003840: 7574 5f67 656f 6d65 7472 7974 7970 6520  ut_geometrytype 
+00003850: 2847 656f 6d65 7472 7954 7970 652c 206f  (GeometryType, o
+00003860: 7074 696f 6e61 6c29 3a20 5468 6520 6f75  ptional): The ou
+00003870: 7470 7574 2067 656f 6d65 7472 7920 7479  tput geometry ty
+00003880: 7065 2074 6f0a 2020 2020 2020 2020 2020  pe to.          
+00003890: 2020 666f 7263 652e 2049 6620 4e6f 6e65    force. If None
+000038a0: 2c20 6120 6265 7374 2d65 6666 6f72 7420  , a best-effort 
+000038b0: 6775 6573 7320 6973 206d 6164 652e 2044  guess is made. D
+000038c0: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
+000038d0: 0a20 2020 2020 2020 206e 625f 7061 7261  .        nb_para
+000038e0: 6c6c 656c 2028 696e 742c 206f 7074 696f  llel (int, optio
+000038f0: 6e61 6c29 3a20 5b64 6573 6372 6970 7469  nal): [descripti
+00003900: 6f6e 5d2e 2044 6566 6175 6c74 7320 746f  on]. Defaults to
+00003910: 202d 312e 0a20 2020 2020 2020 2062 6174   -1..        bat
+00003920: 6368 7369 7a65 2028 696e 742c 206f 7074  chsize (int, opt
+00003930: 696f 6e61 6c29 3a20 696e 6469 6361 7469  ional): indicati
+00003940: 7665 206e 756d 6265 7220 6f66 2072 6f77  ve number of row
+00003950: 7320 746f 2070 726f 6365 7373 2070 6572  s to process per
+00003960: 0a20 2020 2020 2020 2020 2020 2062 6174  .            bat
+00003970: 6368 2e20 4120 736d 616c 6c65 7220 6261  ch. A smaller ba
+00003980: 7463 6820 7369 7a65 2c20 706f 7373 6962  tch size, possib
+00003990: 6c79 2069 6e20 636f 6d62 696e 6174 696f  ly in combinatio
+000039a0: 6e20 7769 7468 2061 0a20 2020 2020 2020  n with a.       
+000039b0: 2020 2020 2073 6d61 6c6c 6572 206e 625f       smaller nb_
+000039c0: 7061 7261 6c6c 656c 2c20 7769 6c6c 2072  parallel, will r
+000039d0: 6564 7563 6520 7468 6520 6d65 6d6f 7279  educe the memory
+000039e0: 2075 7361 6765 2e0a 2020 2020 2020 2020   usage..        
+000039f0: 2020 2020 4465 6661 756c 7473 2074 6f20      Defaults to 
+00003a00: 2d31 3a20 2874 7279 2074 6f29 2064 6574  -1: (try to) det
+00003a10: 6572 6d69 6e65 206f 7074 696d 616c 2073  ermine optimal s
+00003a20: 697a 6520 6175 746f 6d61 7469 6361 6c6c  ize automaticall
+00003a30: 792e 0a20 2020 2020 2020 2066 6f72 6365  y..        force
+00003a40: 2028 626f 6f6c 2c20 6f70 7469 6f6e 616c   (bool, optional
+00003a50: 293a 205b 6465 7363 7269 7074 696f 6e5d  ): [description]
+00003a60: 2e20 4465 6661 756c 7473 2074 6f20 4661  . Defaults to Fa
+00003a70: 6c73 652e 0a20 2020 2022 2222 0a20 2020  lse..    """.   
+00003a80: 2023 2049 6e69 740a 2020 2020 7374 6172   # Init.    star
+00003a90: 745f 7469 6d65 5f67 6c6f 6261 6c20 3d20  t_time_global = 
+00003aa0: 6461 7465 7469 6d65 2e6e 6f77 2829 0a0a  datetime.now()..
+00003ab0: 2020 2020 2320 4368 6563 6b20 696e 7075      # Check inpu
+00003ac0: 7420 7061 7261 6d65 7465 7273 2e2e 2e0a  t parameters....
+00003ad0: 2020 2020 6f70 6572 6174 696f 6e5f 6e61      operation_na
+00003ae0: 6d65 203d 206f 7065 7261 7469 6f6e 2e6e  me = operation.n
+00003af0: 616d 652e 6c6f 7765 7228 290a 2020 2020  ame.lower().    
+00003b00: 6966 206e 6f74 2069 6e70 7574 5f70 6174  if not input_pat
+00003b10: 682e 6578 6973 7473 2829 3a0a 2020 2020  h.exists():.    
+00003b20: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
+00003b30: 7272 6f72 2866 227b 6f70 6572 6174 696f  rror(f"{operatio
+00003b40: 6e5f 6e61 6d65 7d3a 2069 6e70 7574 5f70  n_name}: input_p
+00003b50: 6174 6820 646f 6573 6e27 7420 6578 6973  ath doesn't exis
+00003b60: 743a 207b 696e 7075 745f 7061 7468 7d22  t: {input_path}"
+00003b70: 290a 2020 2020 6966 2069 6e70 7574 5f70  ).    if input_p
+00003b80: 6174 6820 3d3d 206f 7574 7075 745f 7061  ath == output_pa
+00003b90: 7468 3a0a 2020 2020 2020 2020 7261 6973  th:.        rais
+00003ba0: 6520 5661 6c75 6545 7272 6f72 2866 227b  e ValueError(f"{
+00003bb0: 6f70 6572 6174 696f 6e5f 6e61 6d65 7d3a  operation_name}:
+00003bc0: 206f 7574 7075 745f 7061 7468 206d 7573   output_path mus
+00003bd0: 7420 6e6f 7420 6571 7561 6c20 696e 7075  t not equal inpu
+00003be0: 745f 7061 7468 2229 0a20 2020 2069 6620  t_path").    if 
+00003bf0: 696e 7075 745f 6c61 7965 7220 6973 204e  input_layer is N
+00003c00: 6f6e 653a 0a20 2020 2020 2020 2069 6e70  one:.        inp
+00003c10: 7574 5f6c 6179 6572 203d 2067 666f 2e67  ut_layer = gfo.g
+00003c20: 6574 5f6f 6e6c 795f 6c61 7965 7228 696e  et_only_layer(in
+00003c30: 7075 745f 7061 7468 290a 2020 2020 6966  put_path).    if
+00003c40: 206f 7574 7075 745f 7061 7468 2e65 7869   output_path.exi
+00003c50: 7374 7328 293a 0a20 2020 2020 2020 2069  sts():.        i
+00003c60: 6620 666f 7263 6520 6973 2046 616c 7365  f force is False
+00003c70: 3a0a 2020 2020 2020 2020 2020 2020 6c6f  :.            lo
+00003c80: 6767 6572 2e69 6e66 6f28 6622 5374 6f70  gger.info(f"Stop
+00003c90: 207b 6f70 6572 6174 696f 6e5f 6e61 6d65   {operation_name
+00003ca0: 7d3a 206f 7574 7075 7420 6578 6973 7473  }: output exists
+00003cb0: 2061 6c72 6561 6479 207b 6f75 7470 7574   already {output
+00003cc0: 5f70 6174 687d 2229 0a20 2020 2020 2020  _path}").       
+00003cd0: 2020 2020 2072 6574 7572 6e0a 2020 2020       return.    
+00003ce0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00003cf0: 2020 2020 2020 6766 6f2e 7265 6d6f 7665        gfo.remove
+00003d00: 286f 7574 7075 745f 7061 7468 290a 2020  (output_path).  
+00003d10: 2020 6966 2069 6e70 7574 5f6c 6179 6572    if input_layer
+00003d20: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00003d30: 2020 696e 7075 745f 6c61 7965 7220 3d20    input_layer = 
+00003d40: 6766 6f2e 6765 745f 6f6e 6c79 5f6c 6179  gfo.get_only_lay
+00003d50: 6572 2869 6e70 7574 5f70 6174 6829 0a20  er(input_path). 
+00003d60: 2020 2069 6620 6f75 7470 7574 5f6c 6179     if output_lay
+00003d70: 6572 2069 7320 4e6f 6e65 3a0a 2020 2020  er is None:.    
+00003d80: 2020 2020 6f75 7470 7574 5f6c 6179 6572      output_layer
+00003d90: 203d 2067 666f 2e67 6574 5f64 6566 6175   = gfo.get_defau
+00003da0: 6c74 5f6c 6179 6572 286f 7574 7075 745f  lt_layer(output_
+00003db0: 7061 7468 290a 2020 2020 6966 2069 7369  path).    if isi
+00003dc0: 6e73 7461 6e63 6528 666f 7263 655f 6f75  nstance(force_ou
+00003dd0: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+00003de0: 652c 2047 656f 6d65 7472 7954 7970 6529  e, GeometryType)
+00003df0: 3a0a 2020 2020 2020 2020 666f 7263 655f  :.        force_
+00003e00: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
+00003e10: 7970 6520 3d20 666f 7263 655f 6f75 7470  ype = force_outp
+00003e20: 7574 5f67 656f 6d65 7472 7974 7970 652e  ut_geometrytype.
+00003e30: 6e61 6d65 0a0a 2020 2020 2320 5072 6570  name..    # Prep
+00003e40: 6172 6520 746d 7020 6669 6c65 730a 2020  are tmp files.  
+00003e50: 2020 7465 6d70 6469 7220 3d20 5f69 6f5f    tempdir = _io_
+00003e60: 7574 696c 2e63 7265 6174 655f 7465 6d70  util.create_temp
+00003e70: 6469 7228 6622 6765 6f66 696c 656f 7073  dir(f"geofileops
+00003e80: 2f7b 6f70 6572 6174 696f 6e2e 7661 6c75  /{operation.valu
+00003e90: 657d 2229 0a20 2020 206c 6f67 6765 722e  e}").    logger.
+00003ea0: 696e 666f 2866 2253 7461 7274 2063 616c  info(f"Start cal
+00003eb0: 6375 6c61 7469 6f6e 2074 6f20 7465 6d70  culation to temp
+00003ec0: 2066 696c 6573 2069 6e20 7b74 656d 7064   files in {tempd
+00003ed0: 6972 7d22 290a 0a20 2020 2023 2043 616c  ir}")..    # Cal
+00003ee0: 6375 6c61 7465 0a20 2020 2074 7279 3a0a  culate.    try:.
+00003ef0: 2020 2020 2020 2020 2320 5265 6d61 726b          # Remark
+00003f00: 3a20 6361 6c63 756c 6174 696e 6720 6361  : calculating ca
+00003f10: 6e20 6265 2064 6f6e 6520 696e 2070 6172  n be done in par
+00003f20: 616c 6c65 6c2c 2062 7574 206f 6e6c 7920  allel, but only 
+00003f30: 6f6e 6520 7072 6f63 6573 730a 2020 2020  one process.    
+00003f40: 2020 2020 2320 6361 6e20 7772 6974 6520      # can write 
+00003f50: 746f 2074 6865 2073 616d 6520 6f75 7470  to the same outp
+00003f60: 7574 2066 696c 6520 6174 2074 6865 2074  ut file at the t
+00003f70: 696d 652e 2e2e 0a0a 2020 2020 2020 2020  ime.....        
+00003f80: 2320 4361 6c63 756c 6174 6520 7468 6520  # Calculate the 
+00003f90: 6265 7374 206e 756d 6265 7220 6f66 2070  best number of p
+00003fa0: 6172 616c 6c65 6c20 7072 6f63 6573 7365  arallel processe
+00003fb0: 7320 616e 6420 6261 7463 6865 7320 666f  s and batches fo
+00003fc0: 720a 2020 2020 2020 2020 2320 7468 6520  r.        # the 
+00003fd0: 6176 6169 6c61 626c 6520 7265 736f 7572  available resour
+00003fe0: 6365 730a 2020 2020 2020 2020 696e 7075  ces.        inpu
+00003ff0: 745f 6c61 7965 7269 6e66 6f20 3d20 6766  t_layerinfo = gf
+00004000: 6f2e 6765 745f 6c61 7965 7269 6e66 6f28  o.get_layerinfo(
+00004010: 696e 7075 745f 7061 7468 2c20 696e 7075  input_path, inpu
+00004020: 745f 6c61 7965 7229 0a20 2020 2020 2020  t_layer).       
+00004030: 206e 625f 726f 7773 5f74 6f74 616c 203d   nb_rows_total =
+00004040: 2069 6e70 7574 5f6c 6179 6572 696e 666f   input_layerinfo
+00004050: 2e66 6561 7475 7265 636f 756e 740a 2020  .featurecount.  
+00004060: 2020 2020 2020 6966 2062 6174 6368 7369        if batchsi
+00004070: 7a65 203e 2030 3a0a 2020 2020 2020 2020  ze > 0:.        
+00004080: 2020 2020 7061 7261 6c6c 656c 6c69 7a61      parallelliza
+00004090: 7469 6f6e 5f63 6f6e 6669 6720 3d20 5061  tion_config = Pa
+000040a0: 7261 6c6c 656c 697a 6174 696f 6e43 6f6e  rallelizationCon
+000040b0: 6669 6728 0a20 2020 2020 2020 2020 2020  fig(.           
+000040c0: 2020 2020 206d 696e 5f61 7667 5f72 6f77       min_avg_row
+000040d0: 735f 7065 725f 6261 7463 683d 6d61 7468  s_per_batch=math
+000040e0: 2e63 6569 6c28 6261 7463 6873 697a 6520  .ceil(batchsize 
+000040f0: 2f20 3229 2c0a 2020 2020 2020 2020 2020  / 2),.          
+00004100: 2020 2020 2020 6d61 785f 6176 675f 726f        max_avg_ro
+00004110: 7773 5f70 6572 5f62 6174 6368 3d62 6174  ws_per_batch=bat
+00004120: 6368 7369 7a65 2c0a 2020 2020 2020 2020  chsize,.        
+00004130: 2020 2020 290a 2020 2020 2020 2020 656c      ).        el
+00004140: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00004150: 7061 7261 6c6c 656c 6c69 7a61 7469 6f6e  parallellization
+00004160: 5f63 6f6e 6669 6720 3d20 5061 7261 6c6c  _config = Parall
+00004170: 656c 697a 6174 696f 6e43 6f6e 6669 6728  elizationConfig(
+00004180: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004190: 206d 6178 5f61 7667 5f72 6f77 735f 7065   max_avg_rows_pe
+000041a0: 725f 6261 7463 683d 3530 3030 300a 2020  r_batch=50000.  
+000041b0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+000041c0: 2020 2020 6e62 5f70 6172 616c 6c65 6c2c      nb_parallel,
+000041d0: 206e 625f 6261 7463 6865 732c 2072 6561   nb_batches, rea
+000041e0: 6c5f 6261 7463 6873 697a 6520 3d20 6765  l_batchsize = ge
+000041f0: 745f 7061 7261 6c6c 656c 697a 6174 696f  t_parallelizatio
+00004200: 6e5f 7061 7261 6d73 280a 2020 2020 2020  n_params(.      
+00004210: 2020 2020 2020 6e62 5f72 6f77 735f 746f        nb_rows_to
+00004220: 7461 6c3d 6e62 5f72 6f77 735f 746f 7461  tal=nb_rows_tota
+00004230: 6c2c 0a20 2020 2020 2020 2020 2020 206e  l,.            n
+00004240: 625f 7061 7261 6c6c 656c 3d6e 625f 7061  b_parallel=nb_pa
+00004250: 7261 6c6c 656c 2c0a 2020 2020 2020 2020  rallel,.        
+00004260: 2020 2020 7061 7261 6c6c 656c 697a 6174      parallelizat
+00004270: 696f 6e5f 636f 6e66 6967 3d70 6172 616c  ion_config=paral
+00004280: 6c65 6c6c 697a 6174 696f 6e5f 636f 6e66  lellization_conf
+00004290: 6967 2c0a 2020 2020 2020 2020 290a 0a20  ig,.        ).. 
+000042a0: 2020 2020 2020 2023 2054 4f44 4f3a 2064         # TODO: d
+000042b0: 6574 6572 6d69 6e65 2074 6865 206f 7074  etermine the opt
+000042c0: 696d 616c 2062 6174 6368 2073 697a 6573  imal batch sizes
+000042d0: 2077 6974 6820 6d69 6e20 616e 6420 6d61   with min and ma
+000042e0: 7820 6f66 2072 6f77 6964 2077 696c 6c0a  x of rowid will.
+000042f0: 2020 2020 2020 2020 2320 696e 2073 6f6d          # in som
+00004300: 6520 6361 7365 2069 6d70 726f 7665 2070  e case improve p
+00004310: 6572 666f 726d 616e 6365 0a20 2020 2020  erformance.     
+00004320: 2020 2022 2222 0a20 2020 2020 2020 2073     """.        s
+00004330: 716c 5f73 746d 7420 3d20 6627 2727 5345  ql_stmt = f'''SE
+00004340: 4c45 4354 204d 494e 2872 6f77 6964 2920  LECT MIN(rowid) 
+00004350: 6173 206d 696e 5f72 6f77 6964 2c20 4d41  as min_rowid, MA
+00004360: 5828 726f 7769 6429 2061 7320 6d61 785f  X(rowid) as max_
+00004370: 726f 7769 640a 2020 2020 2020 2020 2020  rowid.          
+00004380: 2020 2020 2020 2020 2020 2020 2020 2046                 F
+00004390: 524f 4d20 227b 696e 7075 745f 6c61 7965  ROM "{input_laye
+000043a0: 727d 2227 2727 0a20 2020 2020 2020 2072  r}"'''.        r
+000043b0: 6573 756c 7420 3d20 6766 6f2e 7265 6164  esult = gfo.read
+000043c0: 5f66 696c 6528 0a20 2020 2020 2020 2020  _file(.         
+000043d0: 2020 2070 6174 683d 7465 6d70 5f70 6174     path=temp_pat
+000043e0: 682c 206c 6179 6572 3d69 6e70 7574 5f6c  h, layer=input_l
+000043f0: 6179 6572 2c20 7371 6c5f 7374 6d74 3d73  ayer, sql_stmt=s
+00004400: 716c 5f73 746d 742c 2073 716c 5f64 6961  ql_stmt, sql_dia
+00004410: 6c65 6374 3d22 5351 4c49 5445 220a 2020  lect="SQLITE".  
+00004420: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00004430: 6966 206c 656e 2872 6573 756c 7429 203d  if len(result) =
+00004440: 3d20 313a 0a20 2020 2020 2020 2020 2020  = 1:.           
+00004450: 206d 696e 5f72 6f77 6964 203d 2072 6573   min_rowid = res
+00004460: 756c 745b 276d 696e 5f72 6f77 6964 275d  ult['min_rowid']
+00004470: 2e76 616c 7565 735b 305d 0a20 2020 2020  .values[0].     
+00004480: 2020 2020 2020 206d 6178 5f72 6f77 6964         max_rowid
+00004490: 203d 2072 6573 756c 745b 276d 6178 5f72   = result['max_r
+000044a0: 6f77 6964 275d 2e76 616c 7565 735b 305d  owid'].values[0]
+000044b0: 0a20 2020 2020 2020 2020 2020 206e 625f  .            nb_
+000044c0: 726f 7769 6473 5f70 6572 5f62 6174 6368  rowids_per_batch
+000044d0: 203d 2028 6d61 785f 726f 7769 6420 2d20   = (max_rowid - 
+000044e0: 6d69 6e5f 726f 7769 6429 2f6e 625f 6261  min_rowid)/nb_ba
+000044f0: 7463 6865 730a 2020 2020 2020 2020 656c  tches.        el
+00004500: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00004510: 7261 6973 6520 4578 6365 7074 696f 6e28  raise Exception(
+00004520: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004530: 2066 2245 7272 6f72 2067 6574 7469 6e67   f"Error getting
+00004540: 206d 696e 2061 6e64 206d 6178 2072 6f77   min and max row
+00004550: 6964 2066 6f72 207b 7465 6d70 5f70 6174  id for {temp_pat
+00004560: 687d 2c20 6c61 7965 7220 7b69 6e70 7574  h}, layer {input
+00004570: 5f6c 6179 6572 7d22 0a20 2020 2020 2020  _layer}".       
+00004580: 2020 2020 2029 0a20 2020 2020 2020 2022       ).        "
+00004590: 2222 0a0a 2020 2020 2020 2020 2320 5072  ""..        # Pr
+000045a0: 6f63 6573 7369 6e67 2069 6e20 7468 7265  ocessing in thre
+000045b0: 6164 7320 6973 2032 7820 6661 7374 6572  ads is 2x faster
+000045c0: 2066 6f72 2073 6d61 6c6c 2064 6174 6173   for small datas
+000045d0: 6574 7320 286f 6e20 5769 6e64 6f77 7329  ets (on Windows)
+000045e0: 0a20 2020 2020 2020 2063 616c 6375 6c61  .        calcula
+000045f0: 7465 5f69 6e5f 7468 7265 6164 7320 3d20  te_in_threads = 
+00004600: 5472 7565 2069 6620 696e 7075 745f 6c61  True if input_la
+00004610: 7965 7269 6e66 6f2e 6665 6174 7572 6563  yerinfo.featurec
+00004620: 6f75 6e74 203c 3d20 3130 3020 656c 7365  ount <= 100 else
+00004630: 2046 616c 7365 0a20 2020 2020 2020 2077   False.        w
+00004640: 6974 6820 5f70 726f 6365 7373 696e 675f  ith _processing_
+00004650: 7574 696c 2e50 6f6f 6c65 6445 7865 6375  util.PooledExecu
+00004660: 746f 7246 6163 746f 7279 280a 2020 2020  torFactory(.    
+00004670: 2020 2020 2020 2020 7468 7265 6164 706f          threadpo
+00004680: 6f6c 3d63 616c 6375 6c61 7465 5f69 6e5f  ol=calculate_in_
+00004690: 7468 7265 6164 732c 0a20 2020 2020 2020  threads,.       
+000046a0: 2020 2020 206d 6178 5f77 6f72 6b65 7273       max_workers
+000046b0: 3d6e 625f 7061 7261 6c6c 656c 2c0a 2020  =nb_parallel,.  
+000046c0: 2020 2020 2020 2020 2020 696e 6974 6961            initia
+000046d0: 6c69 7a65 723d 5f70 726f 6365 7373 696e  lizer=_processin
+000046e0: 675f 7574 696c 2e69 6e69 7469 616c 697a  g_util.initializ
+000046f0: 655f 776f 726b 6572 2829 2c0a 2020 2020  e_worker(),.    
+00004700: 2020 2020 2920 6173 2063 616c 6375 6c61      ) as calcula
+00004710: 7465 5f70 6f6f 6c3a 0a20 2020 2020 2020  te_pool:.       
+00004720: 2020 2020 2023 2050 7265 7061 7265 206f       # Prepare o
+00004730: 7574 7075 7420 6669 6c65 6e61 6d65 0a20  utput filename. 
+00004740: 2020 2020 2020 2020 2020 2074 6d70 5f6f             tmp_o
+00004750: 7574 7075 745f 7061 7468 203d 2074 656d  utput_path = tem
+00004760: 7064 6972 202f 206f 7574 7075 745f 7061  pdir / output_pa
+00004770: 7468 2e6e 616d 650a 0a20 2020 2020 2020  th.name..       
+00004780: 2020 2020 2072 6f77 5f6f 6666 7365 7420       row_offset 
+00004790: 3d20 300a 2020 2020 2020 2020 2020 2020  = 0.            
+000047a0: 6261 7463 6865 7320 3d20 7b7d 0a20 2020  batches = {}.   
+000047b0: 2020 2020 2020 2020 2066 7574 7572 655f           future_
+000047c0: 746f 5f62 6174 6368 5f69 6420 3d20 7b7d  to_batch_id = {}
+000047d0: 0a20 2020 2020 2020 2020 2020 206e 625f  .            nb_
+000047e0: 646f 6e65 203d 2030 0a0a 2020 2020 2020  done = 0..      
+000047f0: 2020 2020 2020 666f 7220 6261 7463 685f        for batch_
+00004800: 6964 2069 6e20 7261 6e67 6528 6e62 5f62  id in range(nb_b
+00004810: 6174 6368 6573 293a 0a20 2020 2020 2020  atches):.       
+00004820: 2020 2020 2020 2020 2062 6174 6368 6573           batches
+00004830: 5b62 6174 6368 5f69 645d 203d 207b 7d0a  [batch_id] = {}.
+00004840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004850: 6261 7463 6865 735b 6261 7463 685f 6964  batches[batch_id
+00004860: 5d5b 226c 6179 6572 225d 203d 206f 7574  ]["layer"] = out
+00004870: 7075 745f 6c61 7965 720a 0a20 2020 2020  put_layer..     
+00004880: 2020 2020 2020 2020 2020 2023 204f 7574             # Out
+00004890: 7075 7420 6561 6368 2062 6174 6368 2074  put each batch t
+000048a0: 6f20 6120 7365 7065 7261 7465 2074 656d  o a seperate tem
+000048b0: 706f 7261 7279 2066 696c 652c 206f 7468  porary file, oth
+000048c0: 6572 7769 7365 2074 6865 7265 0a20 2020  erwise there.   
+000048d0: 2020 2020 2020 2020 2020 2020 2023 2061               # a
+000048e0: 7265 2074 696d 656f 7574 2069 7373 7565  re timeout issue
+000048f0: 7320 7768 656e 2070 726f 6365 7373 696e  s when processin
+00004900: 6720 6c61 7267 6520 6669 6c65 730a 2020  g large files.  
+00004910: 2020 2020 2020 2020 2020 2020 2020 6f75                ou
+00004920: 7470 7574 5f74 6d70 5f70 6172 7469 616c  tput_tmp_partial
+00004930: 5f70 6174 6820 3d20 280a 2020 2020 2020  _path = (.      
+00004940: 2020 2020 2020 2020 2020 2020 2020 7465                te
+00004950: 6d70 6469 7220 2f20 6622 7b6f 7574 7075  mpdir / f"{outpu
+00004960: 745f 7061 7468 2e73 7465 6d7d 5f7b 6261  t_path.stem}_{ba
+00004970: 7463 685f 6964 7d7b 6f75 7470 7574 5f70  tch_id}{output_p
+00004980: 6174 682e 7375 6666 6978 7d22 0a20 2020  ath.suffix}".   
+00004990: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+000049a0: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+000049b0: 6174 6368 6573 5b62 6174 6368 5f69 645d  atches[batch_id]
+000049c0: 5b22 746d 705f 7061 7274 6961 6c5f 6f75  ["tmp_partial_ou
+000049d0: 7470 7574 5f70 6174 6822 5d20 3d20 6f75  tput_path"] = ou
+000049e0: 7470 7574 5f74 6d70 5f70 6172 7469 616c  tput_tmp_partial
+000049f0: 5f70 6174 680a 0a20 2020 2020 2020 2020  _path..         
+00004a00: 2020 2020 2020 2023 2046 6f72 2074 6865         # For the
+00004a10: 206c 6173 7420 7472 616e 736c 6174 655f   last translate_
+00004a20: 6964 2c20 7461 6b65 2061 6c6c 2072 6f77  id, take all row
+00004a30: 6964 2773 206c 6566 742e 2e2e 0a20 2020  id's left....   
+00004a40: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00004a50: 6261 7463 685f 6964 203c 206e 625f 6261  batch_id < nb_ba
+00004a60: 7463 6865 7320 2d20 313a 0a20 2020 2020  tches - 1:.     
+00004a70: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00004a80: 6f77 7320 3d20 736c 6963 6528 726f 775f  ows = slice(row_
+00004a90: 6f66 6673 6574 2c20 726f 775f 6f66 6673  offset, row_offs
+00004aa0: 6574 202b 2072 6561 6c5f 6261 7463 6873  et + real_batchs
+00004ab0: 697a 6529 0a20 2020 2020 2020 2020 2020  ize).           
+00004ac0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00004ad0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00004ae0: 6f77 7320 3d20 736c 6963 6528 726f 775f  ows = slice(row_
+00004af0: 6f66 6673 6574 2c20 6e62 5f72 6f77 735f  offset, nb_rows_
+00004b00: 746f 7461 6c29 0a0a 2020 2020 2020 2020  total)..        
+00004b10: 2020 2020 2020 2020 2320 5265 6d61 726b          # Remark
+00004b20: 3a20 7468 6973 2074 656d 7020 6669 6c65  : this temp file
+00004b30: 2064 6f65 736e 2774 206e 6565 6420 7370   doesn't need sp
+00004b40: 6174 6961 6c20 696e 6465 780a 2020 2020  atial index.    
+00004b50: 2020 2020 2020 2020 2020 2020 2320 5265              # Re
+00004b60: 6d61 726b 3a20 6265 6361 7573 6520 666f  mark: because fo
+00004b70: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
+00004b80: 7472 7974 7970 6520 666f 7220 4765 6f44  trytype for GeoD
+00004b90: 6174 6146 7261 6d65 0a20 2020 2020 2020  ataFrame.       
+00004ba0: 2020 2020 2020 2020 2023 206f 7065 7261           # opera
+00004bb0: 7469 6f6e 7320 6973 2028 6120 6c6f 7429  tions is (a lot)
+00004bc0: 206d 6f72 6520 6c69 6d69 7465 6420 7468   more limited th
+00004bd0: 616e 2067 6461 6c2d 6261 7365 642c 2074  an gdal-based, t
+00004be0: 6865 2067 6461 6c20 7665 7273 696f 6e0a  he gdal version.
+00004bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004c00: 2320 6973 2075 7365 6420 6c61 7465 7220  # is used later 
+00004c10: 6f6e 2077 6865 6e20 7468 6520 7265 7375  on when the resu
+00004c20: 6c74 7320 6172 6520 6d65 7267 6564 2074  lts are merged t
+00004c30: 6f20 7468 6520 7265 7375 6c74 2066 696c  o the result fil
+00004c40: 652e 0a20 2020 2020 2020 2020 2020 2020  e..             
+00004c50: 2020 2066 7574 7572 6520 3d20 6361 6c63     future = calc
+00004c60: 756c 6174 655f 706f 6f6c 2e73 7562 6d69  ulate_pool.submi
+00004c70: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
+00004c80: 2020 2020 2020 205f 6170 706c 795f 6765         _apply_ge
+00004c90: 6f6f 7065 7261 7469 6f6e 2c0a 2020 2020  ooperation,.    
+00004ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004cb0: 696e 7075 745f 7061 7468 3d69 6e70 7574  input_path=input
+00004cc0: 5f70 6174 682c 0a20 2020 2020 2020 2020  _path,.         
+00004cd0: 2020 2020 2020 2020 2020 206f 7574 7075             outpu
+00004ce0: 745f 7061 7468 3d6f 7574 7075 745f 746d  t_path=output_tm
+00004cf0: 705f 7061 7274 6961 6c5f 7061 7468 2c0a  p_partial_path,.
+00004d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004d10: 2020 2020 6f70 6572 6174 696f 6e3d 6f70      operation=op
+00004d20: 6572 6174 696f 6e2c 0a20 2020 2020 2020  eration,.       
+00004d30: 2020 2020 2020 2020 2020 2020 206f 7065               ope
+00004d40: 7261 7469 6f6e 5f70 6172 616d 733d 6f70  ration_params=op
+00004d50: 6572 6174 696f 6e5f 7061 7261 6d73 2c0a  eration_params,.
+00004d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004d70: 2020 2020 696e 7075 745f 6c61 7965 723d      input_layer=
+00004d80: 696e 7075 745f 6c61 7965 722c 0a20 2020  input_layer,.   
+00004d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004da0: 2063 6f6c 756d 6e73 3d63 6f6c 756d 6e73   columns=columns
+00004db0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00004dc0: 2020 2020 2020 6f75 7470 7574 5f6c 6179        output_lay
+00004dd0: 6572 3d6f 7574 7075 745f 6c61 7965 722c  er=output_layer,
+00004de0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004df0: 2020 2020 2072 6f77 733d 726f 7773 2c0a       rows=rows,.
+00004e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004e10: 2020 2020 6578 706c 6f64 6563 6f6c 6c65      explodecolle
+00004e20: 6374 696f 6e73 3d65 7870 6c6f 6465 636f  ctions=explodeco
+00004e30: 6c6c 6563 7469 6f6e 732c 0a20 2020 2020  llections,.     
+00004e40: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00004e50: 6f72 6365 3d66 6f72 6365 2c0a 2020 2020  orce=force,.    
+00004e60: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00004e70: 2020 2020 2020 2020 2020 2020 2020 6675                fu
+00004e80: 7475 7265 5f74 6f5f 6261 7463 685f 6964  ture_to_batch_id
+00004e90: 5b66 7574 7572 655d 203d 2062 6174 6368  [future] = batch
+00004ea0: 5f69 640a 2020 2020 2020 2020 2020 2020  _id.            
+00004eb0: 2020 2020 726f 775f 6f66 6673 6574 202b      row_offset +
+00004ec0: 3d20 7265 616c 5f62 6174 6368 7369 7a65  = real_batchsize
+00004ed0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+00004ee0: 4c6f 6f70 2074 696c 6c20 616c 6c20 7061  Loop till all pa
+00004ef0: 7261 6c6c 656c 2070 726f 6365 7373 6573  rallel processes
+00004f00: 2061 7265 2072 6561 6479 2c20 6275 7420   are ready, but 
+00004f10: 7072 6f63 6573 7320 6561 6368 206f 6e65  process each one
+00004f20: 0a20 2020 2020 2020 2020 2020 2023 2074  .            # t
+00004f30: 6861 7420 6973 2072 6561 6479 2061 6c72  hat is ready alr
+00004f40: 6561 6479 0a20 2020 2020 2020 2020 2020  eady.           
+00004f50: 2073 7461 7274 5f74 696d 6520 3d20 6461   start_time = da
+00004f60: 7465 7469 6d65 2e6e 6f77 2829 0a20 2020  tetime.now().   
+00004f70: 2020 2020 2020 2020 205f 6765 6e65 7261           _genera
+00004f80: 6c5f 7574 696c 2e72 6570 6f72 745f 7072  l_util.report_pr
+00004f90: 6f67 7265 7373 280a 2020 2020 2020 2020  ogress(.        
+00004fa0: 2020 2020 2020 2020 7374 6172 745f 7469          start_ti
+00004fb0: 6d65 2c20 6e62 5f64 6f6e 652c 206e 625f  me, nb_done, nb_
+00004fc0: 6261 7463 6865 732c 206f 7065 7261 7469  batches, operati
+00004fd0: 6f6e 2e76 616c 7565 2c20 6e62 5f70 6172  on.value, nb_par
+00004fe0: 616c 6c65 6c0a 2020 2020 2020 2020 2020  allel.          
+00004ff0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+00005000: 666f 7220 6675 7475 7265 2069 6e20 6675  for future in fu
+00005010: 7475 7265 732e 6173 5f63 6f6d 706c 6574  tures.as_complet
+00005020: 6564 2866 7574 7572 655f 746f 5f62 6174  ed(future_to_bat
+00005030: 6368 5f69 6429 3a0a 2020 2020 2020 2020  ch_id):.        
+00005040: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
+00005050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005060: 206d 6573 7361 6765 203d 2066 7574 7572   message = futur
+00005070: 652e 7265 7375 6c74 2829 0a20 2020 2020  e.result().     
+00005080: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+00005090: 6f67 6765 722e 6465 6275 6728 6d65 7373  ogger.debug(mess
+000050a0: 6167 6529 0a0a 2020 2020 2020 2020 2020  age)..          
+000050b0: 2020 2020 2020 2020 2020 2320 4966 2074            # If t
+000050c0: 6865 2063 616c 6375 6c61 7465 2067 6176  he calculate gav
+000050d0: 6520 7265 7375 6c74 732c 2063 6f70 7920  e results, copy 
+000050e0: 746f 206f 7574 7075 740a 2020 2020 2020  to output.      
+000050f0: 2020 2020 2020 2020 2020 2020 2020 6261                ba
+00005100: 7463 685f 6964 203d 2066 7574 7572 655f  tch_id = future_
+00005110: 746f 5f62 6174 6368 5f69 645b 6675 7475  to_batch_id[futu
+00005120: 7265 5d0a 2020 2020 2020 2020 2020 2020  re].            
+00005130: 2020 2020 2020 2020 746d 705f 7061 7274          tmp_part
+00005140: 6961 6c5f 6f75 7470 7574 5f70 6174 6820  ial_output_path 
+00005150: 3d20 6261 7463 6865 735b 6261 7463 685f  = batches[batch_
+00005160: 6964 5d5b 0a20 2020 2020 2020 2020 2020  id][.           
+00005170: 2020 2020 2020 2020 2020 2020 2022 746d               "tm
+00005180: 705f 7061 7274 6961 6c5f 6f75 7470 7574  p_partial_output
+00005190: 5f70 6174 6822 0a20 2020 2020 2020 2020  _path".         
+000051a0: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
+000051b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000051c0: 2069 6620 280a 2020 2020 2020 2020 2020   if (.          
+000051d0: 2020 2020 2020 2020 2020 2020 2020 746d                tm
+000051e0: 705f 7061 7274 6961 6c5f 6f75 7470 7574  p_partial_output
+000051f0: 5f70 6174 682e 6578 6973 7473 2829 0a20  _path.exists(). 
+00005200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005210: 2020 2020 2020 2061 6e64 2074 6d70 5f70         and tmp_p
+00005220: 6172 7469 616c 5f6f 7574 7075 745f 7061  artial_output_pa
+00005230: 7468 2e73 7461 7428 292e 7374 5f73 697a  th.stat().st_siz
+00005240: 6520 3e20 300a 2020 2020 2020 2020 2020  e > 0.          
+00005250: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
+00005260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005270: 2020 2020 2023 2052 656d 6172 6b3a 2062       # Remark: b
+00005280: 6563 6175 7365 2066 6f72 6365 5f6f 7574  ecause force_out
+00005290: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
+000052a0: 2066 6f72 2047 656f 4461 7461 4672 616d   for GeoDataFram
+000052b0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+000052c0: 2020 2020 2020 2020 2020 2320 6f70 6572            # oper
+000052d0: 6174 696f 6e73 2069 7320 2861 206c 6f74  ations is (a lot
+000052e0: 2920 6d6f 7265 206c 696d 6974 6564 2074  ) more limited t
+000052f0: 6861 6e20 6764 616c 2d62 6173 6564 2c20  han gdal-based, 
+00005300: 7573 6520 7468 650a 2020 2020 2020 2020  use the.        
+00005310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005320: 2320 6764 616c 2076 6572 7369 6f6e 2076  # gdal version v
+00005330: 6961 205f 6170 7065 6e64 5f74 6f5f 6e6f  ia _append_to_no
+00005340: 6c6f 636b 2e0a 2020 2020 2020 2020 2020  lock..          
+00005350: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00005360: 206e 625f 6261 7463 6865 7320 3d3d 2031   nb_batches == 1
+00005370: 2061 6e64 2066 6f72 6365 5f6f 7574 7075   and force_outpu
+00005380: 745f 6765 6f6d 6574 7279 7479 7065 2069  t_geometrytype i
+00005390: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+000053a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000053b0: 2020 2020 6766 6f2e 6d6f 7665 2874 6d70      gfo.move(tmp
+000053c0: 5f70 6172 7469 616c 5f6f 7574 7075 745f  _partial_output_
+000053d0: 7061 7468 2c20 746d 705f 6f75 7470 7574  path, tmp_output
+000053e0: 5f70 6174 6829 0a20 2020 2020 2020 2020  _path).         
+000053f0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00005400: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00005410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005420: 2066 696c 656f 7073 2e5f 6170 7065 6e64   fileops._append
+00005430: 5f74 6f5f 6e6f 6c6f 636b 280a 2020 2020  _to_nolock(.    
+00005440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005450: 2020 2020 2020 2020 2020 2020 7372 633d              src=
+00005460: 746d 705f 7061 7274 6961 6c5f 6f75 7470  tmp_partial_outp
+00005470: 7574 5f70 6174 682c 0a20 2020 2020 2020  ut_path,.       
 00005480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005490: 2029 3a0d 0a20 2020 2020 2020 2020 2020   ):..           
-000054a0: 2020 2020 2020 2020 2020 2020 2023 2052               # R
-000054b0: 656d 6172 6b3a 2062 6563 6175 7365 2066  emark: because f
-000054c0: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-000054d0: 6574 7279 7479 7065 2066 6f72 2047 656f  etrytype for Geo
-000054e0: 4461 7461 4672 616d 650d 0a20 2020 2020  DataFrame..     
-000054f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005500: 2020 2023 206f 7065 7261 7469 6f6e 7320     # operations 
-00005510: 6973 2028 6120 6c6f 7429 206d 6f72 6520  is (a lot) more 
-00005520: 6c69 6d69 7465 6420 7468 616e 2067 6461  limited than gda
-00005530: 6c2d 6261 7365 642c 2075 7365 2074 6865  l-based, use the
-00005540: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00005550: 2020 2020 2020 2020 2020 2320 6764 616c            # gdal
-00005560: 2076 6572 7369 6f6e 2076 6961 205f 6170   version via _ap
-00005570: 7065 6e64 5f74 6f5f 6e6f 6c6f 636b 2e0d  pend_to_nolock..
-00005580: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005590: 2020 2020 2020 2020 2069 6620 6e62 5f62           if nb_b
-000055a0: 6174 6368 6573 203d 3d20 3120 616e 6420  atches == 1 and 
-000055b0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
-000055c0: 6d65 7472 7974 7970 6520 6973 204e 6f6e  metrytype is Non
-000055d0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-000055e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000055f0: 6766 6f2e 6d6f 7665 2874 6d70 5f70 6172  gfo.move(tmp_par
-00005600: 7469 616c 5f6f 7574 7075 745f 7061 7468  tial_output_path
-00005610: 2c20 746d 705f 6f75 7470 7574 5f70 6174  , tmp_output_pat
-00005620: 6829 0d0a 2020 2020 2020 2020 2020 2020  h)..            
-00005630: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00005640: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00005650: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00005660: 696c 656f 7073 2e5f 6170 7065 6e64 5f74  ileops._append_t
-00005670: 6f5f 6e6f 6c6f 636b 280d 0a20 2020 2020  o_nolock(..     
-00005680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005690: 2020 2020 2020 2020 2020 2073 7263 3d74             src=t
-000056a0: 6d70 5f70 6172 7469 616c 5f6f 7574 7075  mp_partial_outpu
-000056b0: 745f 7061 7468 2c0d 0a20 2020 2020 2020  t_path,..       
-000056c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000056d0: 2020 2020 2020 2020 2064 7374 3d74 6d70           dst=tmp
-000056e0: 5f6f 7574 7075 745f 7061 7468 2c0d 0a20  _output_path,.. 
-000056f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005700: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00005710: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
-00005720: 733d 6578 706c 6f64 6563 6f6c 6c65 6374  s=explodecollect
-00005730: 696f 6e73 2c0d 0a20 2020 2020 2020 2020  ions,..         
-00005740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005750: 2020 2020 2020 2063 7265 6174 655f 7370         create_sp
-00005760: 6174 6961 6c5f 696e 6465 783d 4661 6c73  atial_index=Fals
-00005770: 652c 0d0a 2020 2020 2020 2020 2020 2020  e,..            
-00005780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005790: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
-000057a0: 5f67 656f 6d65 7472 7974 7970 653d 666f  _geometrytype=fo
-000057b0: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-000057c0: 7472 7974 7970 652c 0d0a 2020 2020 2020  trytype,..      
-000057d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000057e0: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-000057f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005800: 2020 2020 2067 666f 2e72 656d 6f76 6528       gfo.remove(
-00005810: 746d 705f 7061 7274 6961 6c5f 6f75 7470  tmp_partial_outp
-00005820: 7574 5f70 6174 6829 0d0a 0d0a 2020 2020  ut_path)....    
-00005830: 2020 2020 2020 2020 2020 2020 6578 6365              exce
-00005840: 7074 2045 7863 6570 7469 6f6e 3a0d 0a20  pt Exception:.. 
-00005850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005860: 2020 2062 6174 6368 5f69 6420 3d20 6675     batch_id = fu
-00005870: 7475 7265 5f74 6f5f 6261 7463 685f 6964  ture_to_batch_id
-00005880: 5b66 7574 7572 655d 0d0a 2020 2020 2020  [future]..      
-00005890: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-000058a0: 6361 6c63 756c 6174 655f 706f 6f6c 2e73  calculate_pool.s
-000058b0: 6875 7464 6f77 6e28 290d 0a20 2020 2020  hutdown()..     
-000058c0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-000058d0: 6f67 6765 722e 6578 6365 7074 696f 6e28  ogger.exception(
-000058e0: 6622 4572 726f 7220 6578 6563 7574 696e  f"Error executin
-000058f0: 6720 7b62 6174 6368 6573 5b62 6174 6368  g {batches[batch
-00005900: 5f69 645d 7d22 290d 0a0d 0a20 2020 2020  _id]}")....     
-00005910: 2020 2020 2020 2020 2020 2023 204c 6f67             # Log
-00005920: 2074 6865 2070 726f 6772 6573 7320 616e   the progress an
-00005930: 6420 7072 6564 6963 7469 6f6e 2073 7065  d prediction spe
-00005940: 6564 0d0a 2020 2020 2020 2020 2020 2020  ed..            
-00005950: 2020 2020 6e62 5f64 6f6e 6520 2b3d 2031      nb_done += 1
-00005960: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00005970: 2020 5f67 656e 6572 616c 5f75 7469 6c2e    _general_util.
-00005980: 7265 706f 7274 5f70 726f 6772 6573 7328  report_progress(
-00005990: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000059a0: 2020 2020 2020 7374 6172 745f 7469 6d65        start_time
-000059b0: 2c20 6e62 5f64 6f6e 652c 206e 625f 6261  , nb_done, nb_ba
-000059c0: 7463 6865 732c 206f 7065 7261 7469 6f6e  tches, operation
-000059d0: 2e76 616c 7565 2c20 6e62 5f70 6172 616c  .value, nb_paral
-000059e0: 6c65 6c0d 0a20 2020 2020 2020 2020 2020  lel..           
-000059f0: 2020 2020 2029 0d0a 0d0a 2020 2020 2020       )....      
-00005a00: 2020 2320 526f 756e 6420 7570 2061 6e64    # Round up and
-00005a10: 2063 6c65 616e 2075 700d 0a20 2020 2020   clean up..     
-00005a20: 2020 2023 204e 6f77 2063 7265 6174 6520     # Now create 
-00005a30: 7370 6174 6961 6c20 696e 6465 7820 616e  spatial index an
-00005a40: 6420 6d6f 7665 2074 6f20 6f75 7470 7574  d move to output
-00005a50: 206c 6f63 6174 696f 6e0d 0a20 2020 2020   location..     
-00005a60: 2020 2069 6620 746d 705f 6f75 7470 7574     if tmp_output
-00005a70: 5f70 6174 682e 6578 6973 7473 2829 3a0d  _path.exists():.
-00005a80: 0a20 2020 2020 2020 2020 2020 2067 666f  .            gfo
-00005a90: 2e63 7265 6174 655f 7370 6174 6961 6c5f  .create_spatial_
-00005aa0: 696e 6465 7828 7061 7468 3d74 6d70 5f6f  index(path=tmp_o
-00005ab0: 7574 7075 745f 7061 7468 2c20 6c61 7965  utput_path, laye
-00005ac0: 723d 6f75 7470 7574 5f6c 6179 6572 290d  r=output_layer).
-00005ad0: 0a20 2020 2020 2020 2020 2020 2067 666f  .            gfo
-00005ae0: 2e6d 6f76 6528 746d 705f 6f75 7470 7574  .move(tmp_output
-00005af0: 5f70 6174 682c 206f 7574 7075 745f 7061  _path, output_pa
-00005b00: 7468 290d 0a20 2020 2020 2020 2065 6c73  th)..        els
-00005b10: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-00005b20: 6c6f 6767 6572 2e64 6562 7567 2866 2252  logger.debug(f"R
-00005b30: 6573 756c 7420 6f66 207b 6f70 6572 6174  esult of {operat
-00005b40: 696f 6e7d 2077 6173 2065 6d70 7479 2122  ion} was empty!"
-00005b50: 290d 0a0d 0a20 2020 2066 696e 616c 6c79  )....    finally
-00005b60: 3a0d 0a20 2020 2020 2020 2023 2043 6c65  :..        # Cle
-00005b70: 616e 2074 6d70 2064 6972 0d0a 2020 2020  an tmp dir..    
-00005b80: 2020 2020 7368 7574 696c 2e72 6d74 7265      shutil.rmtre
-00005b90: 6528 7465 6d70 6469 7229 0d0a 2020 2020  e(tempdir)..    
-00005ba0: 2020 2020 6c6f 6767 6572 2e69 6e66 6f28      logger.info(
-00005bb0: 6622 7b6f 7065 7261 7469 6f6e 7d20 7265  f"{operation} re
-00005bc0: 6164 792c 2074 6f6f 6b20 7b64 6174 6574  ady, took {datet
-00005bd0: 696d 652e 6e6f 7728 292d 7374 6172 745f  ime.now()-start_
-00005be0: 7469 6d65 5f67 6c6f 6261 6c7d 2122 290d  time_global}!").
-00005bf0: 0a0d 0a0d 0a64 6566 205f 6170 706c 795f  .....def _apply_
-00005c00: 6765 6f6f 7065 7261 7469 6f6e 280d 0a20  geooperation(.. 
-00005c10: 2020 2069 6e70 7574 5f70 6174 683a 2050     input_path: P
-00005c20: 6174 682c 0d0a 2020 2020 6f75 7470 7574  ath,..    output
-00005c30: 5f70 6174 683a 2050 6174 682c 0d0a 2020  _path: Path,..  
-00005c40: 2020 6f70 6572 6174 696f 6e3a 2047 656f    operation: Geo
-00005c50: 4f70 6572 6174 696f 6e2c 0d0a 2020 2020  Operation,..    
-00005c60: 6f70 6572 6174 696f 6e5f 7061 7261 6d73  operation_params
-00005c70: 3a20 6469 6374 2c0d 0a20 2020 2069 6e70  : dict,..    inp
-00005c80: 7574 5f6c 6179 6572 3a20 4f70 7469 6f6e  ut_layer: Option
-00005c90: 616c 5b73 7472 5d20 3d20 4e6f 6e65 2c0d  al[str] = None,.
-00005ca0: 0a20 2020 206f 7574 7075 745f 6c61 7965  .    output_laye
-00005cb0: 723a 204f 7074 696f 6e61 6c5b 7374 725d  r: Optional[str]
-00005cc0: 203d 204e 6f6e 652c 0d0a 2020 2020 636f   = None,..    co
-00005cd0: 6c75 6d6e 733a 204f 7074 696f 6e61 6c5b  lumns: Optional[
-00005ce0: 4c69 7374 5b73 7472 5d5d 203d 204e 6f6e  List[str]] = Non
-00005cf0: 652c 0d0a 2020 2020 726f 7773 3d4e 6f6e  e,..    rows=Non
-00005d00: 652c 0d0a 2020 2020 6578 706c 6f64 6563  e,..    explodec
-00005d10: 6f6c 6c65 6374 696f 6e73 3a20 626f 6f6c  ollections: bool
-00005d20: 203d 2046 616c 7365 2c0d 0a20 2020 2066   = False,..    f
-00005d30: 6f72 6365 3a20 626f 6f6c 203d 2046 616c  orce: bool = Fal
-00005d40: 7365 2c0d 0a29 202d 3e20 7374 723a 0d0a  se,..) -> str:..
-00005d50: 2020 2020 2320 496e 6974 0d0a 2020 2020      # Init..    
-00005d60: 6966 206f 7574 7075 745f 7061 7468 2e65  if output_path.e
-00005d70: 7869 7374 7328 293a 0d0a 2020 2020 2020  xists():..      
-00005d80: 2020 6966 2066 6f72 6365 2069 7320 4661    if force is Fa
-00005d90: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-00005da0: 2020 6d65 7373 6167 6520 3d20 6622 5374    message = f"St
-00005db0: 6f70 207b 6f70 6572 6174 696f 6e7d 3a20  op {operation}: 
-00005dc0: 6f75 7470 7574 2065 7869 7374 7320 616c  output exists al
-00005dd0: 7265 6164 7920 7b6f 7574 7075 745f 7061  ready {output_pa
-00005de0: 7468 7d22 0d0a 2020 2020 2020 2020 2020  th}"..          
-00005df0: 2020 7265 7475 726e 206d 6573 7361 6765    return message
-00005e00: 0d0a 2020 2020 2020 2020 656c 7365 3a0d  ..        else:.
-00005e10: 0a20 2020 2020 2020 2020 2020 2067 666f  .            gfo
-00005e20: 2e72 656d 6f76 6528 6f75 7470 7574 5f70  .remove(output_p
-00005e30: 6174 6829 0d0a 0d0a 2020 2020 2320 4e6f  ath)....    # No
-00005e40: 7720 676f 210d 0a20 2020 2073 7461 7274  w go!..    start
-00005e50: 5f74 696d 6520 3d20 6461 7465 7469 6d65  _time = datetime
-00005e60: 2e6e 6f77 2829 0d0a 2020 2020 6461 7461  .now()..    data
-00005e70: 5f67 6466 203d 2067 666f 2e72 6561 645f  _gdf = gfo.read_
-00005e80: 6669 6c65 280d 0a20 2020 2020 2020 2070  file(..        p
-00005e90: 6174 683d 696e 7075 745f 7061 7468 2c20  ath=input_path, 
-00005ea0: 6c61 7965 723d 696e 7075 745f 6c61 7965  layer=input_laye
-00005eb0: 722c 2063 6f6c 756d 6e73 3d63 6f6c 756d  r, columns=colum
-00005ec0: 6e73 2c20 726f 7773 3d72 6f77 730d 0a20  ns, rows=rows.. 
-00005ed0: 2020 2029 0d0a 0d0a 2020 2020 2320 5275     )....    # Ru
-00005ee0: 6e20 6f70 6572 6174 696f 6e73 0d0a 2020  n operations..  
-00005ef0: 2020 6966 206f 7065 7261 7469 6f6e 2069    if operation i
-00005f00: 7320 4765 6f4f 7065 7261 7469 6f6e 2e42  s GeoOperation.B
-00005f10: 5546 4645 523a 0d0a 2020 2020 2020 2020  UFFER:..        
-00005f20: 6461 7461 5f67 6466 2e67 656f 6d65 7472  data_gdf.geometr
-00005f30: 7920 3d20 6461 7461 5f67 6466 2e67 656f  y = data_gdf.geo
-00005f40: 6d65 7472 792e 6275 6666 6572 280d 0a20  metry.buffer(.. 
-00005f50: 2020 2020 2020 2020 2020 2064 6973 7461             dista
-00005f60: 6e63 653d 6f70 6572 6174 696f 6e5f 7061  nce=operation_pa
-00005f70: 7261 6d73 5b22 6469 7374 616e 6365 225d  rams["distance"]
-00005f80: 2c0d 0a20 2020 2020 2020 2020 2020 2072  ,..            r
-00005f90: 6573 6f6c 7574 696f 6e3d 6f70 6572 6174  esolution=operat
-00005fa0: 696f 6e5f 7061 7261 6d73 5b22 7175 6164  ion_params["quad
-00005fb0: 7261 6e74 7365 676d 656e 7473 225d 2c0d  rantsegments"],.
-00005fc0: 0a20 2020 2020 2020 2020 2020 2063 6170  .            cap
-00005fd0: 5f73 7479 6c65 3d6f 7065 7261 7469 6f6e  _style=operation
-00005fe0: 5f70 6172 616d 735b 2265 6e64 6361 705f  _params["endcap_
-00005ff0: 7374 796c 6522 5d2e 7661 6c75 652c 0d0a  style"].value,..
-00006000: 2020 2020 2020 2020 2020 2020 6a6f 696e              join
-00006010: 5f73 7479 6c65 3d6f 7065 7261 7469 6f6e  _style=operation
-00006020: 5f70 6172 616d 735b 226a 6f69 6e5f 7374  _params["join_st
-00006030: 796c 6522 5d2e 7661 6c75 652c 0d0a 2020  yle"].value,..  
-00006040: 2020 2020 2020 2020 2020 6d69 7472 655f            mitre_
-00006050: 6c69 6d69 743d 6f70 6572 6174 696f 6e5f  limit=operation_
-00006060: 7061 7261 6d73 5b22 6d69 7472 655f 6c69  params["mitre_li
-00006070: 6d69 7422 5d2c 0d0a 2020 2020 2020 2020  mit"],..        
-00006080: 2020 2020 7369 6e67 6c65 5f73 6964 6564      single_sided
-00006090: 3d6f 7065 7261 7469 6f6e 5f70 6172 616d  =operation_param
-000060a0: 735b 2273 696e 676c 655f 7369 6465 6422  s["single_sided"
-000060b0: 5d2c 0d0a 2020 2020 2020 2020 290d 0a20  ],..        ).. 
-000060c0: 2020 2065 6c69 6620 6f70 6572 6174 696f     elif operatio
-000060d0: 6e20 6973 2047 656f 4f70 6572 6174 696f  n is GeoOperatio
-000060e0: 6e2e 434f 4e56 4558 4855 4c4c 3a0d 0a20  n.CONVEXHULL:.. 
-000060f0: 2020 2020 2020 2064 6174 615f 6764 662e         data_gdf.
-00006100: 6765 6f6d 6574 7279 203d 2064 6174 615f  geometry = data_
-00006110: 6764 662e 6765 6f6d 6574 7279 2e63 6f6e  gdf.geometry.con
-00006120: 7665 785f 6875 6c6c 0d0a 2020 2020 656c  vex_hull..    el
-00006130: 6966 206f 7065 7261 7469 6f6e 2069 7320  if operation is 
-00006140: 4765 6f4f 7065 7261 7469 6f6e 2e53 494d  GeoOperation.SIM
-00006150: 504c 4946 593a 0d0a 2020 2020 2020 2020  PLIFY:..        
-00006160: 6461 7461 5f67 6466 2e67 656f 6d65 7472  data_gdf.geometr
-00006170: 7920 3d20 6765 6f73 6572 6965 735f 7574  y = geoseries_ut
-00006180: 696c 2e73 696d 706c 6966 795f 6578 7428  il.simplify_ext(
-00006190: 0d0a 2020 2020 2020 2020 2020 2020 6461  ..            da
-000061a0: 7461 5f67 6466 2e67 656f 6d65 7472 792c  ta_gdf.geometry,
-000061b0: 0d0a 2020 2020 2020 2020 2020 2020 616c  ..            al
-000061c0: 676f 7269 7468 6d3d 6f70 6572 6174 696f  gorithm=operatio
-000061d0: 6e5f 7061 7261 6d73 5b22 616c 676f 7269  n_params["algori
-000061e0: 7468 6d22 5d2c 0d0a 2020 2020 2020 2020  thm"],..        
-000061f0: 2020 2020 746f 6c65 7261 6e63 653d 6f70      tolerance=op
-00006200: 6572 6174 696f 6e5f 7061 7261 6d73 5b22  eration_params["
-00006210: 746f 6c65 7261 6e63 6522 5d2c 0d0a 2020  tolerance"],..  
-00006220: 2020 2020 2020 2020 2020 6c6f 6f6b 6168            lookah
-00006230: 6561 643d 6f70 6572 6174 696f 6e5f 7061  ead=operation_pa
-00006240: 7261 6d73 5b22 7374 6570 225d 2c0d 0a20  rams["step"],.. 
-00006250: 2020 2020 2020 2029 0d0a 2020 2020 656c         )..    el
-00006260: 6966 206f 7065 7261 7469 6f6e 2069 7320  if operation is 
-00006270: 4765 6f4f 7065 7261 7469 6f6e 2e41 5050  GeoOperation.APP
-00006280: 4c59 3a0d 0a20 2020 2020 2020 2066 756e  LY:..        fun
-00006290: 6320 3d20 7069 636b 6c65 2e6c 6f61 6473  c = pickle.loads
-000062a0: 286f 7065 7261 7469 6f6e 5f70 6172 616d  (operation_param
-000062b0: 735b 2270 6963 6b6c 6564 5f66 756e 6322  s["pickled_func"
-000062c0: 5d29 0d0a 2020 2020 2020 2020 6966 206f  ])..        if o
-000062d0: 7065 7261 7469 6f6e 5f70 6172 616d 735b  peration_params[
-000062e0: 226f 6e6c 795f 6765 6f6d 5f69 6e70 7574  "only_geom_input
-000062f0: 225d 2069 7320 5472 7565 3a0d 0a20 2020  "] is True:..   
-00006300: 2020 2020 2020 2020 2064 6174 615f 6764           data_gd
-00006310: 662e 6765 6f6d 6574 7279 203d 2064 6174  f.geometry = dat
-00006320: 615f 6764 662e 6765 6f6d 6574 7279 2e61  a_gdf.geometry.a
-00006330: 7070 6c79 2866 756e 6329 0d0a 2020 2020  pply(func)..    
-00006340: 2020 2020 656c 7365 3a0d 0a20 2020 2020      else:..     
-00006350: 2020 2020 2020 2064 6174 615f 6764 662e         data_gdf.
-00006360: 6765 6f6d 6574 7279 203d 2064 6174 615f  geometry = data_
-00006370: 6764 662e 6170 706c 7928 6675 6e63 2c20  gdf.apply(func, 
-00006380: 6178 6973 3d31 290d 0a20 2020 2065 6c73  axis=1)..    els
-00006390: 653a 0d0a 2020 2020 2020 2020 7261 6973  e:..        rais
-000063a0: 6520 5661 6c75 6545 7272 6f72 2866 226f  e ValueError(f"o
-000063b0: 7065 7261 7469 6f6e 206e 6f74 2073 7570  peration not sup
-000063c0: 706f 7274 6564 3a20 7b6f 7065 7261 7469  ported: {operati
-000063d0: 6f6e 7d22 290d 0a0d 0a20 2020 2023 2052  on}")....    # R
-000063e0: 656d 6f76 6520 726f 7773 2077 6865 7265  emove rows where
-000063f0: 2067 656f 6d20 6973 2065 6d70 7479 0d0a   geom is empty..
-00006400: 2020 2020 6461 7461 5f67 6466 203d 2064      data_gdf = d
-00006410: 6174 615f 6764 665b 7e64 6174 615f 6764  ata_gdf[~data_gd
-00006420: 662e 6765 6f6d 6574 7279 2e69 735f 656d  f.geometry.is_em
-00006430: 7074 795d 0d0a 2020 2020 6461 7461 5f67  pty]..    data_g
-00006440: 6466 203d 2064 6174 615f 6764 665b 7e64  df = data_gdf[~d
-00006450: 6174 615f 6764 662e 6765 6f6d 6574 7279  ata_gdf.geometry
-00006460: 2e69 736e 6128 295d 0d0a 0d0a 2020 2020  .isna()]....    
-00006470: 2320 4966 2074 6865 7265 2069 7320 616e  # If there is an
-00006480: 2066 6964 2063 6f6c 756d 6e20 696e 2074   fid column in t
-00006490: 6865 2064 6174 6173 6574 2c20 7265 6e61  he dataset, rena
-000064a0: 6d65 2069 742c 2062 6563 6175 7365 2074  me it, because t
-000064b0: 6865 2066 6964 2063 6f6c 756d 6e20 6973  he fid column is
-000064c0: 2061 0d0a 2020 2020 2320 2273 7065 6369   a..    # "speci
-000064d0: 616c 2063 6173 6522 2069 6e20 6764 616c  al case" in gdal
-000064e0: 2074 6861 7420 7368 6f75 6c64 206e 6f74   that should not
-000064f0: 2062 6520 7772 6974 7465 6e2e 0d0a 2020   be written...  
-00006500: 2020 636f 6c75 6d6e 735f 6c6f 7765 725f    columns_lower_
-00006510: 6c6f 6f6b 7570 203d 207b 636f 6c75 6d6e  lookup = {column
-00006520: 2e6c 6f77 6572 2829 3a20 636f 6c75 6d6e  .lower(): column
-00006530: 2066 6f72 2063 6f6c 756d 6e20 696e 2064   for column in d
-00006540: 6174 615f 6764 662e 636f 6c75 6d6e 737d  ata_gdf.columns}
-00006550: 0d0a 2020 2020 6966 2022 6669 6422 2069  ..    if "fid" i
-00006560: 6e20 636f 6c75 6d6e 735f 6c6f 7765 725f  n columns_lower_
-00006570: 6c6f 6f6b 7570 3a0d 0a20 2020 2020 2020  lookup:..       
-00006580: 2066 6964 5f63 6f6c 756d 6e20 3d20 636f   fid_column = co
-00006590: 6c75 6d6e 735f 6c6f 7765 725f 6c6f 6f6b  lumns_lower_look
-000065a0: 7570 5b22 6669 6422 5d0d 0a20 2020 2020  up["fid"]..     
-000065b0: 2020 2066 6f72 2066 6964 5f6e 756d 6265     for fid_numbe
-000065c0: 7220 696e 2072 616e 6765 2831 2c20 3130  r in range(1, 10
-000065d0: 3029 3a0d 0a20 2020 2020 2020 2020 2020  0):..           
-000065e0: 206e 6577 5f6e 616d 6520 3d20 6622 7b66   new_name = f"{f
-000065f0: 6964 5f63 6f6c 756d 6e7d 5f7b 6669 645f  id_column}_{fid_
-00006600: 6e75 6d62 6572 7d22 0d0a 2020 2020 2020  number}"..      
-00006610: 2020 2020 2020 6966 206e 6577 5f6e 616d        if new_nam
-00006620: 6520 6e6f 7420 696e 2063 6f6c 756d 6e73  e not in columns
-00006630: 5f6c 6f77 6572 5f6c 6f6f 6b75 703a 0d0a  _lower_lookup:..
-00006640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006650: 6461 7461 5f67 6466 203d 2064 6174 615f  data_gdf = data_
-00006660: 6764 662e 7265 6e61 6d65 280d 0a20 2020  gdf.rename(..   
-00006670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006680: 2063 6f6c 756d 6e73 3d7b 6669 645f 636f   columns={fid_co
-00006690: 6c75 6d6e 3a20 6e65 775f 6e61 6d65 7d2c  lumn: new_name},
-000066a0: 2063 6f70 793d 4661 6c73 6520 2023 2074   copy=False  # t
-000066b0: 7970 653a 2069 676e 6f72 650d 0a20 2020  ype: ignore..   
-000066c0: 2020 2020 2020 2020 2020 2020 2029 0d0a               )..
-000066d0: 2020 2020 6966 2065 7870 6c6f 6465 636f      if explodeco
-000066e0: 6c6c 6563 7469 6f6e 733a 0d0a 2020 2020  llections:..    
-000066f0: 2020 2020 6461 7461 5f67 6466 203d 2064      data_gdf = d
-00006700: 6174 615f 6764 662e 6578 706c 6f64 6528  ata_gdf.explode(
-00006710: 6967 6e6f 7265 5f69 6e64 6578 3d54 7275  ignore_index=Tru
-00006720: 6529 2020 2320 7479 7065 3a20 6967 6e6f  e)  # type: igno
-00006730: 7265 0d0a 0d0a 2020 2020 2320 4966 2074  re....    # If t
-00006740: 6865 2072 6573 756c 7420 6973 2065 6d70  he result is emp
-00006750: 7479 2c20 616e 6420 6e6f 206f 7574 7075  ty, and no outpu
-00006760: 7420 6765 6f6d 6574 7279 7479 7065 2073  t geometrytype s
-00006770: 7065 6369 6669 6564 2c20 7573 6520 696e  pecified, use in
-00006780: 7075 740d 0a20 2020 2023 2067 656f 6d65  put..    # geome
-00006790: 7472 7974 7970 650d 0a20 2020 2066 6f72  trytype..    for
-000067a0: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-000067b0: 7279 7479 7065 203d 204e 6f6e 650d 0a20  rytype = None.. 
-000067c0: 2020 2069 6620 6c65 6e28 6461 7461 5f67     if len(data_g
-000067d0: 6466 2920 3d3d 2030 3a0d 0a20 2020 2020  df) == 0:..     
-000067e0: 2020 2069 6e70 7574 5f6c 6179 6572 696e     input_layerin
-000067f0: 666f 203d 2067 666f 2e67 6574 5f6c 6179  fo = gfo.get_lay
-00006800: 6572 696e 666f 2869 6e70 7574 5f70 6174  erinfo(input_pat
-00006810: 682c 2069 6e70 7574 5f6c 6179 6572 290d  h, input_layer).
-00006820: 0a20 2020 2020 2020 2066 6f72 6365 5f6f  .        force_o
-00006830: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-00006840: 7065 203d 2069 6e70 7574 5f6c 6179 6572  pe = input_layer
-00006850: 696e 666f 2e67 656f 6d65 7472 7974 7970  info.geometrytyp
-00006860: 652e 746f 5f6d 756c 7469 7479 7065 2e6e  e.to_multitype.n
-00006870: 616d 650d 0a0d 0a20 2020 2023 2061 7373  ame....    # ass
-00006880: 6572 7420 746f 2065 7661 6465 2070 794c  ert to evade pyL
-00006890: 616e 6365 2077 6172 6e69 6e67 0d0a 2020  ance warning..  
-000068a0: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
-000068b0: 6e63 6528 6461 7461 5f67 6466 2c20 6770  nce(data_gdf, gp
-000068c0: 642e 4765 6f44 6174 6146 7261 6d65 290d  d.GeoDataFrame).
-000068d0: 0a20 2020 2023 2055 7365 2066 6f72 6365  .    # Use force
-000068e0: 5f6d 756c 7469 7479 7065 2c20 746f 2065  _multitype, to e
-000068f0: 7661 6465 2077 6172 6e69 6e67 7320 7768  vade warnings wh
-00006900: 656e 2073 6f6d 6520 6261 7463 6865 7320  en some batches 
-00006910: 636f 6e74 6169 6e0d 0a20 2020 2023 2073  contain..    # s
-00006920: 696e 676c 6574 7970 6520 616e 6420 736f  ingletype and so
-00006930: 6d65 2063 6f6e 7461 696e 206d 756c 7469  me contain multi
-00006940: 7479 7065 2067 656f 6d65 7472 6965 730d  type geometries.
-00006950: 0a20 2020 2067 666f 2e74 6f5f 6669 6c65  .    gfo.to_file
-00006960: 280d 0a20 2020 2020 2020 2067 6466 3d64  (..        gdf=d
-00006970: 6174 615f 6764 662c 0d0a 2020 2020 2020  ata_gdf,..      
-00006980: 2020 7061 7468 3d6f 7574 7075 745f 7061    path=output_pa
-00006990: 7468 2c0d 0a20 2020 2020 2020 206c 6179  th,..        lay
-000069a0: 6572 3d6f 7574 7075 745f 6c61 7965 722c  er=output_layer,
-000069b0: 0d0a 2020 2020 2020 2020 696e 6465 783d  ..        index=
-000069c0: 4661 6c73 652c 0d0a 2020 2020 2020 2020  False,..        
-000069d0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
-000069e0: 6d65 7472 7974 7970 653d 666f 7263 655f  metrytype=force_
-000069f0: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-00006a00: 7970 652c 0d0a 2020 2020 2020 2020 666f  ype,..        fo
-00006a10: 7263 655f 6d75 6c74 6974 7970 653d 5472  rce_multitype=Tr
-00006a20: 7565 2c0d 0a20 2020 2020 2020 2063 7265  ue,..        cre
-00006a30: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
-00006a40: 783d 4661 6c73 652c 0d0a 2020 2020 290d  x=False,..    ).
-00006a50: 0a0d 0a20 2020 206d 6573 7361 6765 203d  ...    message =
-00006a60: 2066 2254 6f6f 6b20 7b64 6174 6574 696d   f"Took {datetim
-00006a70: 652e 6e6f 7728 292d 7374 6172 745f 7469  e.now()-start_ti
-00006a80: 6d65 7d20 666f 7220 7b6c 656e 2864 6174  me} for {len(dat
-00006a90: 615f 6764 6629 7d20 726f 7773 2028 7b72  a_gdf)} rows ({r
-00006aa0: 6f77 737d 2921 220d 0a20 2020 2072 6574  ows})!"..    ret
-00006ab0: 7572 6e20 6d65 7373 6167 650d 0a0d 0a0d  urn message.....
-00006ac0: 0a64 6566 2064 6973 736f 6c76 6528 0d0a  .def dissolve(..
-00006ad0: 2020 2020 696e 7075 745f 7061 7468 3a20      input_path: 
-00006ae0: 5061 7468 2c0d 0a20 2020 206f 7574 7075  Path,..    outpu
-00006af0: 745f 7061 7468 3a20 5061 7468 2c0d 0a20  t_path: Path,.. 
-00006b00: 2020 2067 726f 7570 6279 5f63 6f6c 756d     groupby_colum
-00006b10: 6e73 3a20 4f70 7469 6f6e 616c 5b49 7465  ns: Optional[Ite
-00006b20: 7261 626c 655b 7374 725d 5d20 3d20 4e6f  rable[str]] = No
-00006b30: 6e65 2c0d 0a20 2020 2061 6767 5f63 6f6c  ne,..    agg_col
-00006b40: 756d 6e73 3a20 4f70 7469 6f6e 616c 5b64  umns: Optional[d
-00006b50: 6963 745d 203d 204e 6f6e 652c 0d0a 2020  ict] = None,..  
-00006b60: 2020 6578 706c 6f64 6563 6f6c 6c65 6374    explodecollect
-00006b70: 696f 6e73 3a20 626f 6f6c 203d 2054 7275  ions: bool = Tru
-00006b80: 652c 0d0a 2020 2020 7469 6c65 735f 7061  e,..    tiles_pa
-00006b90: 7468 3a20 4f70 7469 6f6e 616c 5b50 6174  th: Optional[Pat
-00006ba0: 685d 203d 204e 6f6e 652c 0d0a 2020 2020  h] = None,..    
-00006bb0: 6e62 5f73 7175 6172 6973 685f 7469 6c65  nb_squarish_tile
-00006bc0: 733a 2069 6e74 203d 2031 2c0d 0a20 2020  s: int = 1,..   
-00006bd0: 2069 6e70 7574 5f6c 6179 6572 3a20 4f70   input_layer: Op
-00006be0: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
-00006bf0: 6e65 2c0d 0a20 2020 206f 7574 7075 745f  ne,..    output_
-00006c00: 6c61 7965 723a 204f 7074 696f 6e61 6c5b  layer: Optional[
-00006c10: 7374 725d 203d 204e 6f6e 652c 0d0a 2020  str] = None,..  
-00006c20: 2020 6e62 5f70 6172 616c 6c65 6c3a 2069    nb_parallel: i
-00006c30: 6e74 203d 202d 312c 0d0a 2020 2020 6261  nt = -1,..    ba
-00006c40: 7463 6873 697a 653a 2069 6e74 203d 202d  tchsize: int = -
-00006c50: 312c 0d0a 2020 2020 666f 7263 653a 2062  1,..    force: b
-00006c60: 6f6f 6c20 3d20 4661 6c73 652c 0d0a 2920  ool = False,..) 
-00006c70: 2d3e 2064 6963 743a 0d0a 2020 2020 2222  -> dict:..    ""
-00006c80: 220d 0a20 2020 2046 756e 6374 696f 6e20  "..    Function 
-00006c90: 7468 6174 2061 7070 6c69 6573 2061 2064  that applies a d
-00006ca0: 6973 736f 6c76 652e 0d0a 0d0a 2020 2020  issolve.....    
-00006cb0: 4d6f 7265 2064 6574 6169 6c65 6420 646f  More detailed do
-00006cc0: 6375 6d65 6e74 6174 696f 6e20 696e 206d  cumentation in m
-00006cd0: 6f64 756c 6520 6765 6f6f 7073 210d 0a20  odule geoops!.. 
-00006ce0: 2020 2022 2222 0d0a 0d0a 2020 2020 2320     """....    # 
-00006cf0: 496e 6974 2061 6e64 2076 616c 6964 6174  Init and validat
-00006d00: 6520 696e 7075 7420 7061 7261 6d65 7465  e input paramete
-00006d10: 7273 0d0a 2020 2020 2320 2d2d 2d2d 2d2d  rs..    # ------
-00006d20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006d30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a 2020  ------------..  
-00006d40: 2020 7374 6172 745f 7469 6d65 203d 2064    start_time = d
-00006d50: 6174 6574 696d 652e 6e6f 7728 290d 0a20  atetime.now().. 
-00006d60: 2020 206f 7065 7261 7469 6f6e 203d 2022     operation = "
-00006d70: 6469 7373 6f6c 7665 220d 0a20 2020 2072  dissolve"..    r
-00006d80: 6573 756c 745f 696e 666f 203d 207b 7d0d  esult_info = {}.
-00006d90: 0a0d 0a20 2020 2023 2043 6865 636b 2069  ...    # Check i
-00006da0: 6e70 7574 2070 6172 616d 6574 6572 730d  nput parameters.
-00006db0: 0a20 2020 2069 6620 6772 6f75 7062 795f  .    if groupby_
-00006dc0: 636f 6c75 6d6e 7320 6973 206e 6f74 204e  columns is not N
-00006dd0: 6f6e 6520 616e 6420 6c65 6e28 6c69 7374  one and len(list
-00006de0: 2867 726f 7570 6279 5f63 6f6c 756d 6e73  (groupby_columns
-00006df0: 2929 203d 3d20 303a 0d0a 2020 2020 2020  )) == 0:..      
-00006e00: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
-00006e10: 6f72 2822 6772 6f75 7062 795f 636f 6c75  or("groupby_colu
-00006e20: 6d6e 733d 5b5d 2069 7320 6e6f 7420 7375  mns=[] is not su
-00006e30: 7070 6f72 7465 642e 2055 7365 204e 6f6e  pported. Use Non
-00006e40: 652e 2229 0d0a 2020 2020 6966 206e 6f74  e.")..    if not
-00006e50: 2069 6e70 7574 5f70 6174 682e 6578 6973   input_path.exis
-00006e60: 7473 2829 3a0d 0a20 2020 2020 2020 2072  ts():..        r
-00006e70: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-00006e80: 6622 696e 7075 745f 7061 7468 2064 6f65  f"input_path doe
-00006e90: 736e 2774 2065 7869 7374 3a20 7b69 6e70  sn't exist: {inp
-00006ea0: 7574 5f70 6174 687d 2229 0d0a 2020 2020  ut_path}")..    
-00006eb0: 6966 2069 6e70 7574 5f70 6174 6820 3d3d  if input_path ==
-00006ec0: 206f 7574 7075 745f 7061 7468 3a0d 0a20   output_path:.. 
-00006ed0: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
-00006ee0: 7565 4572 726f 7228 226f 7574 7075 745f  ueError("output_
-00006ef0: 7061 7468 206d 7573 7420 6e6f 7420 6571  path must not eq
-00006f00: 7561 6c20 696e 7075 745f 7061 7468 2229  ual input_path")
-00006f10: 0d0a 0d0a 2020 2020 696e 7075 745f 6c61  ....    input_la
-00006f20: 7965 7269 6e66 6f20 3d20 6766 6f2e 6765  yerinfo = gfo.ge
-00006f30: 745f 6c61 7965 7269 6e66 6f28 696e 7075  t_layerinfo(inpu
-00006f40: 745f 7061 7468 2c20 696e 7075 745f 6c61  t_path, input_la
-00006f50: 7965 7229 0d0a 2020 2020 6966 2069 6e70  yer)..    if inp
-00006f60: 7574 5f6c 6179 6572 696e 666f 2e67 656f  ut_layerinfo.geo
-00006f70: 6d65 7472 7974 7970 652e 746f 5f70 7269  metrytype.to_pri
-00006f80: 6d69 7469 7665 7479 7065 2069 6e20 5b0d  mitivetype in [.
-00006f90: 0a20 2020 2020 2020 2050 7269 6d69 7469  .        Primiti
-00006fa0: 7665 5479 7065 2e50 4f49 4e54 2c0d 0a20  veType.POINT,.. 
-00006fb0: 2020 2020 2020 2050 7269 6d69 7469 7665         Primitive
-00006fc0: 5479 7065 2e4c 494e 4553 5452 494e 472c  Type.LINESTRING,
-00006fd0: 0d0a 2020 2020 5d3a 0d0a 2020 2020 2020  ..    ]:..      
-00006fe0: 2020 6966 2074 696c 6573 5f70 6174 6820    if tiles_path 
-00006ff0: 6973 206e 6f74 204e 6f6e 6520 6f72 206e  is not None or n
-00007000: 625f 7371 7561 7269 7368 5f74 696c 6573  b_squarish_tiles
-00007010: 203e 2031 3a0d 0a20 2020 2020 2020 2020   > 1:..         
-00007020: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00007030: 726f 7228 0d0a 2020 2020 2020 2020 2020  ror(..          
-00007040: 2020 2020 2020 6622 4469 7373 6f6c 7665        f"Dissolve
-00007050: 2074 6f20 7469 6c65 7320 6973 206e 6f74   to tiles is not
-00007060: 2073 7570 706f 7274 6564 2066 6f72 207b   supported for {
-00007070: 696e 7075 745f 6c61 7965 7269 6e66 6f2e  input_layerinfo.
-00007080: 6765 6f6d 6574 7279 7479 7065 7d22 0d0a  geometrytype}"..
-00007090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000070a0: 222c 2073 6f20 7469 6c65 735f 7061 7468  ", so tiles_path
-000070b0: 2073 686f 756c 6420 6265 204e 6f6e 6520   should be None 
-000070c0: 616e 6420 6e62 5f73 7175 6172 6973 685f  and nb_squarish_
-000070d0: 7469 6c65 7320 7368 6f75 6c64 2062 6520  tiles should be 
-000070e0: 3129 220d 0a20 2020 2020 2020 2020 2020  1)"..           
-000070f0: 2029 0d0a 0d0a 2020 2020 2320 4368 6563   )....    # Chec
-00007100: 6b20 636f 6c75 6d6e 7320 696e 2067 726f  k columns in gro
-00007110: 7570 6279 5f63 6f6c 756d 6e73 0d0a 2020  upby_columns..  
-00007120: 2020 6966 2067 726f 7570 6279 5f63 6f6c    if groupby_col
-00007130: 756d 6e73 2069 7320 6e6f 7420 4e6f 6e65  umns is not None
-00007140: 3a0d 0a20 2020 2020 2020 2063 6f6c 756d  :..        colum
-00007150: 6e73 5f69 6e5f 6c61 7965 725f 7570 7065  ns_in_layer_uppe
-00007160: 7220 3d20 5b0d 0a20 2020 2020 2020 2020  r = [..         
-00007170: 2020 2063 6f6c 756d 6e2e 7570 7065 7228     column.upper(
-00007180: 2920 666f 7220 636f 6c75 6d6e 2069 6e20  ) for column in 
-00007190: 6c69 7374 2869 6e70 7574 5f6c 6179 6572  list(input_layer
-000071a0: 696e 666f 2e63 6f6c 756d 6e73 2920 2b20  info.columns) + 
-000071b0: 5b22 6669 6422 5d0d 0a20 2020 2020 2020  ["fid"]..       
-000071c0: 205d 0d0a 2020 2020 2020 2020 666f 7220   ]..        for 
-000071d0: 636f 6c75 6d6e 2069 6e20 6772 6f75 7062  column in groupb
-000071e0: 795f 636f 6c75 6d6e 733a 0d0a 2020 2020  y_columns:..    
-000071f0: 2020 2020 2020 2020 6966 2063 6f6c 756d          if colum
-00007200: 6e2e 7570 7065 7228 2920 6e6f 7420 696e  n.upper() not in
-00007210: 2063 6f6c 756d 6e73 5f69 6e5f 6c61 7965   columns_in_laye
-00007220: 725f 7570 7065 723a 0d0a 2020 2020 2020  r_upper:..      
-00007230: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00007240: 5661 6c75 6545 7272 6f72 280d 0a20 2020  ValueError(..   
-00007250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007260: 2066 2263 6f6c 756d 6e20 696e 2067 726f   f"column in gro
-00007270: 7570 6279 5f63 6f6c 756d 6e73 206e 6f74  upby_columns not
-00007280: 2061 7661 696c 6162 6c65 2069 6e20 6c61   available in la
-00007290: 7965 723a 207b 636f 6c75 6d6e 7d22 0d0a  yer: {column}"..
-000072a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000072b0: 290d 0a0d 0a20 2020 2023 2043 6865 636b  )....    # Check
-000072c0: 2061 6767 5f63 6f6c 756d 6e73 2070 6172   agg_columns par
-000072d0: 616d 0d0a 2020 2020 6966 2061 6767 5f63  am..    if agg_c
-000072e0: 6f6c 756d 6e73 2069 7320 6e6f 7420 4e6f  olumns is not No
-000072f0: 6e65 3a0d 0a20 2020 2020 2020 2023 2056  ne:..        # V
-00007300: 616c 6964 6174 6520 7468 6520 6469 6374  alidate the dict
-00007310: 2073 7472 7563 7475 7265 2c20 736f 2077   structure, so w
-00007320: 6520 6361 6e20 6173 7375 6d65 2065 7665  e can assume eve
-00007330: 7279 7468 696e 6720 6973 204f 4b20 6675  rything is OK fu
-00007340: 7274 6865 7220 6f6e 0d0a 2020 2020 2020  rther on..      
-00007350: 2020 5f70 6172 616d 6574 6572 5f68 656c    _parameter_hel
-00007360: 7065 722e 7661 6c69 6461 7465 5f61 6767  per.validate_agg
-00007370: 5f63 6f6c 756d 6e73 2861 6767 5f63 6f6c  _columns(agg_col
-00007380: 756d 6e73 290d 0a0d 0a20 2020 2020 2020  umns)....       
-00007390: 2023 2046 6972 7374 2074 616b 6520 6120   # First take a 
-000073a0: 6465 6570 2063 6f70 792c 2061 7320 7661  deep copy, as va
-000073b0: 6c75 6573 2063 616e 2062 6520 6368 616e  lues can be chan
-000073c0: 6765 6420 6675 7274 6865 7220 6f6e 2074  ged further on t
-000073d0: 6f20 7472 6561 7420 636f 6c75 6d6e 730d  o treat columns.
-000073e0: 0a20 2020 2020 2020 2023 2063 6173 6520  .        # case 
-000073f0: 696e 7365 6e73 6974 6976 650d 0a20 2020  insensitive..   
-00007400: 2020 2020 2061 6767 5f63 6f6c 756d 6e73       agg_columns
-00007410: 203d 206a 736f 6e2e 6c6f 6164 7328 6a73   = json.loads(js
-00007420: 6f6e 2e64 756d 7073 2861 6767 5f63 6f6c  on.dumps(agg_col
-00007430: 756d 6e73 2929 0d0a 2020 2020 2020 2020  umns))..        
-00007440: 6173 7365 7274 2061 6767 5f63 6f6c 756d  assert agg_colum
-00007450: 6e73 2069 7320 6e6f 7420 4e6f 6e65 0d0a  ns is not None..
-00007460: 2020 2020 2020 2020 6966 2022 6a73 6f6e          if "json
-00007470: 2220 696e 2061 6767 5f63 6f6c 756d 6e73  " in agg_columns
-00007480: 3a0d 0a20 2020 2020 2020 2020 2020 2069  :..            i
-00007490: 6620 6167 675f 636f 6c75 6d6e 735b 226a  f agg_columns["j
-000074a0: 736f 6e22 5d20 6973 204e 6f6e 653a 0d0a  son"] is None:..
-000074b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000074c0: 6167 675f 636f 6c75 6d6e 735b 226a 736f  agg_columns["jso
-000074d0: 6e22 5d20 3d20 5b0d 0a20 2020 2020 2020  n"] = [..       
-000074e0: 2020 2020 2020 2020 2020 2020 2063 6f6c               col
-000074f0: 2066 6f72 2063 6f6c 2069 6e20 696e 7075   for col in inpu
-00007500: 745f 6c61 7965 7269 6e66 6f2e 636f 6c75  t_layerinfo.colu
-00007510: 6d6e 7320 6966 2063 6f6c 2e75 7070 6572  mns if col.upper
-00007520: 2829 2021 3d20 2249 4e44 4558 220d 0a20  () != "INDEX".. 
-00007530: 2020 2020 2020 2020 2020 2020 2020 205d                 ]
-00007540: 0d0a 2020 2020 2020 2020 2020 2020 656c  ..            el
-00007550: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-00007560: 2020 2020 2023 2041 6c69 676e 2063 6173       # Align cas
-00007570: 696e 6720 6f66 2063 6f6c 756d 6e20 6e61  ing of column na
-00007580: 6d65 7320 746f 2064 6174 610d 0a20 2020  mes to data..   
-00007590: 2020 2020 2020 2020 2020 2020 2061 6767               agg
-000075a0: 5f63 6f6c 756d 6e73 5b22 6a73 6f6e 225d  _columns["json"]
-000075b0: 203d 205f 6765 6e65 7261 6c5f 7574 696c   = _general_util
-000075c0: 2e61 6c69 676e 5f63 6173 696e 675f 6c69  .align_casing_li
-000075d0: 7374 280d 0a20 2020 2020 2020 2020 2020  st(..           
-000075e0: 2020 2020 2020 2020 2061 6767 5f63 6f6c           agg_col
-000075f0: 756d 6e73 5b22 6a73 6f6e 225d 2c20 6c69  umns["json"], li
-00007600: 7374 2869 6e70 7574 5f6c 6179 6572 696e  st(input_layerin
-00007610: 666f 2e63 6f6c 756d 6e73 2920 2b20 5b22  fo.columns) + ["
-00007620: 6669 6422 5d0d 0a20 2020 2020 2020 2020  fid"]..         
-00007630: 2020 2020 2020 2029 0d0a 2020 2020 2020         )..      
-00007640: 2020 656c 6966 2022 636f 6c75 6d6e 7322    elif "columns"
-00007650: 2069 6e20 6167 675f 636f 6c75 6d6e 733a   in agg_columns:
-00007660: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-00007670: 4c6f 6f70 2074 6872 6f75 6768 2061 6c6c  Loop through all
-00007680: 2072 6f77 730d 0a20 2020 2020 2020 2020   rows..         
-00007690: 2020 2066 6f72 2061 6767 5f63 6f6c 756d     for agg_colum
-000076a0: 6e20 696e 2061 6767 5f63 6f6c 756d 6e73  n in agg_columns
-000076b0: 5b22 636f 6c75 6d6e 7322 5d3a 0d0a 2020  ["columns"]:..  
-000076c0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-000076d0: 4368 6563 6b20 6966 2063 6f6c 756d 6e20  Check if column 
-000076e0: 6578 6973 7473 202b 2073 6574 2063 6173  exists + set cas
-000076f0: 696e 6720 7361 6d65 2061 7320 696e 2064  ing same as in d
-00007700: 6174 610d 0a20 2020 2020 2020 2020 2020  ata..           
-00007710: 2020 2020 2061 6767 5f63 6f6c 756d 6e5b       agg_column[
-00007720: 2263 6f6c 756d 6e22 5d20 3d20 5f67 656e  "column"] = _gen
-00007730: 6572 616c 5f75 7469 6c2e 616c 6967 6e5f  eral_util.align_
-00007740: 6361 7369 6e67 280d 0a20 2020 2020 2020  casing(..       
-00007750: 2020 2020 2020 2020 2020 2020 2061 6767               agg
-00007760: 5f63 6f6c 756d 6e5b 2263 6f6c 756d 6e22  _column["column"
-00007770: 5d2c 206c 6973 7428 696e 7075 745f 6c61  ], list(input_la
-00007780: 7965 7269 6e66 6f2e 636f 6c75 6d6e 7329  yerinfo.columns)
-00007790: 202b 205b 2266 6964 225d 0d0a 2020 2020   + ["fid"]..    
-000077a0: 2020 2020 2020 2020 2020 2020 290d 0a0d              )...
-000077b0: 0a20 2020 2023 204e 6f77 2069 6e70 7574  .    # Now input
-000077c0: 2070 6172 616d 6574 6572 7320 6172 6520   parameters are 
-000077d0: 6368 6563 6b65 642c 2063 6865 636b 2069  checked, check i
-000077e0: 6620 7765 206e 6565 6420 746f 2063 616c  f we need to cal
-000077f0: 6361 6c61 7465 2061 6e79 7761 790d 0a20  calate anyway.. 
-00007800: 2020 2069 6620 6f75 7470 7574 5f70 6174     if output_pat
-00007810: 682e 6578 6973 7473 2829 3a0d 0a20 2020  h.exists():..   
-00007820: 2020 2020 2069 6620 666f 7263 6520 6973       if force is
-00007830: 2046 616c 7365 3a0d 0a20 2020 2020 2020   False:..       
-00007840: 2020 2020 2072 6573 756c 745f 696e 666f       result_info
-00007850: 5b0d 0a20 2020 2020 2020 2020 2020 2020  [..             
-00007860: 2020 2022 6d65 7373 6167 6522 0d0a 2020     "message"..  
-00007870: 2020 2020 2020 2020 2020 5d20 3d20 6622            ] = f"
-00007880: 6f75 7470 7574 2065 7869 7374 7320 616c  output exists al
-00007890: 7265 6164 7920 7b6f 7574 7075 745f 7061  ready {output_pa
-000078a0: 7468 7d20 616e 6420 666f 7263 6520 6973  th} and force is
-000078b0: 2066 616c 7365 220d 0a20 2020 2020 2020   false"..       
-000078c0: 2020 2020 206c 6f67 6765 722e 696e 666f       logger.info
-000078d0: 2872 6573 756c 745f 696e 666f 5b22 6d65  (result_info["me
-000078e0: 7373 6167 6522 5d29 0d0a 2020 2020 2020  ssage"])..      
-000078f0: 2020 2020 2020 7265 7475 726e 2072 6573        return res
-00007900: 756c 745f 696e 666f 0d0a 2020 2020 2020  ult_info..      
-00007910: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-00007920: 2020 2020 2067 666f 2e72 656d 6f76 6528       gfo.remove(
-00007930: 6f75 7470 7574 5f70 6174 6829 0d0a 0d0a  output_path)....
-00007940: 2020 2020 2320 4e6f 7720 7374 6172 7420      # Now start 
-00007950: 6469 7373 6f6c 7669 6e67 0d0a 2020 2020  dissolving..    
-00007960: 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  # --------------
-00007970: 2d2d 2d2d 2d2d 0d0a 2020 2020 2320 456d  ------..    # Em
-00007980: 7074 7920 6f72 204c 696e 6520 616e 6420  pty or Line and 
-00007990: 706f 696e 7420 6c61 7965 7273 2061 7265  point layers are
-000079a0: 3a0d 0a20 2020 2023 2020 202a 206e 6f74  :..    #   * not
-000079b0: 2073 6f20 6c61 7267 6520 286d 656d 6f72   so large (memor
-000079c0: 792d 7769 7365 290d 0a20 2020 2023 2020  y-wise)..    #  
-000079d0: 202a 2061 7265 6e27 7420 636f 6d70 7574   * aren't comput
-000079e0: 6174 696f 6e61 6c6c 7920 6865 6176 790d  ationally heavy.
-000079f0: 0a20 2020 2023 2041 6464 6974 696f 6e61  .    # Additiona
-00007a00: 6c6c 7920 6c69 6e65 206c 6179 6572 7320  lly line layers 
-00007a10: 6172 6520 6120 7061 696e 2074 6f20 6861  are a pain to ha
-00007a20: 6e64 6c65 2063 6f72 7265 6374 6c79 2062  ndle correctly b
-00007a30: 6563 6175 7365 206f 660d 0a20 2020 2023  ecause of..    #
-00007a40: 2072 6f75 6e64 696e 6720 6973 7375 6573   rounding issues
-00007a50: 2061 7420 7468 6520 626f 7264 6572 7320   at the borders 
-00007a60: 6f66 2074 696c 6573 2e2e 2e20 736f 206a  of tiles... so j
-00007a70: 7573 7420 6469 7373 6f6c 7665 2074 6865  ust dissolve the
-00007a80: 6d20 696e 206f 6e65 2067 6f2e 0d0a 2020  m in one go...  
-00007a90: 2020 6966 2028 0d0a 2020 2020 2020 2020    if (..        
-00007aa0: 696e 7075 745f 6c61 7965 7269 6e66 6f2e  input_layerinfo.
-00007ab0: 6665 6174 7572 6563 6f75 6e74 203d 3d20  featurecount == 
-00007ac0: 300d 0a20 2020 2020 2020 206f 7220 696e  0..        or in
-00007ad0: 7075 745f 6c61 7965 7269 6e66 6f2e 6765  put_layerinfo.ge
-00007ae0: 6f6d 6574 7279 7479 7065 2e74 6f5f 7072  ometrytype.to_pr
-00007af0: 696d 6974 6976 6574 7970 650d 0a20 2020  imitivetype..   
-00007b00: 2020 2020 2069 6e20 5b0d 0a20 2020 2020       in [..     
-00007b10: 2020 2020 2020 2050 7269 6d69 7469 7665         Primitive
-00007b20: 5479 7065 2e50 4f49 4e54 2c0d 0a20 2020  Type.POINT,..   
-00007b30: 2020 2020 2020 2020 2050 7269 6d69 7469           Primiti
-00007b40: 7665 5479 7065 2e4c 494e 4553 5452 494e  veType.LINESTRIN
-00007b50: 472c 0d0a 2020 2020 2020 2020 5d0d 0a20  G,..        ].. 
-00007b60: 2020 2029 3a0d 0a20 2020 2020 2020 205f     ):..        _
-00007b70: 6765 6f6f 7073 5f73 716c 2e64 6973 736f  geoops_sql.disso
-00007b80: 6c76 655f 7369 6e67 6c65 7468 7265 6164  lve_singlethread
-00007b90: 280d 0a20 2020 2020 2020 2020 2020 2069  (..            i
-00007ba0: 6e70 7574 5f70 6174 683d 696e 7075 745f  nput_path=input_
-00007bb0: 7061 7468 2c0d 0a20 2020 2020 2020 2020  path,..         
-00007bc0: 2020 206f 7574 7075 745f 7061 7468 3d6f     output_path=o
-00007bd0: 7574 7075 745f 7061 7468 2c0d 0a20 2020  utput_path,..   
-00007be0: 2020 2020 2020 2020 2065 7870 6c6f 6465           explode
-00007bf0: 636f 6c6c 6563 7469 6f6e 733d 6578 706c  collections=expl
-00007c00: 6f64 6563 6f6c 6c65 6374 696f 6e73 2c0d  odecollections,.
-00007c10: 0a20 2020 2020 2020 2020 2020 2067 726f  .            gro
-00007c20: 7570 6279 5f63 6f6c 756d 6e73 3d67 726f  upby_columns=gro
-00007c30: 7570 6279 5f63 6f6c 756d 6e73 2c0d 0a20  upby_columns,.. 
-00007c40: 2020 2020 2020 2020 2020 2061 6767 5f63             agg_c
-00007c50: 6f6c 756d 6e73 3d61 6767 5f63 6f6c 756d  olumns=agg_colum
-00007c60: 6e73 2c0d 0a20 2020 2020 2020 2020 2020  ns,..           
-00007c70: 2069 6e70 7574 5f6c 6179 6572 3d69 6e70   input_layer=inp
-00007c80: 7574 5f6c 6179 6572 2c0d 0a20 2020 2020  ut_layer,..     
-00007c90: 2020 2020 2020 206f 7574 7075 745f 6c61         output_la
-00007ca0: 7965 723d 6f75 7470 7574 5f6c 6179 6572  yer=output_layer
-00007cb0: 2c0d 0a20 2020 2020 2020 2020 2020 2066  ,..            f
-00007cc0: 6f72 6365 3d66 6f72 6365 2c0d 0a20 2020  orce=force,..   
-00007cd0: 2020 2020 2029 0d0a 0d0a 2020 2020 656c       )....    el
-00007ce0: 6966 2069 6e70 7574 5f6c 6179 6572 696e  if input_layerin
-00007cf0: 666f 2e67 656f 6d65 7472 7974 7970 652e  fo.geometrytype.
-00007d00: 746f 5f70 7269 6d69 7469 7665 7479 7065  to_primitivetype
-00007d10: 2069 7320 5072 696d 6974 6976 6554 7970   is PrimitiveTyp
-00007d20: 652e 504f 4c59 474f 4e3a 0d0a 2020 2020  e.POLYGON:..    
-00007d30: 2020 2020 2320 4966 2061 2074 696c 6573      # If a tiles
-00007d40: 5f70 6174 6820 6973 2073 7065 6369 6669  _path is specifi
-00007d50: 6564 2c20 7265 6164 2074 686f 7365 2074  ed, read those t
-00007d60: 696c 6573 2e2e 2e0d 0a20 2020 2020 2020  iles.....       
-00007d70: 2072 6573 756c 745f 7469 6c65 735f 6764   result_tiles_gd
-00007d80: 6620 3d20 4e6f 6e65 0d0a 2020 2020 2020  f = None..      
-00007d90: 2020 6966 2074 696c 6573 5f70 6174 6820    if tiles_path 
-00007da0: 6973 206e 6f74 204e 6f6e 653a 0d0a 2020  is not None:..  
-00007db0: 2020 2020 2020 2020 2020 7265 7375 6c74            result
-00007dc0: 5f74 696c 6573 5f67 6466 203d 2067 666f  _tiles_gdf = gfo
-00007dd0: 2e72 6561 645f 6669 6c65 2874 696c 6573  .read_file(tiles
-00007de0: 5f70 6174 6829 0d0a 2020 2020 2020 2020  _path)..        
-00007df0: 2020 2020 6966 206e 625f 7061 7261 6c6c      if nb_parall
-00007e00: 656c 203d 3d20 2d31 3a0d 0a20 2020 2020  el == -1:..     
-00007e10: 2020 2020 2020 2020 2020 206e 625f 6370             nb_cp
-00007e20: 7520 3d20 6d75 6c74 6970 726f 6365 7373  u = multiprocess
-00007e30: 696e 672e 6370 755f 636f 756e 7428 290d  ing.cpu_count().
-00007e40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007e50: 206e 625f 7061 7261 6c6c 656c 203d 206e   nb_parallel = n
-00007e60: 625f 6370 7520 2023 2069 6e74 2831 2e32  b_cpu  # int(1.2
-00007e70: 3520 2a20 6e62 5f63 7075 290d 0a20 2020  5 * nb_cpu)..   
-00007e80: 2020 2020 2020 2020 2020 2020 206c 6f67               log
-00007e90: 6765 722e 6465 6275 6728 6622 4e62 2063  ger.debug(f"Nb c
-00007ea0: 7075 7320 666f 756e 643a 207b 6e62 5f63  pus found: {nb_c
-00007eb0: 7075 7d2c 206e 625f 7061 7261 6c6c 656c  pu}, nb_parallel
-00007ec0: 3a20 7b6e 625f 7061 7261 6c6c 656c 7d22  : {nb_parallel}"
-00007ed0: 290d 0a20 2020 2020 2020 2065 6c73 653a  )..        else:
-00007ee0: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-00007ef0: 456c 7365 2c20 6372 6561 7465 2061 2067  Else, create a g
-00007f00: 7269 6420 6261 7365 6420 6f6e 2074 6865  rid based on the
-00007f10: 206e 756d 6265 7220 6f66 2074 696c 6573   number of tiles
-00007f20: 2077 616e 7465 6420 6173 2072 6573 756c   wanted as resul
-00007f30: 740d 0a20 2020 2020 2020 2020 2020 2072  t..            r
-00007f40: 6573 756c 745f 7469 6c65 735f 6764 6620  esult_tiles_gdf 
-00007f50: 3d20 6772 6964 5f75 7469 6c2e 6372 6561  = grid_util.crea
-00007f60: 7465 5f67 7269 6432 280d 0a20 2020 2020  te_grid2(..     
-00007f70: 2020 2020 2020 2020 2020 2069 6e70 7574             input
-00007f80: 5f6c 6179 6572 696e 666f 2e74 6f74 616c  _layerinfo.total
-00007f90: 5f62 6f75 6e64 732c 206e 625f 7371 7561  _bounds, nb_squa
-00007fa0: 7269 7368 5f74 696c 6573 2c20 696e 7075  rish_tiles, inpu
-00007fb0: 745f 6c61 7965 7269 6e66 6f2e 6372 730d  t_layerinfo.crs.
-00007fc0: 0a20 2020 2020 2020 2020 2020 2029 0d0a  .            )..
-00007fd0: 2020 2020 2020 2020 2020 2020 6966 206c              if l
-00007fe0: 656e 2872 6573 756c 745f 7469 6c65 735f  en(result_tiles_
-00007ff0: 6764 6629 203e 2031 3a0d 0a20 2020 2020  gdf) > 1:..     
-00008000: 2020 2020 2020 2020 2020 2067 666f 2e74             gfo.t
-00008010: 6f5f 6669 6c65 280d 0a20 2020 2020 2020  o_file(..       
-00008020: 2020 2020 2020 2020 2020 2020 2072 6573               res
-00008030: 756c 745f 7469 6c65 735f 6764 662c 0d0a  ult_tiles_gdf,..
-00008040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008050: 2020 2020 6f75 7470 7574 5f70 6174 682e      output_path.
-00008060: 7061 7265 6e74 202f 2066 227b 6f75 7470  parent / f"{outp
-00008070: 7574 5f70 6174 682e 7374 656d 7d5f 7469  ut_path.stem}_ti
-00008080: 6c65 732e 6770 6b67 222c 0d0a 2020 2020  les.gpkg",..    
-00008090: 2020 2020 2020 2020 2020 2020 290d 0a0d              )...
-000080a0: 0a20 2020 2020 2020 2023 2049 6620 6120  .        # If a 
-000080b0: 7469 6c65 6420 7265 7375 6c74 2069 7320  tiled result is 
-000080c0: 6173 6b65 642c 2061 6464 2074 696c 655f  asked, add tile_
-000080d0: 6964 2074 6f20 6772 6f75 7020 6f6e 2066  id to group on f
-000080e0: 6f72 2074 6865 2072 6573 756c 740d 0a20  or the result.. 
-000080f0: 2020 2020 2020 2069 6620 6c65 6e28 7265         if len(re
-00008100: 7375 6c74 5f74 696c 6573 5f67 6466 2920  sult_tiles_gdf) 
-00008110: 3e20 313a 0d0a 2020 2020 2020 2020 2020  > 1:..          
-00008120: 2020 7265 7375 6c74 5f74 696c 6573 5f67    result_tiles_g
-00008130: 6466 5b22 7469 6c65 5f69 6422 5d20 3d20  df["tile_id"] = 
-00008140: 7265 7375 6c74 5f74 696c 6573 5f67 6466  result_tiles_gdf
-00008150: 2e72 6573 6574 5f69 6e64 6578 2829 2e69  .reset_index().i
-00008160: 6e64 6578 0d0a 0d0a 2020 2020 2020 2020  ndex....        
-00008170: 2320 5468 6520 6469 7373 6f6c 7665 2066  # The dissolve f
-00008180: 6f72 2070 6f6c 7967 6f6e 7320 6973 2064  or polygons is d
-00008190: 6f6e 6520 696e 2073 6576 6572 616c 2070  one in several p
-000081a0: 6173 7365 732c 2061 6e64 2061 6674 6572  asses, and after
-000081b0: 2074 6865 2066 6972 7374 0d0a 2020 2020   the first..    
-000081c0: 2020 2020 2320 7061 7373 2c20 6f6e 6c79      # pass, only
-000081d0: 2074 6865 2027 6f6e 626f 7264 6572 2720   the 'onborder' 
-000081e0: 6665 6174 7572 6573 2061 7265 2066 7572  features are fur
-000081f0: 7468 6572 2064 6973 736f 6c76 6564 2c20  ther dissolved, 
-00008200: 6173 2074 6865 0d0a 2020 2020 2020 2020  as the..        
-00008210: 2320 276e 6f74 6f6e 626f 7264 6572 2720  # 'notonborder' 
-00008220: 6665 6174 7572 6573 2061 7265 2061 6c72  features are alr
-00008230: 6561 6479 204f 4b2e 0d0a 2020 2020 2020  eady OK...      
-00008240: 2020 7465 6d70 6469 7220 3d20 5f69 6f5f    tempdir = _io_
-00008250: 7574 696c 2e63 7265 6174 655f 7465 6d70  util.create_temp
-00008260: 6469 7228 6622 6765 6f66 696c 656f 7073  dir(f"geofileops
-00008270: 2f7b 6f70 6572 6174 696f 6e7d 2229 0d0a  /{operation}")..
-00008280: 2020 2020 2020 2020 7472 793a 0d0a 2020          try:..  
-00008290: 2020 2020 2020 2020 2020 6966 206f 7574            if out
-000082a0: 7075 745f 6c61 7965 7220 6973 204e 6f6e  put_layer is Non
-000082b0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-000082c0: 2020 2020 6f75 7470 7574 5f6c 6179 6572      output_layer
-000082d0: 203d 2067 666f 2e67 6574 5f64 6566 6175   = gfo.get_defau
-000082e0: 6c74 5f6c 6179 6572 286f 7574 7075 745f  lt_layer(output_
-000082f0: 7061 7468 290d 0a20 2020 2020 2020 2020  path)..         
-00008300: 2020 206f 7574 7075 745f 746d 705f 7061     output_tmp_pa
-00008310: 7468 203d 2074 656d 7064 6972 202f 2066  th = tempdir / f
-00008320: 227b 6f75 7470 7574 5f70 6174 682e 7374  "{output_path.st
-00008330: 656d 7d2e 6770 6b67 220d 0a20 2020 2020  em}.gpkg"..     
-00008340: 2020 2020 2020 2070 7265 765f 6e62 5f62         prev_nb_b
-00008350: 6174 6368 6573 203d 204e 6f6e 650d 0a20  atches = None.. 
-00008360: 2020 2020 2020 2020 2020 206c 6173 745f             last_
-00008370: 7061 7373 203d 2046 616c 7365 0d0a 2020  pass = False..  
-00008380: 2020 2020 2020 2020 2020 7061 7373 5f69            pass_i
-00008390: 6420 3d20 300d 0a20 2020 2020 2020 2020  d = 0..         
-000083a0: 2020 206c 6f67 6765 722e 696e 666f 2866     logger.info(f
-000083b0: 2253 7461 7274 2064 6973 736f 6c76 6520  "Start dissolve 
-000083c0: 6f6e 2066 696c 6520 7b69 6e70 7574 5f70  on file {input_p
-000083d0: 6174 687d 2229 0d0a 2020 2020 2020 2020  ath}")..        
-000083e0: 2020 2020 7768 696c 6520 5472 7565 3a0d      while True:.
-000083f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008400: 2023 2047 6574 2069 6e66 6f20 6f66 2074   # Get info of t
-00008410: 6865 2063 7572 7265 6e74 2066 696c 6520  he current file 
-00008420: 7468 6174 206e 6565 6473 2074 6f20 6265  that needs to be
-00008430: 2064 6973 736f 6c76 6564 0d0a 2020 2020   dissolved..    
-00008440: 2020 2020 2020 2020 2020 2020 7061 7373              pass
-00008450: 5f69 6e70 7574 5f6c 6179 6572 696e 666f  _input_layerinfo
-00008460: 203d 2067 666f 2e67 6574 5f6c 6179 6572   = gfo.get_layer
-00008470: 696e 666f 2869 6e70 7574 5f70 6174 682c  info(input_path,
-00008480: 2069 6e70 7574 5f6c 6179 6572 290d 0a20   input_layer).. 
-00008490: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-000084a0: 625f 726f 7773 5f74 6f74 616c 203d 2070  b_rows_total = p
-000084b0: 6173 735f 696e 7075 745f 6c61 7965 7269  ass_input_layeri
-000084c0: 6e66 6f2e 6665 6174 7572 6563 6f75 6e74  nfo.featurecount
-000084d0: 0d0a 0d0a 2020 2020 2020 2020 2020 2020  ....            
-000084e0: 2020 2020 2320 4361 6c63 756c 6174 6520      # Calculate 
-000084f0: 7468 6520 6265 7374 206e 756d 6265 7220  the best number 
-00008500: 6f66 2070 6172 616c 6c65 6c20 7072 6f63  of parallel proc
-00008510: 6573 7365 7320 616e 6420 6261 7463 6865  esses and batche
-00008520: 7320 666f 720d 0a20 2020 2020 2020 2020  s for..         
-00008530: 2020 2020 2020 2023 2074 6865 2061 7661         # the ava
-00008540: 696c 6162 6c65 2072 6573 6f75 7263 6573  ilable resources
-00008550: 2066 6f72 2074 6865 2063 7572 7265 6e74   for the current
-00008560: 2070 6173 730d 0a20 2020 2020 2020 2020   pass..         
-00008570: 2020 2020 2020 2069 6620 6261 7463 6873         if batchs
-00008580: 697a 6520 3e20 303a 0d0a 2020 2020 2020  ize > 0:..      
-00008590: 2020 2020 2020 2020 2020 2020 2020 7061                pa
-000085a0: 7261 6c6c 656c 697a 6174 696f 6e5f 636f  rallelization_co
-000085b0: 6e66 6967 203d 2050 6172 616c 6c65 6c69  nfig = Paralleli
-000085c0: 7a61 7469 6f6e 436f 6e66 6967 280d 0a20  zationConfig(.. 
+00005490: 2020 2020 2020 2020 2064 7374 3d74 6d70           dst=tmp
+000054a0: 5f6f 7574 7075 745f 7061 7468 2c0a 2020  _output_path,.  
+000054b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000054c0: 2020 2020 2020 2020 2020 2020 2020 6578                ex
+000054d0: 706c 6f64 6563 6f6c 6c65 6374 696f 6e73  plodecollections
+000054e0: 3d65 7870 6c6f 6465 636f 6c6c 6563 7469  =explodecollecti
+000054f0: 6f6e 732c 0a20 2020 2020 2020 2020 2020  ons,.           
+00005500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005510: 2020 2020 2063 7265 6174 655f 7370 6174       create_spat
+00005520: 6961 6c5f 696e 6465 783d 4661 6c73 652c  ial_index=False,
+00005530: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005550: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
+00005560: 6f6d 6574 7279 7479 7065 3d66 6f72 6365  ometrytype=force
+00005570: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
+00005580: 7479 7065 2c0a 2020 2020 2020 2020 2020  type,.          
+00005590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000055a0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+000055b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000055c0: 6766 6f2e 7265 6d6f 7665 2874 6d70 5f70  gfo.remove(tmp_p
+000055d0: 6172 7469 616c 5f6f 7574 7075 745f 7061  artial_output_pa
+000055e0: 7468 290a 0a20 2020 2020 2020 2020 2020  th)..           
+000055f0: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
+00005600: 7074 696f 6e3a 0a20 2020 2020 2020 2020  ption:.         
+00005610: 2020 2020 2020 2020 2020 2062 6174 6368             batch
+00005620: 5f69 6420 3d20 6675 7475 7265 5f74 6f5f  _id = future_to_
+00005630: 6261 7463 685f 6964 5b66 7574 7572 655d  batch_id[future]
+00005640: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005650: 2020 2020 2023 2063 616c 6375 6c61 7465       # calculate
+00005660: 5f70 6f6f 6c2e 7368 7574 646f 776e 2829  _pool.shutdown()
+00005670: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005680: 2020 2020 206c 6f67 6765 722e 6578 6365       logger.exce
+00005690: 7074 696f 6e28 6622 4572 726f 7220 6578  ption(f"Error ex
+000056a0: 6563 7574 696e 6720 7b62 6174 6368 6573  ecuting {batches
+000056b0: 5b62 6174 6368 5f69 645d 7d22 290a 0a20  [batch_id]}").. 
+000056c0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+000056d0: 204c 6f67 2074 6865 2070 726f 6772 6573   Log the progres
+000056e0: 7320 616e 6420 7072 6564 6963 7469 6f6e  s and prediction
+000056f0: 2073 7065 6564 0a20 2020 2020 2020 2020   speed.         
+00005700: 2020 2020 2020 206e 625f 646f 6e65 202b         nb_done +
+00005710: 3d20 310a 2020 2020 2020 2020 2020 2020  = 1.            
+00005720: 2020 2020 5f67 656e 6572 616c 5f75 7469      _general_uti
+00005730: 6c2e 7265 706f 7274 5f70 726f 6772 6573  l.report_progres
+00005740: 7328 0a20 2020 2020 2020 2020 2020 2020  s(.             
+00005750: 2020 2020 2020 2073 7461 7274 5f74 696d         start_tim
+00005760: 652c 206e 625f 646f 6e65 2c20 6e62 5f62  e, nb_done, nb_b
+00005770: 6174 6368 6573 2c20 6f70 6572 6174 696f  atches, operatio
+00005780: 6e2e 7661 6c75 652c 206e 625f 7061 7261  n.value, nb_para
+00005790: 6c6c 656c 0a20 2020 2020 2020 2020 2020  llel.           
+000057a0: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+000057b0: 2320 526f 756e 6420 7570 2061 6e64 2063  # Round up and c
+000057c0: 6c65 616e 2075 700a 2020 2020 2020 2020  lean up.        
+000057d0: 2320 4e6f 7720 6372 6561 7465 2073 7061  # Now create spa
+000057e0: 7469 616c 2069 6e64 6578 2061 6e64 206d  tial index and m
+000057f0: 6f76 6520 746f 206f 7574 7075 7420 6c6f  ove to output lo
+00005800: 6361 7469 6f6e 0a20 2020 2020 2020 2069  cation.        i
+00005810: 6620 746d 705f 6f75 7470 7574 5f70 6174  f tmp_output_pat
+00005820: 682e 6578 6973 7473 2829 3a0a 2020 2020  h.exists():.    
+00005830: 2020 2020 2020 2020 6766 6f2e 6372 6561          gfo.crea
+00005840: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
+00005850: 2870 6174 683d 746d 705f 6f75 7470 7574  (path=tmp_output
+00005860: 5f70 6174 682c 206c 6179 6572 3d6f 7574  _path, layer=out
+00005870: 7075 745f 6c61 7965 7229 0a20 2020 2020  put_layer).     
+00005880: 2020 2020 2020 2067 666f 2e6d 6f76 6528         gfo.move(
+00005890: 746d 705f 6f75 7470 7574 5f70 6174 682c  tmp_output_path,
+000058a0: 206f 7574 7075 745f 7061 7468 290a 2020   output_path).  
+000058b0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+000058c0: 2020 2020 2020 2020 6c6f 6767 6572 2e64          logger.d
+000058d0: 6562 7567 2866 2252 6573 756c 7420 6f66  ebug(f"Result of
+000058e0: 207b 6f70 6572 6174 696f 6e7d 2077 6173   {operation} was
+000058f0: 2065 6d70 7479 2122 290a 0a20 2020 2066   empty!")..    f
+00005900: 696e 616c 6c79 3a0a 2020 2020 2020 2020  inally:.        
+00005910: 2320 436c 6561 6e20 746d 7020 6469 720a  # Clean tmp dir.
+00005920: 2020 2020 2020 2020 7368 7574 696c 2e72          shutil.r
+00005930: 6d74 7265 6528 7465 6d70 6469 7229 0a20  mtree(tempdir). 
+00005940: 2020 2020 2020 206c 6f67 6765 722e 696e         logger.in
+00005950: 666f 2866 227b 6f70 6572 6174 696f 6e7d  fo(f"{operation}
+00005960: 2072 6561 6479 2c20 746f 6f6b 207b 6461   ready, took {da
+00005970: 7465 7469 6d65 2e6e 6f77 2829 2d73 7461  tetime.now()-sta
+00005980: 7274 5f74 696d 655f 676c 6f62 616c 7d21  rt_time_global}!
+00005990: 2229 0a0a 0a64 6566 205f 6170 706c 795f  ")...def _apply_
+000059a0: 6765 6f6f 7065 7261 7469 6f6e 280a 2020  geooperation(.  
+000059b0: 2020 696e 7075 745f 7061 7468 3a20 5061    input_path: Pa
+000059c0: 7468 2c0a 2020 2020 6f75 7470 7574 5f70  th,.    output_p
+000059d0: 6174 683a 2050 6174 682c 0a20 2020 206f  ath: Path,.    o
+000059e0: 7065 7261 7469 6f6e 3a20 4765 6f4f 7065  peration: GeoOpe
+000059f0: 7261 7469 6f6e 2c0a 2020 2020 6f70 6572  ration,.    oper
+00005a00: 6174 696f 6e5f 7061 7261 6d73 3a20 6469  ation_params: di
+00005a10: 6374 2c0a 2020 2020 696e 7075 745f 6c61  ct,.    input_la
+00005a20: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
+00005a30: 725d 203d 204e 6f6e 652c 0a20 2020 206f  r] = None,.    o
+00005a40: 7574 7075 745f 6c61 7965 723a 204f 7074  utput_layer: Opt
+00005a50: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
+00005a60: 652c 0a20 2020 2063 6f6c 756d 6e73 3a20  e,.    columns: 
+00005a70: 4f70 7469 6f6e 616c 5b4c 6973 745b 7374  Optional[List[st
+00005a80: 725d 5d20 3d20 4e6f 6e65 2c0a 2020 2020  r]] = None,.    
+00005a90: 726f 7773 3d4e 6f6e 652c 0a20 2020 2065  rows=None,.    e
+00005aa0: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
+00005ab0: 733a 2062 6f6f 6c20 3d20 4661 6c73 652c  s: bool = False,
+00005ac0: 0a20 2020 2066 6f72 6365 3a20 626f 6f6c  .    force: bool
+00005ad0: 203d 2046 616c 7365 2c0a 2920 2d3e 2073   = False,.) -> s
+00005ae0: 7472 3a0a 2020 2020 2320 496e 6974 0a20  tr:.    # Init. 
+00005af0: 2020 2069 6620 6f75 7470 7574 5f70 6174     if output_pat
+00005b00: 682e 6578 6973 7473 2829 3a0a 2020 2020  h.exists():.    
+00005b10: 2020 2020 6966 2066 6f72 6365 2069 7320      if force is 
+00005b20: 4661 6c73 653a 0a20 2020 2020 2020 2020  False:.         
+00005b30: 2020 206d 6573 7361 6765 203d 2066 2253     message = f"S
+00005b40: 746f 7020 7b6f 7065 7261 7469 6f6e 7d3a  top {operation}:
+00005b50: 206f 7574 7075 7420 6578 6973 7473 2061   output exists a
+00005b60: 6c72 6561 6479 207b 6f75 7470 7574 5f70  lready {output_p
+00005b70: 6174 687d 220a 2020 2020 2020 2020 2020  ath}".          
+00005b80: 2020 7265 7475 726e 206d 6573 7361 6765    return message
+00005b90: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00005ba0: 2020 2020 2020 2020 2020 2067 666f 2e72             gfo.r
+00005bb0: 656d 6f76 6528 6f75 7470 7574 5f70 6174  emove(output_pat
+00005bc0: 6829 0a0a 2020 2020 2320 4e6f 7720 676f  h)..    # Now go
+00005bd0: 210a 2020 2020 7374 6172 745f 7469 6d65  !.    start_time
+00005be0: 203d 2064 6174 6574 696d 652e 6e6f 7728   = datetime.now(
+00005bf0: 290a 2020 2020 6461 7461 5f67 6466 203d  ).    data_gdf =
+00005c00: 2067 666f 2e72 6561 645f 6669 6c65 280a   gfo.read_file(.
+00005c10: 2020 2020 2020 2020 7061 7468 3d69 6e70          path=inp
+00005c20: 7574 5f70 6174 682c 206c 6179 6572 3d69  ut_path, layer=i
+00005c30: 6e70 7574 5f6c 6179 6572 2c20 636f 6c75  nput_layer, colu
+00005c40: 6d6e 733d 636f 6c75 6d6e 732c 2072 6f77  mns=columns, row
+00005c50: 733d 726f 7773 0a20 2020 2029 0a0a 2020  s=rows.    )..  
+00005c60: 2020 2320 5275 6e20 6f70 6572 6174 696f    # Run operatio
+00005c70: 6e73 0a20 2020 2069 6620 6f70 6572 6174  ns.    if operat
+00005c80: 696f 6e20 6973 2047 656f 4f70 6572 6174  ion is GeoOperat
+00005c90: 696f 6e2e 4255 4646 4552 3a0a 2020 2020  ion.BUFFER:.    
+00005ca0: 2020 2020 6461 7461 5f67 6466 2e67 656f      data_gdf.geo
+00005cb0: 6d65 7472 7920 3d20 6461 7461 5f67 6466  metry = data_gdf
+00005cc0: 2e67 656f 6d65 7472 792e 6275 6666 6572  .geometry.buffer
+00005cd0: 280a 2020 2020 2020 2020 2020 2020 6469  (.            di
+00005ce0: 7374 616e 6365 3d6f 7065 7261 7469 6f6e  stance=operation
+00005cf0: 5f70 6172 616d 735b 2264 6973 7461 6e63  _params["distanc
+00005d00: 6522 5d2c 0a20 2020 2020 2020 2020 2020  e"],.           
+00005d10: 2072 6573 6f6c 7574 696f 6e3d 6f70 6572   resolution=oper
+00005d20: 6174 696f 6e5f 7061 7261 6d73 5b22 7175  ation_params["qu
+00005d30: 6164 7261 6e74 7365 676d 656e 7473 225d  adrantsegments"]
+00005d40: 2c0a 2020 2020 2020 2020 2020 2020 6361  ,.            ca
+00005d50: 705f 7374 796c 653d 6f70 6572 6174 696f  p_style=operatio
+00005d60: 6e5f 7061 7261 6d73 5b22 656e 6463 6170  n_params["endcap
+00005d70: 5f73 7479 6c65 225d 2e76 616c 7565 2c0a  _style"].value,.
+00005d80: 2020 2020 2020 2020 2020 2020 6a6f 696e              join
+00005d90: 5f73 7479 6c65 3d6f 7065 7261 7469 6f6e  _style=operation
+00005da0: 5f70 6172 616d 735b 226a 6f69 6e5f 7374  _params["join_st
+00005db0: 796c 6522 5d2e 7661 6c75 652c 0a20 2020  yle"].value,.   
+00005dc0: 2020 2020 2020 2020 206d 6974 7265 5f6c           mitre_l
+00005dd0: 696d 6974 3d6f 7065 7261 7469 6f6e 5f70  imit=operation_p
+00005de0: 6172 616d 735b 226d 6974 7265 5f6c 696d  arams["mitre_lim
+00005df0: 6974 225d 2c0a 2020 2020 2020 2020 2020  it"],.          
+00005e00: 2020 7369 6e67 6c65 5f73 6964 6564 3d6f    single_sided=o
+00005e10: 7065 7261 7469 6f6e 5f70 6172 616d 735b  peration_params[
+00005e20: 2273 696e 676c 655f 7369 6465 6422 5d2c  "single_sided"],
+00005e30: 0a20 2020 2020 2020 2029 0a20 2020 2065  .        ).    e
+00005e40: 6c69 6620 6f70 6572 6174 696f 6e20 6973  lif operation is
+00005e50: 2047 656f 4f70 6572 6174 696f 6e2e 434f   GeoOperation.CO
+00005e60: 4e56 4558 4855 4c4c 3a0a 2020 2020 2020  NVEXHULL:.      
+00005e70: 2020 6461 7461 5f67 6466 2e67 656f 6d65    data_gdf.geome
+00005e80: 7472 7920 3d20 6461 7461 5f67 6466 2e67  try = data_gdf.g
+00005e90: 656f 6d65 7472 792e 636f 6e76 6578 5f68  eometry.convex_h
+00005ea0: 756c 6c0a 2020 2020 656c 6966 206f 7065  ull.    elif ope
+00005eb0: 7261 7469 6f6e 2069 7320 4765 6f4f 7065  ration is GeoOpe
+00005ec0: 7261 7469 6f6e 2e53 494d 504c 4946 593a  ration.SIMPLIFY:
+00005ed0: 0a20 2020 2020 2020 2064 6174 615f 6764  .        data_gd
+00005ee0: 662e 6765 6f6d 6574 7279 203d 2067 656f  f.geometry = geo
+00005ef0: 7365 7269 6573 5f75 7469 6c2e 7369 6d70  series_util.simp
+00005f00: 6c69 6679 5f65 7874 280a 2020 2020 2020  lify_ext(.      
+00005f10: 2020 2020 2020 6461 7461 5f67 6466 2e67        data_gdf.g
+00005f20: 656f 6d65 7472 792c 0a20 2020 2020 2020  eometry,.       
+00005f30: 2020 2020 2061 6c67 6f72 6974 686d 3d6f       algorithm=o
+00005f40: 7065 7261 7469 6f6e 5f70 6172 616d 735b  peration_params[
+00005f50: 2261 6c67 6f72 6974 686d 225d 2c0a 2020  "algorithm"],.  
+00005f60: 2020 2020 2020 2020 2020 746f 6c65 7261            tolera
+00005f70: 6e63 653d 6f70 6572 6174 696f 6e5f 7061  nce=operation_pa
+00005f80: 7261 6d73 5b22 746f 6c65 7261 6e63 6522  rams["tolerance"
+00005f90: 5d2c 0a20 2020 2020 2020 2020 2020 206c  ],.            l
+00005fa0: 6f6f 6b61 6865 6164 3d6f 7065 7261 7469  ookahead=operati
+00005fb0: 6f6e 5f70 6172 616d 735b 2273 7465 7022  on_params["step"
+00005fc0: 5d2c 0a20 2020 2020 2020 2029 0a20 2020  ],.        ).   
+00005fd0: 2065 6c69 6620 6f70 6572 6174 696f 6e20   elif operation 
+00005fe0: 6973 2047 656f 4f70 6572 6174 696f 6e2e  is GeoOperation.
+00005ff0: 4150 504c 593a 0a20 2020 2020 2020 2066  APPLY:.        f
+00006000: 756e 6320 3d20 7069 636b 6c65 2e6c 6f61  unc = pickle.loa
+00006010: 6473 286f 7065 7261 7469 6f6e 5f70 6172  ds(operation_par
+00006020: 616d 735b 2270 6963 6b6c 6564 5f66 756e  ams["pickled_fun
+00006030: 6322 5d29 0a20 2020 2020 2020 2069 6620  c"]).        if 
+00006040: 6f70 6572 6174 696f 6e5f 7061 7261 6d73  operation_params
+00006050: 5b22 6f6e 6c79 5f67 656f 6d5f 696e 7075  ["only_geom_inpu
+00006060: 7422 5d20 6973 2054 7275 653a 0a20 2020  t"] is True:.   
+00006070: 2020 2020 2020 2020 2064 6174 615f 6764           data_gd
+00006080: 662e 6765 6f6d 6574 7279 203d 2064 6174  f.geometry = dat
+00006090: 615f 6764 662e 6765 6f6d 6574 7279 2e61  a_gdf.geometry.a
+000060a0: 7070 6c79 2866 756e 6329 0a20 2020 2020  pply(func).     
+000060b0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000060c0: 2020 2020 2064 6174 615f 6764 662e 6765       data_gdf.ge
+000060d0: 6f6d 6574 7279 203d 2064 6174 615f 6764  ometry = data_gd
+000060e0: 662e 6170 706c 7928 6675 6e63 2c20 6178  f.apply(func, ax
+000060f0: 6973 3d31 290a 2020 2020 656c 7365 3a0a  is=1).    else:.
+00006100: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+00006110: 6c75 6545 7272 6f72 2866 226f 7065 7261  lueError(f"opera
+00006120: 7469 6f6e 206e 6f74 2073 7570 706f 7274  tion not support
+00006130: 6564 3a20 7b6f 7065 7261 7469 6f6e 7d22  ed: {operation}"
+00006140: 290a 0a20 2020 2023 2052 656d 6f76 6520  )..    # Remove 
+00006150: 726f 7773 2077 6865 7265 2067 656f 6d20  rows where geom 
+00006160: 6973 2065 6d70 7479 0a20 2020 2064 6174  is empty.    dat
+00006170: 615f 6764 6620 3d20 6461 7461 5f67 6466  a_gdf = data_gdf
+00006180: 5b7e 6461 7461 5f67 6466 2e67 656f 6d65  [~data_gdf.geome
+00006190: 7472 792e 6973 5f65 6d70 7479 5d0a 2020  try.is_empty].  
+000061a0: 2020 6461 7461 5f67 6466 203d 2064 6174    data_gdf = dat
+000061b0: 615f 6764 665b 7e64 6174 615f 6764 662e  a_gdf[~data_gdf.
+000061c0: 6765 6f6d 6574 7279 2e69 736e 6128 295d  geometry.isna()]
+000061d0: 0a0a 2020 2020 2320 4966 2074 6865 7265  ..    # If there
+000061e0: 2069 7320 616e 2066 6964 2063 6f6c 756d   is an fid colum
+000061f0: 6e20 696e 2074 6865 2064 6174 6173 6574  n in the dataset
+00006200: 2c20 7265 6e61 6d65 2069 742c 2062 6563  , rename it, bec
+00006210: 6175 7365 2074 6865 2066 6964 2063 6f6c  ause the fid col
+00006220: 756d 6e20 6973 2061 0a20 2020 2023 2022  umn is a.    # "
+00006230: 7370 6563 6961 6c20 6361 7365 2220 696e  special case" in
+00006240: 2067 6461 6c20 7468 6174 2073 686f 756c   gdal that shoul
+00006250: 6420 6e6f 7420 6265 2077 7269 7474 656e  d not be written
+00006260: 2e0a 2020 2020 636f 6c75 6d6e 735f 6c6f  ..    columns_lo
+00006270: 7765 725f 6c6f 6f6b 7570 203d 207b 636f  wer_lookup = {co
+00006280: 6c75 6d6e 2e6c 6f77 6572 2829 3a20 636f  lumn.lower(): co
+00006290: 6c75 6d6e 2066 6f72 2063 6f6c 756d 6e20  lumn for column 
+000062a0: 696e 2064 6174 615f 6764 662e 636f 6c75  in data_gdf.colu
+000062b0: 6d6e 737d 0a20 2020 2069 6620 2266 6964  mns}.    if "fid
+000062c0: 2220 696e 2063 6f6c 756d 6e73 5f6c 6f77  " in columns_low
+000062d0: 6572 5f6c 6f6f 6b75 703a 0a20 2020 2020  er_lookup:.     
+000062e0: 2020 2066 6964 5f63 6f6c 756d 6e20 3d20     fid_column = 
+000062f0: 636f 6c75 6d6e 735f 6c6f 7765 725f 6c6f  columns_lower_lo
+00006300: 6f6b 7570 5b22 6669 6422 5d0a 2020 2020  okup["fid"].    
+00006310: 2020 2020 666f 7220 6669 645f 6e75 6d62      for fid_numb
+00006320: 6572 2069 6e20 7261 6e67 6528 312c 2031  er in range(1, 1
+00006330: 3030 293a 0a20 2020 2020 2020 2020 2020  00):.           
+00006340: 206e 6577 5f6e 616d 6520 3d20 6622 7b66   new_name = f"{f
+00006350: 6964 5f63 6f6c 756d 6e7d 5f7b 6669 645f  id_column}_{fid_
+00006360: 6e75 6d62 6572 7d22 0a20 2020 2020 2020  number}".       
+00006370: 2020 2020 2069 6620 6e65 775f 6e61 6d65       if new_name
+00006380: 206e 6f74 2069 6e20 636f 6c75 6d6e 735f   not in columns_
+00006390: 6c6f 7765 725f 6c6f 6f6b 7570 3a0a 2020  lower_lookup:.  
+000063a0: 2020 2020 2020 2020 2020 2020 2020 6461                da
+000063b0: 7461 5f67 6466 203d 2064 6174 615f 6764  ta_gdf = data_gd
+000063c0: 662e 7265 6e61 6d65 280a 2020 2020 2020  f.rename(.      
+000063d0: 2020 2020 2020 2020 2020 2020 2020 636f                co
+000063e0: 6c75 6d6e 733d 7b66 6964 5f63 6f6c 756d  lumns={fid_colum
+000063f0: 6e3a 206e 6577 5f6e 616d 657d 2c20 636f  n: new_name}, co
+00006400: 7079 3d46 616c 7365 2020 2320 7479 7065  py=False  # type
+00006410: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
+00006420: 2020 2020 2020 2020 2029 0a20 2020 2069           ).    i
+00006430: 6620 6578 706c 6f64 6563 6f6c 6c65 6374  f explodecollect
+00006440: 696f 6e73 3a0a 2020 2020 2020 2020 6461  ions:.        da
+00006450: 7461 5f67 6466 203d 2064 6174 615f 6764  ta_gdf = data_gd
+00006460: 662e 6578 706c 6f64 6528 6967 6e6f 7265  f.explode(ignore
+00006470: 5f69 6e64 6578 3d54 7275 6529 2020 2320  _index=True)  # 
+00006480: 7479 7065 3a20 6967 6e6f 7265 0a0a 2020  type: ignore..  
+00006490: 2020 2320 4966 2074 6865 2072 6573 756c    # If the resul
+000064a0: 7420 6973 2065 6d70 7479 2c20 616e 6420  t is empty, and 
+000064b0: 6e6f 206f 7574 7075 7420 6765 6f6d 6574  no output geomet
+000064c0: 7279 7479 7065 2073 7065 6369 6669 6564  rytype specified
+000064d0: 2c20 7573 6520 696e 7075 740a 2020 2020  , use input.    
+000064e0: 2320 6765 6f6d 6574 7279 7479 7065 0a20  # geometrytype. 
+000064f0: 2020 2066 6f72 6365 5f6f 7574 7075 745f     force_output_
+00006500: 6765 6f6d 6574 7279 7479 7065 203d 204e  geometrytype = N
+00006510: 6f6e 650a 2020 2020 6966 206c 656e 2864  one.    if len(d
+00006520: 6174 615f 6764 6629 203d 3d20 303a 0a20  ata_gdf) == 0:. 
+00006530: 2020 2020 2020 2069 6e70 7574 5f6c 6179         input_lay
+00006540: 6572 696e 666f 203d 2067 666f 2e67 6574  erinfo = gfo.get
+00006550: 5f6c 6179 6572 696e 666f 2869 6e70 7574  _layerinfo(input
+00006560: 5f70 6174 682c 2069 6e70 7574 5f6c 6179  _path, input_lay
+00006570: 6572 290a 2020 2020 2020 2020 666f 7263  er).        forc
+00006580: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+00006590: 7974 7970 6520 3d20 696e 7075 745f 6c61  ytype = input_la
+000065a0: 7965 7269 6e66 6f2e 6765 6f6d 6574 7279  yerinfo.geometry
+000065b0: 7479 7065 2e74 6f5f 6d75 6c74 6974 7970  type.to_multityp
+000065c0: 652e 6e61 6d65 0a0a 2020 2020 2320 6173  e.name..    # as
+000065d0: 7365 7274 2074 6f20 6576 6164 6520 7079  sert to evade py
+000065e0: 4c61 6e63 6520 7761 726e 696e 670a 2020  Lance warning.  
+000065f0: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+00006600: 6e63 6528 6461 7461 5f67 6466 2c20 6770  nce(data_gdf, gp
+00006610: 642e 4765 6f44 6174 6146 7261 6d65 290a  d.GeoDataFrame).
+00006620: 2020 2020 2320 5573 6520 666f 7263 655f      # Use force_
+00006630: 6d75 6c74 6974 7970 652c 2074 6f20 6576  multitype, to ev
+00006640: 6164 6520 7761 726e 696e 6773 2077 6865  ade warnings whe
+00006650: 6e20 736f 6d65 2062 6174 6368 6573 2063  n some batches c
+00006660: 6f6e 7461 696e 0a20 2020 2023 2073 696e  ontain.    # sin
+00006670: 676c 6574 7970 6520 616e 6420 736f 6d65  gletype and some
+00006680: 2063 6f6e 7461 696e 206d 756c 7469 7479   contain multity
+00006690: 7065 2067 656f 6d65 7472 6965 730a 2020  pe geometries.  
+000066a0: 2020 6766 6f2e 746f 5f66 696c 6528 0a20    gfo.to_file(. 
+000066b0: 2020 2020 2020 2067 6466 3d64 6174 615f         gdf=data_
+000066c0: 6764 662c 0a20 2020 2020 2020 2070 6174  gdf,.        pat
+000066d0: 683d 6f75 7470 7574 5f70 6174 682c 0a20  h=output_path,. 
+000066e0: 2020 2020 2020 206c 6179 6572 3d6f 7574         layer=out
+000066f0: 7075 745f 6c61 7965 722c 0a20 2020 2020  put_layer,.     
+00006700: 2020 2069 6e64 6578 3d46 616c 7365 2c0a     index=False,.
+00006710: 2020 2020 2020 2020 666f 7263 655f 6f75          force_ou
+00006720: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+00006730: 653d 666f 7263 655f 6f75 7470 7574 5f67  e=force_output_g
+00006740: 656f 6d65 7472 7974 7970 652c 0a20 2020  eometrytype,.   
+00006750: 2020 2020 2066 6f72 6365 5f6d 756c 7469       force_multi
+00006760: 7479 7065 3d54 7275 652c 0a20 2020 2020  type=True,.     
+00006770: 2020 2063 7265 6174 655f 7370 6174 6961     create_spatia
+00006780: 6c5f 696e 6465 783d 4661 6c73 652c 0a20  l_index=False,. 
+00006790: 2020 2029 0a0a 2020 2020 6d65 7373 6167     )..    messag
+000067a0: 6520 3d20 6622 546f 6f6b 207b 6461 7465  e = f"Took {date
+000067b0: 7469 6d65 2e6e 6f77 2829 2d73 7461 7274  time.now()-start
+000067c0: 5f74 696d 657d 2066 6f72 207b 6c65 6e28  _time} for {len(
+000067d0: 6461 7461 5f67 6466 297d 2072 6f77 7320  data_gdf)} rows 
+000067e0: 287b 726f 7773 7d29 2122 0a20 2020 2072  ({rows})!".    r
+000067f0: 6574 7572 6e20 6d65 7373 6167 650a 0a0a  eturn message...
+00006800: 6465 6620 6469 7373 6f6c 7665 280a 2020  def dissolve(.  
+00006810: 2020 696e 7075 745f 7061 7468 3a20 5061    input_path: Pa
+00006820: 7468 2c0a 2020 2020 6f75 7470 7574 5f70  th,.    output_p
+00006830: 6174 683a 2050 6174 682c 0a20 2020 2067  ath: Path,.    g
+00006840: 726f 7570 6279 5f63 6f6c 756d 6e73 3a20  roupby_columns: 
+00006850: 4f70 7469 6f6e 616c 5b49 7465 7261 626c  Optional[Iterabl
+00006860: 655b 7374 725d 5d20 3d20 4e6f 6e65 2c0a  e[str]] = None,.
+00006870: 2020 2020 6167 675f 636f 6c75 6d6e 733a      agg_columns:
+00006880: 204f 7074 696f 6e61 6c5b 6469 6374 5d20   Optional[dict] 
+00006890: 3d20 4e6f 6e65 2c0a 2020 2020 6578 706c  = None,.    expl
+000068a0: 6f64 6563 6f6c 6c65 6374 696f 6e73 3a20  odecollections: 
+000068b0: 626f 6f6c 203d 2054 7275 652c 0a20 2020  bool = True,.   
+000068c0: 2074 696c 6573 5f70 6174 683a 204f 7074   tiles_path: Opt
+000068d0: 696f 6e61 6c5b 5061 7468 5d20 3d20 4e6f  ional[Path] = No
+000068e0: 6e65 2c0a 2020 2020 6e62 5f73 7175 6172  ne,.    nb_squar
+000068f0: 6973 685f 7469 6c65 733a 2069 6e74 203d  ish_tiles: int =
+00006900: 2031 2c0a 2020 2020 696e 7075 745f 6c61   1,.    input_la
+00006910: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
+00006920: 725d 203d 204e 6f6e 652c 0a20 2020 206f  r] = None,.    o
+00006930: 7574 7075 745f 6c61 7965 723a 204f 7074  utput_layer: Opt
+00006940: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
+00006950: 652c 0a20 2020 206e 625f 7061 7261 6c6c  e,.    nb_parall
+00006960: 656c 3a20 696e 7420 3d20 2d31 2c0a 2020  el: int = -1,.  
+00006970: 2020 6261 7463 6873 697a 653a 2069 6e74    batchsize: int
+00006980: 203d 202d 312c 0a20 2020 2066 6f72 6365   = -1,.    force
+00006990: 3a20 626f 6f6c 203d 2046 616c 7365 2c0a  : bool = False,.
+000069a0: 2920 2d3e 2064 6963 743a 0a20 2020 2022  ) -> dict:.    "
+000069b0: 2222 0a20 2020 2046 756e 6374 696f 6e20  "".    Function 
+000069c0: 7468 6174 2061 7070 6c69 6573 2061 2064  that applies a d
+000069d0: 6973 736f 6c76 652e 0a0a 2020 2020 4d6f  issolve...    Mo
+000069e0: 7265 2064 6574 6169 6c65 6420 646f 6375  re detailed docu
+000069f0: 6d65 6e74 6174 696f 6e20 696e 206d 6f64  mentation in mod
+00006a00: 756c 6520 6765 6f6f 7073 210a 2020 2020  ule geoops!.    
+00006a10: 2222 220a 0a20 2020 2023 2049 6e69 7420  """..    # Init 
+00006a20: 616e 6420 7661 6c69 6461 7465 2069 6e70  and validate inp
+00006a30: 7574 2070 6172 616d 6574 6572 730a 2020  ut parameters.  
+00006a40: 2020 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d    # ------------
+00006a50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006a60: 2d2d 2d2d 2d2d 0a20 2020 2073 7461 7274  ------.    start
+00006a70: 5f74 696d 6520 3d20 6461 7465 7469 6d65  _time = datetime
+00006a80: 2e6e 6f77 2829 0a20 2020 206f 7065 7261  .now().    opera
+00006a90: 7469 6f6e 203d 2022 6469 7373 6f6c 7665  tion = "dissolve
+00006aa0: 220a 2020 2020 7265 7375 6c74 5f69 6e66  ".    result_inf
+00006ab0: 6f20 3d20 7b7d 0a0a 2020 2020 2320 4368  o = {}..    # Ch
+00006ac0: 6563 6b20 696e 7075 7420 7061 7261 6d65  eck input parame
+00006ad0: 7465 7273 0a20 2020 2069 6620 6772 6f75  ters.    if grou
+00006ae0: 7062 795f 636f 6c75 6d6e 7320 6973 206e  pby_columns is n
+00006af0: 6f74 204e 6f6e 6520 616e 6420 6c65 6e28  ot None and len(
+00006b00: 6c69 7374 2867 726f 7570 6279 5f63 6f6c  list(groupby_col
+00006b10: 756d 6e73 2929 203d 3d20 303a 0a20 2020  umns)) == 0:.   
+00006b20: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00006b30: 4572 726f 7228 2267 726f 7570 6279 5f63  Error("groupby_c
+00006b40: 6f6c 756d 6e73 3d5b 5d20 6973 206e 6f74  olumns=[] is not
+00006b50: 2073 7570 706f 7274 6564 2e20 5573 6520   supported. Use 
+00006b60: 4e6f 6e65 2e22 290a 2020 2020 6966 206e  None.").    if n
+00006b70: 6f74 2069 6e70 7574 5f70 6174 682e 6578  ot input_path.ex
+00006b80: 6973 7473 2829 3a0a 2020 2020 2020 2020  ists():.        
+00006b90: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+00006ba0: 2866 2269 6e70 7574 5f70 6174 6820 646f  (f"input_path do
+00006bb0: 6573 6e27 7420 6578 6973 743a 207b 696e  esn't exist: {in
+00006bc0: 7075 745f 7061 7468 7d22 290a 2020 2020  put_path}").    
+00006bd0: 6966 2069 6e70 7574 5f70 6174 6820 3d3d  if input_path ==
+00006be0: 206f 7574 7075 745f 7061 7468 3a0a 2020   output_path:.  
+00006bf0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00006c00: 6545 7272 6f72 2822 6f75 7470 7574 5f70  eError("output_p
+00006c10: 6174 6820 6d75 7374 206e 6f74 2065 7175  ath must not equ
+00006c20: 616c 2069 6e70 7574 5f70 6174 6822 290a  al input_path").
+00006c30: 0a20 2020 2069 6e70 7574 5f6c 6179 6572  .    input_layer
+00006c40: 696e 666f 203d 2067 666f 2e67 6574 5f6c  info = gfo.get_l
+00006c50: 6179 6572 696e 666f 2869 6e70 7574 5f70  ayerinfo(input_p
+00006c60: 6174 682c 2069 6e70 7574 5f6c 6179 6572  ath, input_layer
+00006c70: 290a 2020 2020 6966 2069 6e70 7574 5f6c  ).    if input_l
+00006c80: 6179 6572 696e 666f 2e67 656f 6d65 7472  ayerinfo.geometr
+00006c90: 7974 7970 652e 746f 5f70 7269 6d69 7469  ytype.to_primiti
+00006ca0: 7665 7479 7065 2069 6e20 5b0a 2020 2020  vetype in [.    
+00006cb0: 2020 2020 5072 696d 6974 6976 6554 7970      PrimitiveTyp
+00006cc0: 652e 504f 494e 542c 0a20 2020 2020 2020  e.POINT,.       
+00006cd0: 2050 7269 6d69 7469 7665 5479 7065 2e4c   PrimitiveType.L
+00006ce0: 494e 4553 5452 494e 472c 0a20 2020 205d  INESTRING,.    ]
+00006cf0: 3a0a 2020 2020 2020 2020 6966 2074 696c  :.        if til
+00006d00: 6573 5f70 6174 6820 6973 206e 6f74 204e  es_path is not N
+00006d10: 6f6e 6520 6f72 206e 625f 7371 7561 7269  one or nb_squari
+00006d20: 7368 5f74 696c 6573 203e 2031 3a0a 2020  sh_tiles > 1:.  
+00006d30: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00006d40: 5661 6c75 6545 7272 6f72 280a 2020 2020  ValueError(.    
+00006d50: 2020 2020 2020 2020 2020 2020 6622 4469              f"Di
+00006d60: 7373 6f6c 7665 2074 6f20 7469 6c65 7320  ssolve to tiles 
+00006d70: 6973 206e 6f74 2073 7570 706f 7274 6564  is not supported
+00006d80: 2066 6f72 207b 696e 7075 745f 6c61 7965   for {input_laye
+00006d90: 7269 6e66 6f2e 6765 6f6d 6574 7279 7479  rinfo.geometryty
+00006da0: 7065 7d22 0a20 2020 2020 2020 2020 2020  pe}".           
+00006db0: 2020 2020 2022 2c20 736f 2074 696c 6573       ", so tiles
+00006dc0: 5f70 6174 6820 7368 6f75 6c64 2062 6520  _path should be 
+00006dd0: 4e6f 6e65 2061 6e64 206e 625f 7371 7561  None and nb_squa
+00006de0: 7269 7368 5f74 696c 6573 2073 686f 756c  rish_tiles shoul
+00006df0: 6420 6265 2031 2922 0a20 2020 2020 2020  d be 1)".       
+00006e00: 2020 2020 2029 0a0a 2020 2020 2320 4368       )..    # Ch
+00006e10: 6563 6b20 636f 6c75 6d6e 7320 696e 2067  eck columns in g
+00006e20: 726f 7570 6279 5f63 6f6c 756d 6e73 0a20  roupby_columns. 
+00006e30: 2020 2069 6620 6772 6f75 7062 795f 636f     if groupby_co
+00006e40: 6c75 6d6e 7320 6973 206e 6f74 204e 6f6e  lumns is not Non
+00006e50: 653a 0a20 2020 2020 2020 2063 6f6c 756d  e:.        colum
+00006e60: 6e73 5f69 6e5f 6c61 7965 725f 7570 7065  ns_in_layer_uppe
+00006e70: 7220 3d20 5b0a 2020 2020 2020 2020 2020  r = [.          
+00006e80: 2020 636f 6c75 6d6e 2e75 7070 6572 2829    column.upper()
+00006e90: 2066 6f72 2063 6f6c 756d 6e20 696e 206c   for column in l
+00006ea0: 6973 7428 696e 7075 745f 6c61 7965 7269  ist(input_layeri
+00006eb0: 6e66 6f2e 636f 6c75 6d6e 7329 202b 205b  nfo.columns) + [
+00006ec0: 2266 6964 225d 0a20 2020 2020 2020 205d  "fid"].        ]
+00006ed0: 0a20 2020 2020 2020 2066 6f72 2063 6f6c  .        for col
+00006ee0: 756d 6e20 696e 2067 726f 7570 6279 5f63  umn in groupby_c
+00006ef0: 6f6c 756d 6e73 3a0a 2020 2020 2020 2020  olumns:.        
+00006f00: 2020 2020 6966 2063 6f6c 756d 6e2e 7570      if column.up
+00006f10: 7065 7228 2920 6e6f 7420 696e 2063 6f6c  per() not in col
+00006f20: 756d 6e73 5f69 6e5f 6c61 7965 725f 7570  umns_in_layer_up
+00006f30: 7065 723a 0a20 2020 2020 2020 2020 2020  per:.           
+00006f40: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00006f50: 4572 726f 7228 0a20 2020 2020 2020 2020  Error(.         
+00006f60: 2020 2020 2020 2020 2020 2066 2263 6f6c             f"col
+00006f70: 756d 6e20 696e 2067 726f 7570 6279 5f63  umn in groupby_c
+00006f80: 6f6c 756d 6e73 206e 6f74 2061 7661 696c  olumns not avail
+00006f90: 6162 6c65 2069 6e20 6c61 7965 723a 207b  able in layer: {
+00006fa0: 636f 6c75 6d6e 7d22 0a20 2020 2020 2020  column}".       
+00006fb0: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+00006fc0: 2320 4368 6563 6b20 6167 675f 636f 6c75  # Check agg_colu
+00006fd0: 6d6e 7320 7061 7261 6d0a 2020 2020 6966  mns param.    if
+00006fe0: 2061 6767 5f63 6f6c 756d 6e73 2069 7320   agg_columns is 
+00006ff0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+00007000: 2020 2320 5661 6c69 6461 7465 2074 6865    # Validate the
+00007010: 2064 6963 7420 7374 7275 6374 7572 652c   dict structure,
+00007020: 2073 6f20 7765 2063 616e 2061 7373 756d   so we can assum
+00007030: 6520 6576 6572 7974 6869 6e67 2069 7320  e everything is 
+00007040: 4f4b 2066 7572 7468 6572 206f 6e0a 2020  OK further on.  
+00007050: 2020 2020 2020 5f70 6172 616d 6574 6572        _parameter
+00007060: 5f68 656c 7065 722e 7661 6c69 6461 7465  _helper.validate
+00007070: 5f61 6767 5f63 6f6c 756d 6e73 2861 6767  _agg_columns(agg
+00007080: 5f63 6f6c 756d 6e73 290a 0a20 2020 2020  _columns)..     
+00007090: 2020 2023 2046 6972 7374 2074 616b 6520     # First take 
+000070a0: 6120 6465 6570 2063 6f70 792c 2061 7320  a deep copy, as 
+000070b0: 7661 6c75 6573 2063 616e 2062 6520 6368  values can be ch
+000070c0: 616e 6765 6420 6675 7274 6865 7220 6f6e  anged further on
+000070d0: 2074 6f20 7472 6561 7420 636f 6c75 6d6e   to treat column
+000070e0: 730a 2020 2020 2020 2020 2320 6361 7365  s.        # case
+000070f0: 2069 6e73 656e 7369 7469 7665 0a20 2020   insensitive.   
+00007100: 2020 2020 2061 6767 5f63 6f6c 756d 6e73       agg_columns
+00007110: 203d 206a 736f 6e2e 6c6f 6164 7328 6a73   = json.loads(js
+00007120: 6f6e 2e64 756d 7073 2861 6767 5f63 6f6c  on.dumps(agg_col
+00007130: 756d 6e73 2929 0a20 2020 2020 2020 2061  umns)).        a
+00007140: 7373 6572 7420 6167 675f 636f 6c75 6d6e  ssert agg_column
+00007150: 7320 6973 206e 6f74 204e 6f6e 650a 2020  s is not None.  
+00007160: 2020 2020 2020 6966 2022 6a73 6f6e 2220        if "json" 
+00007170: 696e 2061 6767 5f63 6f6c 756d 6e73 3a0a  in agg_columns:.
+00007180: 2020 2020 2020 2020 2020 2020 6966 2061              if a
+00007190: 6767 5f63 6f6c 756d 6e73 5b22 6a73 6f6e  gg_columns["json
+000071a0: 225d 2069 7320 4e6f 6e65 3a0a 2020 2020  "] is None:.    
+000071b0: 2020 2020 2020 2020 2020 2020 6167 675f              agg_
+000071c0: 636f 6c75 6d6e 735b 226a 736f 6e22 5d20  columns["json"] 
+000071d0: 3d20 5b0a 2020 2020 2020 2020 2020 2020  = [.            
+000071e0: 2020 2020 2020 2020 636f 6c20 666f 7220          col for 
+000071f0: 636f 6c20 696e 2069 6e70 7574 5f6c 6179  col in input_lay
+00007200: 6572 696e 666f 2e63 6f6c 756d 6e73 2069  erinfo.columns i
+00007210: 6620 636f 6c2e 7570 7065 7228 2920 213d  f col.upper() !=
+00007220: 2022 494e 4445 5822 0a20 2020 2020 2020   "INDEX".       
+00007230: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
+00007240: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00007250: 2020 2020 2020 2020 2020 2020 2023 2041               # A
+00007260: 6c69 676e 2063 6173 696e 6720 6f66 2063  lign casing of c
+00007270: 6f6c 756d 6e20 6e61 6d65 7320 746f 2064  olumn names to d
+00007280: 6174 610a 2020 2020 2020 2020 2020 2020  ata.            
+00007290: 2020 2020 6167 675f 636f 6c75 6d6e 735b      agg_columns[
+000072a0: 226a 736f 6e22 5d20 3d20 5f67 656e 6572  "json"] = _gener
+000072b0: 616c 5f75 7469 6c2e 616c 6967 6e5f 6361  al_util.align_ca
+000072c0: 7369 6e67 5f6c 6973 7428 0a20 2020 2020  sing_list(.     
+000072d0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+000072e0: 6767 5f63 6f6c 756d 6e73 5b22 6a73 6f6e  gg_columns["json
+000072f0: 225d 2c20 6c69 7374 2869 6e70 7574 5f6c  "], list(input_l
+00007300: 6179 6572 696e 666f 2e63 6f6c 756d 6e73  ayerinfo.columns
+00007310: 2920 2b20 5b22 6669 6422 5d0a 2020 2020  ) + ["fid"].    
+00007320: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00007330: 2020 2020 2020 656c 6966 2022 636f 6c75        elif "colu
+00007340: 6d6e 7322 2069 6e20 6167 675f 636f 6c75  mns" in agg_colu
+00007350: 6d6e 733a 0a20 2020 2020 2020 2020 2020  mns:.           
+00007360: 2023 204c 6f6f 7020 7468 726f 7567 6820   # Loop through 
+00007370: 616c 6c20 726f 7773 0a20 2020 2020 2020  all rows.       
+00007380: 2020 2020 2066 6f72 2061 6767 5f63 6f6c       for agg_col
+00007390: 756d 6e20 696e 2061 6767 5f63 6f6c 756d  umn in agg_colum
+000073a0: 6e73 5b22 636f 6c75 6d6e 7322 5d3a 0a20  ns["columns"]:. 
+000073b0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+000073c0: 2043 6865 636b 2069 6620 636f 6c75 6d6e   Check if column
+000073d0: 2065 7869 7374 7320 2b20 7365 7420 6361   exists + set ca
+000073e0: 7369 6e67 2073 616d 6520 6173 2069 6e20  sing same as in 
+000073f0: 6461 7461 0a20 2020 2020 2020 2020 2020  data.           
+00007400: 2020 2020 2061 6767 5f63 6f6c 756d 6e5b       agg_column[
+00007410: 2263 6f6c 756d 6e22 5d20 3d20 5f67 656e  "column"] = _gen
+00007420: 6572 616c 5f75 7469 6c2e 616c 6967 6e5f  eral_util.align_
+00007430: 6361 7369 6e67 280a 2020 2020 2020 2020  casing(.        
+00007440: 2020 2020 2020 2020 2020 2020 6167 675f              agg_
+00007450: 636f 6c75 6d6e 5b22 636f 6c75 6d6e 225d  column["column"]
+00007460: 2c20 6c69 7374 2869 6e70 7574 5f6c 6179  , list(input_lay
+00007470: 6572 696e 666f 2e63 6f6c 756d 6e73 2920  erinfo.columns) 
+00007480: 2b20 5b22 6669 6422 5d0a 2020 2020 2020  + ["fid"].      
+00007490: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+000074a0: 2023 204e 6f77 2069 6e70 7574 2070 6172   # Now input par
+000074b0: 616d 6574 6572 7320 6172 6520 6368 6563  ameters are chec
+000074c0: 6b65 642c 2063 6865 636b 2069 6620 7765  ked, check if we
+000074d0: 206e 6565 6420 746f 2063 616c 6361 6c61   need to calcala
+000074e0: 7465 2061 6e79 7761 790a 2020 2020 6966  te anyway.    if
+000074f0: 206f 7574 7075 745f 7061 7468 2e65 7869   output_path.exi
+00007500: 7374 7328 293a 0a20 2020 2020 2020 2069  sts():.        i
+00007510: 6620 666f 7263 6520 6973 2046 616c 7365  f force is False
+00007520: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00007530: 7375 6c74 5f69 6e66 6f5b 0a20 2020 2020  sult_info[.     
+00007540: 2020 2020 2020 2020 2020 2022 6d65 7373             "mess
+00007550: 6167 6522 0a20 2020 2020 2020 2020 2020  age".           
+00007560: 205d 203d 2066 226f 7574 7075 7420 6578   ] = f"output ex
+00007570: 6973 7473 2061 6c72 6561 6479 207b 6f75  ists already {ou
+00007580: 7470 7574 5f70 6174 687d 2061 6e64 2066  tput_path} and f
+00007590: 6f72 6365 2069 7320 6661 6c73 6522 0a20  orce is false". 
+000075a0: 2020 2020 2020 2020 2020 206c 6f67 6765             logge
+000075b0: 722e 696e 666f 2872 6573 756c 745f 696e  r.info(result_in
+000075c0: 666f 5b22 6d65 7373 6167 6522 5d29 0a20  fo["message"]). 
+000075d0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000075e0: 6e20 7265 7375 6c74 5f69 6e66 6f0a 2020  n result_info.  
+000075f0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00007600: 2020 2020 2020 2020 6766 6f2e 7265 6d6f          gfo.remo
+00007610: 7665 286f 7574 7075 745f 7061 7468 290a  ve(output_path).
+00007620: 0a20 2020 2023 204e 6f77 2073 7461 7274  .    # Now start
+00007630: 2064 6973 736f 6c76 696e 670a 2020 2020   dissolving.    
+00007640: 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  # --------------
+00007650: 2d2d 2d2d 2d2d 0a20 2020 2023 2045 6d70  ------.    # Emp
+00007660: 7479 206f 7220 4c69 6e65 2061 6e64 2070  ty or Line and p
+00007670: 6f69 6e74 206c 6179 6572 7320 6172 653a  oint layers are:
+00007680: 0a20 2020 2023 2020 202a 206e 6f74 2073  .    #   * not s
+00007690: 6f20 6c61 7267 6520 286d 656d 6f72 792d  o large (memory-
+000076a0: 7769 7365 290a 2020 2020 2320 2020 2a20  wise).    #   * 
+000076b0: 6172 656e 2774 2063 6f6d 7075 7461 7469  aren't computati
+000076c0: 6f6e 616c 6c79 2068 6561 7679 0a20 2020  onally heavy.   
+000076d0: 2023 2041 6464 6974 696f 6e61 6c6c 7920   # Additionally 
+000076e0: 6c69 6e65 206c 6179 6572 7320 6172 6520  line layers are 
+000076f0: 6120 7061 696e 2074 6f20 6861 6e64 6c65  a pain to handle
+00007700: 2063 6f72 7265 6374 6c79 2062 6563 6175   correctly becau
+00007710: 7365 206f 660a 2020 2020 2320 726f 756e  se of.    # roun
+00007720: 6469 6e67 2069 7373 7565 7320 6174 2074  ding issues at t
+00007730: 6865 2062 6f72 6465 7273 206f 6620 7469  he borders of ti
+00007740: 6c65 732e 2e2e 2073 6f20 6a75 7374 2064  les... so just d
+00007750: 6973 736f 6c76 6520 7468 656d 2069 6e20  issolve them in 
+00007760: 6f6e 6520 676f 2e0a 2020 2020 6966 2028  one go..    if (
+00007770: 0a20 2020 2020 2020 2069 6e70 7574 5f6c  .        input_l
+00007780: 6179 6572 696e 666f 2e66 6561 7475 7265  ayerinfo.feature
+00007790: 636f 756e 7420 3d3d 2030 0a20 2020 2020  count == 0.     
+000077a0: 2020 206f 7220 696e 7075 745f 6c61 7965     or input_laye
+000077b0: 7269 6e66 6f2e 6765 6f6d 6574 7279 7479  rinfo.geometryty
+000077c0: 7065 2e74 6f5f 7072 696d 6974 6976 6574  pe.to_primitivet
+000077d0: 7970 650a 2020 2020 2020 2020 696e 205b  ype.        in [
+000077e0: 0a20 2020 2020 2020 2020 2020 2050 7269  .            Pri
+000077f0: 6d69 7469 7665 5479 7065 2e50 4f49 4e54  mitiveType.POINT
+00007800: 2c0a 2020 2020 2020 2020 2020 2020 5072  ,.            Pr
+00007810: 696d 6974 6976 6554 7970 652e 4c49 4e45  imitiveType.LINE
+00007820: 5354 5249 4e47 2c0a 2020 2020 2020 2020  STRING,.        
+00007830: 5d0a 2020 2020 293a 0a20 2020 2020 2020  ].    ):.       
+00007840: 205f 6765 6f6f 7073 5f73 716c 2e64 6973   _geoops_sql.dis
+00007850: 736f 6c76 655f 7369 6e67 6c65 7468 7265  solve_singlethre
+00007860: 6164 280a 2020 2020 2020 2020 2020 2020  ad(.            
+00007870: 696e 7075 745f 7061 7468 3d69 6e70 7574  input_path=input
+00007880: 5f70 6174 682c 0a20 2020 2020 2020 2020  _path,.         
+00007890: 2020 206f 7574 7075 745f 7061 7468 3d6f     output_path=o
+000078a0: 7574 7075 745f 7061 7468 2c0a 2020 2020  utput_path,.    
+000078b0: 2020 2020 2020 2020 6578 706c 6f64 6563          explodec
+000078c0: 6f6c 6c65 6374 696f 6e73 3d65 7870 6c6f  ollections=explo
+000078d0: 6465 636f 6c6c 6563 7469 6f6e 732c 0a20  decollections,. 
+000078e0: 2020 2020 2020 2020 2020 2067 726f 7570             group
+000078f0: 6279 5f63 6f6c 756d 6e73 3d67 726f 7570  by_columns=group
+00007900: 6279 5f63 6f6c 756d 6e73 2c0a 2020 2020  by_columns,.    
+00007910: 2020 2020 2020 2020 6167 675f 636f 6c75          agg_colu
+00007920: 6d6e 733d 6167 675f 636f 6c75 6d6e 732c  mns=agg_columns,
+00007930: 0a20 2020 2020 2020 2020 2020 2069 6e70  .            inp
+00007940: 7574 5f6c 6179 6572 3d69 6e70 7574 5f6c  ut_layer=input_l
+00007950: 6179 6572 2c0a 2020 2020 2020 2020 2020  ayer,.          
+00007960: 2020 6f75 7470 7574 5f6c 6179 6572 3d6f    output_layer=o
+00007970: 7574 7075 745f 6c61 7965 722c 0a20 2020  utput_layer,.   
+00007980: 2020 2020 2020 2020 2066 6f72 6365 3d66           force=f
+00007990: 6f72 6365 2c0a 2020 2020 2020 2020 290a  orce,.        ).
+000079a0: 0a20 2020 2065 6c69 6620 696e 7075 745f  .    elif input_
+000079b0: 6c61 7965 7269 6e66 6f2e 6765 6f6d 6574  layerinfo.geomet
+000079c0: 7279 7479 7065 2e74 6f5f 7072 696d 6974  rytype.to_primit
+000079d0: 6976 6574 7970 6520 6973 2050 7269 6d69  ivetype is Primi
+000079e0: 7469 7665 5479 7065 2e50 4f4c 5947 4f4e  tiveType.POLYGON
+000079f0: 3a0a 2020 2020 2020 2020 2320 4966 2061  :.        # If a
+00007a00: 2074 696c 6573 5f70 6174 6820 6973 2073   tiles_path is s
+00007a10: 7065 6369 6669 6564 2c20 7265 6164 2074  pecified, read t
+00007a20: 686f 7365 2074 696c 6573 2e2e 2e0a 2020  hose tiles....  
+00007a30: 2020 2020 2020 7265 7375 6c74 5f74 696c        result_til
+00007a40: 6573 5f67 6466 203d 204e 6f6e 650a 2020  es_gdf = None.  
+00007a50: 2020 2020 2020 6966 2074 696c 6573 5f70        if tiles_p
+00007a60: 6174 6820 6973 206e 6f74 204e 6f6e 653a  ath is not None:
+00007a70: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
+00007a80: 756c 745f 7469 6c65 735f 6764 6620 3d20  ult_tiles_gdf = 
+00007a90: 6766 6f2e 7265 6164 5f66 696c 6528 7469  gfo.read_file(ti
+00007aa0: 6c65 735f 7061 7468 290a 2020 2020 2020  les_path).      
+00007ab0: 2020 2020 2020 6966 206e 625f 7061 7261        if nb_para
+00007ac0: 6c6c 656c 203d 3d20 2d31 3a0a 2020 2020  llel == -1:.    
+00007ad0: 2020 2020 2020 2020 2020 2020 6e62 5f63              nb_c
+00007ae0: 7075 203d 206d 756c 7469 7072 6f63 6573  pu = multiproces
+00007af0: 7369 6e67 2e63 7075 5f63 6f75 6e74 2829  sing.cpu_count()
+00007b00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007b10: 206e 625f 7061 7261 6c6c 656c 203d 206e   nb_parallel = n
+00007b20: 625f 6370 7520 2023 2069 6e74 2831 2e32  b_cpu  # int(1.2
+00007b30: 3520 2a20 6e62 5f63 7075 290a 2020 2020  5 * nb_cpu).    
+00007b40: 2020 2020 2020 2020 2020 2020 6c6f 6767              logg
+00007b50: 6572 2e64 6562 7567 2866 224e 6220 6370  er.debug(f"Nb cp
+00007b60: 7573 2066 6f75 6e64 3a20 7b6e 625f 6370  us found: {nb_cp
+00007b70: 757d 2c20 6e62 5f70 6172 616c 6c65 6c3a  u}, nb_parallel:
+00007b80: 207b 6e62 5f70 6172 616c 6c65 6c7d 2229   {nb_parallel}")
+00007b90: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00007ba0: 2020 2020 2020 2020 2020 2023 2045 6c73             # Els
+00007bb0: 652c 2063 7265 6174 6520 6120 6772 6964  e, create a grid
+00007bc0: 2062 6173 6564 206f 6e20 7468 6520 6e75   based on the nu
+00007bd0: 6d62 6572 206f 6620 7469 6c65 7320 7761  mber of tiles wa
+00007be0: 6e74 6564 2061 7320 7265 7375 6c74 0a20  nted as result. 
+00007bf0: 2020 2020 2020 2020 2020 2072 6573 756c             resul
+00007c00: 745f 7469 6c65 735f 6764 6620 3d20 6772  t_tiles_gdf = gr
+00007c10: 6964 5f75 7469 6c2e 6372 6561 7465 5f67  id_util.create_g
+00007c20: 7269 6432 280a 2020 2020 2020 2020 2020  rid2(.          
+00007c30: 2020 2020 2020 696e 7075 745f 6c61 7965        input_laye
+00007c40: 7269 6e66 6f2e 746f 7461 6c5f 626f 756e  rinfo.total_boun
+00007c50: 6473 2c20 6e62 5f73 7175 6172 6973 685f  ds, nb_squarish_
+00007c60: 7469 6c65 732c 2069 6e70 7574 5f6c 6179  tiles, input_lay
+00007c70: 6572 696e 666f 2e63 7273 0a20 2020 2020  erinfo.crs.     
+00007c80: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00007c90: 2020 2020 2069 6620 6c65 6e28 7265 7375       if len(resu
+00007ca0: 6c74 5f74 696c 6573 5f67 6466 2920 3e20  lt_tiles_gdf) > 
+00007cb0: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
+00007cc0: 2020 2067 666f 2e74 6f5f 6669 6c65 280a     gfo.to_file(.
+00007cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007ce0: 2020 2020 7265 7375 6c74 5f74 696c 6573      result_tiles
+00007cf0: 5f67 6466 2c0a 2020 2020 2020 2020 2020  _gdf,.          
+00007d00: 2020 2020 2020 2020 2020 6f75 7470 7574            output
+00007d10: 5f70 6174 682e 7061 7265 6e74 202f 2066  _path.parent / f
+00007d20: 227b 6f75 7470 7574 5f70 6174 682e 7374  "{output_path.st
+00007d30: 656d 7d5f 7469 6c65 732e 6770 6b67 222c  em}_tiles.gpkg",
+00007d40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007d50: 2029 0a0a 2020 2020 2020 2020 2320 4966   )..        # If
+00007d60: 2061 2074 696c 6564 2072 6573 756c 7420   a tiled result 
+00007d70: 6973 2061 736b 6564 2c20 6164 6420 7469  is asked, add ti
+00007d80: 6c65 5f69 6420 746f 2067 726f 7570 206f  le_id to group o
+00007d90: 6e20 666f 7220 7468 6520 7265 7375 6c74  n for the result
+00007da0: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
+00007db0: 7265 7375 6c74 5f74 696c 6573 5f67 6466  result_tiles_gdf
+00007dc0: 2920 3e20 313a 0a20 2020 2020 2020 2020  ) > 1:.         
+00007dd0: 2020 2072 6573 756c 745f 7469 6c65 735f     result_tiles_
+00007de0: 6764 665b 2274 696c 655f 6964 225d 203d  gdf["tile_id"] =
+00007df0: 2072 6573 756c 745f 7469 6c65 735f 6764   result_tiles_gd
+00007e00: 662e 7265 7365 745f 696e 6465 7828 292e  f.reset_index().
+00007e10: 696e 6465 780a 0a20 2020 2020 2020 2023  index..        #
+00007e20: 2054 6865 2064 6973 736f 6c76 6520 666f   The dissolve fo
+00007e30: 7220 706f 6c79 676f 6e73 2069 7320 646f  r polygons is do
+00007e40: 6e65 2069 6e20 7365 7665 7261 6c20 7061  ne in several pa
+00007e50: 7373 6573 2c20 616e 6420 6166 7465 7220  sses, and after 
+00007e60: 7468 6520 6669 7273 740a 2020 2020 2020  the first.      
+00007e70: 2020 2320 7061 7373 2c20 6f6e 6c79 2074    # pass, only t
+00007e80: 6865 2027 6f6e 626f 7264 6572 2720 6665  he 'onborder' fe
+00007e90: 6174 7572 6573 2061 7265 2066 7572 7468  atures are furth
+00007ea0: 6572 2064 6973 736f 6c76 6564 2c20 6173  er dissolved, as
+00007eb0: 2074 6865 0a20 2020 2020 2020 2023 2027   the.        # '
+00007ec0: 6e6f 746f 6e62 6f72 6465 7227 2066 6561  notonborder' fea
+00007ed0: 7475 7265 7320 6172 6520 616c 7265 6164  tures are alread
+00007ee0: 7920 4f4b 2e0a 2020 2020 2020 2020 7465  y OK..        te
+00007ef0: 6d70 6469 7220 3d20 5f69 6f5f 7574 696c  mpdir = _io_util
+00007f00: 2e63 7265 6174 655f 7465 6d70 6469 7228  .create_tempdir(
+00007f10: 6622 6765 6f66 696c 656f 7073 2f7b 6f70  f"geofileops/{op
+00007f20: 6572 6174 696f 6e7d 2229 0a20 2020 2020  eration}").     
+00007f30: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+00007f40: 2020 2020 6966 206f 7574 7075 745f 6c61      if output_la
+00007f50: 7965 7220 6973 204e 6f6e 653a 0a20 2020  yer is None:.   
+00007f60: 2020 2020 2020 2020 2020 2020 206f 7574               out
+00007f70: 7075 745f 6c61 7965 7220 3d20 6766 6f2e  put_layer = gfo.
+00007f80: 6765 745f 6465 6661 756c 745f 6c61 7965  get_default_laye
+00007f90: 7228 6f75 7470 7574 5f70 6174 6829 0a20  r(output_path). 
+00007fa0: 2020 2020 2020 2020 2020 206f 7574 7075             outpu
+00007fb0: 745f 746d 705f 7061 7468 203d 2074 656d  t_tmp_path = tem
+00007fc0: 7064 6972 202f 2066 227b 6f75 7470 7574  pdir / f"{output
+00007fd0: 5f70 6174 682e 7374 656d 7d2e 6770 6b67  _path.stem}.gpkg
+00007fe0: 220a 2020 2020 2020 2020 2020 2020 7072  ".            pr
+00007ff0: 6576 5f6e 625f 6261 7463 6865 7320 3d20  ev_nb_batches = 
+00008000: 4e6f 6e65 0a20 2020 2020 2020 2020 2020  None.           
+00008010: 206c 6173 745f 7061 7373 203d 2046 616c   last_pass = Fal
+00008020: 7365 0a20 2020 2020 2020 2020 2020 2070  se.            p
+00008030: 6173 735f 6964 203d 2030 0a20 2020 2020  ass_id = 0.     
+00008040: 2020 2020 2020 206c 6f67 6765 722e 696e         logger.in
+00008050: 666f 2866 2253 7461 7274 2064 6973 736f  fo(f"Start disso
+00008060: 6c76 6520 6f6e 2066 696c 6520 7b69 6e70  lve on file {inp
+00008070: 7574 5f70 6174 687d 2229 0a20 2020 2020  ut_path}").     
+00008080: 2020 2020 2020 2077 6869 6c65 2054 7275         while Tru
+00008090: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+000080a0: 2020 2023 2047 6574 2069 6e66 6f20 6f66     # Get info of
+000080b0: 2074 6865 2063 7572 7265 6e74 2066 696c   the current fil
+000080c0: 6520 7468 6174 206e 6565 6473 2074 6f20  e that needs to 
+000080d0: 6265 2064 6973 736f 6c76 6564 0a20 2020  be dissolved.   
+000080e0: 2020 2020 2020 2020 2020 2020 2070 6173               pas
+000080f0: 735f 696e 7075 745f 6c61 7965 7269 6e66  s_input_layerinf
+00008100: 6f20 3d20 6766 6f2e 6765 745f 6c61 7965  o = gfo.get_laye
+00008110: 7269 6e66 6f28 696e 7075 745f 7061 7468  rinfo(input_path
+00008120: 2c20 696e 7075 745f 6c61 7965 7229 0a20  , input_layer). 
+00008130: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00008140: 625f 726f 7773 5f74 6f74 616c 203d 2070  b_rows_total = p
+00008150: 6173 735f 696e 7075 745f 6c61 7965 7269  ass_input_layeri
+00008160: 6e66 6f2e 6665 6174 7572 6563 6f75 6e74  nfo.featurecount
+00008170: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00008180: 2020 2320 4361 6c63 756c 6174 6520 7468    # Calculate th
+00008190: 6520 6265 7374 206e 756d 6265 7220 6f66  e best number of
+000081a0: 2070 6172 616c 6c65 6c20 7072 6f63 6573   parallel proces
+000081b0: 7365 7320 616e 6420 6261 7463 6865 7320  ses and batches 
+000081c0: 666f 720a 2020 2020 2020 2020 2020 2020  for.            
+000081d0: 2020 2020 2320 7468 6520 6176 6169 6c61      # the availa
+000081e0: 626c 6520 7265 736f 7572 6365 7320 666f  ble resources fo
+000081f0: 7220 7468 6520 6375 7272 656e 7420 7061  r the current pa
+00008200: 7373 0a20 2020 2020 2020 2020 2020 2020  ss.             
+00008210: 2020 2069 6620 6261 7463 6873 697a 6520     if batchsize 
+00008220: 3e20 303a 0a20 2020 2020 2020 2020 2020  > 0:.           
+00008230: 2020 2020 2020 2020 2070 6172 616c 6c65           paralle
+00008240: 6c69 7a61 7469 6f6e 5f63 6f6e 6669 6720  lization_config 
+00008250: 3d20 5061 7261 6c6c 656c 697a 6174 696f  = Parallelizatio
+00008260: 6e43 6f6e 6669 6728 0a20 2020 2020 2020  nConfig(.       
+00008270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008280: 206d 696e 5f61 7667 5f72 6f77 735f 7065   min_avg_rows_pe
+00008290: 725f 6261 7463 683d 696e 7428 6d61 7468  r_batch=int(math
+000082a0: 2e63 6569 6c28 6261 7463 6873 697a 6520  .ceil(batchsize 
+000082b0: 2f20 3229 292c 0a20 2020 2020 2020 2020  / 2)),.         
+000082c0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+000082d0: 6178 5f61 7667 5f72 6f77 735f 7065 725f  ax_avg_rows_per_
+000082e0: 6261 7463 683d 6261 7463 6873 697a 652c  batch=batchsize,
+000082f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008300: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+00008310: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00008320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008330: 2070 6172 616c 6c65 6c69 7a61 7469 6f6e   parallelization
+00008340: 5f63 6f6e 6669 6720 3d20 5061 7261 6c6c  _config = Parall
+00008350: 656c 697a 6174 696f 6e43 6f6e 6669 6728  elizationConfig(
+00008360: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00008370: 2020 6e62 5f70 6172 616c 6c65 6c2c 206e    nb_parallel, n
+00008380: 625f 6261 7463 6865 735f 7265 636f 6d6d  b_batches_recomm
+00008390: 656e 6465 642c 205f 203d 2067 6574 5f70  ended, _ = get_p
+000083a0: 6172 616c 6c65 6c69 7a61 7469 6f6e 5f70  arallelization_p
+000083b0: 6172 616d 7328 0a20 2020 2020 2020 2020  arams(.         
+000083c0: 2020 2020 2020 2020 2020 206e 625f 726f             nb_ro
+000083d0: 7773 5f74 6f74 616c 3d6e 625f 726f 7773  ws_total=nb_rows
+000083e0: 5f74 6f74 616c 2c0a 2020 2020 2020 2020  _total,.        
+000083f0: 2020 2020 2020 2020 2020 2020 6e62 5f70              nb_p
+00008400: 6172 616c 6c65 6c3d 6e62 5f70 6172 616c  arallel=nb_paral
+00008410: 6c65 6c2c 0a20 2020 2020 2020 2020 2020  lel,.           
+00008420: 2020 2020 2020 2020 206e 625f 6261 7463           nb_batc
+00008430: 6865 735f 7072 6576 696f 7573 5f70 6173  hes_previous_pas
+00008440: 733d 7072 6576 5f6e 625f 6261 7463 6865  s=prev_nb_batche
+00008450: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+00008460: 2020 2020 2020 2070 6172 616c 6c65 6c69         paralleli
+00008470: 7a61 7469 6f6e 5f63 6f6e 6669 673d 7061  zation_config=pa
+00008480: 7261 6c6c 656c 697a 6174 696f 6e5f 636f  rallelization_co
+00008490: 6e66 6967 2c0a 2020 2020 2020 2020 2020  nfig,.          
+000084a0: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+000084b0: 2020 2020 2020 2020 2023 2049 6620 7468           # If th
+000084c0: 6520 6964 6561 6c20 6e75 6d62 6572 206f  e ideal number o
+000084d0: 6620 6261 7463 6865 7320 6973 2063 6c6f  f batches is clo
+000084e0: 7365 2074 6f20 7468 6520 6e62 2e20 7265  se to the nb. re
+000084f0: 7375 6c74 2074 696c 6573 2061 736b 6564  sult tiles asked
+00008500: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00008510: 2020 2320 6469 7373 6f6c 7665 2074 6f77    # dissolve tow
+00008520: 6172 6473 2074 6865 2061 736b 6564 2072  ards the asked r
+00008530: 6573 756c 7421 0a20 2020 2020 2020 2020  esult!.         
+00008540: 2020 2020 2020 2023 2049 6620 6e6f 742c         # If not,
+00008550: 2061 2074 656d 706f 7261 7279 2072 6573   a temporary res
+00008560: 756c 7420 6973 2063 7265 6174 6564 2075  ult is created u
+00008570: 7369 6e67 2073 6d61 6c6c 6572 2074 696c  sing smaller til
+00008580: 6573 0a20 2020 2020 2020 2020 2020 2020  es.             
+00008590: 2020 2069 6620 6e62 5f62 6174 6368 6573     if nb_batches
+000085a0: 5f72 6563 6f6d 6d65 6e64 6564 203c 3d20  _recommended <= 
+000085b0: 6c65 6e28 7265 7375 6c74 5f74 696c 6573  len(result_tiles
+000085c0: 5f67 6466 2920 2a20 312e 313a 0a20 2020  _gdf) * 1.1:.   
 000085d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000085e0: 2020 2020 2020 206d 696e 5f61 7667 5f72         min_avg_r
-000085f0: 6f77 735f 7065 725f 6261 7463 683d 696e  ows_per_batch=in
-00008600: 7428 6d61 7468 2e63 6569 6c28 6261 7463  t(math.ceil(batc
-00008610: 6873 697a 6520 2f20 3229 292c 0d0a 2020  hsize / 2)),..  
-00008620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008630: 2020 2020 2020 6d61 785f 6176 675f 726f        max_avg_ro
-00008640: 7773 5f70 6572 5f62 6174 6368 3d62 6174  ws_per_batch=bat
-00008650: 6368 7369 7a65 2c0d 0a20 2020 2020 2020  chsize,..       
-00008660: 2020 2020 2020 2020 2020 2020 2029 0d0a               )..
-00008670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008680: 656c 7365 3a0d 0a20 2020 2020 2020 2020  else:..         
-00008690: 2020 2020 2020 2020 2020 2070 6172 616c             paral
-000086a0: 6c65 6c69 7a61 7469 6f6e 5f63 6f6e 6669  lelization_confi
-000086b0: 6720 3d20 5061 7261 6c6c 656c 697a 6174  g = Parallelizat
-000086c0: 696f 6e43 6f6e 6669 6728 290d 0a20 2020  ionConfig()..   
-000086d0: 2020 2020 2020 2020 2020 2020 206e 625f               nb_
-000086e0: 7061 7261 6c6c 656c 2c20 6e62 5f62 6174  parallel, nb_bat
-000086f0: 6368 6573 5f72 6563 6f6d 6d65 6e64 6564  ches_recommended
-00008700: 2c20 5f20 3d20 6765 745f 7061 7261 6c6c  , _ = get_parall
-00008710: 656c 697a 6174 696f 6e5f 7061 7261 6d73  elization_params
-00008720: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-00008730: 2020 2020 2020 206e 625f 726f 7773 5f74         nb_rows_t
-00008740: 6f74 616c 3d6e 625f 726f 7773 5f74 6f74  otal=nb_rows_tot
-00008750: 616c 2c0d 0a20 2020 2020 2020 2020 2020  al,..           
-00008760: 2020 2020 2020 2020 206e 625f 7061 7261           nb_para
-00008770: 6c6c 656c 3d6e 625f 7061 7261 6c6c 656c  llel=nb_parallel
-00008780: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00008790: 2020 2020 2020 206e 625f 6261 7463 6865         nb_batche
-000087a0: 735f 7072 6576 696f 7573 5f70 6173 733d  s_previous_pass=
-000087b0: 7072 6576 5f6e 625f 6261 7463 6865 732c  prev_nb_batches,
-000087c0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000087d0: 2020 2020 2020 7061 7261 6c6c 656c 697a        paralleliz
-000087e0: 6174 696f 6e5f 636f 6e66 6967 3d70 6172  ation_config=par
-000087f0: 616c 6c65 6c69 7a61 7469 6f6e 5f63 6f6e  allelization_con
-00008800: 6669 672c 0d0a 2020 2020 2020 2020 2020  fig,..          
-00008810: 2020 2020 2020 290d 0a0d 0a20 2020 2020        )....     
-00008820: 2020 2020 2020 2020 2020 2023 2049 6620             # If 
-00008830: 7468 6520 6964 6561 6c20 6e75 6d62 6572  the ideal number
-00008840: 206f 6620 6261 7463 6865 7320 6973 2063   of batches is c
-00008850: 6c6f 7365 2074 6f20 7468 6520 6e62 2e20  lose to the nb. 
-00008860: 7265 7375 6c74 2074 696c 6573 2061 736b  result tiles ask
-00008870: 6564 2c0d 0a20 2020 2020 2020 2020 2020  ed,..           
-00008880: 2020 2020 2023 2064 6973 736f 6c76 6520       # dissolve 
-00008890: 746f 7761 7264 7320 7468 6520 6173 6b65  towards the aske
-000088a0: 6420 7265 7375 6c74 210d 0a20 2020 2020  d result!..     
-000088b0: 2020 2020 2020 2020 2020 2023 2049 6620             # If 
-000088c0: 6e6f 742c 2061 2074 656d 706f 7261 7279  not, a temporary
-000088d0: 2072 6573 756c 7420 6973 2063 7265 6174   result is creat
-000088e0: 6564 2075 7369 6e67 2073 6d61 6c6c 6572  ed using smaller
-000088f0: 2074 696c 6573 0d0a 2020 2020 2020 2020   tiles..        
-00008900: 2020 2020 2020 2020 6966 206e 625f 6261          if nb_ba
-00008910: 7463 6865 735f 7265 636f 6d6d 656e 6465  tches_recommende
-00008920: 6420 3c3d 206c 656e 2872 6573 756c 745f  d <= len(result_
-00008930: 7469 6c65 735f 6764 6629 202a 2031 2e31  tiles_gdf) * 1.1
-00008940: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00008950: 2020 2020 2020 2074 696c 6573 5f67 6466         tiles_gdf
-00008960: 203d 2072 6573 756c 745f 7469 6c65 735f   = result_tiles_
-00008970: 6764 660d 0a20 2020 2020 2020 2020 2020  gdf..           
-00008980: 2020 2020 2020 2020 206c 6173 745f 7061           last_pa
-00008990: 7373 203d 2054 7275 650d 0a20 2020 2020  ss = True..     
-000089a0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-000089b0: 625f 7061 7261 6c6c 656c 203d 206d 696e  b_parallel = min
-000089c0: 286c 656e 2872 6573 756c 745f 7469 6c65  (len(result_tile
-000089d0: 735f 6764 6629 2c20 6e62 5f70 6172 616c  s_gdf), nb_paral
-000089e0: 6c65 6c29 0d0a 2020 2020 2020 2020 2020  lel)..          
-000089f0: 2020 2020 2020 656c 6966 206c 656e 2872        elif len(r
-00008a00: 6573 756c 745f 7469 6c65 735f 6764 6629  esult_tiles_gdf)
-00008a10: 203d 3d20 313a 0d0a 2020 2020 2020 2020   == 1:..        
-00008a20: 2020 2020 2020 2020 2020 2020 2320 4372              # Cr
-00008a30: 6561 7465 2061 2067 7269 6420 6261 7365  eate a grid base
-00008a40: 6420 6f6e 2074 6865 2069 6465 616c 206e  d on the ideal n
-00008a50: 756d 6265 7220 6f66 2062 6174 6368 6573  umber of batches
-00008a60: 2c20 6275 7420 6d61 6b65 0d0a 2020 2020  , but make..    
-00008a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008a80: 2320 7375 7265 2074 6865 206e 756d 6265  # sure the numbe
-00008a90: 7220 6973 2073 6d61 6c6c 6572 2074 6861  r is smaller tha
-00008aa0: 6e20 7468 6520 6d61 7869 6d75 6d2e 2e2e  n the maximum...
-00008ab0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00008ac0: 2020 2020 2020 6e62 5f73 7175 6172 6973        nb_squaris
-00008ad0: 685f 7469 6c65 735f 6d61 7820 3d20 4e6f  h_tiles_max = No
-00008ae0: 6e65 0d0a 2020 2020 2020 2020 2020 2020  ne..            
-00008af0: 2020 2020 2020 2020 6966 2070 7265 765f          if prev_
-00008b00: 6e62 5f62 6174 6368 6573 2069 7320 6e6f  nb_batches is no
-00008b10: 7420 4e6f 6e65 3a0d 0a20 2020 2020 2020  t None:..       
-00008b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008b30: 206e 625f 7371 7561 7269 7368 5f74 696c   nb_squarish_til
-00008b40: 6573 5f6d 6178 203d 206d 6178 2870 7265  es_max = max(pre
-00008b50: 765f 6e62 5f62 6174 6368 6573 202d 2031  v_nb_batches - 1
-00008b60: 2c20 3129 0d0a 2020 2020 2020 2020 2020  , 1)..          
-00008b70: 2020 2020 2020 2020 2020 7469 6c65 735f            tiles_
-00008b80: 6764 6620 3d20 6772 6964 5f75 7469 6c2e  gdf = grid_util.
-00008b90: 6372 6561 7465 5f67 7269 6432 280d 0a20  create_grid2(.. 
-00008ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008bb0: 2020 2020 2020 2074 6f74 616c 5f62 6f75         total_bou
-00008bc0: 6e64 733d 7061 7373 5f69 6e70 7574 5f6c  nds=pass_input_l
-00008bd0: 6179 6572 696e 666f 2e74 6f74 616c 5f62  ayerinfo.total_b
-00008be0: 6f75 6e64 732c 0d0a 2020 2020 2020 2020  ounds,..        
-00008bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008c00: 6e62 5f73 7175 6172 6973 685f 7469 6c65  nb_squarish_tile
-00008c10: 733d 6e62 5f62 6174 6368 6573 5f72 6563  s=nb_batches_rec
-00008c20: 6f6d 6d65 6e64 6564 2c0d 0a20 2020 2020  ommended,..     
-00008c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008c40: 2020 206e 625f 7371 7561 7269 7368 5f74     nb_squarish_t
-00008c50: 696c 6573 5f6d 6178 3d6e 625f 7371 7561  iles_max=nb_squa
-00008c60: 7269 7368 5f74 696c 6573 5f6d 6178 2c0d  rish_tiles_max,.
-00008c70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008c80: 2020 2020 2020 2020 2063 7273 3d70 6173           crs=pas
-00008c90: 735f 696e 7075 745f 6c61 7965 7269 6e66  s_input_layerinf
-00008ca0: 6f2e 6372 732c 0d0a 2020 2020 2020 2020  o.crs,..        
-00008cb0: 2020 2020 2020 2020 2020 2020 290d 0a20              ).. 
-00008cc0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00008cd0: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-00008ce0: 2020 2020 2020 2020 2020 2320 4966 2061            # If a
-00008cf0: 2067 7269 6420 6973 2073 7065 6369 6669   grid is specifi
-00008d00: 6564 2061 6c72 6561 6479 2c20 6164 6420  ed already, add 
-00008d10: 6578 7472 6120 636f 6c75 6d6e 732f 726f  extra columns/ro
-00008d20: 7773 2069 6e73 7465 6164 206f 660d 0a20  ws instead of.. 
-00008d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008d40: 2020 2023 2063 7265 6174 696e 6720 6e65     # creating ne
-00008d50: 7720 6f6e 652e 2e2e 0d0a 2020 2020 2020  w one.....      
-00008d60: 2020 2020 2020 2020 2020 2020 2020 7469                ti
-00008d70: 6c65 735f 6764 6620 3d20 6772 6964 5f75  les_gdf = grid_u
-00008d80: 7469 6c2e 7370 6c69 745f 7469 6c65 7328  til.split_tiles(
-00008d90: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00008da0: 2020 2020 2020 2020 2020 7265 7375 6c74            result
-00008db0: 5f74 696c 6573 5f67 6466 2c20 6e62 5f62  _tiles_gdf, nb_b
-00008dc0: 6174 6368 6573 5f72 6563 6f6d 6d65 6e64  atches_recommend
-00008dd0: 6564 0d0a 2020 2020 2020 2020 2020 2020  ed..            
-00008de0: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-00008df0: 2020 2020 2020 2020 2020 2067 666f 2e74             gfo.t
-00008e00: 6f5f 6669 6c65 280d 0a20 2020 2020 2020  o_file(..       
-00008e10: 2020 2020 2020 2020 2020 2020 2074 696c               til
-00008e20: 6573 5f67 6466 2c20 7465 6d70 6469 7220  es_gdf, tempdir 
-00008e30: 2f20 6622 7b6f 7574 7075 745f 7061 7468  / f"{output_path
-00008e40: 2e73 7465 6d7d 5f7b 7061 7373 5f69 647d  .stem}_{pass_id}
-00008e50: 5f74 696c 6573 2e67 706b 6722 0d0a 2020  _tiles.gpkg"..  
-00008e60: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-00008e70: 0a0d 0a20 2020 2020 2020 2020 2020 2020  ...             
-00008e80: 2020 2023 2049 6620 7468 6520 6e75 6d62     # If the numb
-00008e90: 6572 206f 6620 7469 6c65 7320 656e 6473  er of tiles ends
-00008ea0: 2075 7020 6173 2031 2c20 6974 2069 7320   up as 1, it is 
-00008eb0: 7468 6520 6c61 7374 2070 6173 7320 616e  the last pass an
-00008ec0: 7977 6179 2e2e 2e0d 0a20 2020 2020 2020  yway.....       
-00008ed0: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
-00008ee0: 7469 6c65 735f 6764 6629 203d 3d20 313a  tiles_gdf) == 1:
-00008ef0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00008f00: 2020 2020 2020 6c61 7374 5f70 6173 7320        last_pass 
-00008f10: 3d20 5472 7565 0d0a 0d0a 2020 2020 2020  = True....      
-00008f20: 2020 2020 2020 2020 2020 2320 4966 2077            # If w
-00008f30: 6520 6172 6520 6e6f 7420 696e 2074 6865  e are not in the
-00008f40: 206c 6173 7420 7061 7373 2c20 6f6e 626f   last pass, onbo
-00008f50: 7264 6572 2070 6172 6365 6c73 2077 696c  rder parcels wil
-00008f60: 6c20 6e65 6564 2065 7874 7261 0d0a 2020  l need extra..  
-00008f70: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00008f80: 7072 6f63 6573 7369 6e67 2073 7469 6c6c  processing still
-00008f90: 2069 6e20 6675 7274 6865 7220 7061 7373   in further pass
-00008fa0: 6573 2c20 736f 2061 7265 2073 6176 6564  es, so are saved
-00008fb0: 2069 6e20 6120 7365 7065 7261 7465 0d0a   in a seperate..
-00008fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008fd0: 2320 6766 6f2e 2054 6865 206e 6f74 6f6e  # gfo. The noton
-00008fe0: 626f 7264 6572 2072 6f77 7320 6172 6520  border rows are 
-00008ff0: 6669 6e61 6c20 696d 6d65 6469 6174 656c  final immediatel
-00009000: 790d 0a20 2020 2020 2020 2020 2020 2020  y..             
-00009010: 2020 2069 6620 6c61 7374 5f70 6173 7320     if last_pass 
-00009020: 6973 206e 6f74 2054 7275 653a 0d0a 2020  is not True:..  
+000085e0: 2074 696c 6573 5f67 6466 203d 2072 6573   tiles_gdf = res
+000085f0: 756c 745f 7469 6c65 735f 6764 660a 2020  ult_tiles_gdf.  
+00008600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008610: 2020 6c61 7374 5f70 6173 7320 3d20 5472    last_pass = Tr
+00008620: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
+00008630: 2020 2020 2020 206e 625f 7061 7261 6c6c         nb_parall
+00008640: 656c 203d 206d 696e 286c 656e 2872 6573  el = min(len(res
+00008650: 756c 745f 7469 6c65 735f 6764 6629 2c20  ult_tiles_gdf), 
+00008660: 6e62 5f70 6172 616c 6c65 6c29 0a20 2020  nb_parallel).   
+00008670: 2020 2020 2020 2020 2020 2020 2065 6c69               eli
+00008680: 6620 6c65 6e28 7265 7375 6c74 5f74 696c  f len(result_til
+00008690: 6573 5f67 6466 2920 3d3d 2031 3a0a 2020  es_gdf) == 1:.  
+000086a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000086b0: 2020 2320 4372 6561 7465 2061 2067 7269    # Create a gri
+000086c0: 6420 6261 7365 6420 6f6e 2074 6865 2069  d based on the i
+000086d0: 6465 616c 206e 756d 6265 7220 6f66 2062  deal number of b
+000086e0: 6174 6368 6573 2c20 6275 7420 6d61 6b65  atches, but make
+000086f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008700: 2020 2020 2023 2073 7572 6520 7468 6520       # sure the 
+00008710: 6e75 6d62 6572 2069 7320 736d 616c 6c65  number is smalle
+00008720: 7220 7468 616e 2074 6865 206d 6178 696d  r than the maxim
+00008730: 756d 2e2e 2e0a 2020 2020 2020 2020 2020  um....          
+00008740: 2020 2020 2020 2020 2020 6e62 5f73 7175            nb_squ
+00008750: 6172 6973 685f 7469 6c65 735f 6d61 7820  arish_tiles_max 
+00008760: 3d20 4e6f 6e65 0a20 2020 2020 2020 2020  = None.         
+00008770: 2020 2020 2020 2020 2020 2069 6620 7072             if pr
+00008780: 6576 5f6e 625f 6261 7463 6865 7320 6973  ev_nb_batches is
+00008790: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+000087a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000087b0: 2020 206e 625f 7371 7561 7269 7368 5f74     nb_squarish_t
+000087c0: 696c 6573 5f6d 6178 203d 206d 6178 2870  iles_max = max(p
+000087d0: 7265 765f 6e62 5f62 6174 6368 6573 202d  rev_nb_batches -
+000087e0: 2031 2c20 3129 0a20 2020 2020 2020 2020   1, 1).         
+000087f0: 2020 2020 2020 2020 2020 2074 696c 6573             tiles
+00008800: 5f67 6466 203d 2067 7269 645f 7574 696c  _gdf = grid_util
+00008810: 2e63 7265 6174 655f 6772 6964 3228 0a20  .create_grid2(. 
+00008820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008830: 2020 2020 2020 2074 6f74 616c 5f62 6f75         total_bou
+00008840: 6e64 733d 7061 7373 5f69 6e70 7574 5f6c  nds=pass_input_l
+00008850: 6179 6572 696e 666f 2e74 6f74 616c 5f62  ayerinfo.total_b
+00008860: 6f75 6e64 732c 0a20 2020 2020 2020 2020  ounds,.         
+00008870: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00008880: 625f 7371 7561 7269 7368 5f74 696c 6573  b_squarish_tiles
+00008890: 3d6e 625f 6261 7463 6865 735f 7265 636f  =nb_batches_reco
+000088a0: 6d6d 656e 6465 642c 0a20 2020 2020 2020  mmended,.       
+000088b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000088c0: 206e 625f 7371 7561 7269 7368 5f74 696c   nb_squarish_til
+000088d0: 6573 5f6d 6178 3d6e 625f 7371 7561 7269  es_max=nb_squari
+000088e0: 7368 5f74 696c 6573 5f6d 6178 2c0a 2020  sh_tiles_max,.  
+000088f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008900: 2020 2020 2020 6372 733d 7061 7373 5f69        crs=pass_i
+00008910: 6e70 7574 5f6c 6179 6572 696e 666f 2e63  nput_layerinfo.c
+00008920: 7273 2c0a 2020 2020 2020 2020 2020 2020  rs,.            
+00008930: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00008940: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00008950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008960: 2020 2020 2320 4966 2061 2067 7269 6420      # If a grid 
+00008970: 6973 2073 7065 6369 6669 6564 2061 6c72  is specified alr
+00008980: 6561 6479 2c20 6164 6420 6578 7472 6120  eady, add extra 
+00008990: 636f 6c75 6d6e 732f 726f 7773 2069 6e73  columns/rows ins
+000089a0: 7465 6164 206f 660a 2020 2020 2020 2020  tead of.        
+000089b0: 2020 2020 2020 2020 2020 2020 2320 6372              # cr
+000089c0: 6561 7469 6e67 206e 6577 206f 6e65 2e2e  eating new one..
+000089d0: 2e0a 2020 2020 2020 2020 2020 2020 2020  ..              
+000089e0: 2020 2020 2020 7469 6c65 735f 6764 6620        tiles_gdf 
+000089f0: 3d20 6772 6964 5f75 7469 6c2e 7370 6c69  = grid_util.spli
+00008a00: 745f 7469 6c65 7328 0a20 2020 2020 2020  t_tiles(.       
+00008a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008a20: 2072 6573 756c 745f 7469 6c65 735f 6764   result_tiles_gd
+00008a30: 662c 206e 625f 6261 7463 6865 735f 7265  f, nb_batches_re
+00008a40: 636f 6d6d 656e 6465 640a 2020 2020 2020  commended.      
+00008a50: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00008a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008a70: 6766 6f2e 746f 5f66 696c 6528 0a20 2020  gfo.to_file(.   
+00008a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008a90: 2074 696c 6573 5f67 6466 2c20 7465 6d70   tiles_gdf, temp
+00008aa0: 6469 7220 2f20 6622 7b6f 7574 7075 745f  dir / f"{output_
+00008ab0: 7061 7468 2e73 7465 6d7d 5f7b 7061 7373  path.stem}_{pass
+00008ac0: 5f69 647d 5f74 696c 6573 2e67 706b 6722  _id}_tiles.gpkg"
+00008ad0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008ae0: 2029 0a0a 2020 2020 2020 2020 2020 2020   )..            
+00008af0: 2020 2020 2320 4966 2074 6865 206e 756d      # If the num
+00008b00: 6265 7220 6f66 2074 696c 6573 2065 6e64  ber of tiles end
+00008b10: 7320 7570 2061 7320 312c 2069 7420 6973  s up as 1, it is
+00008b20: 2074 6865 206c 6173 7420 7061 7373 2061   the last pass a
+00008b30: 6e79 7761 792e 2e2e 0a20 2020 2020 2020  nyway....       
+00008b40: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
+00008b50: 7469 6c65 735f 6764 6629 203d 3d20 313a  tiles_gdf) == 1:
+00008b60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008b70: 2020 2020 206c 6173 745f 7061 7373 203d       last_pass =
+00008b80: 2054 7275 650a 0a20 2020 2020 2020 2020   True..         
+00008b90: 2020 2020 2020 2023 2049 6620 7765 2061         # If we a
+00008ba0: 7265 206e 6f74 2069 6e20 7468 6520 6c61  re not in the la
+00008bb0: 7374 2070 6173 732c 206f 6e62 6f72 6465  st pass, onborde
+00008bc0: 7220 7061 7263 656c 7320 7769 6c6c 206e  r parcels will n
+00008bd0: 6565 6420 6578 7472 610a 2020 2020 2020  eed extra.      
+00008be0: 2020 2020 2020 2020 2020 2320 7072 6f63            # proc
+00008bf0: 6573 7369 6e67 2073 7469 6c6c 2069 6e20  essing still in 
+00008c00: 6675 7274 6865 7220 7061 7373 6573 2c20  further passes, 
+00008c10: 736f 2061 7265 2073 6176 6564 2069 6e20  so are saved in 
+00008c20: 6120 7365 7065 7261 7465 0a20 2020 2020  a seperate.     
+00008c30: 2020 2020 2020 2020 2020 2023 2067 666f             # gfo
+00008c40: 2e20 5468 6520 6e6f 746f 6e62 6f72 6465  . The notonborde
+00008c50: 7220 726f 7773 2061 7265 2066 696e 616c  r rows are final
+00008c60: 2069 6d6d 6564 6961 7465 6c79 0a20 2020   immediately.   
+00008c70: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00008c80: 6c61 7374 5f70 6173 7320 6973 206e 6f74  last_pass is not
+00008c90: 2054 7275 653a 0a20 2020 2020 2020 2020   True:.         
+00008ca0: 2020 2020 2020 2020 2020 206f 7574 7075             outpu
+00008cb0: 745f 746d 705f 6f6e 626f 7264 6572 5f70  t_tmp_onborder_p
+00008cc0: 6174 6820 3d20 280a 2020 2020 2020 2020  ath = (.        
+00008cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008ce0: 7465 6d70 6469 7220 2f20 6622 7b6f 7574  tempdir / f"{out
+00008cf0: 7075 745f 7061 7468 2e73 7465 6d7d 5f7b  put_path.stem}_{
+00008d00: 7061 7373 5f69 647d 5f6f 6e62 6f72 6465  pass_id}_onborde
+00008d10: 722e 6770 6b67 220a 2020 2020 2020 2020  r.gpkg".        
+00008d20: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00008d30: 2020 2020 2020 2020 2020 2020 2020 656c                el
+00008d40: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00008d50: 2020 2020 2020 2020 6f75 7470 7574 5f74          output_t
+00008d60: 6d70 5f6f 6e62 6f72 6465 725f 7061 7468  mp_onborder_path
+00008d70: 203d 206f 7574 7075 745f 746d 705f 7061   = output_tmp_pa
+00008d80: 7468 0a0a 2020 2020 2020 2020 2020 2020  th..            
+00008d90: 2020 2020 2320 4e6f 7720 676f 210a 2020      # Now go!.  
+00008da0: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
+00008db0: 6767 6572 2e69 6e66 6f28 6622 5374 6172  gger.info(f"Star
+00008dc0: 7420 6469 7373 6f6c 7665 2070 6173 7320  t dissolve pass 
+00008dd0: 7b70 6173 735f 6964 7d20 746f 207b 6c65  {pass_id} to {le
+00008de0: 6e28 7469 6c65 735f 6764 6629 7d20 7469  n(tiles_gdf)} ti
+00008df0: 6c65 7322 290a 2020 2020 2020 2020 2020  les").          
+00008e00: 2020 2020 2020 5f20 3d20 5f64 6973 736f        _ = _disso
+00008e10: 6c76 655f 706f 6c79 676f 6e73 5f70 6173  lve_polygons_pas
+00008e20: 7328 0a20 2020 2020 2020 2020 2020 2020  s(.             
+00008e30: 2020 2020 2020 2069 6e70 7574 5f70 6174         input_pat
+00008e40: 683d 696e 7075 745f 7061 7468 2c0a 2020  h=input_path,.  
+00008e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008e60: 2020 6f75 7470 7574 5f6e 6f74 6f6e 626f    output_notonbo
+00008e70: 7264 6572 5f70 6174 683d 6f75 7470 7574  rder_path=output
+00008e80: 5f74 6d70 5f70 6174 682c 0a20 2020 2020  _tmp_path,.     
+00008e90: 2020 2020 2020 2020 2020 2020 2020 206f                 o
+00008ea0: 7574 7075 745f 6f6e 626f 7264 6572 5f70  utput_onborder_p
+00008eb0: 6174 683d 6f75 7470 7574 5f74 6d70 5f6f  ath=output_tmp_o
+00008ec0: 6e62 6f72 6465 725f 7061 7468 2c0a 2020  nborder_path,.  
+00008ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008ee0: 2020 6578 706c 6f64 6563 6f6c 6c65 6374    explodecollect
+00008ef0: 696f 6e73 3d65 7870 6c6f 6465 636f 6c6c  ions=explodecoll
+00008f00: 6563 7469 6f6e 732c 0a20 2020 2020 2020  ections,.       
+00008f10: 2020 2020 2020 2020 2020 2020 2067 726f               gro
+00008f20: 7570 6279 5f63 6f6c 756d 6e73 3d67 726f  upby_columns=gro
+00008f30: 7570 6279 5f63 6f6c 756d 6e73 2c0a 2020  upby_columns,.  
+00008f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008f50: 2020 6167 675f 636f 6c75 6d6e 733d 6167    agg_columns=ag
+00008f60: 675f 636f 6c75 6d6e 732c 0a20 2020 2020  g_columns,.     
+00008f70: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+00008f80: 696c 6573 5f67 6466 3d74 696c 6573 5f67  iles_gdf=tiles_g
+00008f90: 6466 2c0a 2020 2020 2020 2020 2020 2020  df,.            
+00008fa0: 2020 2020 2020 2020 696e 7075 745f 6c61          input_la
+00008fb0: 7965 723d 696e 7075 745f 6c61 7965 722c  yer=input_layer,
+00008fc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008fd0: 2020 2020 206f 7574 7075 745f 6c61 7965       output_laye
+00008fe0: 723d 6f75 7470 7574 5f6c 6179 6572 2c0a  r=output_layer,.
+00008ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009000: 2020 2020 6e62 5f70 6172 616c 6c65 6c3d      nb_parallel=
+00009010: 6e62 5f70 6172 616c 6c65 6c2c 0a20 2020  nb_parallel,.   
+00009020: 2020 2020 2020 2020 2020 2020 2029 0a0a               )..
 00009030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009040: 2020 6f75 7470 7574 5f74 6d70 5f6f 6e62    output_tmp_onb
-00009050: 6f72 6465 725f 7061 7468 203d 2028 0d0a  order_path = (..
-00009060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009070: 2020 2020 2020 2020 7465 6d70 6469 7220          tempdir 
-00009080: 2f20 6622 7b6f 7574 7075 745f 7061 7468  / f"{output_path
-00009090: 2e73 7465 6d7d 5f7b 7061 7373 5f69 647d  .stem}_{pass_id}
-000090a0: 5f6f 6e62 6f72 6465 722e 6770 6b67 220d  _onborder.gpkg".
-000090b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000090c0: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-000090d0: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-000090e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000090f0: 2020 206f 7574 7075 745f 746d 705f 6f6e     output_tmp_on
-00009100: 626f 7264 6572 5f70 6174 6820 3d20 6f75  border_path = ou
-00009110: 7470 7574 5f74 6d70 5f70 6174 680d 0a0d  tput_tmp_path...
-00009120: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009130: 2023 204e 6f77 2067 6f21 0d0a 2020 2020   # Now go!..    
-00009140: 2020 2020 2020 2020 2020 2020 6c6f 6767              logg
-00009150: 6572 2e69 6e66 6f28 6622 5374 6172 7420  er.info(f"Start 
-00009160: 6469 7373 6f6c 7665 2070 6173 7320 7b70  dissolve pass {p
-00009170: 6173 735f 6964 7d20 746f 207b 6c65 6e28  ass_id} to {len(
-00009180: 7469 6c65 735f 6764 6629 7d20 7469 6c65  tiles_gdf)} tile
-00009190: 7322 290d 0a20 2020 2020 2020 2020 2020  s")..           
-000091a0: 2020 2020 205f 203d 205f 6469 7373 6f6c       _ = _dissol
-000091b0: 7665 5f70 6f6c 7967 6f6e 735f 7061 7373  ve_polygons_pass
-000091c0: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-000091d0: 2020 2020 2020 2069 6e70 7574 5f70 6174         input_pat
-000091e0: 683d 696e 7075 745f 7061 7468 2c0d 0a20  h=input_path,.. 
-000091f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009200: 2020 206f 7574 7075 745f 6e6f 746f 6e62     output_notonb
-00009210: 6f72 6465 725f 7061 7468 3d6f 7574 7075  order_path=outpu
-00009220: 745f 746d 705f 7061 7468 2c0d 0a20 2020  t_tmp_path,..   
-00009230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009240: 206f 7574 7075 745f 6f6e 626f 7264 6572   output_onborder
-00009250: 5f70 6174 683d 6f75 7470 7574 5f74 6d70  _path=output_tmp
-00009260: 5f6f 6e62 6f72 6465 725f 7061 7468 2c0d  _onborder_path,.
-00009270: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009280: 2020 2020 2065 7870 6c6f 6465 636f 6c6c       explodecoll
-00009290: 6563 7469 6f6e 733d 6578 706c 6f64 6563  ections=explodec
-000092a0: 6f6c 6c65 6374 696f 6e73 2c0d 0a20 2020  ollections,..   
+00009040: 2320 5072 6570 6172 6520 7468 6520 6e65  # Prepare the ne
+00009050: 7874 2070 6173 730a 2020 2020 2020 2020  xt pass.        
+00009060: 2020 2020 2020 2020 2320 5468 6520 696e          # The in
+00009070: 7075 7420 7061 7468 2069 7320 7468 6520  put path is the 
+00009080: 6f6e 626f 7264 6572 2066 696c 650a 2020  onborder file.  
+00009090: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+000090a0: 6576 5f6e 625f 6261 7463 6865 7320 3d20  ev_nb_batches = 
+000090b0: 6c65 6e28 7469 6c65 735f 6764 6629 0a20  len(tiles_gdf). 
+000090c0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+000090d0: 6e70 7574 5f70 6174 6820 3d20 6f75 7470  nput_path = outp
+000090e0: 7574 5f74 6d70 5f6f 6e62 6f72 6465 725f  ut_tmp_onborder_
+000090f0: 7061 7468 0a20 2020 2020 2020 2020 2020  path.           
+00009100: 2020 2020 2070 6173 735f 6964 202b 3d20       pass_id += 
+00009110: 310a 0a20 2020 2020 2020 2020 2020 2020  1..             
+00009120: 2020 2023 2049 6620 7765 2061 7265 2072     # If we are r
+00009130: 6561 6479 2e2e 2e0a 2020 2020 2020 2020  eady....        
+00009140: 2020 2020 2020 2020 6966 206c 6173 745f          if last_
+00009150: 7061 7373 2069 7320 5472 7565 3a0a 2020  pass is True:.  
+00009160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009170: 2020 6272 6561 6b0a 0a20 2020 2020 2020    break..       
+00009180: 2020 2020 2023 2043 616c 6375 6c61 7469       # Calculati
+00009190: 6f6e 2072 6561 6479 2120 4e6f 7720 6669  on ready! Now fi
+000091a0: 6e61 6c69 7365 206f 7574 7075 7421 0a20  nalise output!. 
+000091b0: 2020 2020 2020 2020 2020 2023 2049 6620             # If 
+000091c0: 7468 6572 6520 6973 2061 2072 6573 756c  there is a resul
+000091d0: 7420 6f6e 2062 6f72 6465 722c 2061 7070  t on border, app
+000091e0: 656e 6420 6974 2074 6f20 7468 6520 7265  end it to the re
+000091f0: 7374 0a20 2020 2020 2020 2020 2020 2069  st.            i
+00009200: 6620 280a 2020 2020 2020 2020 2020 2020  f (.            
+00009210: 2020 2020 7374 7228 6f75 7470 7574 5f74      str(output_t
+00009220: 6d70 5f6f 6e62 6f72 6465 725f 7061 7468  mp_onborder_path
+00009230: 2920 213d 2073 7472 286f 7574 7075 745f  ) != str(output_
+00009240: 746d 705f 7061 7468 290a 2020 2020 2020  tmp_path).      
+00009250: 2020 2020 2020 2020 2020 616e 6420 6f75            and ou
+00009260: 7470 7574 5f74 6d70 5f6f 6e62 6f72 6465  tput_tmp_onborde
+00009270: 725f 7061 7468 2e65 7869 7374 7328 290a  r_path.exists().
+00009280: 2020 2020 2020 2020 2020 2020 293a 0a20              ):. 
+00009290: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+000092a0: 666f 2e61 7070 656e 645f 746f 280a 2020  fo.append_to(.  
 000092b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000092c0: 2067 726f 7570 6279 5f63 6f6c 756d 6e73   groupby_columns
-000092d0: 3d67 726f 7570 6279 5f63 6f6c 756d 6e73  =groupby_columns
-000092e0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-000092f0: 2020 2020 2020 2061 6767 5f63 6f6c 756d         agg_colum
-00009300: 6e73 3d61 6767 5f63 6f6c 756d 6e73 2c0d  ns=agg_columns,.
-00009310: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009320: 2020 2020 2074 696c 6573 5f67 6466 3d74       tiles_gdf=t
-00009330: 696c 6573 5f67 6466 2c0d 0a20 2020 2020  iles_gdf,..     
-00009340: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00009350: 6e70 7574 5f6c 6179 6572 3d69 6e70 7574  nput_layer=input
-00009360: 5f6c 6179 6572 2c0d 0a20 2020 2020 2020  _layer,..       
-00009370: 2020 2020 2020 2020 2020 2020 206f 7574               out
-00009380: 7075 745f 6c61 7965 723d 6f75 7470 7574  put_layer=output
-00009390: 5f6c 6179 6572 2c0d 0a20 2020 2020 2020  _layer,..       
-000093a0: 2020 2020 2020 2020 2020 2020 206e 625f               nb_
-000093b0: 7061 7261 6c6c 656c 3d6e 625f 7061 7261  parallel=nb_para
-000093c0: 6c6c 656c 2c0d 0a20 2020 2020 2020 2020  llel,..         
-000093d0: 2020 2020 2020 2029 0d0a 0d0a 2020 2020         )....    
-000093e0: 2020 2020 2020 2020 2020 2020 2320 5072              # Pr
-000093f0: 6570 6172 6520 7468 6520 6e65 7874 2070  epare the next p
-00009400: 6173 730d 0a20 2020 2020 2020 2020 2020  ass..           
-00009410: 2020 2020 2023 2054 6865 2069 6e70 7574       # The input
-00009420: 2070 6174 6820 6973 2074 6865 206f 6e62   path is the onb
-00009430: 6f72 6465 7220 6669 6c65 0d0a 2020 2020  order file..    
-00009440: 2020 2020 2020 2020 2020 2020 7072 6576              prev
-00009450: 5f6e 625f 6261 7463 6865 7320 3d20 6c65  _nb_batches = le
-00009460: 6e28 7469 6c65 735f 6764 6629 0d0a 2020  n(tiles_gdf)..  
-00009470: 2020 2020 2020 2020 2020 2020 2020 696e                in
-00009480: 7075 745f 7061 7468 203d 206f 7574 7075  put_path = outpu
-00009490: 745f 746d 705f 6f6e 626f 7264 6572 5f70  t_tmp_onborder_p
-000094a0: 6174 680d 0a20 2020 2020 2020 2020 2020  ath..           
-000094b0: 2020 2020 2070 6173 735f 6964 202b 3d20       pass_id += 
-000094c0: 310d 0a0d 0a20 2020 2020 2020 2020 2020  1....           
-000094d0: 2020 2020 2023 2049 6620 7765 2061 7265       # If we are
-000094e0: 2072 6561 6479 2e2e 2e0d 0a20 2020 2020   ready.....     
-000094f0: 2020 2020 2020 2020 2020 2069 6620 6c61             if la
-00009500: 7374 5f70 6173 7320 6973 2054 7275 653a  st_pass is True:
-00009510: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00009520: 2020 2020 2020 6272 6561 6b0d 0a0d 0a20        break.... 
-00009530: 2020 2020 2020 2020 2020 2023 2043 616c             # Cal
-00009540: 6375 6c61 7469 6f6e 2072 6561 6479 2120  culation ready! 
-00009550: 4e6f 7720 6669 6e61 6c69 7365 206f 7574  Now finalise out
-00009560: 7075 7421 0d0a 2020 2020 2020 2020 2020  put!..          
-00009570: 2020 2320 4966 2074 6865 7265 2069 7320    # If there is 
-00009580: 6120 7265 7375 6c74 206f 6e20 626f 7264  a result on bord
-00009590: 6572 2c20 6170 7065 6e64 2069 7420 746f  er, append it to
-000095a0: 2074 6865 2072 6573 740d 0a20 2020 2020   the rest..     
-000095b0: 2020 2020 2020 2069 6620 280d 0a20 2020         if (..   
-000095c0: 2020 2020 2020 2020 2020 2020 2073 7472               str
-000095d0: 286f 7574 7075 745f 746d 705f 6f6e 626f  (output_tmp_onbo
-000095e0: 7264 6572 5f70 6174 6829 2021 3d20 7374  rder_path) != st
-000095f0: 7228 6f75 7470 7574 5f74 6d70 5f70 6174  r(output_tmp_pat
-00009600: 6829 0d0a 2020 2020 2020 2020 2020 2020  h)..            
-00009610: 2020 2020 616e 6420 6f75 7470 7574 5f74      and output_t
-00009620: 6d70 5f6f 6e62 6f72 6465 725f 7061 7468  mp_onborder_path
-00009630: 2e65 7869 7374 7328 290d 0a20 2020 2020  .exists()..     
-00009640: 2020 2020 2020 2029 3a0d 0a20 2020 2020         ):..     
-00009650: 2020 2020 2020 2020 2020 2067 666f 2e61             gfo.a
-00009660: 7070 656e 645f 746f 280d 0a20 2020 2020  ppend_to(..     
-00009670: 2020 2020 2020 2020 2020 2020 2020 206f                 o
-00009680: 7574 7075 745f 746d 705f 6f6e 626f 7264  utput_tmp_onbord
-00009690: 6572 5f70 6174 682c 206f 7574 7075 745f  er_path, output_
-000096a0: 746d 705f 7061 7468 2c20 6473 745f 6c61  tmp_path, dst_la
-000096b0: 7965 723d 6f75 7470 7574 5f6c 6179 6572  yer=output_layer
-000096c0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000096d0: 2020 290d 0a0d 0a20 2020 2020 2020 2020    )....         
-000096e0: 2020 2023 2049 6620 7468 6572 6520 6973     # If there is
-000096f0: 2061 2072 6573 756c 742e 2e2e 0d0a 2020   a result.....  
-00009700: 2020 2020 2020 2020 2020 6966 206f 7574            if out
-00009710: 7075 745f 746d 705f 7061 7468 2e65 7869  put_tmp_path.exi
-00009720: 7374 7328 293a 0d0a 2020 2020 2020 2020  sts():..        
-00009730: 2020 2020 2020 2020 2320 4966 2074 696c          # If til
-00009740: 6564 206f 7574 7075 7420 6173 6b65 642c  ed output asked,
-00009750: 2061 6464 2022 7469 6c65 5f69 6422 2074   add "tile_id" t
-00009760: 6f20 6772 6f75 7062 795f 636f 6c75 6d6e  o groupby_column
-00009770: 730d 0a20 2020 2020 2020 2020 2020 2020  s..             
-00009780: 2020 2069 6620 6c65 6e28 7265 7375 6c74     if len(result
-00009790: 5f74 696c 6573 5f67 6466 2920 3e20 313a  _tiles_gdf) > 1:
-000097a0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000097b0: 2020 2020 2020 6966 2067 726f 7570 6279        if groupby
-000097c0: 5f63 6f6c 756d 6e73 2069 7320 4e6f 6e65  _columns is None
-000097d0: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-000097e0: 2020 2020 2020 2020 2020 2067 726f 7570             group
-000097f0: 6279 5f63 6f6c 756d 6e73 203d 205b 2274  by_columns = ["t
-00009800: 696c 655f 6964 225d 0d0a 2020 2020 2020  ile_id"]..      
-00009810: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00009820: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-00009830: 2020 2020 2020 2020 2020 2020 2067 726f               gro
-00009840: 7570 6279 5f63 6f6c 756d 6e73 203d 206c  upby_columns = l
-00009850: 6973 7428 6772 6f75 7062 795f 636f 6c75  ist(groupby_colu
-00009860: 6d6e 7329 2e63 6f70 7928 290d 0a20 2020  mns).copy()..   
-00009870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009880: 2020 2020 2067 726f 7570 6279 5f63 6f6c       groupby_col
-00009890: 756d 6e73 2e61 7070 656e 6428 2274 696c  umns.append("til
-000098a0: 655f 6964 2229 0d0a 0d0a 2020 2020 2020  e_id")....      
-000098b0: 2020 2020 2020 2020 2020 2320 5072 6570            # Prep
-000098c0: 6172 6520 7374 7269 6e67 7320 746f 2075  are strings to u
-000098d0: 7365 2069 6e20 7365 6c65 6374 2062 6173  se in select bas
-000098e0: 6564 206f 6e20 6772 6f75 7062 795f 636f  ed on groupby_co
-000098f0: 6c75 6d6e 730d 0a20 2020 2020 2020 2020  lumns..         
-00009900: 2020 2020 2020 2069 6620 6772 6f75 7062         if groupb
-00009910: 795f 636f 6c75 6d6e 7320 6973 206e 6f74  y_columns is not
-00009920: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-00009930: 2020 2020 2020 2020 2020 2020 6772 6f75              grou
-00009940: 7062 795f 7072 6566 6978 6564 5f6c 6973  pby_prefixed_lis
-00009950: 7420 3d20 5b0d 0a20 2020 2020 2020 2020  t = [..         
-00009960: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00009970: 277b 7b70 7265 6669 787d 7d22 7b63 6f6c  '{{prefix}}"{col
-00009980: 756d 6e7d 2227 2066 6f72 2063 6f6c 756d  umn}"' for colum
-00009990: 6e20 696e 2067 726f 7570 6279 5f63 6f6c  n in groupby_col
-000099a0: 756d 6e73 0d0a 2020 2020 2020 2020 2020  umns..          
-000099b0: 2020 2020 2020 2020 2020 5d0d 0a20 2020            ]..   
-000099c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000099d0: 2067 726f 7570 6279 5f73 656c 6563 745f   groupby_select_
-000099e0: 7072 6566 6978 6564 5f73 7472 203d 2028  prefixed_str = (
-000099f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00009a00: 2020 2020 2020 2020 2020 6622 2c20 7b27            f", {'
-00009a10: 2c20 272e 6a6f 696e 2867 726f 7570 6279  , '.join(groupby
-00009a20: 5f70 7265 6669 7865 645f 6c69 7374 297d  _prefixed_list)}
-00009a30: 220d 0a20 2020 2020 2020 2020 2020 2020  "..             
-00009a40: 2020 2020 2020 2029 0d0a 2020 2020 2020         )..      
-00009a50: 2020 2020 2020 2020 2020 2020 2020 6772                gr
-00009a60: 6f75 7062 795f 6772 6f75 7062 795f 7072  oupby_groupby_pr
-00009a70: 6566 6978 6564 5f73 7472 203d 2028 0d0a  efixed_str = (..
-00009a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009a90: 2020 2020 2020 2020 6622 4752 4f55 5020          f"GROUP 
-00009aa0: 4259 207b 272c 2027 2e6a 6f69 6e28 6772  BY {', '.join(gr
-00009ab0: 6f75 7062 795f 7072 6566 6978 6564 5f6c  oupby_prefixed_l
-00009ac0: 6973 7429 7d22 0d0a 2020 2020 2020 2020  ist)}"..        
-00009ad0: 2020 2020 2020 2020 2020 2020 290d 0a0d              )...
+000092c0: 2020 6f75 7470 7574 5f74 6d70 5f6f 6e62    output_tmp_onb
+000092d0: 6f72 6465 725f 7061 7468 2c20 6f75 7470  order_path, outp
+000092e0: 7574 5f74 6d70 5f70 6174 682c 2064 7374  ut_tmp_path, dst
+000092f0: 5f6c 6179 6572 3d6f 7574 7075 745f 6c61  _layer=output_la
+00009300: 7965 720a 2020 2020 2020 2020 2020 2020  yer.            
+00009310: 2020 2020 290a 0a20 2020 2020 2020 2020      )..         
+00009320: 2020 2023 2049 6620 7468 6572 6520 6973     # If there is
+00009330: 2061 2072 6573 756c 742e 2e2e 0a20 2020   a result....   
+00009340: 2020 2020 2020 2020 2069 6620 6f75 7470           if outp
+00009350: 7574 5f74 6d70 5f70 6174 682e 6578 6973  ut_tmp_path.exis
+00009360: 7473 2829 3a0a 2020 2020 2020 2020 2020  ts():.          
+00009370: 2020 2020 2020 2320 4966 2074 696c 6564        # If tiled
+00009380: 206f 7574 7075 7420 6173 6b65 642c 2061   output asked, a
+00009390: 6464 2022 7469 6c65 5f69 6422 2074 6f20  dd "tile_id" to 
+000093a0: 6772 6f75 7062 795f 636f 6c75 6d6e 730a  groupby_columns.
+000093b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000093c0: 6966 206c 656e 2872 6573 756c 745f 7469  if len(result_ti
+000093d0: 6c65 735f 6764 6629 203e 2031 3a0a 2020  les_gdf) > 1:.  
+000093e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000093f0: 2020 6966 2067 726f 7570 6279 5f63 6f6c    if groupby_col
+00009400: 756d 6e73 2069 7320 4e6f 6e65 3a0a 2020  umns is None:.  
+00009410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009420: 2020 2020 2020 6772 6f75 7062 795f 636f        groupby_co
+00009430: 6c75 6d6e 7320 3d20 5b22 7469 6c65 5f69  lumns = ["tile_i
+00009440: 6422 5d0a 2020 2020 2020 2020 2020 2020  d"].            
+00009450: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00009460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009470: 2020 2020 2020 6772 6f75 7062 795f 636f        groupby_co
+00009480: 6c75 6d6e 7320 3d20 6c69 7374 2867 726f  lumns = list(gro
+00009490: 7570 6279 5f63 6f6c 756d 6e73 292e 636f  upby_columns).co
+000094a0: 7079 2829 0a20 2020 2020 2020 2020 2020  py().           
+000094b0: 2020 2020 2020 2020 2020 2020 2067 726f               gro
+000094c0: 7570 6279 5f63 6f6c 756d 6e73 2e61 7070  upby_columns.app
+000094d0: 656e 6428 2274 696c 655f 6964 2229 0a0a  end("tile_id")..
+000094e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000094f0: 2320 5072 6570 6172 6520 7374 7269 6e67  # Prepare string
+00009500: 7320 746f 2075 7365 2069 6e20 7365 6c65  s to use in sele
+00009510: 6374 2062 6173 6564 206f 6e20 6772 6f75  ct based on grou
+00009520: 7062 795f 636f 6c75 6d6e 730a 2020 2020  pby_columns.    
+00009530: 2020 2020 2020 2020 2020 2020 6966 2067              if g
+00009540: 726f 7570 6279 5f63 6f6c 756d 6e73 2069  roupby_columns i
+00009550: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00009560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009570: 6772 6f75 7062 795f 7072 6566 6978 6564  groupby_prefixed
+00009580: 5f6c 6973 7420 3d20 5b0a 2020 2020 2020  _list = [.      
+00009590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000095a0: 2020 6627 7b7b 7072 6566 6978 7d7d 227b    f'{{prefix}}"{
+000095b0: 636f 6c75 6d6e 7d22 2720 666f 7220 636f  column}"' for co
+000095c0: 6c75 6d6e 2069 6e20 6772 6f75 7062 795f  lumn in groupby_
+000095d0: 636f 6c75 6d6e 730a 2020 2020 2020 2020  columns.        
+000095e0: 2020 2020 2020 2020 2020 2020 5d0a 2020              ].  
+000095f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009600: 2020 6772 6f75 7062 795f 7365 6c65 6374    groupby_select
+00009610: 5f70 7265 6669 7865 645f 7374 7220 3d20  _prefixed_str = 
+00009620: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00009630: 2020 2020 2020 2020 2020 6622 2c20 7b27            f", {'
+00009640: 2c20 272e 6a6f 696e 2867 726f 7570 6279  , '.join(groupby
+00009650: 5f70 7265 6669 7865 645f 6c69 7374 297d  _prefixed_list)}
+00009660: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+00009670: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00009680: 2020 2020 2020 2020 2020 2020 6772 6f75              grou
+00009690: 7062 795f 6772 6f75 7062 795f 7072 6566  pby_groupby_pref
+000096a0: 6978 6564 5f73 7472 203d 2028 0a20 2020  ixed_str = (.   
+000096b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000096c0: 2020 2020 2066 2247 524f 5550 2042 5920       f"GROUP BY 
+000096d0: 7b27 2c20 272e 6a6f 696e 2867 726f 7570  {', '.join(group
+000096e0: 6279 5f70 7265 6669 7865 645f 6c69 7374  by_prefixed_list
+000096f0: 297d 220a 2020 2020 2020 2020 2020 2020  )}".            
+00009700: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
+00009710: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+00009720: 726f 7570 6279 5f66 696c 7465 725f 6c69  roupby_filter_li
+00009730: 7374 203d 205b 0a20 2020 2020 2020 2020  st = [.         
+00009740: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00009750: 2720 414e 4420 6765 6f5f 6461 7461 2e22  ' AND geo_data."
+00009760: 7b63 6f6c 756d 6e7d 2220 3d20 6a73 6f6e  {column}" = json
+00009770: 5f64 6174 612e 227b 636f 6c75 6d6e 7d22  _data."{column}"
+00009780: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
+00009790: 2020 2020 2020 2020 2020 666f 7220 636f            for co
+000097a0: 6c75 6d6e 2069 6e20 6772 6f75 7062 795f  lumn in groupby_
+000097b0: 636f 6c75 6d6e 730a 2020 2020 2020 2020  columns.        
+000097c0: 2020 2020 2020 2020 2020 2020 5d0a 2020              ].  
+000097d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000097e0: 2020 6772 6f75 7062 795f 6669 6c74 6572    groupby_filter
+000097f0: 5f73 7472 203d 2022 2022 2e6a 6f69 6e28  _str = " ".join(
+00009800: 6772 6f75 7062 795f 6669 6c74 6572 5f6c  groupby_filter_l
+00009810: 6973 7429 0a20 2020 2020 2020 2020 2020  ist).           
+00009820: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00009830: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+00009840: 726f 7570 6279 5f73 656c 6563 745f 7072  roupby_select_pr
+00009850: 6566 6978 6564 5f73 7472 203d 2022 220a  efixed_str = "".
+00009860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009870: 2020 2020 6772 6f75 7062 795f 6772 6f75      groupby_grou
+00009880: 7062 795f 7072 6566 6978 6564 5f73 7472  pby_prefixed_str
+00009890: 203d 2022 220a 2020 2020 2020 2020 2020   = "".          
+000098a0: 2020 2020 2020 2020 2020 6772 6f75 7062            groupb
+000098b0: 795f 6669 6c74 6572 5f73 7472 203d 2022  y_filter_str = "
+000098c0: 220a 0a20 2020 2020 2020 2020 2020 2020  "..             
+000098d0: 2020 2023 2050 7265 7061 7265 2073 7472     # Prepare str
+000098e0: 696e 6773 2074 6f20 7573 6520 696e 2073  ings to use in s
+000098f0: 656c 6563 7420 6261 7365 6420 6f6e 2061  elect based on a
+00009900: 6767 5f63 6f6c 756d 6e73 0a20 2020 2020  gg_columns.     
+00009910: 2020 2020 2020 2020 2020 2061 6767 5f63             agg_c
+00009920: 6f6c 756d 6e73 5f73 7472 203d 2022 220a  olumns_str = "".
+00009930: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009940: 6966 2061 6767 5f63 6f6c 756d 6e73 2069  if agg_columns i
+00009950: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00009960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009970: 6966 2022 6a73 6f6e 2220 696e 2061 6767  if "json" in agg
+00009980: 5f63 6f6c 756d 6e73 3a0a 2020 2020 2020  _columns:.      
+00009990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000099a0: 2020 2320 5468 6520 6167 6772 6567 6174    # The aggregat
+000099b0: 696f 6e20 6973 2074 6f20 6120 6a73 6f6e  ion is to a json
+000099c0: 2063 6f6c 756d 6e2c 2073 6f20 6164 640a   column, so add.
+000099d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000099e0: 2020 2020 2020 2020 6167 675f 636f 6c75          agg_colu
+000099f0: 6d6e 735f 7374 7220 2b3d 2028 0a20 2020  mns_str += (.   
+00009a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009a10: 2020 2020 2020 2020 2022 2c6a 736f 6e5f           ",json_
+00009a20: 6772 6f75 705f 6172 7261 7928 4449 5354  group_array(DIST
+00009a30: 494e 4354 206a 736f 6e5f 6461 7461 2e6a  INCT json_data.j
+00009a40: 736f 6e5f 726f 7729 2061 7320 6a73 6f6e  son_row) as json
+00009a50: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+00009a60: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00009a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009a80: 656c 6966 2022 636f 6c75 6d6e 7322 2069  elif "columns" i
+00009a90: 6e20 6167 675f 636f 6c75 6d6e 733a 0a20  n agg_columns:. 
+00009aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ab0: 2020 2020 2020 2066 6f72 2061 6767 5f63         for agg_c
+00009ac0: 6f6c 756d 6e20 696e 2061 6767 5f63 6f6c  olumn in agg_col
+00009ad0: 756d 6e73 5b22 636f 6c75 6d6e 7322 5d3a  umns["columns"]:
 00009ae0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009af0: 2020 2020 2067 726f 7570 6279 5f66 696c       groupby_fil
-00009b00: 7465 725f 6c69 7374 203d 205b 0d0a 2020  ter_list = [..  
+00009af0: 2020 2020 2020 2020 2020 2020 2023 2049               # I
+00009b00: 6e69 740a 2020 2020 2020 2020 2020 2020  nit.            
 00009b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b20: 2020 2020 2020 6627 2041 4e44 2067 656f        f' AND geo
-00009b30: 5f64 6174 612e 227b 636f 6c75 6d6e 7d22  _data."{column}"
-00009b40: 203d 206a 736f 6e5f 6461 7461 2e22 7b63   = json_data."{c
-00009b50: 6f6c 756d 6e7d 2227 0d0a 2020 2020 2020  olumn}"'..      
-00009b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b70: 2020 666f 7220 636f 6c75 6d6e 2069 6e20    for column in 
-00009b80: 6772 6f75 7062 795f 636f 6c75 6d6e 730d  groupby_columns.
-00009b90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009ba0: 2020 2020 205d 0d0a 2020 2020 2020 2020       ]..        
-00009bb0: 2020 2020 2020 2020 2020 2020 6772 6f75              grou
-00009bc0: 7062 795f 6669 6c74 6572 5f73 7472 203d  pby_filter_str =
-00009bd0: 2022 2022 2e6a 6f69 6e28 6772 6f75 7062   " ".join(groupb
-00009be0: 795f 6669 6c74 6572 5f6c 6973 7429 0d0a  y_filter_list)..
-00009bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c00: 656c 7365 3a0d 0a20 2020 2020 2020 2020  else:..         
-00009c10: 2020 2020 2020 2020 2020 2067 726f 7570             group
-00009c20: 6279 5f73 656c 6563 745f 7072 6566 6978  by_select_prefix
-00009c30: 6564 5f73 7472 203d 2022 220d 0a20 2020  ed_str = ""..   
-00009c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c50: 2067 726f 7570 6279 5f67 726f 7570 6279   groupby_groupby
-00009c60: 5f70 7265 6669 7865 645f 7374 7220 3d20  _prefixed_str = 
-00009c70: 2222 0d0a 2020 2020 2020 2020 2020 2020  ""..            
-00009c80: 2020 2020 2020 2020 6772 6f75 7062 795f          groupby_
-00009c90: 6669 6c74 6572 5f73 7472 203d 2022 220d  filter_str = "".
-00009ca0: 0a0d 0a20 2020 2020 2020 2020 2020 2020  ...             
-00009cb0: 2020 2023 2050 7265 7061 7265 2073 7472     # Prepare str
-00009cc0: 696e 6773 2074 6f20 7573 6520 696e 2073  ings to use in s
-00009cd0: 656c 6563 7420 6261 7365 6420 6f6e 2061  elect based on a
-00009ce0: 6767 5f63 6f6c 756d 6e73 0d0a 2020 2020  gg_columns..    
-00009cf0: 2020 2020 2020 2020 2020 2020 6167 675f              agg_
-00009d00: 636f 6c75 6d6e 735f 7374 7220 3d20 2222  columns_str = ""
-00009d10: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00009d20: 2020 6966 2061 6767 5f63 6f6c 756d 6e73    if agg_columns
-00009d30: 2069 7320 6e6f 7420 4e6f 6e65 3a0d 0a20   is not None:.. 
-00009d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009d50: 2020 2069 6620 226a 736f 6e22 2069 6e20     if "json" in 
-00009d60: 6167 675f 636f 6c75 6d6e 733a 0d0a 2020  agg_columns:..  
-00009d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009d80: 2020 2020 2020 2320 5468 6520 6167 6772        # The aggr
-00009d90: 6567 6174 696f 6e20 6973 2074 6f20 6120  egation is to a 
-00009da0: 6a73 6f6e 2063 6f6c 756d 6e2c 2073 6f20  json column, so 
-00009db0: 6164 640d 0a20 2020 2020 2020 2020 2020  add..           
-00009dc0: 2020 2020 2020 2020 2020 2020 2061 6767               agg
-00009dd0: 5f63 6f6c 756d 6e73 5f73 7472 202b 3d20  _columns_str += 
-00009de0: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-00009df0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00009e00: 2c6a 736f 6e5f 6772 6f75 705f 6172 7261  ,json_group_arra
-00009e10: 7928 4449 5354 494e 4354 206a 736f 6e5f  y(DISTINCT json_
-00009e20: 6461 7461 2e6a 736f 6e5f 726f 7729 2061  data.json_row) a
-00009e30: 7320 6a73 6f6e 220d 0a20 2020 2020 2020  s json"..       
-00009e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009e50: 2029 0d0a 2020 2020 2020 2020 2020 2020   )..            
-00009e60: 2020 2020 2020 2020 656c 6966 2022 636f          elif "co
-00009e70: 6c75 6d6e 7322 2069 6e20 6167 675f 636f  lumns" in agg_co
-00009e80: 6c75 6d6e 733a 0d0a 2020 2020 2020 2020  lumns:..        
-00009e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ea0: 666f 7220 6167 675f 636f 6c75 6d6e 2069  for agg_column i
-00009eb0: 6e20 6167 675f 636f 6c75 6d6e 735b 2263  n agg_columns["c
-00009ec0: 6f6c 756d 6e73 225d 3a0d 0a20 2020 2020  olumns"]:..     
+00009b20: 6469 7374 696e 6374 5f73 7472 203d 2022  distinct_str = "
+00009b30: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+00009b40: 2020 2020 2020 2020 2020 2020 2020 6578                ex
+00009b50: 7472 615f 7061 7261 6d5f 7374 7220 3d20  tra_param_str = 
+00009b60: 2222 0a0a 2020 2020 2020 2020 2020 2020  ""..            
+00009b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b80: 2320 5072 6570 6172 6520 6167 6772 6567  # Prepare aggreg
+00009b90: 6174 696f 6e20 6b65 7977 6f72 642e 0a20  ation keyword.. 
+00009ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009bb0: 2020 2020 2020 2020 2020 2069 6620 6167             if ag
+00009bc0: 675f 636f 6c75 6d6e 5b22 6167 6722 5d2e  g_column["agg"].
+00009bd0: 6c6f 7765 7228 2920 696e 205b 0a20 2020  lower() in [.   
+00009be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009bf0: 2020 2020 2020 2020 2020 2020 2022 636f               "co
+00009c00: 756e 7422 2c0a 2020 2020 2020 2020 2020  unt",.          
+00009c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c20: 2020 2020 2020 2273 756d 222c 0a20 2020        "sum",.   
+00009c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c40: 2020 2020 2020 2020 2020 2020 2022 6d69               "mi
+00009c50: 6e22 2c0a 2020 2020 2020 2020 2020 2020  n",.            
+00009c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c70: 2020 2020 226d 6178 222c 0a20 2020 2020      "max",.     
+00009c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c90: 2020 2020 2020 2020 2020 2022 6d65 6469             "medi
+00009ca0: 616e 222c 0a20 2020 2020 2020 2020 2020  an",.           
+00009cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009cc0: 205d 3a0a 2020 2020 2020 2020 2020 2020   ]:.            
+00009cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ce0: 2020 2020 6167 6772 6567 6174 696f 6e5f      aggregation_
+00009cf0: 7374 7220 3d20 6167 675f 636f 6c75 6d6e  str = agg_column
+00009d00: 5b22 6167 6722 5d0a 2020 2020 2020 2020  ["agg"].        
+00009d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009d20: 2020 2020 656c 6966 2061 6767 5f63 6f6c      elif agg_col
+00009d30: 756d 6e5b 2261 6767 225d 2e6c 6f77 6572  umn["agg"].lower
+00009d40: 2829 2069 6e20 5b22 6d65 616e 222c 2022  () in ["mean", "
+00009d50: 6176 6722 5d3a 0a20 2020 2020 2020 2020  avg"]:.         
+00009d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009d70: 2020 2020 2020 2061 6767 7265 6761 7469         aggregati
+00009d80: 6f6e 5f73 7472 203d 2022 6176 6722 0a20  on_str = "avg". 
+00009d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009da0: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
+00009db0: 6167 675f 636f 6c75 6d6e 5b22 6167 6722  agg_column["agg"
+00009dc0: 5d2e 6c6f 7765 7228 2920 3d3d 2022 636f  ].lower() == "co
+00009dd0: 6e63 6174 223a 0a20 2020 2020 2020 2020  ncat":.         
+00009de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009df0: 2020 2020 2020 2061 6767 7265 6761 7469         aggregati
+00009e00: 6f6e 5f73 7472 203d 2022 6772 6f75 705f  on_str = "group_
+00009e10: 636f 6e63 6174 220a 2020 2020 2020 2020  concat".        
+00009e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e30: 2020 2020 2020 2020 6966 2022 7365 7022          if "sep"
+00009e40: 2069 6e20 6167 675f 636f 6c75 6d6e 3a0a   in agg_column:.
+00009e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e70: 2020 2020 6578 7472 615f 7061 7261 6d5f      extra_param_
+00009e80: 7374 7220 3d20 6622 2c20 277b 6167 675f  str = f", '{agg_
+00009e90: 636f 6c75 6d6e 5b27 7365 7027 5d7d 2722  column['sep']}'"
+00009ea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009eb0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+00009ec0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
 00009ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ee0: 2020 2020 2020 2023 2049 6e69 740d 0a20         # Init.. 
-00009ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f00: 2020 2020 2020 2020 2020 2064 6973 7469             disti
-00009f10: 6e63 745f 7374 7220 3d20 2222 0d0a 2020  nct_str = ""..  
-00009f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f30: 2020 2020 2020 2020 2020 6578 7472 615f            extra_
-00009f40: 7061 7261 6d5f 7374 7220 3d20 2222 0d0a  param_str = ""..
-00009f50: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00009f60: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00009f70: 5072 6570 6172 6520 6167 6772 6567 6174  Prepare aggregat
-00009f80: 696f 6e20 6b65 7977 6f72 642e 0d0a 2020  ion keyword...  
-00009f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009fa0: 2020 2020 2020 2020 2020 6966 2061 6767            if agg
-00009fb0: 5f63 6f6c 756d 6e5b 2261 6767 225d 2e6c  _column["agg"].l
-00009fc0: 6f77 6572 2829 2069 6e20 5b0d 0a20 2020  ower() in [..   
-00009fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009fe0: 2020 2020 2020 2020 2020 2020 2022 636f               "co
-00009ff0: 756e 7422 2c0d 0a20 2020 2020 2020 2020  unt",..         
-0000a000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a010: 2020 2020 2020 2022 7375 6d22 2c0d 0a20         "sum",.. 
+00009ee0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+00009ef0: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
+00009f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f10: 2020 2020 2020 2020 2066 2261 6767 7265           f"aggre
+00009f20: 6761 7469 6f6e 207b 6167 675f 636f 6c75  gation {agg_colu
+00009f30: 6d6e 5b27 6167 6727 5d7d 2069 7320 6e6f  mn['agg']} is no
+00009f40: 7420 7375 7070 6f72 7465 6422 0a20 2020  t supported".   
+00009f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f60: 2020 2020 2020 2020 2020 2020 2029 0a0a               )..
+00009f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f80: 2020 2020 2020 2020 2020 2020 2320 4966              # If
+00009f90: 2064 6973 7469 6e63 7420 6973 2073 7065   distinct is spe
+00009fa0: 6369 6669 6564 2c20 6164 6420 7468 6520  cified, add the 
+00009fb0: 6469 7374 696e 6374 206b 6579 776f 7264  distinct keyword
+00009fc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009fd0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00009fe0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00009ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a000: 2020 2264 6973 7469 6e63 7422 2069 6e20    "distinct" in 
+0000a010: 6167 675f 636f 6c75 6d6e 0a20 2020 2020  agg_column.     
 0000a020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a030: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-0000a040: 6d69 6e22 2c0d 0a20 2020 2020 2020 2020  min",..         
-0000a050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a060: 2020 2020 2020 2022 6d61 7822 2c0d 0a20         "max",.. 
-0000a070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a080: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-0000a090: 6d65 6469 616e 222c 0d0a 2020 2020 2020  median",..      
-0000a0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0b0: 2020 2020 2020 5d3a 0d0a 2020 2020 2020        ]:..      
+0000a030: 2020 2020 2020 2020 2020 2061 6e64 2061             and a
+0000a040: 6767 5f63 6f6c 756d 6e5b 2264 6973 7469  gg_column["disti
+0000a050: 6e63 7422 5d20 6973 2054 7275 650a 2020  nct"] is True.  
+0000a060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a070: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
+0000a080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a090: 2020 2020 2020 2020 2020 2020 2064 6973               dis
+0000a0a0: 7469 6e63 745f 7374 7220 3d20 2244 4953  tinct_str = "DIS
+0000a0b0: 5449 4e43 5420 220a 0a20 2020 2020 2020  TINCT "..       
 0000a0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0d0: 2020 2020 2020 2020 2020 6167 6772 6567            aggreg
-0000a0e0: 6174 696f 6e5f 7374 7220 3d20 6167 675f  ation_str = agg_
-0000a0f0: 636f 6c75 6d6e 5b22 6167 6722 5d0d 0a20  column["agg"].. 
-0000a100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a110: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
-0000a120: 6167 675f 636f 6c75 6d6e 5b22 6167 6722  agg_column["agg"
-0000a130: 5d2e 6c6f 7765 7228 2920 696e 205b 226d  ].lower() in ["m
-0000a140: 6561 6e22 2c20 2261 7667 225d 3a0d 0a20  ean", "avg"]:.. 
-0000a150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a160: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0000a170: 6767 7265 6761 7469 6f6e 5f73 7472 203d  ggregation_str =
-0000a180: 2022 6176 6722 0d0a 2020 2020 2020 2020   "avg"..        
-0000a190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a1a0: 2020 2020 656c 6966 2061 6767 5f63 6f6c      elif agg_col
-0000a1b0: 756d 6e5b 2261 6767 225d 2e6c 6f77 6572  umn["agg"].lower
-0000a1c0: 2829 203d 3d20 2263 6f6e 6361 7422 3a0d  () == "concat":.
-0000a1d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a1f0: 2061 6767 7265 6761 7469 6f6e 5f73 7472   aggregation_str
-0000a200: 203d 2022 6772 6f75 705f 636f 6e63 6174   = "group_concat
-0000a210: 220d 0a20 2020 2020 2020 2020 2020 2020  "..             
-0000a220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a230: 2020 2069 6620 2273 6570 2220 696e 2061     if "sep" in a
-0000a240: 6767 5f63 6f6c 756d 6e3a 0d0a 2020 2020  gg_column:..    
-0000a250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a270: 6578 7472 615f 7061 7261 6d5f 7374 7220  extra_param_str 
-0000a280: 3d20 6622 2c20 277b 6167 675f 636f 6c75  = f", '{agg_colu
-0000a290: 6d6e 5b27 7365 7027 5d7d 2722 0d0a 2020  mn['sep']}'"..  
-0000a2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a2b0: 2020 2020 2020 2020 2020 656c 7365 3a0d            else:.
-0000a2c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a0d0: 2020 2020 2023 2050 7265 7061 7265 2063       # Prepare c
+0000a0e0: 6f6c 756d 6e20 6e61 6d65 2073 7472 696e  olumn name strin
+0000a0f0: 672e 0a20 2020 2020 2020 2020 2020 2020  g..             
+0000a100: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0000a110: 6f6c 756d 6e5f 7374 7220 3d20 280a 2020  olumn_str = (.  
+0000a120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a130: 2020 2020 2020 2020 2020 2020 2020 226a                "j
+0000a140: 736f 6e5f 6578 7472 6163 7428 6a73 6f6e  son_extract(json
+0000a150: 5f64 6174 612e 6a73 6f6e 5f72 6f77 2c20  _data.json_row, 
+0000a160: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0000a170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a180: 2020 6627 2224 2e7b 6167 675f 636f 6c75    f'"$.{agg_colu
+0000a190: 6d6e 5b22 636f 6c75 6d6e 225d 7d22 2927  mn["column"]}")'
+0000a1a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a1b0: 2020 2020 2020 2020 2020 2020 2029 0a0a               )..
+0000a1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a1d0: 2020 2020 2020 2020 2020 2020 2320 4e6f              # No
+0000a1e0: 7720 7075 7420 6576 6572 7974 6869 6e67  w put everything
+0000a1f0: 2074 6f67 6574 6865 720a 2020 2020 2020   together.      
+0000a200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a210: 2020 2020 2020 6167 675f 636f 6c75 6d6e        agg_column
+0000a220: 735f 7374 7220 2b3d 2028 0a20 2020 2020  s_str += (.     
+0000a230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a240: 2020 2020 2020 2020 2020 2066 222c 207b             f", {
+0000a250: 6167 6772 6567 6174 696f 6e5f 7374 727d  aggregation_str}
+0000a260: 287b 6469 7374 696e 6374 5f73 7472 7d7b  ({distinct_str}{
+0000a270: 636f 6c75 6d6e 5f73 7472 7d22 0a20 2020  column_str}".   
+0000a280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a290: 2020 2020 2020 2020 2020 2020 2066 277b               f'{
+0000a2a0: 6578 7472 615f 7061 7261 6d5f 7374 727d  extra_param_str}
+0000a2b0: 2920 4153 2022 7b61 6767 5f63 6f6c 756d  ) AS "{agg_colum
+0000a2c0: 6e5b 2261 7322 5d7d 2227 0a20 2020 2020  n["as"]}"'.     
 0000a2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a2e0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0000a2f0: 7228 0d0a 2020 2020 2020 2020 2020 2020  r(..            
-0000a300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a310: 2020 2020 2020 2020 6622 6167 6772 6567          f"aggreg
-0000a320: 6174 696f 6e20 7b61 6767 5f63 6f6c 756d  ation {agg_colum
-0000a330: 6e5b 2761 6767 275d 7d20 6973 206e 6f74  n['agg']} is not
-0000a340: 2073 7570 706f 7274 6564 220d 0a20 2020   supported"..   
-0000a350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a360: 2020 2020 2020 2020 2020 2020 2029 0d0a               )..
-0000a370: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000a380: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000a390: 4966 2064 6973 7469 6e63 7420 6973 2073  If distinct is s
-0000a3a0: 7065 6369 6669 6564 2c20 6164 6420 7468  pecified, add th
-0000a3b0: 6520 6469 7374 696e 6374 206b 6579 776f  e distinct keywo
-0000a3c0: 7264 0d0a 2020 2020 2020 2020 2020 2020  rd..            
-0000a3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a3e0: 6966 2028 0d0a 2020 2020 2020 2020 2020  if (..          
-0000a3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a400: 2020 2020 2020 2264 6973 7469 6e63 7422        "distinct"
-0000a410: 2069 6e20 6167 675f 636f 6c75 6d6e 0d0a   in agg_column..
-0000a420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a440: 616e 6420 6167 675f 636f 6c75 6d6e 5b22  and agg_column["
-0000a450: 6469 7374 696e 6374 225d 2069 7320 5472  distinct"] is Tr
-0000a460: 7565 0d0a 2020 2020 2020 2020 2020 2020  ue..            
-0000a470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a480: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-0000a490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a4a0: 2020 2020 6469 7374 696e 6374 5f73 7472      distinct_str
-0000a4b0: 203d 2022 4449 5354 494e 4354 2022 0d0a   = "DISTINCT "..
-0000a4c0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000a4d0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000a4e0: 5072 6570 6172 6520 636f 6c75 6d6e 206e  Prepare column n
-0000a4f0: 616d 6520 7374 7269 6e67 2e0d 0a20 2020  ame string...   
-0000a500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a510: 2020 2020 2020 2020 2063 6f6c 756d 6e5f           column_
-0000a520: 7374 7220 3d20 280d 0a20 2020 2020 2020  str = (..       
-0000a530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a540: 2020 2020 2020 2020 2022 6a73 6f6e 5f65           "json_e
-0000a550: 7874 7261 6374 286a 736f 6e5f 6461 7461  xtract(json_data
-0000a560: 2e6a 736f 6e5f 726f 772c 2022 0d0a 2020  .json_row, "..  
-0000a570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a580: 2020 2020 2020 2020 2020 2020 2020 6627                f'
-0000a590: 2224 2e7b 6167 675f 636f 6c75 6d6e 5b22  "$.{agg_column["
-0000a5a0: 636f 6c75 6d6e 225d 7d22 2927 0d0a 2020  column"]}")'..  
-0000a5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a5c0: 2020 2020 2020 2020 2020 290d 0a0d 0a20            ).... 
-0000a5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a5e0: 2020 2020 2020 2020 2020 2023 204e 6f77             # Now
-0000a5f0: 2070 7574 2065 7665 7279 7468 696e 6720   put everything 
-0000a600: 746f 6765 7468 6572 0d0a 2020 2020 2020  together..      
-0000a610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a620: 2020 2020 2020 6167 675f 636f 6c75 6d6e        agg_column
-0000a630: 735f 7374 7220 2b3d 2028 0d0a 2020 2020  s_str += (..    
+0000a2e0: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+0000a2f0: 2020 2020 2020 2020 2020 2320 4164 6420            # Add 
+0000a300: 6120 636f 6c75 6d6e 2074 6f20 6f72 6465  a column to orde
+0000a310: 7220 7468 6520 7265 7375 6c74 2062 7920  r the result by 
+0000a320: 746f 2065 7661 6465 2068 6176 696e 6720  to evade having 
+0000a330: 616c 6c0a 2020 2020 2020 2020 2020 2020  all.            
+0000a340: 2020 2020 2320 636f 6d70 6c65 7820 6765      # complex ge
+0000a350: 6f6d 6574 7269 6573 2074 6f67 6574 6865  ometries togethe
+0000a360: 7220 696e 2074 6865 206f 7574 7075 7420  r in the output 
+0000a370: 6669 6c65 2e0a 2020 2020 2020 2020 2020  file..          
+0000a380: 2020 2020 2020 6f72 6465 7262 795f 636f        orderby_co
+0000a390: 6c75 6d6e 203d 2022 7465 6d70 5f6f 7264  lumn = "temp_ord
+0000a3a0: 6572 636f 6c75 6d6e 5f67 656f 6861 7368  ercolumn_geohash
+0000a3b0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0000a3c0: 2020 5f61 6464 5f6f 7264 6572 6279 5f63    _add_orderby_c
+0000a3d0: 6f6c 756d 6e28 0a20 2020 2020 2020 2020  olumn(.         
+0000a3e0: 2020 2020 2020 2020 2020 2070 6174 683d             path=
+0000a3f0: 6f75 7470 7574 5f74 6d70 5f70 6174 682c  output_tmp_path,
+0000a400: 206c 6179 6572 3d6f 7574 7075 745f 6c61   layer=output_la
+0000a410: 7965 722c 206e 616d 653d 6f72 6465 7262  yer, name=orderb
+0000a420: 795f 636f 6c75 6d6e 0a20 2020 2020 2020  y_column.       
+0000a430: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+0000a440: 2020 2020 2020 2020 2020 2020 2320 5072              # Pr
+0000a450: 6570 6172 6520 5351 4c20 7374 6174 656d  epare SQL statem
+0000a460: 656e 7420 666f 7220 6669 6e61 6c20 6f75  ent for final ou
+0000a470: 7470 7574 2066 696c 652e 0a20 2020 2020  tput file..     
+0000a480: 2020 2020 2020 2020 2020 2023 2041 6c6c             # All
+0000a490: 2074 696c 6573 2061 7265 2061 6c72 6561   tiles are alrea
+0000a4a0: 6479 2064 6973 736f 6c76 6564 2074 6f20  dy dissolved to 
+0000a4b0: 6772 6f75 7073 2c20 6275 7420 6e6f 7720  groups, but now 
+0000a4c0: 7468 650a 2020 2020 2020 2020 2020 2020  the.            
+0000a4d0: 2020 2020 2320 7265 7375 6c74 7320 6672      # results fr
+0000a4e0: 6f6d 2061 6c6c 2074 696c 6573 2073 7469  om all tiles sti
+0000a4f0: 6c6c 206e 6565 6420 746f 2062 650a 2020  ll need to be.  
+0000a500: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0000a510: 6772 6f75 7065 642f 636f 6c6c 6563 7465  grouped/collecte
+0000a520: 6420 746f 6765 7468 6572 2e0a 2020 2020  d together..    
+0000a530: 2020 2020 2020 2020 2020 2020 6c6f 6767              logg
+0000a540: 6572 2e69 6e66 6f28 2250 6f73 7470 726f  er.info("Postpro
+0000a550: 6365 7373 2070 7265 7061 7265 6420 6665  cess prepared fe
+0000a560: 6174 7572 6573 2e2e 2e22 290a 2020 2020  atures...").    
+0000a570: 2020 2020 2020 2020 2020 2020 6966 2061              if a
+0000a580: 6767 5f63 6f6c 756d 6e73 2069 7320 4e6f  gg_columns is No
+0000a590: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+0000a5a0: 2020 2020 2020 2020 2320 4966 2074 6865          # If the
+0000a5b0: 7265 2061 7265 206e 6f20 6167 6772 6567  re are no aggreg
+0000a5c0: 6174 696f 6e20 636f 6c75 6d6e 732c 2074  ation columns, t
+0000a5d0: 6869 6e67 7320 6172 6520 6e6f 7420 746f  hings are not to
+0000a5e0: 6f0a 2020 2020 2020 2020 2020 2020 2020  o.              
+0000a5f0: 2020 2020 2020 2320 636f 6d70 6c69 6361        # complica
+0000a600: 7465 642e 0a20 2020 2020 2020 2020 2020  ted..           
+0000a610: 2020 2020 2020 2020 2069 6620 6578 706c           if expl
+0000a620: 6f64 6563 6f6c 6c65 6374 696f 6e73 2069  odecollections i
+0000a630: 7320 5472 7565 3a0a 2020 2020 2020 2020  s True:.        
 0000a640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a650: 2020 2020 2020 2020 2020 2020 6622 2c20              f", 
-0000a660: 7b61 6767 7265 6761 7469 6f6e 5f73 7472  {aggregation_str
-0000a670: 7d28 7b64 6973 7469 6e63 745f 7374 727d  }({distinct_str}
-0000a680: 7b63 6f6c 756d 6e5f 7374 727d 220d 0a20  {column_str}".. 
-0000a690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6a0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0000a6b0: 277b 6578 7472 615f 7061 7261 6d5f 7374  '{extra_param_st
-0000a6c0: 727d 2920 4153 2022 7b61 6767 5f63 6f6c  r}) AS "{agg_col
-0000a6d0: 756d 6e5b 2261 7322 5d7d 2227 0d0a 2020  umn["as"]}"'..  
-0000a6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6f0: 2020 2020 2020 2020 2020 290d 0a0d 0a20            ).... 
-0000a700: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000a710: 2041 6464 2061 2063 6f6c 756d 6e20 746f   Add a column to
-0000a720: 206f 7264 6572 2074 6865 2072 6573 756c   order the resul
-0000a730: 7420 6279 2074 6f20 6576 6164 6520 6861  t by to evade ha
-0000a740: 7669 6e67 2061 6c6c 0d0a 2020 2020 2020  ving all..      
-0000a750: 2020 2020 2020 2020 2020 2320 636f 6d70            # comp
-0000a760: 6c65 7820 6765 6f6d 6574 7269 6573 2074  lex geometries t
-0000a770: 6f67 6574 6865 7220 696e 2074 6865 206f  ogether in the o
-0000a780: 7574 7075 7420 6669 6c65 2e0d 0a20 2020  utput file...   
-0000a790: 2020 2020 2020 2020 2020 2020 206f 7264               ord
-0000a7a0: 6572 6279 5f63 6f6c 756d 6e20 3d20 2274  erby_column = "t
-0000a7b0: 656d 705f 6f72 6465 7263 6f6c 756d 6e5f  emp_ordercolumn_
-0000a7c0: 6765 6f68 6173 6822 0d0a 2020 2020 2020  geohash"..      
-0000a7d0: 2020 2020 2020 2020 2020 5f61 6464 5f6f            _add_o
-0000a7e0: 7264 6572 6279 5f63 6f6c 756d 6e28 0d0a  rderby_column(..
-0000a7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a800: 2020 2020 7061 7468 3d6f 7574 7075 745f      path=output_
-0000a810: 746d 705f 7061 7468 2c20 6c61 7965 723d  tmp_path, layer=
-0000a820: 6f75 7470 7574 5f6c 6179 6572 2c20 6e61  output_layer, na
-0000a830: 6d65 3d6f 7264 6572 6279 5f63 6f6c 756d  me=orderby_colum
-0000a840: 6e0d 0a20 2020 2020 2020 2020 2020 2020  n..             
-0000a850: 2020 2029 0d0a 0d0a 2020 2020 2020 2020     )....        
-0000a860: 2020 2020 2020 2020 2320 5072 6570 6172          # Prepar
-0000a870: 6520 5351 4c20 7374 6174 656d 656e 7420  e SQL statement 
-0000a880: 666f 7220 6669 6e61 6c20 6f75 7470 7574  for final output
-0000a890: 2066 696c 652e 0d0a 2020 2020 2020 2020   file...        
-0000a8a0: 2020 2020 2020 2020 2320 416c 6c20 7469          # All ti
-0000a8b0: 6c65 7320 6172 6520 616c 7265 6164 7920  les are already 
-0000a8c0: 6469 7373 6f6c 7665 6420 746f 2067 726f  dissolved to gro
-0000a8d0: 7570 732c 2062 7574 206e 6f77 2074 6865  ups, but now the
-0000a8e0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000a8f0: 2020 2320 7265 7375 6c74 7320 6672 6f6d    # results from
-0000a900: 2061 6c6c 2074 696c 6573 2073 7469 6c6c   all tiles still
-0000a910: 206e 6565 6420 746f 2062 650d 0a20 2020   need to be..   
-0000a920: 2020 2020 2020 2020 2020 2020 2023 2067               # g
-0000a930: 726f 7570 6564 2f63 6f6c 6c65 6374 6564  rouped/collected
-0000a940: 2074 6f67 6574 6865 722e 0d0a 2020 2020   together...    
-0000a950: 2020 2020 2020 2020 2020 2020 6c6f 6767              logg
-0000a960: 6572 2e69 6e66 6f28 2250 6f73 7470 726f  er.info("Postpro
-0000a970: 6365 7373 2070 7265 7061 7265 6420 6665  cess prepared fe
-0000a980: 6174 7572 6573 2e2e 2e22 290d 0a20 2020  atures...")..   
-0000a990: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000a9a0: 6167 675f 636f 6c75 6d6e 7320 6973 204e  agg_columns is N
-0000a9b0: 6f6e 653a 0d0a 2020 2020 2020 2020 2020  one:..          
-0000a9c0: 2020 2020 2020 2020 2020 2320 4966 2074            # If t
-0000a9d0: 6865 7265 2061 7265 206e 6f20 6167 6772  here are no aggr
-0000a9e0: 6567 6174 696f 6e20 636f 6c75 6d6e 732c  egation columns,
-0000a9f0: 2074 6869 6e67 7320 6172 6520 6e6f 7420   things are not 
-0000aa00: 746f 6f0d 0a20 2020 2020 2020 2020 2020  too..           
-0000aa10: 2020 2020 2020 2020 2023 2063 6f6d 706c           # compl
-0000aa20: 6963 6174 6564 2e0d 0a20 2020 2020 2020  icated...       
-0000aa30: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000aa40: 6578 706c 6f64 6563 6f6c 6c65 6374 696f  explodecollectio
-0000aa50: 6e73 2069 7320 5472 7565 3a0d 0a20 2020  ns is True:..   
-0000aa60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa70: 2020 2020 2023 2049 6620 6578 706c 6f64       # If explod
-0000aa80: 6563 6f6c 6c65 6374 696f 6e73 2069 7320  ecollections is 
-0000aa90: 7472 7565 2c20 6974 2069 7320 7573 656c  true, it is usel
-0000aaa0: 6573 7320 746f 0d0a 2020 2020 2020 2020  ess to..        
-0000aab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aac0: 2320 6669 7273 7420 6772 6f75 7020 7468  # first group th
-0000aad0: 656d 2068 6572 652c 2061 7320 7468 6579  em here, as they
-0000aae0: 2077 696c 6c20 6265 2065 7870 6c6f 6465   will be explode
-0000aaf0: 6420 6167 6169 6e0d 0a20 2020 2020 2020  d again..       
+0000a650: 2320 4966 2065 7870 6c6f 6465 636f 6c6c  # If explodecoll
+0000a660: 6563 7469 6f6e 7320 6973 2074 7275 652c  ections is true,
+0000a670: 2069 7420 6973 2075 7365 6c65 7373 2074   it is useless t
+0000a680: 6f0a 2020 2020 2020 2020 2020 2020 2020  o.              
+0000a690: 2020 2020 2020 2020 2020 2320 6669 7273            # firs
+0000a6a0: 7420 6772 6f75 7020 7468 656d 2068 6572  t group them her
+0000a6b0: 652c 2061 7320 7468 6579 2077 696c 6c20  e, as they will 
+0000a6c0: 6265 2065 7870 6c6f 6465 6420 6167 6169  be exploded agai
+0000a6d0: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
+0000a6e0: 2020 2020 2020 2020 2020 2320 696e 2074            # in t
+0000a6f0: 6865 2073 656c 6563 7428 2920 6361 6c6c  he select() call
+0000a700: 206c 6174 6572 206f 6e2e 2e2e 2073 6f20   later on... so 
+0000a710: 6a75 7374 206f 7264 6572 2074 6865 6d2e  just order them.
+0000a720: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a730: 2020 2020 2020 2020 2023 2049 6620 6120           # If a 
+0000a740: 7469 6c65 6420 7265 7375 6c74 2069 7320  tiled result is 
+0000a750: 6173 6b65 642c 2061 6c73 6f20 646f 6e27  asked, also don'
+0000a760: 7420 636f 6c6c 6563 742e 0a20 2020 2020  t collect..     
+0000a770: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a780: 2020 2073 716c 5f73 746d 7420 3d20 6622     sql_stmt = f"
+0000a790: 2222 0a20 2020 2020 2020 2020 2020 2020  "".             
+0000a7a0: 2020 2020 2020 2020 2020 2020 2020 2053                 S
+0000a7b0: 454c 4543 5420 7b7b 6765 6f6d 6574 7279  ELECT {{geometry
+0000a7c0: 636f 6c75 6d6e 7d7d 0a20 2020 2020 2020  column}}.       
+0000a7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a7e0: 2020 2020 2020 2020 2020 207b 6772 6f75             {grou
+0000a7f0: 7062 795f 7365 6c65 6374 5f70 7265 6669  pby_select_prefi
+0000a800: 7865 645f 7374 722e 666f 726d 6174 2870  xed_str.format(p
+0000a810: 7265 6669 783d 226c 6179 6572 2e22 297d  refix="layer.")}
+0000a820: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a830: 2020 2020 2020 2020 2020 2020 2020 2046                 F
+0000a840: 524f 4d20 227b 7b69 6e70 7574 5f6c 6179  ROM "{{input_lay
+0000a850: 6572 7d7d 2220 6c61 7965 720a 2020 2020  er}}" layer.    
+0000a860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a870: 2020 2020 2020 2020 204f 5244 4552 2042           ORDER B
+0000a880: 5920 6c61 7965 722e 7b6f 7264 6572 6279  Y layer.{orderby
+0000a890: 5f63 6f6c 756d 6e7d 0a20 2020 2020 2020  _column}.       
+0000a8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a8b0: 2022 2222 0a20 2020 2020 2020 2020 2020   """.           
+0000a8c0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000a8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a8e0: 2020 2020 2020 2023 204e 6f20 6578 706c         # No expl
+0000a8f0: 6f64 6563 6f6c 6c65 6374 696f 6e73 2c20  odecollections, 
+0000a900: 736f 2063 6f6c 6c65 6374 2074 6f20 6f6e  so collect to on
+0000a910: 6520 6765 6f6d 6574 7279 0a20 2020 2020  e geometry.     
+0000a920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a930: 2020 2023 2028 7065 7220 6772 6f75 7062     # (per groupb
+0000a940: 7920 6966 2061 7070 6c69 6361 626c 6529  y if applicable)
+0000a950: 2e0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0000a960: 2020 2020 2020 2020 2020 7371 6c5f 7374            sql_st
+0000a970: 6d74 203d 2066 2222 220a 2020 2020 2020  mt = f""".      
+0000a980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a990: 2020 2020 2020 5345 4c45 4354 2053 545f        SELECT ST_
+0000a9a0: 436f 6c6c 6563 7428 7b7b 6765 6f6d 6574  Collect({{geomet
+0000a9b0: 7279 636f 6c75 6d6e 7d7d 2920 4153 207b  rycolumn}}) AS {
+0000a9c0: 7b67 656f 6d65 7472 7963 6f6c 756d 6e7d  {geometrycolumn}
+0000a9d0: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
+0000a9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a9f0: 2020 2020 7b67 726f 7570 6279 5f73 656c      {groupby_sel
+0000aa00: 6563 745f 7072 6566 6978 6564 5f73 7472  ect_prefixed_str
+0000aa10: 2e66 6f72 6d61 7428 7072 6566 6978 3d22  .format(prefix="
+0000aa20: 6c61 7965 722e 2229 7d0a 2020 2020 2020  layer.")}.      
+0000aa30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aa40: 2020 2020 2020 2020 4652 4f4d 2022 7b7b          FROM "{{
+0000aa50: 696e 7075 745f 6c61 7965 727d 7d22 206c  input_layer}}" l
+0000aa60: 6179 6572 0a20 2020 2020 2020 2020 2020  ayer.           
+0000aa70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aa80: 2020 207b 6772 6f75 7062 795f 6772 6f75     {groupby_grou
+0000aa90: 7062 795f 7072 6566 6978 6564 5f73 7472  pby_prefixed_str
+0000aaa0: 2e66 6f72 6d61 7428 7072 6566 6978 3d22  .format(prefix="
+0000aab0: 6c61 7965 722e 2229 7d0a 2020 2020 2020  layer.")}.      
+0000aac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aad0: 2020 2020 2020 204f 5244 4552 2042 5920         ORDER BY 
+0000aae0: 4d49 4e28 6c61 7965 722e 7b6f 7264 6572  MIN(layer.{order
+0000aaf0: 6279 5f63 6f6c 756d 6e7d 290a 2020 2020  by_column}).    
 0000ab00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab10: 2023 2069 6e20 7468 6520 7365 6c65 6374   # in the select
-0000ab20: 2829 2063 616c 6c20 6c61 7465 7220 6f6e  () call later on
-0000ab30: 2e2e 2e20 736f 206a 7573 7420 6f72 6465  ... so just orde
-0000ab40: 7220 7468 656d 2e0d 0a20 2020 2020 2020  r them...       
-0000ab50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab60: 2023 2049 6620 6120 7469 6c65 6420 7265   # If a tiled re
-0000ab70: 7375 6c74 2069 7320 6173 6b65 642c 2061  sult is asked, a
-0000ab80: 6c73 6f20 646f 6e27 7420 636f 6c6c 6563  lso don't collec
-0000ab90: 742e 0d0a 2020 2020 2020 2020 2020 2020  t...            
-0000aba0: 2020 2020 2020 2020 2020 2020 7371 6c5f              sql_
-0000abb0: 7374 6d74 203d 2066 2222 220d 0a20 2020  stmt = f"""..   
-0000abc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000abd0: 2020 2020 2020 2020 2053 454c 4543 5420           SELECT 
-0000abe0: 7b7b 6765 6f6d 6574 7279 636f 6c75 6d6e  {{geometrycolumn
-0000abf0: 7d7d 0d0a 2020 2020 2020 2020 2020 2020  }}..            
+0000ab10: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0000ab20: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000ab30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ab40: 2020 2320 4966 2061 6767 5f63 6f6c 756d    # If agg_colum
+0000ab50: 6e73 2073 7065 6369 6669 6564 2c20 706f  ns specified, po
+0000ab60: 7374 7072 6f63 6573 7369 6e67 2069 7320  stprocessing is 
+0000ab70: 6120 6269 7420 6d6f 7265 0a20 2020 2020  a bit more.     
+0000ab80: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000ab90: 2063 6f6d 706c 6963 6174 6564 2e0a 2020   complicated..  
+0000aba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000abb0: 2020 7371 6c5f 7374 6d74 203d 2066 2222    sql_stmt = f""
+0000abc0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0000abd0: 2020 2020 2020 2020 2020 5345 4c45 4354            SELECT
+0000abe0: 2067 656f 5f64 6174 612e 7b7b 6765 6f6d   geo_data.{{geom
+0000abf0: 6574 7279 636f 6c75 6d6e 7d7d 0a20 2020  etrycolumn}}.   
 0000ac00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac10: 2020 2020 2020 7b67 726f 7570 6279 5f73        {groupby_s
-0000ac20: 656c 6563 745f 7072 6566 6978 6564 5f73  elect_prefixed_s
-0000ac30: 7472 2e66 6f72 6d61 7428 7072 6566 6978  tr.format(prefix
-0000ac40: 3d22 6c61 7965 722e 2229 7d0d 0a20 2020  ="layer.")}..   
-0000ac50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac60: 2020 2020 2020 2020 2020 2046 524f 4d20             FROM 
-0000ac70: 227b 7b69 6e70 7574 5f6c 6179 6572 7d7d  "{{input_layer}}
-0000ac80: 2220 6c61 7965 720d 0a20 2020 2020 2020  " layer..       
-0000ac90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aca0: 2020 2020 2020 4f52 4445 5220 4259 206c        ORDER BY l
-0000acb0: 6179 6572 2e7b 6f72 6465 7262 795f 636f  ayer.{orderby_co
-0000acc0: 6c75 6d6e 7d0d 0a20 2020 2020 2020 2020  lumn}..         
-0000acd0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-0000ace0: 2222 0d0a 2020 2020 2020 2020 2020 2020  ""..            
-0000acf0: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
+0000ac10: 2020 2020 2020 2020 2020 207b 6772 6f75             {grou
+0000ac20: 7062 795f 7365 6c65 6374 5f70 7265 6669  pby_select_prefi
+0000ac30: 7865 645f 7374 722e 666f 726d 6174 2870  xed_str.format(p
+0000ac40: 7265 6669 783d 2267 656f 5f64 6174 612e  refix="geo_data.
+0000ac50: 2229 7d0a 2020 2020 2020 2020 2020 2020  ")}.            
+0000ac60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ac70: 2020 7b61 6767 5f63 6f6c 756d 6e73 5f73    {agg_columns_s
+0000ac80: 7472 7d0a 2020 2020 2020 2020 2020 2020  tr}.            
+0000ac90: 2020 2020 2020 2020 2020 2020 2020 4652                FR
+0000aca0: 4f4d 2028 0a20 2020 2020 2020 2020 2020  OM (.           
+0000acb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000acc0: 2053 454c 4543 5420 5354 5f43 6f6c 6c65   SELECT ST_Colle
+0000acd0: 6374 286c 6179 6572 5f67 656f 2e7b 7b67  ct(layer_geo.{{g
+0000ace0: 656f 6d65 7472 7963 6f6c 756d 6e7d 7d0a  eometrycolumn}}.
+0000acf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000ad00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad10: 2020 2020 2020 2023 204e 6f20 6578 706c         # No expl
-0000ad20: 6f64 6563 6f6c 6c65 6374 696f 6e73 2c20  odecollections, 
-0000ad30: 736f 2063 6f6c 6c65 6374 2074 6f20 6f6e  so collect to on
-0000ad40: 6520 6765 6f6d 6574 7279 0d0a 2020 2020  e geometry..    
-0000ad50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad60: 2020 2020 2320 2870 6572 2067 726f 7570      # (per group
-0000ad70: 6279 2069 6620 6170 706c 6963 6162 6c65  by if applicable
-0000ad80: 292e 0d0a 2020 2020 2020 2020 2020 2020  )...            
-0000ad90: 2020 2020 2020 2020 2020 2020 7371 6c5f              sql_
-0000ada0: 7374 6d74 203d 2066 2222 220d 0a20 2020  stmt = f"""..   
-0000adb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000adc0: 2020 2020 2020 2020 2053 454c 4543 5420           SELECT 
-0000add0: 5354 5f43 6f6c 6c65 6374 287b 7b67 656f  ST_Collect({{geo
-0000ade0: 6d65 7472 7963 6f6c 756d 6e7d 7d29 2041  metrycolumn}}) A
-0000adf0: 5320 7b7b 6765 6f6d 6574 7279 636f 6c75  S {{geometrycolu
-0000ae00: 6d6e 7d7d 0d0a 2020 2020 2020 2020 2020  mn}}..          
-0000ae10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ae20: 2020 2020 2020 2020 7b67 726f 7570 6279          {groupby
-0000ae30: 5f73 656c 6563 745f 7072 6566 6978 6564  _select_prefixed
-0000ae40: 5f73 7472 2e66 6f72 6d61 7428 7072 6566  _str.format(pref
-0000ae50: 6978 3d22 6c61 7965 722e 2229 7d0d 0a20  ix="layer.")}.. 
-0000ae60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ae70: 2020 2020 2020 2020 2020 2020 2046 524f               FRO
-0000ae80: 4d20 227b 7b69 6e70 7574 5f6c 6179 6572  M "{{input_layer
-0000ae90: 7d7d 2220 6c61 7965 720d 0a20 2020 2020  }}" layer..     
+0000ad10: 2020 2029 2041 5320 7b7b 6765 6f6d 6574     ) AS {{geomet
+0000ad20: 7279 636f 6c75 6d6e 7d7d 0a20 2020 2020  rycolumn}}.     
+0000ad30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ad40: 2020 2020 2020 2020 2020 2020 207b 6772               {gr
+0000ad50: 6f75 7062 795f 7365 6c65 6374 5f70 7265  oupby_select_pre
+0000ad60: 6669 7865 645f 7374 722e 666f 726d 6174  fixed_str.format
+0000ad70: 2870 7265 6669 783d 226c 6179 6572 5f67  (prefix="layer_g
+0000ad80: 656f 2e22 297d 0a20 2020 2020 2020 2020  eo.")}.         
+0000ad90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ada0: 2020 2020 2020 2020 202c 4d49 4e28 6c61           ,MIN(la
+0000adb0: 7965 725f 6765 6f2e 7b6f 7264 6572 6279  yer_geo.{orderby
+0000adc0: 5f63 6f6c 756d 6e7d 2920 6173 207b 6f72  _column}) as {or
+0000add0: 6465 7262 795f 636f 6c75 6d6e 7d0a 2020  derby_column}.  
+0000ade0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000adf0: 2020 2020 2020 2020 2020 2020 4652 4f4d              FROM
+0000ae00: 2022 7b7b 696e 7075 745f 6c61 7965 727d   "{{input_layer}
+0000ae10: 7d22 206c 6179 6572 5f67 656f 0a20 2020  }" layer_geo.   
+0000ae20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ae30: 2020 2020 2020 2020 2020 207b 6772 6f75             {grou
+0000ae40: 7062 795f 6772 6f75 7062 795f 7072 6566  pby_groupby_pref
+0000ae50: 6978 6564 5f73 7472 2e66 6f72 6d61 7428  ixed_str.format(
+0000ae60: 7072 6566 6978 3d22 6c61 7965 725f 6765  prefix="layer_ge
+0000ae70: 6f2e 2229 7d0a 2020 2020 2020 2020 2020  o.")}.          
+0000ae80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ae90: 2020 2920 6765 6f5f 6461 7461 0a20 2020    ) geo_data.   
 0000aea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aeb0: 2020 2020 2020 2020 207b 6772 6f75 7062           {groupb
-0000aec0: 795f 6772 6f75 7062 795f 7072 6566 6978  y_groupby_prefix
-0000aed0: 6564 5f73 7472 2e66 6f72 6d61 7428 7072  ed_str.format(pr
-0000aee0: 6566 6978 3d22 6c61 7965 722e 2229 7d0d  efix="layer.")}.
-0000aef0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000af00: 2020 2020 2020 2020 2020 2020 2020 4f52                OR
-0000af10: 4445 5220 4259 204d 494e 286c 6179 6572  DER BY MIN(layer
-0000af20: 2e7b 6f72 6465 7262 795f 636f 6c75 6d6e  .{orderby_column
-0000af30: 7d29 0d0a 2020 2020 2020 2020 2020 2020  })..            
-0000af40: 2020 2020 2020 2020 2020 2020 2222 220d              """.
-0000af50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000af60: 2065 6c73 653a 0d0a 2020 2020 2020 2020   else:..        
-0000af70: 2020 2020 2020 2020 2020 2020 2320 4966              # If
-0000af80: 2061 6767 5f63 6f6c 756d 6e73 2073 7065   agg_columns spe
-0000af90: 6369 6669 6564 2c20 706f 7374 7072 6f63  cified, postproc
-0000afa0: 6573 7369 6e67 2069 7320 6120 6269 7420  essing is a bit 
-0000afb0: 6d6f 7265 0d0a 2020 2020 2020 2020 2020  more..          
-0000afc0: 2020 2020 2020 2020 2020 2320 636f 6d70            # comp
-0000afd0: 6c69 6361 7465 642e 0d0a 2020 2020 2020  licated...      
-0000afe0: 2020 2020 2020 2020 2020 2020 2020 7371                sq
-0000aff0: 6c5f 7374 6d74 203d 2066 2222 220d 0a20  l_stmt = f""".. 
-0000b000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b010: 2020 2020 2020 2053 454c 4543 5420 6765         SELECT ge
-0000b020: 6f5f 6461 7461 2e7b 7b67 656f 6d65 7472  o_data.{{geometr
-0000b030: 7963 6f6c 756d 6e7d 7d0d 0a20 2020 2020  ycolumn}}..     
+0000aeb0: 2020 2020 2020 204a 4f49 4e20 280a 2020         JOIN (.  
+0000aec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aed0: 2020 2020 2020 2020 2020 5345 4c45 4354            SELECT
+0000aee0: 2044 4953 5449 4e43 5420 6a73 6f6e 5f72   DISTINCT json_r
+0000aef0: 6f77 735f 7461 626c 652e 7661 6c75 6520  ows_table.value 
+0000af00: 6173 206a 736f 6e5f 726f 770a 2020 2020  as json_row.    
+0000af10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af20: 2020 2020 2020 2020 2020 2020 7b67 726f              {gro
+0000af30: 7570 6279 5f73 656c 6563 745f 7072 6566  upby_select_pref
+0000af40: 6978 6564 5f73 7472 2e66 6f72 6d61 7428  ixed_str.format(
+0000af50: 7072 6566 6978 3d22 6c61 7965 725f 666f  prefix="layer_fo
+0000af60: 725f 6a73 6f6e 2e22 297d 0a20 2020 2020  r_json.")}.     
+0000af70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af80: 2020 2020 2020 2020 2046 524f 4d20 227b           FROM "{
+0000af90: 7b69 6e70 7574 5f6c 6179 6572 7d7d 2220  {input_layer}}" 
+0000afa0: 6c61 7965 725f 666f 725f 6a73 6f6e 0a20  layer_for_json. 
+0000afb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000afc0: 2020 2020 2020 2020 2020 2020 2043 524f               CRO
+0000afd0: 5353 204a 4f49 4e20 6a73 6f6e 5f65 6163  SS JOIN json_eac
+0000afe0: 6828 0a20 2020 2020 2020 2020 2020 2020  h(.             
+0000aff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b000: 2020 2020 206c 6179 6572 5f66 6f72 5f6a       layer_for_j
+0000b010: 736f 6e2e 5f5f 4449 5353 4f4c 5645 5f54  son.__DISSOLVE_T
+0000b020: 4f4a 534f 4e2c 2022 2422 2920 6a73 6f6e  OJSON, "$") json
+0000b030: 5f72 6f77 735f 7461 626c 650a 2020 2020  _rows_table.    
 0000b040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b050: 2020 2020 2020 2020 207b 6772 6f75 7062           {groupb
-0000b060: 795f 7365 6c65 6374 5f70 7265 6669 7865  y_select_prefixe
-0000b070: 645f 7374 722e 666f 726d 6174 2870 7265  d_str.format(pre
-0000b080: 6669 783d 2267 656f 5f64 6174 612e 2229  fix="geo_data.")
-0000b090: 7d0d 0a20 2020 2020 2020 2020 2020 2020  }..             
-0000b0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b0b0: 207b 6167 675f 636f 6c75 6d6e 735f 7374   {agg_columns_st
-0000b0c0: 727d 0d0a 2020 2020 2020 2020 2020 2020  r}..            
-0000b0d0: 2020 2020 2020 2020 2020 2020 2020 4652                FR
-0000b0e0: 4f4d 2028 0d0a 2020 2020 2020 2020 2020  OM (..          
-0000b0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b100: 2020 5345 4c45 4354 2053 545f 436f 6c6c    SELECT ST_Coll
-0000b110: 6563 7428 6c61 7965 725f 6765 6f2e 7b7b  ect(layer_geo.{{
-0000b120: 6765 6f6d 6574 7279 636f 6c75 6d6e 7d7d  geometrycolumn}}
-0000b130: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000b140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b150: 2020 2020 2029 2041 5320 7b7b 6765 6f6d       ) AS {{geom
-0000b160: 6574 7279 636f 6c75 6d6e 7d7d 0d0a 2020  etrycolumn}}..  
-0000b170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b190: 7b67 726f 7570 6279 5f73 656c 6563 745f  {groupby_select_
-0000b1a0: 7072 6566 6978 6564 5f73 7472 2e66 6f72  prefixed_str.for
-0000b1b0: 6d61 7428 7072 6566 6978 3d22 6c61 7965  mat(prefix="laye
-0000b1c0: 725f 6765 6f2e 2229 7d0d 0a20 2020 2020  r_geo.")}..     
+0000b050: 2020 2020 2020 2020 2920 6a73 6f6e 5f64          ) json_d
+0000b060: 6174 610a 2020 2020 2020 2020 2020 2020  ata.            
+0000b070: 2020 2020 2020 2020 2020 2020 2057 4845               WHE
+0000b080: 5245 2031 3d31 0a20 2020 2020 2020 2020  RE 1=1.         
+0000b090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b0a0: 2020 207b 6772 6f75 7062 795f 6669 6c74     {groupby_filt
+0000b0b0: 6572 5f73 7472 7d0a 2020 2020 2020 2020  er_str}.        
+0000b0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b0d0: 2020 7b67 726f 7570 6279 5f67 726f 7570    {groupby_group
+0000b0e0: 6279 5f70 7265 6669 7865 645f 7374 722e  by_prefixed_str.
+0000b0f0: 666f 726d 6174 2870 7265 6669 783d 2267  format(prefix="g
+0000b100: 656f 5f64 6174 612e 2229 7d0a 2020 2020  eo_data.")}.    
+0000b110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b120: 2020 2020 2020 4f52 4445 5220 4259 2067        ORDER BY g
+0000b130: 656f 5f64 6174 612e 7b6f 7264 6572 6279  eo_data.{orderby
+0000b140: 5f63 6f6c 756d 6e7d 0a20 2020 2020 2020  _column}.       
+0000b150: 2020 2020 2020 2020 2020 2020 2022 2222               """
+0000b160: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0000b170: 2020 2320 476f 210a 2020 2020 2020 2020    # Go!.        
+0000b180: 2020 2020 2020 2020 5f67 656f 6f70 735f          _geoops_
+0000b190: 7371 6c2e 7365 6c65 6374 280a 2020 2020  sql.select(.    
+0000b1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b1b0: 696e 7075 745f 7061 7468 3d6f 7574 7075  input_path=outpu
+0000b1c0: 745f 746d 705f 7061 7468 2c0a 2020 2020  t_tmp_path,.    
 0000b1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b1e0: 2020 2020 2020 2020 2020 2020 202c 4d49               ,MI
-0000b1f0: 4e28 6c61 7965 725f 6765 6f2e 7b6f 7264  N(layer_geo.{ord
-0000b200: 6572 6279 5f63 6f6c 756d 6e7d 2920 6173  erby_column}) as
-0000b210: 207b 6f72 6465 7262 795f 636f 6c75 6d6e   {orderby_column
-0000b220: 7d0d 0a20 2020 2020 2020 2020 2020 2020  }..             
-0000b230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b240: 2046 524f 4d20 227b 7b69 6e70 7574 5f6c   FROM "{{input_l
-0000b250: 6179 6572 7d7d 2220 6c61 7965 725f 6765  ayer}}" layer_ge
-0000b260: 6f0d 0a20 2020 2020 2020 2020 2020 2020  o..             
-0000b270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b280: 207b 6772 6f75 7062 795f 6772 6f75 7062   {groupby_groupb
-0000b290: 795f 7072 6566 6978 6564 5f73 7472 2e66  y_prefixed_str.f
-0000b2a0: 6f72 6d61 7428 7072 6566 6978 3d22 6c61  ormat(prefix="la
-0000b2b0: 7965 725f 6765 6f2e 2229 7d0d 0a20 2020  yer_geo.")}..   
-0000b2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b2d0: 2020 2020 2020 2020 2029 2067 656f 5f64           ) geo_d
-0000b2e0: 6174 610d 0a20 2020 2020 2020 2020 2020  ata..           
-0000b2f0: 2020 2020 2020 2020 2020 2020 2020 204a                 J
-0000b300: 4f49 4e20 280d 0a20 2020 2020 2020 2020  OIN (..         
-0000b310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b320: 2020 2053 454c 4543 5420 4449 5354 494e     SELECT DISTIN
-0000b330: 4354 206a 736f 6e5f 726f 7773 5f74 6162  CT json_rows_tab
-0000b340: 6c65 2e76 616c 7565 2061 7320 6a73 6f6e  le.value as json
-0000b350: 5f72 6f77 0d0a 2020 2020 2020 2020 2020  _row..          
-0000b360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b370: 2020 2020 2020 7b67 726f 7570 6279 5f73        {groupby_s
-0000b380: 656c 6563 745f 7072 6566 6978 6564 5f73  elect_prefixed_s
-0000b390: 7472 2e66 6f72 6d61 7428 7072 6566 6978  tr.format(prefix
-0000b3a0: 3d22 6c61 7965 725f 666f 725f 6a73 6f6e  ="layer_for_json
-0000b3b0: 2e22 297d 0d0a 2020 2020 2020 2020 2020  .")}..          
-0000b3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b3d0: 2020 2020 4652 4f4d 2022 7b7b 696e 7075      FROM "{{inpu
-0000b3e0: 745f 6c61 7965 727d 7d22 206c 6179 6572  t_layer}}" layer
-0000b3f0: 5f66 6f72 5f6a 736f 6e0d 0a20 2020 2020  _for_json..     
-0000b400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b410: 2020 2020 2020 2020 2043 524f 5353 204a           CROSS J
-0000b420: 4f49 4e20 6a73 6f6e 5f65 6163 6828 0d0a  OIN json_each(..
-0000b430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b450: 2020 6c61 7965 725f 666f 725f 6a73 6f6e    layer_for_json
-0000b460: 2e5f 5f44 4953 534f 4c56 455f 544f 4a53  .__DISSOLVE_TOJS
-0000b470: 4f4e 2c20 2224 2229 206a 736f 6e5f 726f  ON, "$") json_ro
-0000b480: 7773 5f74 6162 6c65 0d0a 2020 2020 2020  ws_table..      
-0000b490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b4a0: 2020 2020 2020 2920 6a73 6f6e 5f64 6174        ) json_dat
-0000b4b0: 610d 0a20 2020 2020 2020 2020 2020 2020  a..             
-0000b4c0: 2020 2020 2020 2020 2020 2020 5748 4552              WHER
-0000b4d0: 4520 313d 310d 0a20 2020 2020 2020 2020  E 1=1..         
-0000b4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b4f0: 2020 207b 6772 6f75 7062 795f 6669 6c74     {groupby_filt
-0000b500: 6572 5f73 7472 7d0d 0a20 2020 2020 2020  er_str}..       
-0000b510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b520: 2020 207b 6772 6f75 7062 795f 6772 6f75     {groupby_grou
-0000b530: 7062 795f 7072 6566 6978 6564 5f73 7472  pby_prefixed_str
-0000b540: 2e66 6f72 6d61 7428 7072 6566 6978 3d22  .format(prefix="
-0000b550: 6765 6f5f 6461 7461 2e22 297d 0d0a 2020  geo_data.")}..  
-0000b560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b570: 2020 2020 2020 2020 4f52 4445 5220 4259          ORDER BY
-0000b580: 2067 656f 5f64 6174 612e 7b6f 7264 6572   geo_data.{order
-0000b590: 6279 5f63 6f6c 756d 6e7d 0d0a 2020 2020  by_column}..    
-0000b5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b5b0: 2222 220d 0a0d 0a20 2020 2020 2020 2020  """....         
-0000b5c0: 2020 2020 2020 2023 2047 6f21 0d0a 2020         # Go!..  
-0000b5d0: 2020 2020 2020 2020 2020 2020 2020 5f67                _g
-0000b5e0: 656f 6f70 735f 7371 6c2e 7365 6c65 6374  eoops_sql.select
-0000b5f0: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-0000b600: 2020 2020 2020 2069 6e70 7574 5f70 6174         input_pat
-0000b610: 683d 6f75 7470 7574 5f74 6d70 5f70 6174  h=output_tmp_pat
-0000b620: 682c 0d0a 2020 2020 2020 2020 2020 2020  h,..            
-0000b630: 2020 2020 2020 2020 6f75 7470 7574 5f70          output_p
-0000b640: 6174 683d 6f75 7470 7574 5f70 6174 682c  ath=output_path,
-0000b650: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000b660: 2020 2020 2020 7371 6c5f 7374 6d74 3d73        sql_stmt=s
-0000b670: 716c 5f73 746d 742c 0d0a 2020 2020 2020  ql_stmt,..      
-0000b680: 2020 2020 2020 2020 2020 2020 2020 6f75                ou
-0000b690: 7470 7574 5f6c 6179 6572 3d6f 7574 7075  tput_layer=outpu
-0000b6a0: 745f 6c61 7965 722c 0d0a 2020 2020 2020  t_layer,..      
-0000b6b0: 2020 2020 2020 2020 2020 2020 2020 6578                ex
-0000b6c0: 706c 6f64 6563 6f6c 6c65 6374 696f 6e73  plodecollections
-0000b6d0: 3d65 7870 6c6f 6465 636f 6c6c 6563 7469  =explodecollecti
-0000b6e0: 6f6e 732c 0d0a 2020 2020 2020 2020 2020  ons,..          
-0000b6f0: 2020 2020 2020 290d 0a0d 0a20 2020 2020        )....     
-0000b700: 2020 2066 696e 616c 6c79 3a0d 0a20 2020     finally:..   
-0000b710: 2020 2020 2020 2020 2023 2043 6c65 616e           # Clean
-0000b720: 2074 6d70 2064 6972 2069 6620 6974 2065   tmp dir if it e
-0000b730: 7869 7374 732e 2e2e 0d0a 2020 2020 2020  xists.....      
-0000b740: 2020 2020 2020 6966 2074 656d 7064 6972        if tempdir
-0000b750: 2e65 7869 7374 7328 293a 0d0a 2020 2020  .exists():..    
-0000b760: 2020 2020 2020 2020 2020 2020 7368 7574              shut
-0000b770: 696c 2e72 6d74 7265 6528 7465 6d70 6469  il.rmtree(tempdi
-0000b780: 7229 0d0a 2020 2020 656c 7365 3a0d 0a20  r)..    else:.. 
-0000b790: 2020 2020 2020 2072 6169 7365 204e 6f74         raise Not
-0000b7a0: 496d 706c 656d 656e 7465 6445 7272 6f72  ImplementedError
-0000b7b0: 280d 0a20 2020 2020 2020 2020 2020 2066  (..            f
-0000b7c0: 2255 6e73 7570 706f 7274 6564 2069 6e70  "Unsupported inp
-0000b7d0: 7574 2067 656f 6d65 7472 7974 7970 653a  ut geometrytype:
-0000b7e0: 207b 696e 7075 745f 6c61 7965 7269 6e66   {input_layerinf
-0000b7f0: 6f2e 6765 6f6d 6574 7279 7479 7065 7d22  o.geometrytype}"
-0000b800: 0d0a 2020 2020 2020 2020 290d 0a0d 0a20  ..        ).... 
-0000b810: 2020 2023 2052 6574 7572 6e20 7265 7375     # Return resu
-0000b820: 6c74 2069 6e66 6f0d 0a20 2020 2072 6573  lt info..    res
-0000b830: 756c 745f 696e 666f 5b0d 0a20 2020 2020  ult_info[..     
-0000b840: 2020 2022 6d65 7373 6167 6522 0d0a 2020     "message"..  
-0000b850: 2020 5d20 3d20 6622 4469 7373 6f6c 7665    ] = f"Dissolve
-0000b860: 2063 6f6d 706c 6574 656c 7920 7265 6164   completely read
-0000b870: 792c 2074 6f6f 6b20 7b64 6174 6574 696d  y, took {datetim
-0000b880: 652e 6e6f 7728 292d 7374 6172 745f 7469  e.now()-start_ti
-0000b890: 6d65 7d21 220d 0a20 2020 206c 6f67 6765  me}!"..    logge
-0000b8a0: 722e 696e 666f 2872 6573 756c 745f 696e  r.info(result_in
-0000b8b0: 666f 5b22 6d65 7373 6167 6522 5d29 0d0a  fo["message"])..
-0000b8c0: 2020 2020 7265 7475 726e 2072 6573 756c      return resul
-0000b8d0: 745f 696e 666f 0d0a 0d0a 0d0a 6465 6620  t_info......def 
-0000b8e0: 5f64 6973 736f 6c76 655f 706f 6c79 676f  _dissolve_polygo
-0000b8f0: 6e73 5f70 6173 7328 0d0a 2020 2020 696e  ns_pass(..    in
-0000b900: 7075 745f 7061 7468 3a20 5061 7468 2c0d  put_path: Path,.
-0000b910: 0a20 2020 206f 7574 7075 745f 6e6f 746f  .    output_noto
-0000b920: 6e62 6f72 6465 725f 7061 7468 3a20 5061  nborder_path: Pa
-0000b930: 7468 2c0d 0a20 2020 206f 7574 7075 745f  th,..    output_
-0000b940: 6f6e 626f 7264 6572 5f70 6174 683a 2050  onborder_path: P
-0000b950: 6174 682c 0d0a 2020 2020 6578 706c 6f64  ath,..    explod
-0000b960: 6563 6f6c 6c65 6374 696f 6e73 3a20 626f  ecollections: bo
-0000b970: 6f6c 2c0d 0a20 2020 2067 726f 7570 6279  ol,..    groupby
-0000b980: 5f63 6f6c 756d 6e73 3a20 4f70 7469 6f6e  _columns: Option
-0000b990: 616c 5b49 7465 7261 626c 655b 7374 725d  al[Iterable[str]
-0000b9a0: 5d2c 0d0a 2020 2020 6167 675f 636f 6c75  ],..    agg_colu
-0000b9b0: 6d6e 733a 204f 7074 696f 6e61 6c5b 6469  mns: Optional[di
-0000b9c0: 6374 5d2c 0d0a 2020 2020 7469 6c65 735f  ct],..    tiles_
-0000b9d0: 6764 663a 2067 7064 2e47 656f 4461 7461  gdf: gpd.GeoData
-0000b9e0: 4672 616d 652c 0d0a 2020 2020 696e 7075  Frame,..    inpu
-0000b9f0: 745f 6c61 7965 723a 204f 7074 696f 6e61  t_layer: Optiona
-0000ba00: 6c5b 7374 725d 2c0d 0a20 2020 206f 7574  l[str],..    out
-0000ba10: 7075 745f 6c61 7965 723a 204f 7074 696f  put_layer: Optio
-0000ba20: 6e61 6c5b 7374 725d 2c0d 0a20 2020 206e  nal[str],..    n
-0000ba30: 625f 7061 7261 6c6c 656c 3a20 696e 742c  b_parallel: int,
-0000ba40: 0d0a 2920 2d3e 2064 6963 743a 0d0a 2020  ..) -> dict:..  
-0000ba50: 2020 2320 4d61 6b65 2073 7572 6520 7468    # Make sure th
-0000ba60: 6520 696e 7075 7420 6669 6c65 2068 6173  e input file has
-0000ba70: 2061 2073 7061 7469 616c 2069 6e64 6578   a spatial index
-0000ba80: 0d0a 2020 2020 6766 6f2e 6372 6561 7465  ..    gfo.create
-0000ba90: 5f73 7061 7469 616c 5f69 6e64 6578 2869  _spatial_index(i
-0000baa0: 6e70 7574 5f70 6174 682c 2065 7869 7374  nput_path, exist
-0000bab0: 5f6f 6b3d 5472 7565 290d 0a0d 0a20 2020  _ok=True)....   
-0000bac0: 2023 2053 7461 7274 2063 616c 6375 6c61   # Start calcula
-0000bad0: 7469 6f6e 2069 6e20 7061 7261 6c6c 656c  tion in parallel
-0000bae0: 0d0a 2020 2020 7374 6172 745f 7469 6d65  ..    start_time
-0000baf0: 203d 2064 6174 6574 696d 652e 6e6f 7728   = datetime.now(
-0000bb00: 290d 0a20 2020 2072 6573 756c 745f 696e  )..    result_in
-0000bb10: 666f 203d 207b 7d0d 0a20 2020 2073 7461  fo = {}..    sta
-0000bb20: 7274 5f74 696d 6520 3d20 6461 7465 7469  rt_time = dateti
-0000bb30: 6d65 2e6e 6f77 2829 0d0a 2020 2020 696e  me.now()..    in
-0000bb40: 7075 745f 6c61 7965 7269 6e66 6f20 3d20  put_layerinfo = 
-0000bb50: 6766 6f2e 6765 745f 6c61 7965 7269 6e66  gfo.get_layerinf
-0000bb60: 6f28 696e 7075 745f 7061 7468 2c20 696e  o(input_path, in
-0000bb70: 7075 745f 6c61 7965 7229 0d0a 0d0a 2020  put_layer)....  
-0000bb80: 2020 2320 5072 6f63 6573 7369 6e67 2069    # Processing i
-0000bb90: 6e20 7468 7265 6164 7320 6973 2032 7820  n threads is 2x 
-0000bba0: 6661 7374 6572 2066 6f72 2073 6d61 6c6c  faster for small
-0000bbb0: 2064 6174 6173 6574 7320 286f 6e20 5769   datasets (on Wi
-0000bbc0: 6e64 6f77 7329 0d0a 2020 2020 6361 6c63  ndows)..    calc
-0000bbd0: 756c 6174 655f 696e 5f74 6872 6561 6473  ulate_in_threads
-0000bbe0: 203d 2054 7275 6520 6966 2069 6e70 7574   = True if input
-0000bbf0: 5f6c 6179 6572 696e 666f 2e66 6561 7475  _layerinfo.featu
-0000bc00: 7265 636f 756e 7420 3c3d 2031 3030 2065  recount <= 100 e
-0000bc10: 6c73 6520 4661 6c73 650d 0a20 2020 2077  lse False..    w
-0000bc20: 6974 6820 5f70 726f 6365 7373 696e 675f  ith _processing_
-0000bc30: 7574 696c 2e50 6f6f 6c65 6445 7865 6375  util.PooledExecu
-0000bc40: 746f 7246 6163 746f 7279 280d 0a20 2020  torFactory(..   
-0000bc50: 2020 2020 2074 6872 6561 6470 6f6f 6c3d       threadpool=
-0000bc60: 6361 6c63 756c 6174 655f 696e 5f74 6872  calculate_in_thr
-0000bc70: 6561 6473 2c0d 0a20 2020 2020 2020 206d  eads,..        m
-0000bc80: 6178 5f77 6f72 6b65 7273 3d6e 625f 7061  ax_workers=nb_pa
-0000bc90: 7261 6c6c 656c 2c0d 0a20 2020 2020 2020  rallel,..       
-0000bca0: 2069 6e69 7469 616c 697a 6572 3d5f 7072   initializer=_pr
-0000bcb0: 6f63 6573 7369 6e67 5f75 7469 6c2e 696e  ocessing_util.in
-0000bcc0: 6974 6961 6c69 7a65 5f77 6f72 6b65 7228  itialize_worker(
-0000bcd0: 292c 0d0a 2020 2020 2920 6173 2063 616c  ),..    ) as cal
-0000bce0: 6375 6c61 7465 5f70 6f6f 6c3a 0d0a 2020  culate_pool:..  
-0000bcf0: 2020 2020 2020 2320 5072 6570 6172 6520        # Prepare 
-0000bd00: 6f75 7470 7574 2066 696c 656e 616d 650d  output filename.
-0000bd10: 0a20 2020 2020 2020 2074 656d 7064 6972  .        tempdir
-0000bd20: 203d 206f 7574 7075 745f 6f6e 626f 7264   = output_onbord
-0000bd30: 6572 5f70 6174 682e 7061 7265 6e74 0d0a  er_path.parent..
-0000bd40: 0d0a 2020 2020 2020 2020 6261 7463 6865  ..        batche
-0000bd50: 7320 3d20 7b7d 0d0a 2020 2020 2020 2020  s = {}..        
-0000bd60: 6e62 5f62 6174 6368 6573 203d 206c 656e  nb_batches = len
-0000bd70: 2874 696c 6573 5f67 6466 290d 0a20 2020  (tiles_gdf)..   
-0000bd80: 2020 2020 206e 625f 6261 7463 6865 735f       nb_batches_
-0000bd90: 646f 6e65 203d 2030 0d0a 2020 2020 2020  done = 0..      
-0000bda0: 2020 6675 7475 7265 5f74 6f5f 6261 7463    future_to_batc
-0000bdb0: 685f 6964 203d 207b 7d0d 0a20 2020 2020  h_id = {}..     
-0000bdc0: 2020 206e 625f 726f 7773 5f64 6f6e 6520     nb_rows_done 
-0000bdd0: 3d20 300d 0a20 2020 2020 2020 2066 6f72  = 0..        for
-0000bde0: 2062 6174 6368 5f69 642c 2074 696c 655f   batch_id, tile_
-0000bdf0: 726f 7720 696e 2065 6e75 6d65 7261 7465  row in enumerate
-0000be00: 2874 696c 6573 5f67 6466 2e69 7465 7274  (tiles_gdf.itert
-0000be10: 7570 6c65 7328 2929 3a0d 0a20 2020 2020  uples()):..     
-0000be20: 2020 2020 2020 2062 6174 6368 6573 5b62         batches[b
-0000be30: 6174 6368 5f69 645d 203d 207b 7d0d 0a20  atch_id] = {}.. 
-0000be40: 2020 2020 2020 2020 2020 2062 6174 6368             batch
-0000be50: 6573 5b62 6174 6368 5f69 645d 5b22 6c61  es[batch_id]["la
-0000be60: 7965 7222 5d20 3d20 6f75 7470 7574 5f6c  yer"] = output_l
-0000be70: 6179 6572 0d0a 2020 2020 2020 2020 2020  ayer..          
-0000be80: 2020 6261 7463 6865 735b 6261 7463 685f    batches[batch_
-0000be90: 6964 5d5b 2262 6f75 6e64 7322 5d20 3d20  id]["bounds"] = 
-0000bea0: 7469 6c65 5f72 6f77 2e67 656f 6d65 7472  tile_row.geometr
-0000beb0: 792e 626f 756e 6473 0d0a 0d0a 2020 2020  y.bounds....    
-0000bec0: 2020 2020 2020 2020 2320 4f75 7470 7574          # Output
-0000bed0: 2065 6163 6820 6261 7463 6820 746f 2061   each batch to a
-0000bee0: 2073 6570 6572 6174 6520 7465 6d70 6f72   seperate tempor
-0000bef0: 6172 7920 6669 6c65 2c20 6f74 6865 7277  ary file, otherw
-0000bf00: 6973 6520 7468 6572 650d 0a20 2020 2020  ise there..     
-0000bf10: 2020 2020 2020 2023 2061 7265 2074 696d         # are tim
-0000bf20: 656f 7574 2069 7373 7565 7320 7768 656e  eout issues when
-0000bf30: 2070 726f 6365 7373 696e 6720 6c61 7267   processing larg
-0000bf40: 6520 6669 6c65 730d 0a20 2020 2020 2020  e files..       
-0000bf50: 2020 2020 2073 7566 6669 7820 3d20 6f75       suffix = ou
-0000bf60: 7470 7574 5f6e 6f74 6f6e 626f 7264 6572  tput_notonborder
-0000bf70: 5f70 6174 682e 7375 6666 6978 0d0a 2020  _path.suffix..  
-0000bf80: 2020 2020 2020 2020 2020 6e61 6d65 203d            name =
-0000bf90: 2066 227b 6f75 7470 7574 5f6e 6f74 6f6e   f"{output_noton
-0000bfa0: 626f 7264 6572 5f70 6174 682e 7374 656d  border_path.stem
-0000bfb0: 7d5f 7b62 6174 6368 5f69 647d 7b73 7566  }_{batch_id}{suf
-0000bfc0: 6669 787d 220d 0a20 2020 2020 2020 2020  fix}"..         
-0000bfd0: 2020 206f 7574 7075 745f 6e6f 746f 6e62     output_notonb
-0000bfe0: 6f72 6465 725f 746d 705f 7061 7274 6961  order_tmp_partia
-0000bff0: 6c5f 7061 7468 203d 2074 656d 7064 6972  l_path = tempdir
-0000c000: 202f 206e 616d 650d 0a20 2020 2020 2020   / name..       
-0000c010: 2020 2020 2062 6174 6368 6573 5b62 6174       batches[bat
-0000c020: 6368 5f69 645d 5b0d 0a20 2020 2020 2020  ch_id][..       
-0000c030: 2020 2020 2020 2020 2022 6f75 7470 7574           "output
-0000c040: 5f6e 6f74 6f6e 626f 7264 6572 5f74 6d70  _notonborder_tmp
-0000c050: 5f70 6172 7469 616c 5f70 6174 6822 0d0a  _partial_path"..
-0000c060: 2020 2020 2020 2020 2020 2020 5d20 3d20              ] = 
-0000c070: 6f75 7470 7574 5f6e 6f74 6f6e 626f 7264  output_notonbord
-0000c080: 6572 5f74 6d70 5f70 6172 7469 616c 5f70  er_tmp_partial_p
-0000c090: 6174 680d 0a20 2020 2020 2020 2020 2020  ath..           
-0000c0a0: 206e 616d 6520 3d20 6622 7b6f 7574 7075   name = f"{outpu
-0000c0b0: 745f 6f6e 626f 7264 6572 5f70 6174 682e  t_onborder_path.
-0000c0c0: 7374 656d 7d5f 7b62 6174 6368 5f69 647d  stem}_{batch_id}
-0000c0d0: 7b73 7566 6669 787d 220d 0a20 2020 2020  {suffix}"..     
-0000c0e0: 2020 2020 2020 206f 7574 7075 745f 6f6e         output_on
-0000c0f0: 626f 7264 6572 5f74 6d70 5f70 6172 7469  border_tmp_parti
-0000c100: 616c 5f70 6174 6820 3d20 7465 6d70 6469  al_path = tempdi
-0000c110: 7220 2f20 6e61 6d65 0d0a 2020 2020 2020  r / name..      
-0000c120: 2020 2020 2020 6261 7463 6865 735b 6261        batches[ba
-0000c130: 7463 685f 6964 5d5b 0d0a 2020 2020 2020  tch_id][..      
-0000c140: 2020 2020 2020 2020 2020 226f 7574 7075            "outpu
-0000c150: 745f 6f6e 626f 7264 6572 5f74 6d70 5f70  t_onborder_tmp_p
-0000c160: 6172 7469 616c 5f70 6174 6822 0d0a 2020  artial_path"..  
-0000c170: 2020 2020 2020 2020 2020 5d20 3d20 6f75            ] = ou
-0000c180: 7470 7574 5f6f 6e62 6f72 6465 725f 746d  tput_onborder_tm
-0000c190: 705f 7061 7274 6961 6c5f 7061 7468 0d0a  p_partial_path..
-0000c1a0: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0000c1b0: 4765 7420 7469 6c65 5f69 6420 6966 2070  Get tile_id if p
-0000c1c0: 7265 7365 6e74 0d0a 2020 2020 2020 2020  resent..        
-0000c1d0: 2020 2020 7469 6c65 5f69 6420 3d20 7469      tile_id = ti
-0000c1e0: 6c65 5f72 6f77 2e74 696c 655f 6964 2069  le_row.tile_id i
-0000c1f0: 6620 2274 696c 655f 6964 2220 696e 2074  f "tile_id" in t
-0000c200: 696c 655f 726f 772e 5f66 6965 6c64 7320  ile_row._fields 
-0000c210: 656c 7365 204e 6f6e 650d 0a0d 0a20 2020  else None....   
-0000c220: 2020 2020 2020 2020 2066 7574 7572 6520           future 
-0000c230: 3d20 6361 6c63 756c 6174 655f 706f 6f6c  = calculate_pool
-0000c240: 2e73 7562 6d69 7428 0d0a 2020 2020 2020  .submit(..      
-0000c250: 2020 2020 2020 2020 2020 5f64 6973 736f            _disso
-0000c260: 6c76 655f 706f 6c79 676f 6e73 2c0d 0a20  lve_polygons,.. 
-0000c270: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000c280: 6e70 7574 5f70 6174 683d 696e 7075 745f  nput_path=input_
-0000c290: 7061 7468 2c0d 0a20 2020 2020 2020 2020  path,..         
-0000c2a0: 2020 2020 2020 206f 7574 7075 745f 6e6f         output_no
-0000c2b0: 746f 6e62 6f72 6465 725f 7061 7468 3d6f  tonborder_path=o
-0000c2c0: 7574 7075 745f 6e6f 746f 6e62 6f72 6465  utput_notonborde
-0000c2d0: 725f 746d 705f 7061 7274 6961 6c5f 7061  r_tmp_partial_pa
-0000c2e0: 7468 2c0d 0a20 2020 2020 2020 2020 2020  th,..           
-0000c2f0: 2020 2020 206f 7574 7075 745f 6f6e 626f       output_onbo
-0000c300: 7264 6572 5f70 6174 683d 6f75 7470 7574  rder_path=output
-0000c310: 5f6f 6e62 6f72 6465 725f 746d 705f 7061  _onborder_tmp_pa
-0000c320: 7274 6961 6c5f 7061 7468 2c0d 0a20 2020  rtial_path,..   
-0000c330: 2020 2020 2020 2020 2020 2020 2065 7870               exp
-0000c340: 6c6f 6465 636f 6c6c 6563 7469 6f6e 733d  lodecollections=
-0000c350: 6578 706c 6f64 6563 6f6c 6c65 6374 696f  explodecollectio
-0000c360: 6e73 2c0d 0a20 2020 2020 2020 2020 2020  ns,..           
-0000c370: 2020 2020 2067 726f 7570 6279 5f63 6f6c       groupby_col
-0000c380: 756d 6e73 3d67 726f 7570 6279 5f63 6f6c  umns=groupby_col
-0000c390: 756d 6e73 2c0d 0a20 2020 2020 2020 2020  umns,..         
-0000c3a0: 2020 2020 2020 2061 6767 5f63 6f6c 756d         agg_colum
-0000c3b0: 6e73 3d61 6767 5f63 6f6c 756d 6e73 2c0d  ns=agg_columns,.
-0000c3c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c3d0: 2069 6e70 7574 5f67 656f 6d65 7472 7974   input_geometryt
-0000c3e0: 7970 653d 696e 7075 745f 6c61 7965 7269  ype=input_layeri
-0000c3f0: 6e66 6f2e 6765 6f6d 6574 7279 7479 7065  nfo.geometrytype
-0000c400: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000c410: 2020 2069 6e70 7574 5f6c 6179 6572 3d69     input_layer=i
-0000c420: 6e70 7574 5f6c 6179 6572 2c0d 0a20 2020  nput_layer,..   
-0000c430: 2020 2020 2020 2020 2020 2020 206f 7574               out
-0000c440: 7075 745f 6c61 7965 723d 6f75 7470 7574  put_layer=output
-0000c450: 5f6c 6179 6572 2c0d 0a20 2020 2020 2020  _layer,..       
-0000c460: 2020 2020 2020 2020 2062 626f 783d 7469           bbox=ti
-0000c470: 6c65 5f72 6f77 2e67 656f 6d65 7472 792e  le_row.geometry.
-0000c480: 626f 756e 6473 2c0d 0a20 2020 2020 2020  bounds,..       
-0000c490: 2020 2020 2020 2020 2074 696c 655f 6964           tile_id
-0000c4a0: 3d74 696c 655f 6964 2c0d 0a20 2020 2020  =tile_id,..     
-0000c4b0: 2020 2020 2020 2029 0d0a 2020 2020 2020         )..      
-0000c4c0: 2020 2020 2020 6675 7475 7265 5f74 6f5f        future_to_
-0000c4d0: 6261 7463 685f 6964 5b66 7574 7572 655d  batch_id[future]
-0000c4e0: 203d 2062 6174 6368 5f69 640d 0a0d 0a20   = batch_id.... 
-0000c4f0: 2020 2020 2020 2023 204c 6f6f 7020 7469         # Loop ti
-0000c500: 6c6c 2061 6c6c 2070 6172 616c 6c65 6c20  ll all parallel 
-0000c510: 7072 6f63 6573 7365 7320 6172 6520 7265  processes are re
-0000c520: 6164 792c 2062 7574 2070 726f 6365 7373  ady, but process
-0000c530: 2065 6163 6820 6f6e 650d 0a20 2020 2020   each one..     
-0000c540: 2020 2023 2074 6861 7420 6973 2072 6561     # that is rea
-0000c550: 6479 2061 6c72 6561 6479 0d0a 2020 2020  dy already..    
-0000c560: 2020 2020 5f67 656e 6572 616c 5f75 7469      _general_uti
-0000c570: 6c2e 7265 706f 7274 5f70 726f 6772 6573  l.report_progres
-0000c580: 7328 0d0a 2020 2020 2020 2020 2020 2020  s(..            
-0000c590: 7374 6172 745f 7469 6d65 2c20 6e62 5f62  start_time, nb_b
-0000c5a0: 6174 6368 6573 5f64 6f6e 652c 206e 625f  atches_done, nb_
-0000c5b0: 6261 7463 6865 732c 2022 6469 7373 6f6c  batches, "dissol
-0000c5c0: 7665 220d 0a20 2020 2020 2020 2029 0d0a  ve"..        )..
-0000c5d0: 2020 2020 2020 2020 666f 7220 6675 7475          for futu
-0000c5e0: 7265 2069 6e20 6675 7475 7265 732e 6173  re in futures.as
-0000c5f0: 5f63 6f6d 706c 6574 6564 2866 7574 7572  _completed(futur
-0000c600: 655f 746f 5f62 6174 6368 5f69 6429 3a0d  e_to_batch_id):.
-0000c610: 0a20 2020 2020 2020 2020 2020 2074 7279  .            try
-0000c620: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0000c630: 2020 2023 2049 6620 7468 6520 6361 6c63     # If the calc
-0000c640: 756c 6174 6520 6761 7665 2072 6573 756c  ulate gave resul
-0000c650: 7473 0d0a 2020 2020 2020 2020 2020 2020  ts..            
-0000c660: 2020 2020 6e62 5f62 6174 6368 6573 5f64      nb_batches_d
-0000c670: 6f6e 6520 2b3d 2031 0d0a 2020 2020 2020  one += 1..      
-0000c680: 2020 2020 2020 2020 2020 6261 7463 685f            batch_
-0000c690: 6964 203d 2066 7574 7572 655f 746f 5f62  id = future_to_b
-0000c6a0: 6174 6368 5f69 645b 6675 7475 7265 5d0d  atch_id[future].
-0000c6b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c6c0: 2072 6573 756c 7420 3d20 6675 7475 7265   result = future
-0000c6d0: 2e72 6573 756c 7428 290d 0a0d 0a20 2020  .result()....   
-0000c6e0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000c6f0: 7265 7375 6c74 2069 7320 6e6f 7420 4e6f  result is not No
-0000c700: 6e65 3a0d 0a20 2020 2020 2020 2020 2020  ne:..           
-0000c710: 2020 2020 2020 2020 206e 625f 726f 7773           nb_rows
-0000c720: 5f64 6f6e 6520 2b3d 2072 6573 756c 745b  _done += result[
-0000c730: 226e 625f 726f 7773 5f64 6f6e 6522 5d0d  "nb_rows_done"].
-0000c740: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c750: 2020 2020 2069 6620 7265 7375 6c74 5b22       if result["
-0000c760: 6e62 5f72 6f77 735f 646f 6e65 225d 203e  nb_rows_done"] >
-0000c770: 2030 2061 6e64 2072 6573 756c 745b 2274   0 and result["t
-0000c780: 6f74 616c 5f74 696d 6522 5d20 3e20 303a  otal_time"] > 0:
-0000c790: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000c7a0: 2020 2020 2020 2020 2020 726f 7773 5f70            rows_p
-0000c7b0: 6572 5f73 6563 203d 2072 6f75 6e64 280d  er_sec = round(.
-0000c7c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c7d0: 2020 2020 2020 2020 2020 2020 2072 6573               res
-0000c7e0: 756c 745b 226e 625f 726f 7773 5f64 6f6e  ult["nb_rows_don
-0000c7f0: 6522 5d20 2f20 7265 7375 6c74 5b22 746f  e"] / result["to
-0000c800: 7461 6c5f 7469 6d65 225d 0d0a 2020 2020  tal_time"]..    
-0000c810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c820: 2020 2020 290d 0a20 2020 2020 2020 2020      )..         
-0000c830: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000c840: 6f67 6765 722e 6465 6275 6728 0d0a 2020  ogger.debug(..  
-0000c850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c860: 2020 2020 2020 2020 2020 6622 4261 7463            f"Batc
-0000c870: 6820 7b62 6174 6368 5f69 647d 2070 726f  h {batch_id} pro
-0000c880: 6365 7373 6564 207b 7265 7375 6c74 5b27  cessed {result['
-0000c890: 6e62 5f72 6f77 735f 646f 6e65 275d 7d20  nb_rows_done']} 
-0000c8a0: 726f 7773 2022 0d0a 2020 2020 2020 2020  rows "..        
-0000c8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c8c0: 2020 2020 6622 287b 726f 7773 5f70 6572      f"({rows_per
-0000c8d0: 5f73 6563 7d2f 7365 6329 220d 0a20 2020  _sec}/sec)"..   
-0000c8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c8f0: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-0000c900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c910: 6966 2022 7065 7266 7374 7269 6e67 2220  if "perfstring" 
-0000c920: 696e 2072 6573 756c 743a 0d0a 2020 2020  in result:..    
+0000b1e0: 6f75 7470 7574 5f70 6174 683d 6f75 7470  output_path=outp
+0000b1f0: 7574 5f70 6174 682c 0a20 2020 2020 2020  ut_path,.       
+0000b200: 2020 2020 2020 2020 2020 2020 2073 716c               sql
+0000b210: 5f73 746d 743d 7371 6c5f 7374 6d74 2c0a  _stmt=sql_stmt,.
+0000b220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b230: 2020 2020 6f75 7470 7574 5f6c 6179 6572      output_layer
+0000b240: 3d6f 7574 7075 745f 6c61 7965 722c 0a20  =output_layer,. 
+0000b250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b260: 2020 2065 7870 6c6f 6465 636f 6c6c 6563     explodecollec
+0000b270: 7469 6f6e 733d 6578 706c 6f64 6563 6f6c  tions=explodecol
+0000b280: 6c65 6374 696f 6e73 2c0a 2020 2020 2020  lections,.      
+0000b290: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+0000b2a0: 2020 2020 2066 696e 616c 6c79 3a0a 2020       finally:.  
+0000b2b0: 2020 2020 2020 2020 2020 2320 436c 6561            # Clea
+0000b2c0: 6e20 746d 7020 6469 7220 6966 2069 7420  n tmp dir if it 
+0000b2d0: 6578 6973 7473 2e2e 2e0a 2020 2020 2020  exists....      
+0000b2e0: 2020 2020 2020 6966 2074 656d 7064 6972        if tempdir
+0000b2f0: 2e65 7869 7374 7328 293a 0a20 2020 2020  .exists():.     
+0000b300: 2020 2020 2020 2020 2020 2073 6875 7469             shuti
+0000b310: 6c2e 726d 7472 6565 2874 656d 7064 6972  l.rmtree(tempdir
+0000b320: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
+0000b330: 2020 2020 7261 6973 6520 4e6f 7449 6d70      raise NotImp
+0000b340: 6c65 6d65 6e74 6564 4572 726f 7228 0a20  lementedError(. 
+0000b350: 2020 2020 2020 2020 2020 2066 2255 6e73             f"Uns
+0000b360: 7570 706f 7274 6564 2069 6e70 7574 2067  upported input g
+0000b370: 656f 6d65 7472 7974 7970 653a 207b 696e  eometrytype: {in
+0000b380: 7075 745f 6c61 7965 7269 6e66 6f2e 6765  put_layerinfo.ge
+0000b390: 6f6d 6574 7279 7479 7065 7d22 0a20 2020  ometrytype}".   
+0000b3a0: 2020 2020 2029 0a0a 2020 2020 2320 5265       )..    # Re
+0000b3b0: 7475 726e 2072 6573 756c 7420 696e 666f  turn result info
+0000b3c0: 0a20 2020 2072 6573 756c 745f 696e 666f  .    result_info
+0000b3d0: 5b0a 2020 2020 2020 2020 226d 6573 7361  [.        "messa
+0000b3e0: 6765 220a 2020 2020 5d20 3d20 6622 4469  ge".    ] = f"Di
+0000b3f0: 7373 6f6c 7665 2063 6f6d 706c 6574 656c  ssolve completel
+0000b400: 7920 7265 6164 792c 2074 6f6f 6b20 7b64  y ready, took {d
+0000b410: 6174 6574 696d 652e 6e6f 7728 292d 7374  atetime.now()-st
+0000b420: 6172 745f 7469 6d65 7d21 220a 2020 2020  art_time}!".    
+0000b430: 6c6f 6767 6572 2e69 6e66 6f28 7265 7375  logger.info(resu
+0000b440: 6c74 5f69 6e66 6f5b 226d 6573 7361 6765  lt_info["message
+0000b450: 225d 290a 2020 2020 7265 7475 726e 2072  "]).    return r
+0000b460: 6573 756c 745f 696e 666f 0a0a 0a64 6566  esult_info...def
+0000b470: 205f 6469 7373 6f6c 7665 5f70 6f6c 7967   _dissolve_polyg
+0000b480: 6f6e 735f 7061 7373 280a 2020 2020 696e  ons_pass(.    in
+0000b490: 7075 745f 7061 7468 3a20 5061 7468 2c0a  put_path: Path,.
+0000b4a0: 2020 2020 6f75 7470 7574 5f6e 6f74 6f6e      output_noton
+0000b4b0: 626f 7264 6572 5f70 6174 683a 2050 6174  border_path: Pat
+0000b4c0: 682c 0a20 2020 206f 7574 7075 745f 6f6e  h,.    output_on
+0000b4d0: 626f 7264 6572 5f70 6174 683a 2050 6174  border_path: Pat
+0000b4e0: 682c 0a20 2020 2065 7870 6c6f 6465 636f  h,.    explodeco
+0000b4f0: 6c6c 6563 7469 6f6e 733a 2062 6f6f 6c2c  llections: bool,
+0000b500: 0a20 2020 2067 726f 7570 6279 5f63 6f6c  .    groupby_col
+0000b510: 756d 6e73 3a20 4f70 7469 6f6e 616c 5b49  umns: Optional[I
+0000b520: 7465 7261 626c 655b 7374 725d 5d2c 0a20  terable[str]],. 
+0000b530: 2020 2061 6767 5f63 6f6c 756d 6e73 3a20     agg_columns: 
+0000b540: 4f70 7469 6f6e 616c 5b64 6963 745d 2c0a  Optional[dict],.
+0000b550: 2020 2020 7469 6c65 735f 6764 663a 2067      tiles_gdf: g
+0000b560: 7064 2e47 656f 4461 7461 4672 616d 652c  pd.GeoDataFrame,
+0000b570: 0a20 2020 2069 6e70 7574 5f6c 6179 6572  .    input_layer
+0000b580: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d2c  : Optional[str],
+0000b590: 0a20 2020 206f 7574 7075 745f 6c61 7965  .    output_laye
+0000b5a0: 723a 204f 7074 696f 6e61 6c5b 7374 725d  r: Optional[str]
+0000b5b0: 2c0a 2020 2020 6e62 5f70 6172 616c 6c65  ,.    nb_paralle
+0000b5c0: 6c3a 2069 6e74 2c0a 2920 2d3e 2064 6963  l: int,.) -> dic
+0000b5d0: 743a 0a20 2020 2023 204d 616b 6520 7375  t:.    # Make su
+0000b5e0: 7265 2074 6865 2069 6e70 7574 2066 696c  re the input fil
+0000b5f0: 6520 6861 7320 6120 7370 6174 6961 6c20  e has a spatial 
+0000b600: 696e 6465 780a 2020 2020 6766 6f2e 6372  index.    gfo.cr
+0000b610: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
+0000b620: 6578 2869 6e70 7574 5f70 6174 682c 2065  ex(input_path, e
+0000b630: 7869 7374 5f6f 6b3d 5472 7565 290a 0a20  xist_ok=True).. 
+0000b640: 2020 2023 2053 7461 7274 2063 616c 6375     # Start calcu
+0000b650: 6c61 7469 6f6e 2069 6e20 7061 7261 6c6c  lation in parall
+0000b660: 656c 0a20 2020 2073 7461 7274 5f74 696d  el.    start_tim
+0000b670: 6520 3d20 6461 7465 7469 6d65 2e6e 6f77  e = datetime.now
+0000b680: 2829 0a20 2020 2072 6573 756c 745f 696e  ().    result_in
+0000b690: 666f 203d 207b 7d0a 2020 2020 7374 6172  fo = {}.    star
+0000b6a0: 745f 7469 6d65 203d 2064 6174 6574 696d  t_time = datetim
+0000b6b0: 652e 6e6f 7728 290a 2020 2020 696e 7075  e.now().    inpu
+0000b6c0: 745f 6c61 7965 7269 6e66 6f20 3d20 6766  t_layerinfo = gf
+0000b6d0: 6f2e 6765 745f 6c61 7965 7269 6e66 6f28  o.get_layerinfo(
+0000b6e0: 696e 7075 745f 7061 7468 2c20 696e 7075  input_path, inpu
+0000b6f0: 745f 6c61 7965 7229 0a0a 2020 2020 2320  t_layer)..    # 
+0000b700: 5072 6f63 6573 7369 6e67 2069 6e20 7468  Processing in th
+0000b710: 7265 6164 7320 6973 2032 7820 6661 7374  reads is 2x fast
+0000b720: 6572 2066 6f72 2073 6d61 6c6c 2064 6174  er for small dat
+0000b730: 6173 6574 7320 286f 6e20 5769 6e64 6f77  asets (on Window
+0000b740: 7329 0a20 2020 2063 616c 6375 6c61 7465  s).    calculate
+0000b750: 5f69 6e5f 7468 7265 6164 7320 3d20 5472  _in_threads = Tr
+0000b760: 7565 2069 6620 696e 7075 745f 6c61 7965  ue if input_laye
+0000b770: 7269 6e66 6f2e 6665 6174 7572 6563 6f75  rinfo.featurecou
+0000b780: 6e74 203c 3d20 3130 3020 656c 7365 2046  nt <= 100 else F
+0000b790: 616c 7365 0a20 2020 2077 6974 6820 5f70  alse.    with _p
+0000b7a0: 726f 6365 7373 696e 675f 7574 696c 2e50  rocessing_util.P
+0000b7b0: 6f6f 6c65 6445 7865 6375 746f 7246 6163  ooledExecutorFac
+0000b7c0: 746f 7279 280a 2020 2020 2020 2020 7468  tory(.        th
+0000b7d0: 7265 6164 706f 6f6c 3d63 616c 6375 6c61  readpool=calcula
+0000b7e0: 7465 5f69 6e5f 7468 7265 6164 732c 0a20  te_in_threads,. 
+0000b7f0: 2020 2020 2020 206d 6178 5f77 6f72 6b65         max_worke
+0000b800: 7273 3d6e 625f 7061 7261 6c6c 656c 2c0a  rs=nb_parallel,.
+0000b810: 2020 2020 2020 2020 696e 6974 6961 6c69          initiali
+0000b820: 7a65 723d 5f70 726f 6365 7373 696e 675f  zer=_processing_
+0000b830: 7574 696c 2e69 6e69 7469 616c 697a 655f  util.initialize_
+0000b840: 776f 726b 6572 2829 2c0a 2020 2020 2920  worker(),.    ) 
+0000b850: 6173 2063 616c 6375 6c61 7465 5f70 6f6f  as calculate_poo
+0000b860: 6c3a 0a20 2020 2020 2020 2023 2050 7265  l:.        # Pre
+0000b870: 7061 7265 206f 7574 7075 7420 6669 6c65  pare output file
+0000b880: 6e61 6d65 0a20 2020 2020 2020 2074 656d  name.        tem
+0000b890: 7064 6972 203d 206f 7574 7075 745f 6f6e  pdir = output_on
+0000b8a0: 626f 7264 6572 5f70 6174 682e 7061 7265  border_path.pare
+0000b8b0: 6e74 0a0a 2020 2020 2020 2020 6261 7463  nt..        batc
+0000b8c0: 6865 7320 3d20 7b7d 0a20 2020 2020 2020  hes = {}.       
+0000b8d0: 206e 625f 6261 7463 6865 7320 3d20 6c65   nb_batches = le
+0000b8e0: 6e28 7469 6c65 735f 6764 6629 0a20 2020  n(tiles_gdf).   
+0000b8f0: 2020 2020 206e 625f 6261 7463 6865 735f       nb_batches_
+0000b900: 646f 6e65 203d 2030 0a20 2020 2020 2020  done = 0.       
+0000b910: 2066 7574 7572 655f 746f 5f62 6174 6368   future_to_batch
+0000b920: 5f69 6420 3d20 7b7d 0a20 2020 2020 2020  _id = {}.       
+0000b930: 206e 625f 726f 7773 5f64 6f6e 6520 3d20   nb_rows_done = 
+0000b940: 300a 2020 2020 2020 2020 666f 7220 6261  0.        for ba
+0000b950: 7463 685f 6964 2c20 7469 6c65 5f72 6f77  tch_id, tile_row
+0000b960: 2069 6e20 656e 756d 6572 6174 6528 7469   in enumerate(ti
+0000b970: 6c65 735f 6764 662e 6974 6572 7475 706c  les_gdf.itertupl
+0000b980: 6573 2829 293a 0a20 2020 2020 2020 2020  es()):.         
+0000b990: 2020 2062 6174 6368 6573 5b62 6174 6368     batches[batch
+0000b9a0: 5f69 645d 203d 207b 7d0a 2020 2020 2020  _id] = {}.      
+0000b9b0: 2020 2020 2020 6261 7463 6865 735b 6261        batches[ba
+0000b9c0: 7463 685f 6964 5d5b 226c 6179 6572 225d  tch_id]["layer"]
+0000b9d0: 203d 206f 7574 7075 745f 6c61 7965 720a   = output_layer.
+0000b9e0: 2020 2020 2020 2020 2020 2020 6261 7463              batc
+0000b9f0: 6865 735b 6261 7463 685f 6964 5d5b 2262  hes[batch_id]["b
+0000ba00: 6f75 6e64 7322 5d20 3d20 7469 6c65 5f72  ounds"] = tile_r
+0000ba10: 6f77 2e67 656f 6d65 7472 792e 626f 756e  ow.geometry.boun
+0000ba20: 6473 0a0a 2020 2020 2020 2020 2020 2020  ds..            
+0000ba30: 2320 4f75 7470 7574 2065 6163 6820 6261  # Output each ba
+0000ba40: 7463 6820 746f 2061 2073 6570 6572 6174  tch to a seperat
+0000ba50: 6520 7465 6d70 6f72 6172 7920 6669 6c65  e temporary file
+0000ba60: 2c20 6f74 6865 7277 6973 6520 7468 6572  , otherwise ther
+0000ba70: 650a 2020 2020 2020 2020 2020 2020 2320  e.            # 
+0000ba80: 6172 6520 7469 6d65 6f75 7420 6973 7375  are timeout issu
+0000ba90: 6573 2077 6865 6e20 7072 6f63 6573 7369  es when processi
+0000baa0: 6e67 206c 6172 6765 2066 696c 6573 0a20  ng large files. 
+0000bab0: 2020 2020 2020 2020 2020 2073 7566 6669             suffi
+0000bac0: 7820 3d20 6f75 7470 7574 5f6e 6f74 6f6e  x = output_noton
+0000bad0: 626f 7264 6572 5f70 6174 682e 7375 6666  border_path.suff
+0000bae0: 6978 0a20 2020 2020 2020 2020 2020 206e  ix.            n
+0000baf0: 616d 6520 3d20 6622 7b6f 7574 7075 745f  ame = f"{output_
+0000bb00: 6e6f 746f 6e62 6f72 6465 725f 7061 7468  notonborder_path
+0000bb10: 2e73 7465 6d7d 5f7b 6261 7463 685f 6964  .stem}_{batch_id
+0000bb20: 7d7b 7375 6666 6978 7d22 0a20 2020 2020  }{suffix}".     
+0000bb30: 2020 2020 2020 206f 7574 7075 745f 6e6f         output_no
+0000bb40: 746f 6e62 6f72 6465 725f 746d 705f 7061  tonborder_tmp_pa
+0000bb50: 7274 6961 6c5f 7061 7468 203d 2074 656d  rtial_path = tem
+0000bb60: 7064 6972 202f 206e 616d 650a 2020 2020  pdir / name.    
+0000bb70: 2020 2020 2020 2020 6261 7463 6865 735b          batches[
+0000bb80: 6261 7463 685f 6964 5d5b 0a20 2020 2020  batch_id][.     
+0000bb90: 2020 2020 2020 2020 2020 2022 6f75 7470             "outp
+0000bba0: 7574 5f6e 6f74 6f6e 626f 7264 6572 5f74  ut_notonborder_t
+0000bbb0: 6d70 5f70 6172 7469 616c 5f70 6174 6822  mp_partial_path"
+0000bbc0: 0a20 2020 2020 2020 2020 2020 205d 203d  .            ] =
+0000bbd0: 206f 7574 7075 745f 6e6f 746f 6e62 6f72   output_notonbor
+0000bbe0: 6465 725f 746d 705f 7061 7274 6961 6c5f  der_tmp_partial_
+0000bbf0: 7061 7468 0a20 2020 2020 2020 2020 2020  path.           
+0000bc00: 206e 616d 6520 3d20 6622 7b6f 7574 7075   name = f"{outpu
+0000bc10: 745f 6f6e 626f 7264 6572 5f70 6174 682e  t_onborder_path.
+0000bc20: 7374 656d 7d5f 7b62 6174 6368 5f69 647d  stem}_{batch_id}
+0000bc30: 7b73 7566 6669 787d 220a 2020 2020 2020  {suffix}".      
+0000bc40: 2020 2020 2020 6f75 7470 7574 5f6f 6e62        output_onb
+0000bc50: 6f72 6465 725f 746d 705f 7061 7274 6961  order_tmp_partia
+0000bc60: 6c5f 7061 7468 203d 2074 656d 7064 6972  l_path = tempdir
+0000bc70: 202f 206e 616d 650a 2020 2020 2020 2020   / name.        
+0000bc80: 2020 2020 6261 7463 6865 735b 6261 7463      batches[batc
+0000bc90: 685f 6964 5d5b 0a20 2020 2020 2020 2020  h_id][.         
+0000bca0: 2020 2020 2020 2022 6f75 7470 7574 5f6f         "output_o
+0000bcb0: 6e62 6f72 6465 725f 746d 705f 7061 7274  nborder_tmp_part
+0000bcc0: 6961 6c5f 7061 7468 220a 2020 2020 2020  ial_path".      
+0000bcd0: 2020 2020 2020 5d20 3d20 6f75 7470 7574        ] = output
+0000bce0: 5f6f 6e62 6f72 6465 725f 746d 705f 7061  _onborder_tmp_pa
+0000bcf0: 7274 6961 6c5f 7061 7468 0a0a 2020 2020  rtial_path..    
+0000bd00: 2020 2020 2020 2020 2320 4765 7420 7469          # Get ti
+0000bd10: 6c65 5f69 6420 6966 2070 7265 7365 6e74  le_id if present
+0000bd20: 0a20 2020 2020 2020 2020 2020 2074 696c  .            til
+0000bd30: 655f 6964 203d 2074 696c 655f 726f 772e  e_id = tile_row.
+0000bd40: 7469 6c65 5f69 6420 6966 2022 7469 6c65  tile_id if "tile
+0000bd50: 5f69 6422 2069 6e20 7469 6c65 5f72 6f77  _id" in tile_row
+0000bd60: 2e5f 6669 656c 6473 2065 6c73 6520 4e6f  ._fields else No
+0000bd70: 6e65 0a0a 2020 2020 2020 2020 2020 2020  ne..            
+0000bd80: 6675 7475 7265 203d 2063 616c 6375 6c61  future = calcula
+0000bd90: 7465 5f70 6f6f 6c2e 7375 626d 6974 280a  te_pool.submit(.
+0000bda0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bdb0: 5f64 6973 736f 6c76 655f 706f 6c79 676f  _dissolve_polygo
+0000bdc0: 6e73 2c0a 2020 2020 2020 2020 2020 2020  ns,.            
+0000bdd0: 2020 2020 696e 7075 745f 7061 7468 3d69      input_path=i
+0000bde0: 6e70 7574 5f70 6174 682c 0a20 2020 2020  nput_path,.     
+0000bdf0: 2020 2020 2020 2020 2020 206f 7574 7075             outpu
+0000be00: 745f 6e6f 746f 6e62 6f72 6465 725f 7061  t_notonborder_pa
+0000be10: 7468 3d6f 7574 7075 745f 6e6f 746f 6e62  th=output_notonb
+0000be20: 6f72 6465 725f 746d 705f 7061 7274 6961  order_tmp_partia
+0000be30: 6c5f 7061 7468 2c0a 2020 2020 2020 2020  l_path,.        
+0000be40: 2020 2020 2020 2020 6f75 7470 7574 5f6f          output_o
+0000be50: 6e62 6f72 6465 725f 7061 7468 3d6f 7574  nborder_path=out
+0000be60: 7075 745f 6f6e 626f 7264 6572 5f74 6d70  put_onborder_tmp
+0000be70: 5f70 6172 7469 616c 5f70 6174 682c 0a20  _partial_path,. 
+0000be80: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000be90: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
+0000bea0: 733d 6578 706c 6f64 6563 6f6c 6c65 6374  s=explodecollect
+0000beb0: 696f 6e73 2c0a 2020 2020 2020 2020 2020  ions,.          
+0000bec0: 2020 2020 2020 6772 6f75 7062 795f 636f        groupby_co
+0000bed0: 6c75 6d6e 733d 6772 6f75 7062 795f 636f  lumns=groupby_co
+0000bee0: 6c75 6d6e 732c 0a20 2020 2020 2020 2020  lumns,.         
+0000bef0: 2020 2020 2020 2061 6767 5f63 6f6c 756d         agg_colum
+0000bf00: 6e73 3d61 6767 5f63 6f6c 756d 6e73 2c0a  ns=agg_columns,.
+0000bf10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bf20: 696e 7075 745f 6765 6f6d 6574 7279 7479  input_geometryty
+0000bf30: 7065 3d69 6e70 7574 5f6c 6179 6572 696e  pe=input_layerin
+0000bf40: 666f 2e67 656f 6d65 7472 7974 7970 652c  fo.geometrytype,
+0000bf50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000bf60: 2069 6e70 7574 5f6c 6179 6572 3d69 6e70   input_layer=inp
+0000bf70: 7574 5f6c 6179 6572 2c0a 2020 2020 2020  ut_layer,.      
+0000bf80: 2020 2020 2020 2020 2020 6f75 7470 7574            output
+0000bf90: 5f6c 6179 6572 3d6f 7574 7075 745f 6c61  _layer=output_la
+0000bfa0: 7965 722c 0a20 2020 2020 2020 2020 2020  yer,.           
+0000bfb0: 2020 2020 2062 626f 783d 7469 6c65 5f72       bbox=tile_r
+0000bfc0: 6f77 2e67 656f 6d65 7472 792e 626f 756e  ow.geometry.boun
+0000bfd0: 6473 2c0a 2020 2020 2020 2020 2020 2020  ds,.            
+0000bfe0: 2020 2020 7469 6c65 5f69 643d 7469 6c65      tile_id=tile
+0000bff0: 5f69 642c 0a20 2020 2020 2020 2020 2020  _id,.           
+0000c000: 2029 0a20 2020 2020 2020 2020 2020 2066   ).            f
+0000c010: 7574 7572 655f 746f 5f62 6174 6368 5f69  uture_to_batch_i
+0000c020: 645b 6675 7475 7265 5d20 3d20 6261 7463  d[future] = batc
+0000c030: 685f 6964 0a0a 2020 2020 2020 2020 2320  h_id..        # 
+0000c040: 4c6f 6f70 2074 696c 6c20 616c 6c20 7061  Loop till all pa
+0000c050: 7261 6c6c 656c 2070 726f 6365 7373 6573  rallel processes
+0000c060: 2061 7265 2072 6561 6479 2c20 6275 7420   are ready, but 
+0000c070: 7072 6f63 6573 7320 6561 6368 206f 6e65  process each one
+0000c080: 0a20 2020 2020 2020 2023 2074 6861 7420  .        # that 
+0000c090: 6973 2072 6561 6479 2061 6c72 6561 6479  is ready already
+0000c0a0: 0a20 2020 2020 2020 205f 6765 6e65 7261  .        _genera
+0000c0b0: 6c5f 7574 696c 2e72 6570 6f72 745f 7072  l_util.report_pr
+0000c0c0: 6f67 7265 7373 280a 2020 2020 2020 2020  ogress(.        
+0000c0d0: 2020 2020 7374 6172 745f 7469 6d65 2c20      start_time, 
+0000c0e0: 6e62 5f62 6174 6368 6573 5f64 6f6e 652c  nb_batches_done,
+0000c0f0: 206e 625f 6261 7463 6865 732c 2022 6469   nb_batches, "di
+0000c100: 7373 6f6c 7665 220a 2020 2020 2020 2020  ssolve".        
+0000c110: 290a 2020 2020 2020 2020 666f 7220 6675  ).        for fu
+0000c120: 7475 7265 2069 6e20 6675 7475 7265 732e  ture in futures.
+0000c130: 6173 5f63 6f6d 706c 6574 6564 2866 7574  as_completed(fut
+0000c140: 7572 655f 746f 5f62 6174 6368 5f69 6429  ure_to_batch_id)
+0000c150: 3a0a 2020 2020 2020 2020 2020 2020 7472  :.            tr
+0000c160: 793a 0a20 2020 2020 2020 2020 2020 2020  y:.             
+0000c170: 2020 2023 2049 6620 7468 6520 6361 6c63     # If the calc
+0000c180: 756c 6174 6520 6761 7665 2072 6573 756c  ulate gave resul
+0000c190: 7473 0a20 2020 2020 2020 2020 2020 2020  ts.             
+0000c1a0: 2020 206e 625f 6261 7463 6865 735f 646f     nb_batches_do
+0000c1b0: 6e65 202b 3d20 310a 2020 2020 2020 2020  ne += 1.        
+0000c1c0: 2020 2020 2020 2020 6261 7463 685f 6964          batch_id
+0000c1d0: 203d 2066 7574 7572 655f 746f 5f62 6174   = future_to_bat
+0000c1e0: 6368 5f69 645b 6675 7475 7265 5d0a 2020  ch_id[future].  
+0000c1f0: 2020 2020 2020 2020 2020 2020 2020 7265                re
+0000c200: 7375 6c74 203d 2066 7574 7572 652e 7265  sult = future.re
+0000c210: 7375 6c74 2829 0a0a 2020 2020 2020 2020  sult()..        
+0000c220: 2020 2020 2020 2020 6966 2072 6573 756c          if resul
+0000c230: 7420 6973 206e 6f74 204e 6f6e 653a 0a20  t is not None:. 
+0000c240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c250: 2020 206e 625f 726f 7773 5f64 6f6e 6520     nb_rows_done 
+0000c260: 2b3d 2072 6573 756c 745b 226e 625f 726f  += result["nb_ro
+0000c270: 7773 5f64 6f6e 6522 5d0a 2020 2020 2020  ws_done"].      
+0000c280: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000c290: 2072 6573 756c 745b 226e 625f 726f 7773   result["nb_rows
+0000c2a0: 5f64 6f6e 6522 5d20 3e20 3020 616e 6420  _done"] > 0 and 
+0000c2b0: 7265 7375 6c74 5b22 746f 7461 6c5f 7469  result["total_ti
+0000c2c0: 6d65 225d 203e 2030 3a0a 2020 2020 2020  me"] > 0:.      
+0000c2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c2e0: 2020 726f 7773 5f70 6572 5f73 6563 203d    rows_per_sec =
+0000c2f0: 2072 6f75 6e64 280a 2020 2020 2020 2020   round(.        
+0000c300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c310: 2020 2020 7265 7375 6c74 5b22 6e62 5f72      result["nb_r
+0000c320: 6f77 735f 646f 6e65 225d 202f 2072 6573  ows_done"] / res
+0000c330: 756c 745b 2274 6f74 616c 5f74 696d 6522  ult["total_time"
+0000c340: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0000c350: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+0000c360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c370: 2020 2020 6c6f 6767 6572 2e64 6562 7567      logger.debug
+0000c380: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000c390: 2020 2020 2020 2020 2020 2020 2020 6622                f"
+0000c3a0: 4261 7463 6820 7b62 6174 6368 5f69 647d  Batch {batch_id}
+0000c3b0: 2070 726f 6365 7373 6564 207b 7265 7375   processed {resu
+0000c3c0: 6c74 5b27 6e62 5f72 6f77 735f 646f 6e65  lt['nb_rows_done
+0000c3d0: 275d 7d20 726f 7773 2022 0a20 2020 2020  ']} rows ".     
+0000c3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c3f0: 2020 2020 2020 2066 2228 7b72 6f77 735f         f"({rows_
+0000c400: 7065 725f 7365 637d 2f73 6563 2922 0a20  per_sec}/sec)". 
+0000c410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c420: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0000c430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c440: 2069 6620 2270 6572 6673 7472 696e 6722   if "perfstring"
+0000c450: 2069 6e20 7265 7375 6c74 3a0a 2020 2020   in result:.    
+0000c460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c470: 2020 2020 2020 2020 6c6f 6767 6572 2e64          logger.d
+0000c480: 6562 7567 2866 2250 6572 6673 7472 696e  ebug(f"Perfstrin
+0000c490: 673a 207b 7265 7375 6c74 5b27 7065 7266  g: {result['perf
+0000c4a0: 7374 7269 6e67 275d 7d22 290a 0a20 2020  string']}")..   
+0000c4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c4c0: 2023 2053 7461 7274 2063 6f70 7920 6f66   # Start copy of
+0000c4d0: 2074 6865 2072 6573 756c 7420 746f 2061   the result to a
+0000c4e0: 2063 6f6d 6d6f 6e20 6669 6c65 0a20 2020   common file.   
+0000c4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c500: 2062 6174 6368 5f69 6420 3d20 6675 7475   batch_id = futu
+0000c510: 7265 5f74 6f5f 6261 7463 685f 6964 5b66  re_to_batch_id[f
+0000c520: 7574 7572 655d 0a0a 2020 2020 2020 2020  uture]..        
+0000c530: 2020 2020 2020 2020 2020 2020 2320 4966              # If
+0000c540: 2063 616c 6375 6c61 7465 2067 6176 6520   calculate gave 
+0000c550: 6e6f 746f 6e62 6f72 6465 7220 7265 7375  notonborder resu
+0000c560: 6c74 732c 2061 7070 656e 6420 746f 206f  lts, append to o
+0000c570: 7574 7075 740a 2020 2020 2020 2020 2020  utput.          
+0000c580: 2020 2020 2020 2020 2020 6f75 7470 7574            output
+0000c590: 5f6e 6f74 6f6e 626f 7264 6572 5f74 6d70  _notonborder_tmp
+0000c5a0: 5f70 6172 7469 616c 5f70 6174 6820 3d20  _partial_path = 
+0000c5b0: 6261 7463 6865 735b 6261 7463 685f 6964  batches[batch_id
+0000c5c0: 5d5b 0a20 2020 2020 2020 2020 2020 2020  ][.             
+0000c5d0: 2020 2020 2020 2020 2020 2022 6f75 7470             "outp
+0000c5e0: 7574 5f6e 6f74 6f6e 626f 7264 6572 5f74  ut_notonborder_t
+0000c5f0: 6d70 5f70 6172 7469 616c 5f70 6174 6822  mp_partial_path"
+0000c600: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c610: 2020 2020 205d 0a20 2020 2020 2020 2020       ].         
+0000c620: 2020 2020 2020 2020 2020 2069 6620 280a             if (.
+0000c630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c640: 2020 2020 2020 2020 6f75 7470 7574 5f6e          output_n
+0000c650: 6f74 6f6e 626f 7264 6572 5f74 6d70 5f70  otonborder_tmp_p
+0000c660: 6172 7469 616c 5f70 6174 682e 6578 6973  artial_path.exis
+0000c670: 7473 2829 0a20 2020 2020 2020 2020 2020  ts().           
+0000c680: 2020 2020 2020 2020 2020 2020 2061 6e64               and
+0000c690: 206f 7574 7075 745f 6e6f 746f 6e62 6f72   output_notonbor
+0000c6a0: 6465 725f 746d 705f 7061 7274 6961 6c5f  der_tmp_partial_
+0000c6b0: 7061 7468 2e73 7461 7428 292e 7374 5f73  path.stat().st_s
+0000c6c0: 697a 6520 3e20 300a 2020 2020 2020 2020  ize > 0.        
+0000c6d0: 2020 2020 2020 2020 2020 2020 293a 0a20              ):. 
+0000c6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c6f0: 2020 2020 2020 2066 696c 656f 7073 2e5f         fileops._
+0000c700: 6170 7065 6e64 5f74 6f5f 6e6f 6c6f 636b  append_to_nolock
+0000c710: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000c720: 2020 2020 2020 2020 2020 2020 2020 7372                sr
+0000c730: 633d 6f75 7470 7574 5f6e 6f74 6f6e 626f  c=output_notonbo
+0000c740: 7264 6572 5f74 6d70 5f70 6172 7469 616c  rder_tmp_partial
+0000c750: 5f70 6174 682c 0a20 2020 2020 2020 2020  _path,.         
+0000c760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c770: 2020 2064 7374 3d6f 7574 7075 745f 6e6f     dst=output_no
+0000c780: 746f 6e62 6f72 6465 725f 7061 7468 2c0a  tonborder_path,.
+0000c790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c7a0: 2020 2020 2020 2020 2020 2020 6372 6561              crea
+0000c7b0: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
+0000c7c0: 3d46 616c 7365 2c0a 2020 2020 2020 2020  =False,.        
+0000c7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c7e0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000c7f0: 2020 2020 2020 2020 2020 6766 6f2e 7265            gfo.re
+0000c800: 6d6f 7665 286f 7574 7075 745f 6e6f 746f  move(output_noto
+0000c810: 6e62 6f72 6465 725f 746d 705f 7061 7274  nborder_tmp_part
+0000c820: 6961 6c5f 7061 7468 290a 0a20 2020 2020  ial_path)..     
+0000c830: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000c840: 2049 6620 6361 6c63 756c 6174 6520 6761   If calculate ga
+0000c850: 7665 206f 6e62 6f72 6465 7220 7265 7375  ve onborder resu
+0000c860: 6c74 732c 2061 7070 656e 6420 746f 206f  lts, append to o
+0000c870: 7574 7075 740a 2020 2020 2020 2020 2020  utput.          
+0000c880: 2020 2020 2020 2020 2020 6f75 7470 7574            output
+0000c890: 5f6f 6e62 6f72 6465 725f 746d 705f 7061  _onborder_tmp_pa
+0000c8a0: 7274 6961 6c5f 7061 7468 203d 2062 6174  rtial_path = bat
+0000c8b0: 6368 6573 5b62 6174 6368 5f69 645d 5b0a  ches[batch_id][.
+0000c8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c8d0: 2020 2020 2020 2020 226f 7574 7075 745f          "output_
+0000c8e0: 6f6e 626f 7264 6572 5f74 6d70 5f70 6172  onborder_tmp_par
+0000c8f0: 7469 616c 5f70 6174 6822 0a20 2020 2020  tial_path".     
+0000c900: 2020 2020 2020 2020 2020 2020 2020 205d                 ]
+0000c910: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c920: 2020 2020 2069 6620 280a 2020 2020 2020       if (.      
 0000c930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c940: 2020 2020 2020 2020 6c6f 6767 6572 2e64          logger.d
-0000c950: 6562 7567 2866 2250 6572 6673 7472 696e  ebug(f"Perfstrin
-0000c960: 673a 207b 7265 7375 6c74 5b27 7065 7266  g: {result['perf
-0000c970: 7374 7269 6e67 275d 7d22 290d 0a0d 0a20  string']}").... 
-0000c980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c990: 2020 2023 2053 7461 7274 2063 6f70 7920     # Start copy 
-0000c9a0: 6f66 2074 6865 2072 6573 756c 7420 746f  of the result to
-0000c9b0: 2061 2063 6f6d 6d6f 6e20 6669 6c65 0d0a   a common file..
+0000c940: 2020 6f75 7470 7574 5f6f 6e62 6f72 6465    output_onborde
+0000c950: 725f 746d 705f 7061 7274 6961 6c5f 7061  r_tmp_partial_pa
+0000c960: 7468 2e65 7869 7374 7328 290a 2020 2020  th.exists().    
+0000c970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c980: 2020 2020 616e 6420 6f75 7470 7574 5f6f      and output_o
+0000c990: 6e62 6f72 6465 725f 746d 705f 7061 7274  nborder_tmp_part
+0000c9a0: 6961 6c5f 7061 7468 2e73 7461 7428 292e  ial_path.stat().
+0000c9b0: 7374 5f73 697a 6520 3e20 300a 2020 2020  st_size > 0.    
 0000c9c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c9d0: 2020 2020 6261 7463 685f 6964 203d 2066      batch_id = f
-0000c9e0: 7574 7572 655f 746f 5f62 6174 6368 5f69  uture_to_batch_i
-0000c9f0: 645b 6675 7475 7265 5d0d 0a0d 0a20 2020  d[future]....   
-0000ca00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ca10: 2023 2049 6620 6361 6c63 756c 6174 6520   # If calculate 
-0000ca20: 6761 7665 206e 6f74 6f6e 626f 7264 6572  gave notonborder
-0000ca30: 2072 6573 756c 7473 2c20 6170 7065 6e64   results, append
-0000ca40: 2074 6f20 6f75 7470 7574 0d0a 2020 2020   to output..    
+0000c9d0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000c9e0: 2020 2020 2020 2020 2020 2066 696c 656f             fileo
+0000c9f0: 7073 2e5f 6170 7065 6e64 5f74 6f5f 6e6f  ps._append_to_no
+0000ca00: 6c6f 636b 280a 2020 2020 2020 2020 2020  lock(.          
+0000ca10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ca20: 2020 7372 633d 6f75 7470 7574 5f6f 6e62    src=output_onb
+0000ca30: 6f72 6465 725f 746d 705f 7061 7274 6961  order_tmp_partia
+0000ca40: 6c5f 7061 7468 2c0a 2020 2020 2020 2020  l_path,.        
 0000ca50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ca60: 6f75 7470 7574 5f6e 6f74 6f6e 626f 7264  output_notonbord
-0000ca70: 6572 5f74 6d70 5f70 6172 7469 616c 5f70  er_tmp_partial_p
-0000ca80: 6174 6820 3d20 6261 7463 6865 735b 6261  ath = batches[ba
-0000ca90: 7463 685f 6964 5d5b 0d0a 2020 2020 2020  tch_id][..      
-0000caa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cab0: 2020 226f 7574 7075 745f 6e6f 746f 6e62    "output_notonb
-0000cac0: 6f72 6465 725f 746d 705f 7061 7274 6961  order_tmp_partia
-0000cad0: 6c5f 7061 7468 220d 0a20 2020 2020 2020  l_path"..       
-0000cae0: 2020 2020 2020 2020 2020 2020 205d 0d0a               ]..
-0000caf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb00: 2020 2020 6966 2028 0d0a 2020 2020 2020      if (..      
-0000cb10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb20: 2020 6f75 7470 7574 5f6e 6f74 6f6e 626f    output_notonbo
-0000cb30: 7264 6572 5f74 6d70 5f70 6172 7469 616c  rder_tmp_partial
-0000cb40: 5f70 6174 682e 6578 6973 7473 2829 0d0a  _path.exists()..
-0000cb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb60: 2020 2020 2020 2020 616e 6420 6f75 7470          and outp
-0000cb70: 7574 5f6e 6f74 6f6e 626f 7264 6572 5f74  ut_notonborder_t
-0000cb80: 6d70 5f70 6172 7469 616c 5f70 6174 682e  mp_partial_path.
-0000cb90: 7374 6174 2829 2e73 745f 7369 7a65 203e  stat().st_size >
-0000cba0: 2030 0d0a 2020 2020 2020 2020 2020 2020   0..            
-0000cbb0: 2020 2020 2020 2020 293a 0d0a 2020 2020          ):..    
-0000cbc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cbd0: 2020 2020 6669 6c65 6f70 732e 5f61 7070      fileops._app
-0000cbe0: 656e 645f 746f 5f6e 6f6c 6f63 6b28 0d0a  end_to_nolock(..
-0000cbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc00: 2020 2020 2020 2020 2020 2020 7372 633d              src=
-0000cc10: 6f75 7470 7574 5f6e 6f74 6f6e 626f 7264  output_notonbord
-0000cc20: 6572 5f74 6d70 5f70 6172 7469 616c 5f70  er_tmp_partial_p
-0000cc30: 6174 682c 0d0a 2020 2020 2020 2020 2020  ath,..          
-0000cc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc50: 2020 6473 743d 6f75 7470 7574 5f6e 6f74    dst=output_not
-0000cc60: 6f6e 626f 7264 6572 5f70 6174 682c 0d0a  onborder_path,..
-0000cc70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc80: 2020 2020 2020 2020 2020 2020 6372 6561              crea
-0000cc90: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
-0000cca0: 3d46 616c 7365 2c0d 0a20 2020 2020 2020  =False,..       
-0000ccb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ccc0: 2029 0d0a 2020 2020 2020 2020 2020 2020   )..            
-0000ccd0: 2020 2020 2020 2020 2020 2020 6766 6f2e              gfo.
-0000cce0: 7265 6d6f 7665 286f 7574 7075 745f 6e6f  remove(output_no
-0000ccf0: 746f 6e62 6f72 6465 725f 746d 705f 7061  tonborder_tmp_pa
-0000cd00: 7274 6961 6c5f 7061 7468 290d 0a0d 0a20  rtial_path).... 
-0000cd10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cd20: 2020 2023 2049 6620 6361 6c63 756c 6174     # If calculat
-0000cd30: 6520 6761 7665 206f 6e62 6f72 6465 7220  e gave onborder 
-0000cd40: 7265 7375 6c74 732c 2061 7070 656e 6420  results, append 
-0000cd50: 746f 206f 7574 7075 740d 0a20 2020 2020  to output..     
-0000cd60: 2020 2020 2020 2020 2020 2020 2020 206f                 o
-0000cd70: 7574 7075 745f 6f6e 626f 7264 6572 5f74  utput_onborder_t
-0000cd80: 6d70 5f70 6172 7469 616c 5f70 6174 6820  mp_partial_path 
-0000cd90: 3d20 6261 7463 6865 735b 6261 7463 685f  = batches[batch_
-0000cda0: 6964 5d5b 0d0a 2020 2020 2020 2020 2020  id][..          
-0000cdb0: 2020 2020 2020 2020 2020 2020 2020 226f                "o
-0000cdc0: 7574 7075 745f 6f6e 626f 7264 6572 5f74  utput_onborder_t
-0000cdd0: 6d70 5f70 6172 7469 616c 5f70 6174 6822  mp_partial_path"
-0000cde0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000cdf0: 2020 2020 2020 5d0d 0a20 2020 2020 2020        ]..       
-0000ce00: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000ce10: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-0000ce20: 2020 2020 2020 2020 2020 206f 7574 7075             outpu
-0000ce30: 745f 6f6e 626f 7264 6572 5f74 6d70 5f70  t_onborder_tmp_p
-0000ce40: 6172 7469 616c 5f70 6174 682e 6578 6973  artial_path.exis
-0000ce50: 7473 2829 0d0a 2020 2020 2020 2020 2020  ts()..          
-0000ce60: 2020 2020 2020 2020 2020 2020 2020 616e                an
-0000ce70: 6420 6f75 7470 7574 5f6f 6e62 6f72 6465  d output_onborde
-0000ce80: 725f 746d 705f 7061 7274 6961 6c5f 7061  r_tmp_partial_pa
-0000ce90: 7468 2e73 7461 7428 292e 7374 5f73 697a  th.stat().st_siz
-0000cea0: 6520 3e20 300d 0a20 2020 2020 2020 2020  e > 0..         
-0000ceb0: 2020 2020 2020 2020 2020 2029 3a0d 0a20             ):.. 
-0000cec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ced0: 2020 2020 2020 2066 696c 656f 7073 2e5f         fileops._
-0000cee0: 6170 7065 6e64 5f74 6f5f 6e6f 6c6f 636b  append_to_nolock
-0000cef0: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-0000cf00: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000cf10: 7263 3d6f 7574 7075 745f 6f6e 626f 7264  rc=output_onbord
-0000cf20: 6572 5f74 6d70 5f70 6172 7469 616c 5f70  er_tmp_partial_p
-0000cf30: 6174 682c 0d0a 2020 2020 2020 2020 2020  ath,..          
-0000cf40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cf50: 2020 6473 743d 6f75 7470 7574 5f6f 6e62    dst=output_onb
-0000cf60: 6f72 6465 725f 7061 7468 2c0d 0a20 2020  order_path,..   
-0000cf70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cf80: 2020 2020 2020 2020 2063 7265 6174 655f           create_
-0000cf90: 7370 6174 6961 6c5f 696e 6465 783d 4661  spatial_index=Fa
-0000cfa0: 6c73 652c 0d0a 2020 2020 2020 2020 2020  lse,..          
-0000cfb0: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-0000cfc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000cfd0: 2020 2020 2020 2020 2067 666f 2e72 656d           gfo.rem
-0000cfe0: 6f76 6528 6f75 7470 7574 5f6f 6e62 6f72  ove(output_onbor
-0000cff0: 6465 725f 746d 705f 7061 7274 6961 6c5f  der_tmp_partial_
-0000d000: 7061 7468 290d 0a0d 0a20 2020 2020 2020  path)....       
-0000d010: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
-0000d020: 7074 696f 6e20 6173 2065 783a 0d0a 2020  ption as ex:..  
-0000d030: 2020 2020 2020 2020 2020 2020 2020 6261                ba
-0000d040: 7463 685f 6964 203d 2066 7574 7572 655f  tch_id = future_
-0000d050: 746f 5f62 6174 6368 5f69 645b 6675 7475  to_batch_id[futu
-0000d060: 7265 5d0d 0a20 2020 2020 2020 2020 2020  re]..           
-0000d070: 2020 2020 206d 6573 7361 6765 203d 2066       message = f
-0000d080: 2245 7272 6f72 2065 7865 6375 7469 6e67  "Error executing
-0000d090: 207b 6261 7463 6865 735b 6261 7463 685f   {batches[batch_
-0000d0a0: 6964 5d7d 3a20 7b65 787d 220d 0a20 2020  id]}: {ex}"..   
-0000d0b0: 2020 2020 2020 2020 2020 2020 206c 6f67               log
-0000d0c0: 6765 722e 6578 6365 7074 696f 6e28 6d65  ger.exception(me
-0000d0d0: 7373 6167 6529 0d0a 2020 2020 2020 2020  ssage)..        
-0000d0e0: 2020 2020 2020 2020 6361 6c63 756c 6174          calculat
-0000d0f0: 655f 706f 6f6c 2e73 6875 7464 6f77 6e28  e_pool.shutdown(
-0000d100: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-0000d110: 2020 2072 6169 7365 2045 7863 6570 7469     raise Excepti
-0000d120: 6f6e 286d 6573 7361 6765 2920 6672 6f6d  on(message) from
-0000d130: 2065 780d 0a0d 0a20 2020 2020 2020 2020   ex....         
-0000d140: 2020 2023 204c 6f67 2074 6865 2070 726f     # Log the pro
-0000d150: 6772 6573 7320 616e 6420 7072 6564 6963  gress and predic
-0000d160: 7469 6f6e 2073 7065 6564 0d0a 2020 2020  tion speed..    
-0000d170: 2020 2020 2020 2020 5f67 656e 6572 616c          _general
-0000d180: 5f75 7469 6c2e 7265 706f 7274 5f70 726f  _util.report_pro
-0000d190: 6772 6573 7328 0d0a 2020 2020 2020 2020  gress(..        
-0000d1a0: 2020 2020 2020 2020 7374 6172 745f 7469          start_ti
-0000d1b0: 6d65 2c20 6e62 5f62 6174 6368 6573 5f64  me, nb_batches_d
-0000d1c0: 6f6e 652c 206e 625f 6261 7463 6865 732c  one, nb_batches,
-0000d1d0: 2022 6469 7373 6f6c 7665 220d 0a20 2020   "dissolve"..   
-0000d1e0: 2020 2020 2020 2020 2029 0d0a 0d0a 2020           )....  
-0000d1f0: 2020 6c6f 6767 6572 2e69 6e66 6f28 6622    logger.info(f"
-0000d200: 4469 7373 6f6c 7665 2070 6173 7320 7265  Dissolve pass re
-0000d210: 6164 792c 2074 6f6f 6b20 7b64 6174 6574  ady, took {datet
-0000d220: 696d 652e 6e6f 7728 292d 7374 6172 745f  ime.now()-start_
-0000d230: 7469 6d65 7d21 2229 0d0a 0d0a 2020 2020  time}!")....    
-0000d240: 7265 7475 726e 2072 6573 756c 745f 696e  return result_in
-0000d250: 666f 0d0a 0d0a 0d0a 6465 6620 5f64 6973  fo......def _dis
-0000d260: 736f 6c76 655f 706f 6c79 676f 6e73 280d  solve_polygons(.
-0000d270: 0a20 2020 2069 6e70 7574 5f70 6174 683a  .    input_path:
-0000d280: 2050 6174 682c 0d0a 2020 2020 6f75 7470   Path,..    outp
-0000d290: 7574 5f6e 6f74 6f6e 626f 7264 6572 5f70  ut_notonborder_p
-0000d2a0: 6174 683a 2050 6174 682c 0d0a 2020 2020  ath: Path,..    
-0000d2b0: 6f75 7470 7574 5f6f 6e62 6f72 6465 725f  output_onborder_
-0000d2c0: 7061 7468 3a20 5061 7468 2c0d 0a20 2020  path: Path,..   
-0000d2d0: 2065 7870 6c6f 6465 636f 6c6c 6563 7469   explodecollecti
-0000d2e0: 6f6e 733a 2062 6f6f 6c2c 0d0a 2020 2020  ons: bool,..    
-0000d2f0: 6772 6f75 7062 795f 636f 6c75 6d6e 733a  groupby_columns:
-0000d300: 204f 7074 696f 6e61 6c5b 4974 6572 6162   Optional[Iterab
-0000d310: 6c65 5b73 7472 5d5d 2c0d 0a20 2020 2061  le[str]],..    a
-0000d320: 6767 5f63 6f6c 756d 6e73 3a20 4f70 7469  gg_columns: Opti
-0000d330: 6f6e 616c 5b64 6963 745d 2c0d 0a20 2020  onal[dict],..   
-0000d340: 2069 6e70 7574 5f67 656f 6d65 7472 7974   input_geometryt
-0000d350: 7970 653a 2047 656f 6d65 7472 7954 7970  ype: GeometryTyp
-0000d360: 652c 0d0a 2020 2020 696e 7075 745f 6c61  e,..    input_la
-0000d370: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
-0000d380: 725d 2c0d 0a20 2020 206f 7574 7075 745f  r],..    output_
-0000d390: 6c61 7965 723a 204f 7074 696f 6e61 6c5b  layer: Optional[
-0000d3a0: 7374 725d 2c0d 0a20 2020 2062 626f 783a  str],..    bbox:
-0000d3b0: 2054 7570 6c65 5b66 6c6f 6174 2c20 666c   Tuple[float, fl
-0000d3c0: 6f61 742c 2066 6c6f 6174 2c20 666c 6f61  oat, float, floa
-0000d3d0: 745d 2c0d 0a20 2020 2074 696c 655f 6964  t],..    tile_id
-0000d3e0: 3a20 4f70 7469 6f6e 616c 5b69 6e74 5d2c  : Optional[int],
-0000d3f0: 0d0a 2920 2d3e 2064 6963 743a 0d0a 2020  ..) -> dict:..  
-0000d400: 2020 2320 496e 6974 0d0a 2020 2020 7065    # Init..    pe
-0000d410: 7266 696e 666f 203d 207b 7d0d 0a20 2020  rfinfo = {}..   
-0000d420: 2073 7461 7274 5f74 696d 6520 3d20 6461   start_time = da
-0000d430: 7465 7469 6d65 2e6e 6f77 2829 0d0a 2020  tetime.now()..  
-0000d440: 2020 7265 7475 726e 5f69 6e66 6f20 3d20    return_info = 
-0000d450: 7b0d 0a20 2020 2020 2020 2022 696e 7075  {..        "inpu
-0000d460: 745f 7061 7468 223a 2069 6e70 7574 5f70  t_path": input_p
-0000d470: 6174 682c 0d0a 2020 2020 2020 2020 226f  ath,..        "o
-0000d480: 7574 7075 745f 6e6f 746f 6e62 6f72 6465  utput_notonborde
-0000d490: 725f 7061 7468 223a 206f 7574 7075 745f  r_path": output_
-0000d4a0: 6e6f 746f 6e62 6f72 6465 725f 7061 7468  notonborder_path
-0000d4b0: 2c0d 0a20 2020 2020 2020 2022 6f75 7470  ,..        "outp
-0000d4c0: 7574 5f6f 6e62 6f72 6465 725f 7061 7468  ut_onborder_path
-0000d4d0: 223a 206f 7574 7075 745f 6f6e 626f 7264  ": output_onbord
-0000d4e0: 6572 5f70 6174 682c 0d0a 2020 2020 2020  er_path,..      
-0000d4f0: 2020 2262 626f 7822 3a20 6262 6f78 2c0d    "bbox": bbox,.
-0000d500: 0a20 2020 2020 2020 2022 7469 6c65 5f69  .        "tile_i
-0000d510: 6422 3a20 7469 6c65 5f69 642c 0d0a 2020  d": tile_id,..  
-0000d520: 2020 2020 2020 226e 625f 726f 7773 5f64        "nb_rows_d
-0000d530: 6f6e 6522 3a20 302c 0d0a 2020 2020 2020  one": 0,..      
-0000d540: 2020 2274 6f74 616c 5f74 696d 6522 3a20    "total_time": 
-0000d550: 302c 0d0a 2020 2020 2020 2020 2270 6572  0,..        "per
-0000d560: 6669 6e66 6f22 3a20 2222 2c0d 0a20 2020  finfo": "",..   
-0000d570: 207d 0d0a 0d0a 2020 2020 2320 5265 6164   }....    # Read
-0000d580: 2061 6c6c 2072 6563 6f72 6473 2074 6861   all records tha
-0000d590: 7420 6172 6520 696e 2074 6865 2062 626f  t are in the bbo
-0000d5a0: 780d 0a20 2020 2072 6574 7279 5f63 6f75  x..    retry_cou
-0000d5b0: 6e74 203d 2030 0d0a 2020 2020 7374 6172  nt = 0..    star
-0000d5c0: 745f 7265 6164 203d 2064 6174 6574 696d  t_read = datetim
-0000d5d0: 652e 6e6f 7728 290d 0a20 2020 2061 6767  e.now()..    agg
-0000d5e0: 5f63 6f6c 756d 6e73 5f6e 6565 6465 6420  _columns_needed 
-0000d5f0: 3d20 4e6f 6e65 0d0a 2020 2020 7768 696c  = None..    whil
-0000d600: 6520 5472 7565 3a0d 0a20 2020 2020 2020  e True:..       
-0000d610: 2074 7279 3a0d 0a20 2020 2020 2020 2020   try:..         
-0000d620: 2020 2063 6f6c 756d 6e73 5f74 6f5f 7265     columns_to_re
-0000d630: 6164 203d 2073 6574 2829 0d0a 2020 2020  ad = set()..    
-0000d640: 2020 2020 2020 2020 696e 666f 203d 2067          info = g
-0000d650: 666f 2e67 6574 5f6c 6179 6572 696e 666f  fo.get_layerinfo
-0000d660: 2869 6e70 7574 5f70 6174 682c 2069 6e70  (input_path, inp
-0000d670: 7574 5f6c 6179 6572 290d 0a20 2020 2020  ut_layer)..     
-0000d680: 2020 2020 2020 2069 6620 6772 6f75 7062         if groupb
-0000d690: 795f 636f 6c75 6d6e 7320 6973 206e 6f74  y_columns is not
-0000d6a0: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-0000d6b0: 2020 2020 2020 2020 636f 6c75 6d6e 735f          columns_
-0000d6c0: 746f 5f72 6561 642e 7570 6461 7465 2867  to_read.update(g
-0000d6d0: 726f 7570 6279 5f63 6f6c 756d 6e73 290d  roupby_columns).
-0000d6e0: 0a20 2020 2020 2020 2020 2020 2066 6964  .            fid
-0000d6f0: 5f61 735f 696e 6465 7820 3d20 4661 6c73  _as_index = Fals
-0000d700: 650d 0a20 2020 2020 2020 2020 2020 2069  e..            i
-0000d710: 6620 6167 675f 636f 6c75 6d6e 7320 6973  f agg_columns is
-0000d720: 206e 6f74 204e 6f6e 653a 0d0a 2020 2020   not None:..    
-0000d730: 2020 2020 2020 2020 2020 2020 6669 645f              fid_
-0000d740: 6173 5f69 6e64 6578 203d 2054 7275 650d  as_index = True.
-0000d750: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d760: 2069 6620 225f 5f44 4953 534f 4c56 455f   if "__DISSOLVE_
-0000d770: 544f 4a53 4f4e 2220 696e 2069 6e66 6f2e  TOJSON" in info.
-0000d780: 636f 6c75 6d6e 733a 0d0a 2020 2020 2020  columns:..      
-0000d790: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000d7a0: 4966 2077 6520 6172 6520 6e6f 7420 696e  If we are not in
-0000d7b0: 2074 6865 2066 6972 7374 2070 6173 732c   the first pass,
-0000d7c0: 2074 6865 2063 6f6c 756d 6e73 2074 6f20   the columns to 
-0000d7d0: 6265 2072 6561 640d 0a20 2020 2020 2020  be read..       
-0000d7e0: 2020 2020 2020 2020 2020 2020 2023 2061               # a
-0000d7f0: 7265 2061 6c72 6561 6479 2069 6e20 7468  re already in th
-0000d800: 6520 6a73 6f6e 2063 6f6c 756d 6e0d 0a20  e json column.. 
-0000d810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d820: 2020 2063 6f6c 756d 6e73 5f74 6f5f 7265     columns_to_re
-0000d830: 6164 2e61 6464 2822 5f5f 4449 5353 4f4c  ad.add("__DISSOL
-0000d840: 5645 5f54 4f4a 534f 4e22 290d 0a20 2020  VE_TOJSON")..   
-0000d850: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0000d860: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-0000d870: 2020 2020 2020 2020 2320 5468 6520 6669          # The fi
-0000d880: 7273 7420 7061 7373 2c20 736f 2072 6561  rst pass, so rea
-0000d890: 6420 616c 6c20 7265 6c65 7661 6e74 2063  d all relevant c
-0000d8a0: 6f6c 756d 6e73 2074 6f20 636f 6465 0d0a  olumns to code..
-0000d8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d8c0: 2020 2020 2320 7468 656d 2069 6e20 6a73      # them in js
-0000d8d0: 6f6e 0d0a 2020 2020 2020 2020 2020 2020  on..            
-0000d8e0: 2020 2020 2020 2020 6966 2022 6a73 6f6e          if "json
-0000d8f0: 2220 696e 2061 6767 5f63 6f6c 756d 6e73  " in agg_columns
-0000d900: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0000d910: 2020 2020 2020 2020 2020 2061 6767 5f63             agg_c
-0000d920: 6f6c 756d 6e73 5f6e 6565 6465 6420 3d20  olumns_needed = 
-0000d930: 6167 675f 636f 6c75 6d6e 735b 226a 736f  agg_columns["jso
-0000d940: 6e22 5d0d 0a20 2020 2020 2020 2020 2020  n"]..           
-0000d950: 2020 2020 2020 2020 2065 6c69 6620 2263           elif "c
-0000d960: 6f6c 756d 6e73 2220 696e 2061 6767 5f63  olumns" in agg_c
-0000d970: 6f6c 756d 6e73 3a0d 0a20 2020 2020 2020  olumns:..       
-0000d980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d990: 2061 6767 5f63 6f6c 756d 6e73 5f6e 6565   agg_columns_nee
-0000d9a0: 6465 6420 3d20 5b0d 0a20 2020 2020 2020  ded = [..       
-0000d9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d9c0: 2020 2020 2061 6767 5f63 6f6c 756d 6e5b       agg_column[
-0000d9d0: 2263 6f6c 756d 6e22 5d0d 0a20 2020 2020  "column"]..     
-0000d9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d9f0: 2020 2020 2020 2066 6f72 2061 6767 5f63         for agg_c
-0000da00: 6f6c 756d 6e20 696e 2061 6767 5f63 6f6c  olumn in agg_col
-0000da10: 756d 6e73 5b22 636f 6c75 6d6e 7322 5d0d  umns["columns"].
-0000da20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000da30: 2020 2020 2020 2020 205d 0d0a 2020 2020           ]..    
-0000da40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000da50: 6966 2061 6767 5f63 6f6c 756d 6e73 5f6e  if agg_columns_n
-0000da60: 6565 6465 6420 6973 206e 6f74 204e 6f6e  eeded is not Non
-0000da70: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-0000da80: 2020 2020 2020 2020 2020 2020 636f 6c75              colu
-0000da90: 6d6e 735f 746f 5f72 6561 642e 7570 6461  mns_to_read.upda
-0000daa0: 7465 2861 6767 5f63 6f6c 756d 6e73 5f6e  te(agg_columns_n
-0000dab0: 6565 6465 6429 0d0a 0d0a 2020 2020 2020  eeded)....      
-0000dac0: 2020 2020 2020 696e 7075 745f 6764 6620        input_gdf 
-0000dad0: 3d20 6766 6f2e 7265 6164 5f66 696c 6528  = gfo.read_file(
-0000dae0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000daf0: 2020 7061 7468 3d69 6e70 7574 5f70 6174    path=input_pat
-0000db00: 682c 0d0a 2020 2020 2020 2020 2020 2020  h,..            
-0000db10: 2020 2020 6c61 7965 723d 696e 7075 745f      layer=input_
-0000db20: 6c61 7965 722c 0d0a 2020 2020 2020 2020  layer,..        
-0000db30: 2020 2020 2020 2020 6262 6f78 3d62 626f          bbox=bbo
-0000db40: 782c 0d0a 2020 2020 2020 2020 2020 2020  x,..            
-0000db50: 2020 2020 636f 6c75 6d6e 733d 636f 6c75      columns=colu
-0000db60: 6d6e 735f 746f 5f72 6561 642c 0d0a 2020  mns_to_read,..  
-0000db70: 2020 2020 2020 2020 2020 2020 2020 6669                fi
-0000db80: 645f 6173 5f69 6e64 6578 3d66 6964 5f61  d_as_index=fid_a
-0000db90: 735f 696e 6465 782c 0d0a 2020 2020 2020  s_index,..      
-0000dba0: 2020 2020 2020 290d 0a0d 0a20 2020 2020        )....     
-0000dbb0: 2020 2020 2020 2069 6620 6167 675f 636f         if agg_co
-0000dbc0: 6c75 6d6e 7320 6973 206e 6f74 204e 6f6e  lumns is not Non
-0000dbd0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-0000dbe0: 2020 2020 696e 7075 745f 6764 665b 2266      input_gdf["f
-0000dbf0: 6964 5f6f 7269 6722 5d20 3d20 696e 7075  id_orig"] = inpu
-0000dc00: 745f 6764 662e 696e 6465 780d 0a20 2020  t_gdf.index..   
-0000dc10: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000dc20: 6167 675f 636f 6c75 6d6e 735f 6e65 6564  agg_columns_need
-0000dc30: 6564 2069 7320 6e6f 7420 4e6f 6e65 3a0d  ed is not None:.
-0000dc40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000dc50: 2020 2020 2061 6767 5f63 6f6c 756d 6e73       agg_columns
-0000dc60: 5f6e 6565 6465 642e 6170 7065 6e64 2822  _needed.append("
-0000dc70: 6669 645f 6f72 6967 2229 0d0a 0d0a 2020  fid_orig")....  
-0000dc80: 2020 2020 2020 2020 2020 6272 6561 6b0d            break.
-0000dc90: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
-0000dca0: 4578 6365 7074 696f 6e20 6173 2065 783a  Exception as ex:
-0000dcb0: 0d0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-0000dcc0: 2073 7472 2865 7829 203d 3d20 2264 6174   str(ex) == "dat
-0000dcd0: 6162 6173 6520 6973 206c 6f63 6b65 6422  abase is locked"
-0000dce0: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0000dcf0: 2020 2069 6620 7265 7472 795f 636f 756e     if retry_coun
-0000dd00: 7420 3c20 3130 3a0d 0a20 2020 2020 2020  t < 10:..       
-0000dd10: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-0000dd20: 7279 5f63 6f75 6e74 202b 3d20 310d 0a20  ry_count += 1.. 
-0000dd30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd40: 2020 2074 696d 652e 736c 6565 7028 3129     time.sleep(1)
-0000dd50: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000dd60: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-0000dd70: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-0000dd80: 7365 2045 7863 6570 7469 6f6e 2822 7265  se Exception("re
-0000dd90: 7472 6965 6420 3130 2074 696d 6573 2c20  tried 10 times, 
-0000dda0: 6461 7461 6261 7365 2073 7469 6c6c 206c  database still l
-0000ddb0: 6f63 6b65 6422 2920 6672 6f6d 2065 780d  ocked") from ex.
-0000ddc0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-0000ddd0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-0000dde0: 2020 2020 7261 6973 6520 6578 0d0a 0d0a      raise ex....
-0000ddf0: 2020 2020 2320 4368 6563 6b20 7265 7375      # Check resu
-0000de00: 6c74 0d0a 2020 2020 7065 7266 696e 666f  lt..    perfinfo
-0000de10: 5b22 7469 6d65 5f72 6561 6422 5d20 3d20  ["time_read"] = 
-0000de20: 2864 6174 6574 696d 652e 6e6f 7728 2920  (datetime.now() 
-0000de30: 2d20 7374 6172 745f 7265 6164 292e 746f  - start_read).to
-0000de40: 7461 6c5f 7365 636f 6e64 7328 290d 0a20  tal_seconds().. 
-0000de50: 2020 2072 6574 7572 6e5f 696e 666f 5b22     return_info["
-0000de60: 6e62 5f72 6f77 735f 646f 6e65 225d 203d  nb_rows_done"] =
-0000de70: 206c 656e 2869 6e70 7574 5f67 6466 290d   len(input_gdf).
-0000de80: 0a20 2020 2069 6620 7265 7475 726e 5f69  .    if return_i
-0000de90: 6e66 6f5b 226e 625f 726f 7773 5f64 6f6e  nfo["nb_rows_don
-0000dea0: 6522 5d20 3d3d 2030 3a0d 0a20 2020 2020  e"] == 0:..     
-0000deb0: 2020 206d 6573 7361 6765 203d 2066 224e     message = f"N
-0000dec0: 6f20 696e 7075 7420 6765 6f6d 6574 7269  o input geometri
-0000ded0: 6573 2066 6f75 6e64 2069 6e20 7b69 6e70  es found in {inp
-0000dee0: 7574 5f70 6174 687d 220d 0a20 2020 2020  ut_path}"..     
-0000def0: 2020 206c 6f67 6765 722e 696e 666f 286d     logger.info(m
-0000df00: 6573 7361 6765 290d 0a20 2020 2020 2020  essage)..       
-0000df10: 2072 6574 7572 6e5f 696e 666f 5b22 6d65   return_info["me
-0000df20: 7373 6167 6522 5d20 3d20 6d65 7373 6167  ssage"] = messag
-0000df30: 650d 0a20 2020 2020 2020 2072 6574 7572  e..        retur
-0000df40: 6e5f 696e 666f 5b22 746f 7461 6c5f 7469  n_info["total_ti
-0000df50: 6d65 225d 203d 2028 6461 7465 7469 6d65  me"] = (datetime
-0000df60: 2e6e 6f77 2829 202d 2073 7461 7274 5f74  .now() - start_t
-0000df70: 696d 6529 2e74 6f74 616c 5f73 6563 6f6e  ime).total_secon
-0000df80: 6473 2829 0d0a 2020 2020 2020 2020 7265  ds()..        re
-0000df90: 7475 726e 2072 6574 7572 6e5f 696e 666f  turn return_info
-0000dfa0: 0d0a 0d0a 2020 2020 2320 4e6f 7720 7468  ....    # Now th
-0000dfb0: 6520 7265 616c 2070 726f 6365 7373 696e  e real processin
-0000dfc0: 670d 0a20 2020 2069 6620 6167 675f 636f  g..    if agg_co
-0000dfd0: 6c75 6d6e 7320 6973 206e 6f74 204e 6f6e  lumns is not Non
-0000dfe0: 653a 0d0a 2020 2020 2020 2020 6966 2022  e:..        if "
-0000dff0: 5f5f 4449 5353 4f4c 5645 5f54 4f4a 534f  __DISSOLVE_TOJSO
-0000e000: 4e22 206e 6f74 2069 6e20 696e 7075 745f  N" not in input_
-0000e010: 6764 662e 636f 6c75 6d6e 733a 0d0a 2020  gdf.columns:..  
-0000e020: 2020 2020 2020 2020 2020 2320 4669 7273            # Firs
-0000e030: 7420 7061 7373 202d 3e20 7075 7420 7265  t pass -> put re
-0000e040: 6c65 7661 6e74 2063 6f6c 756d 6e73 2069  levant columns i
-0000e050: 6e20 6a73 6f6e 2066 6965 6c64 0d0a 2020  n json field..  
-0000e060: 2020 2020 2020 2020 2020 6167 6766 756e            aggfun
-0000e070: 6320 3d20 7b22 746f 5f6a 736f 6e22 3a20  c = {"to_json": 
-0000e080: 6167 675f 636f 6c75 6d6e 735f 6e65 6564  agg_columns_need
-0000e090: 6564 7d0d 0a20 2020 2020 2020 2065 6c73  ed}..        els
-0000e0a0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-0000e0b0: 2320 436f 6c75 6d6e 7320 616c 7265 6164  # Columns alread
-0000e0c0: 7920 636f 6465 6420 696e 2061 206a 736f  y coded in a jso
-0000e0d0: 6e20 636f 6c75 6d6e 2c20 736f 206d 6572  n column, so mer
-0000e0e0: 6765 206a 736f 6e20 6c69 7374 730d 0a20  ge json lists.. 
-0000e0f0: 2020 2020 2020 2020 2020 2061 6767 6675             aggfu
-0000e100: 6e63 203d 2022 6d65 7267 655f 6a73 6f6e  nc = "merge_json
-0000e110: 5f6c 6973 7473 220d 0a20 2020 2065 6c73  _lists"..    els
-0000e120: 653a 0d0a 2020 2020 2020 2020 6167 6766  e:..        aggf
-0000e130: 756e 6320 3d20 2266 6972 7374 220d 0a20  unc = "first".. 
-0000e140: 2020 2073 7461 7274 5f64 6973 736f 6c76     start_dissolv
-0000e150: 6520 3d20 6461 7465 7469 6d65 2e6e 6f77  e = datetime.now
-0000e160: 2829 0d0a 2020 2020 6469 7373 5f67 6466  ()..    diss_gdf
-0000e170: 203d 205f 6469 7373 6f6c 7665 280d 0a20   = _dissolve(.. 
-0000e180: 2020 2020 2020 2064 663d 696e 7075 745f         df=input_
-0000e190: 6764 662c 2062 793d 6772 6f75 7062 795f  gdf, by=groupby_
-0000e1a0: 636f 6c75 6d6e 732c 2061 6767 6675 6e63  columns, aggfunc
-0000e1b0: 3d61 6767 6675 6e63 2c20 6173 5f69 6e64  =aggfunc, as_ind
-0000e1c0: 6578 3d46 616c 7365 2c20 6472 6f70 6e61  ex=False, dropna
-0000e1d0: 3d46 616c 7365 0d0a 2020 2020 290d 0a20  =False..    ).. 
-0000e1e0: 2020 2070 6572 6669 6e66 6f5b 2274 696d     perfinfo["tim
-0000e1f0: 655f 6469 7373 6f6c 7665 225d 203d 2028  e_dissolve"] = (
-0000e200: 6461 7465 7469 6d65 2e6e 6f77 2829 202d  datetime.now() -
-0000e210: 2073 7461 7274 5f64 6973 736f 6c76 6529   start_dissolve)
-0000e220: 2e74 6f74 616c 5f73 6563 6f6e 6473 2829  .total_seconds()
-0000e230: 0d0a 0d0a 2020 2020 2320 4966 2065 7870  ....    # If exp
-0000e240: 6c6f 6465 636f 6c6c 6563 7469 6f6e 7320  lodecollections 
-0000e250: 6973 2054 7275 6520 616e 6420 466f 7220  is True and For 
-0000e260: 706f 6c79 676f 6e73 2c20 6578 706c 6f64  polygons, explod
-0000e270: 6520 6d75 6c74 692d 6765 6f6d 6574 7269  e multi-geometri
-0000e280: 6573 2e0d 0a20 2020 2023 2049 6620 6e65  es...    # If ne
-0000e290: 6564 6564 2074 6865 7920 7769 6c6c 2062  eded they will b
-0000e2a0: 6520 2763 6f6c 6c65 6374 6564 2720 6166  e 'collected' af
-0000e2b0: 7465 7277 6172 6473 2074 6f20 6d75 6c74  terwards to mult
-0000e2c0: 6970 6f6c 7967 6f6e 7320 6167 6169 6e2e  ipolygons again.
-0000e2d0: 0d0a 2020 2020 6966 2065 7870 6c6f 6465  ..    if explode
-0000e2e0: 636f 6c6c 6563 7469 6f6e 7320 6973 2054  collections is T
-0000e2f0: 7275 6520 6f72 2069 6e70 7574 5f67 656f  rue or input_geo
-0000e300: 6d65 7472 7974 7970 6520 696e 205b 0d0a  metrytype in [..
-0000e310: 2020 2020 2020 2020 4765 6f6d 6574 7279          Geometry
-0000e320: 5479 7065 2e50 4f4c 5947 4f4e 2c0d 0a20  Type.POLYGON,.. 
-0000e330: 2020 2020 2020 2047 656f 6d65 7472 7954         GeometryT
-0000e340: 7970 652e 4d55 4c54 4950 4f4c 5947 4f4e  ype.MULTIPOLYGON
-0000e350: 2c0d 0a20 2020 205d 3a0d 0a20 2020 2020  ,..    ]:..     
-0000e360: 2020 2023 2061 7373 6572 7420 746f 2065     # assert to e
-0000e370: 7661 6465 2070 794c 616e 6365 2077 6172  vade pyLance war
-0000e380: 6e69 6e67 0d0a 2020 2020 2020 2020 6173  ning..        as
-0000e390: 7365 7274 2069 7369 6e73 7461 6e63 6528  sert isinstance(
-0000e3a0: 6469 7373 5f67 6466 2c20 6770 642e 4765  diss_gdf, gpd.Ge
-0000e3b0: 6f44 6174 6146 7261 6d65 290d 0a20 2020  oDataFrame)..   
-0000e3c0: 2020 2020 2064 6973 735f 6764 6620 3d20       diss_gdf = 
-0000e3d0: 6469 7373 5f67 6466 2e65 7870 6c6f 6465  diss_gdf.explode
-0000e3e0: 2869 676e 6f72 655f 696e 6465 783d 5472  (ignore_index=Tr
-0000e3f0: 7565 290d 0a0d 0a20 2020 2023 2043 6c69  ue)....    # Cli
-0000e400: 7020 7468 6520 7265 7375 6c74 206f 6e20  p the result on 
-0000e410: 7468 6520 626f 7264 6572 7320 6f66 2074  the borders of t
-0000e420: 6865 2062 626f 7820 6e6f 7420 746f 2068  he bbox not to h
-0000e430: 6176 6520 6f76 6572 6c61 7073 0d0a 2020  ave overlaps..  
-0000e440: 2020 2320 6265 7477 6565 6e20 7468 6520    # between the 
-0000e450: 6469 6666 6572 656e 7420 7469 6c65 732e  different tiles.
-0000e460: 0d0a 2020 2020 2320 4966 2074 6869 7320  ..    # If this 
-0000e470: 6973 206e 6f74 2061 7070 6c69 6564 2c20  is not applied, 
-0000e480: 7468 6973 2072 6573 756c 7473 2069 6e20  this results in 
-0000e490: 736f 6d65 2067 656f 6d65 7472 6965 7320  some geometries 
-0000e4a0: 6e6f 7420 6265 696e 6720 6d65 7267 6564  not being merged
-0000e4b0: 0d0a 2020 2020 2320 6f72 2069 6e20 6475  ..    # or in du
-0000e4c0: 706c 6963 6174 6573 2e0d 0a20 2020 2023  plicates...    #
-0000e4d0: 2052 454d 4152 4b3a 2066 6f72 2028 6d75   REMARK: for (mu
-0000e4e0: 6c74 6929 6c69 6e65 7374 7269 6e67 732c  lti)linestrings,
-0000e4f0: 2074 6865 2065 6e64 706f 696e 7473 2063   the endpoints c
-0000e500: 7265 6174 6564 2062 7920 7468 6520 636c  reated by the cl
-0000e510: 6970 2061 7265 206e 6f74 0d0a 2020 2020  ip are not..    
-0000e520: 2320 616c 7761 7973 2074 6865 2073 616d  # always the sam
-0000e530: 6520 6475 6520 746f 2072 6f75 6e64 696e  e due to roundin
-0000e540: 672c 2073 6f20 6469 7373 6f6c 7669 6e67  g, so dissolving
-0000e550: 2069 6e20 6120 6e65 7874 2070 6173 7320   in a next pass 
-0000e560: 646f 6573 6e27 740d 0a20 2020 2023 2061  doesn't..    # a
-0000e570: 6c77 6179 7320 7265 7375 6c74 2069 6e20  lways result in 
-0000e580: 6c69 6e65 7374 7269 6e67 7320 6265 696e  linestrings bein
-0000e590: 6720 7265 2d63 6f6e 6e65 6374 6564 2e2e  g re-connected..
-0000e5a0: 2e20 4265 6361 7573 6520 6469 7373 6f6c  . Because dissol
-0000e5b0: 7669 6e67 0d0a 2020 2020 2320 6c69 6e65  ving..    # line
-0000e5c0: 7320 6973 6e27 7420 736f 2063 6f6d 7075  s isn't so compu
-0000e5d0: 7461 7469 6f6e 616c 6c79 2068 6561 7679  tationally heavy
-0000e5e0: 2061 6e79 7761 792c 2064 726f 7020 7375   anyway, drop su
-0000e5f0: 7070 6f72 7420 6865 7265 2e0d 0a20 2020  pport here...   
-0000e600: 2069 6620 6262 6f78 2069 7320 6e6f 7420   if bbox is not 
-0000e610: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2073  None:..        s
-0000e620: 7461 7274 5f63 6c69 7020 3d20 6461 7465  tart_clip = date
-0000e630: 7469 6d65 2e6e 6f77 2829 0d0a 2020 2020  time.now()..    
-0000e640: 2020 2020 6262 6f78 5f70 6f6c 7967 6f6e      bbox_polygon
-0000e650: 203d 2073 685f 6765 6f6d 2e50 6f6c 7967   = sh_geom.Polyg
-0000e660: 6f6e 280d 0a20 2020 2020 2020 2020 2020  on(..           
-0000e670: 205b 0d0a 2020 2020 2020 2020 2020 2020   [..            
-0000e680: 2020 2020 2862 626f 785b 305d 2c20 6262      (bbox[0], bb
-0000e690: 6f78 5b31 5d29 2c0d 0a20 2020 2020 2020  ox[1]),..       
-0000e6a0: 2020 2020 2020 2020 2028 6262 6f78 5b30           (bbox[0
-0000e6b0: 5d2c 2062 626f 785b 335d 292c 0d0a 2020  ], bbox[3]),..  
-0000e6c0: 2020 2020 2020 2020 2020 2020 2020 2862                (b
-0000e6d0: 626f 785b 325d 2c20 6262 6f78 5b33 5d29  box[2], bbox[3])
-0000e6e0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000e6f0: 2020 2028 6262 6f78 5b32 5d2c 2062 626f     (bbox[2], bbo
-0000e700: 785b 315d 292c 0d0a 2020 2020 2020 2020  x[1]),..        
-0000e710: 2020 2020 2020 2020 2862 626f 785b 305d          (bbox[0]
-0000e720: 2c20 6262 6f78 5b31 5d29 2c0d 0a20 2020  , bbox[1]),..   
-0000e730: 2020 2020 2020 2020 205d 0d0a 2020 2020           ]..    
-0000e740: 2020 2020 290d 0a20 2020 2020 2020 2062      )..        b
-0000e750: 626f 785f 6764 6620 3d20 6770 642e 4765  box_gdf = gpd.Ge
-0000e760: 6f44 6174 6146 7261 6d65 280d 0a20 2020  oDataFrame(..   
-0000e770: 2020 2020 2020 2020 2064 6174 613d 5b31           data=[1
-0000e780: 5d2c 2067 656f 6d65 7472 793d 5b62 626f  ], geometry=[bbo
-0000e790: 785f 706f 6c79 676f 6e5d 2c20 6372 733d  x_polygon], crs=
-0000e7a0: 696e 7075 745f 6764 662e 6372 7320 2023  input_gdf.crs  #
-0000e7b0: 2074 7970 653a 2069 676e 6f72 650d 0a20   type: ignore.. 
-0000e7c0: 2020 2020 2020 2029 0d0a 0d0a 2020 2020         )....    
-0000e7d0: 2020 2020 2320 4361 7463 6820 6972 7265      # Catch irre
-0000e7e0: 6c65 7661 6e74 2070 616e 6461 7320 6675  levant pandas fu
-0000e7f0: 7475 7265 2077 6172 6e69 6e67 0d0a 2020  ture warning..  
-0000e800: 2020 2020 2020 2320 544f 444f 3a20 7768        # TODO: wh
-0000e810: 656e 2072 656d 6f76 6564 2069 6e20 6c61  en removed in la
-0000e820: 7465 7220 7665 7273 696f 6e20 6f66 2070  ter version of p
-0000e830: 616e 6461 732c 2063 616e 2062 6520 7265  andas, can be re
-0000e840: 6d6f 7665 6420 6865 7265 0d0a 2020 2020  moved here..    
-0000e850: 2020 2020 7769 7468 2077 6172 6e69 6e67      with warning
-0000e860: 732e 6361 7463 685f 7761 726e 696e 6773  s.catch_warnings
-0000e870: 2829 3a0d 0a20 2020 2020 2020 2020 2020  ():..           
-0000e880: 206d 6573 7361 6765 203d 2028 0d0a 2020   message = (..  
-0000e890: 2020 2020 2020 2020 2020 2020 2020 2249                "I
-0000e8a0: 6e20 6120 6675 7475 7265 2076 6572 7369  n a future versi
-0000e8b0: 6f6e 2c20 6064 662e 696c 6f63 5b3a 2c20  on, `df.iloc[:, 
-0000e8c0: 695d 203d 206e 6577 7661 6c73 6020 7769  i] = newvals` wi
-0000e8d0: 6c6c 2061 7474 656d 7074 2074 6f20 220d  ll attempt to ".
-0000e8e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e8f0: 2022 7365 7420 7468 6520 7661 6c75 6573   "set the values
-0000e900: 2069 6e70 6c61 6365 2069 6e73 7465 6164   inplace instead
-0000e910: 206f 6620 616c 7761 7973 2073 6574 7469   of always setti
-0000e920: 6e67 2061 206e 6577 2061 7272 6179 2e22  ng a new array."
-0000e930: 0d0a 2020 2020 2020 2020 2020 2020 290d  ..            ).
-0000e940: 0a20 2020 2020 2020 2020 2020 2077 6172  .            war
-0000e950: 6e69 6e67 732e 6669 6c74 6572 7761 726e  nings.filterwarn
-0000e960: 696e 6773 280d 0a20 2020 2020 2020 2020  ings(..         
-0000e970: 2020 2020 2020 2061 6374 696f 6e3d 2269         action="i
-0000e980: 676e 6f72 6522 2c20 6361 7465 676f 7279  gnore", category
-0000e990: 3d46 7574 7572 6557 6172 6e69 6e67 2c20  =FutureWarning, 
-0000e9a0: 6d65 7373 6167 653d 7265 2e65 7363 6170  message=re.escap
-0000e9b0: 6528 6d65 7373 6167 6529 0d0a 2020 2020  e(message)..    
-0000e9c0: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-0000e9d0: 2020 2020 2020 2023 206b 6565 705f 6765         # keep_ge
-0000e9e0: 6f6d 5f74 7970 653d 5472 7565 2067 6176  om_type=True gav
-0000e9f0: 6520 736f 6d65 7469 6d65 7320 6572 726f  e sometimes erro
-0000ea00: 722c 2061 6e64 2073 7469 6c6c 2064 6f65  r, and still doe
-0000ea10: 7320 696e 2030 2e39 2e30 0d0a 2020 2020  s in 0.9.0..    
-0000ea20: 2020 2020 2020 2020 2320 736f 2075 7365          # so use
-0000ea30: 206f 776e 2069 6d70 6c65 6d65 6e74 6174   own implementat
-0000ea40: 696f 6e20 6f66 206b 6565 705f 6765 6f6d  ion of keep_geom
-0000ea50: 5f74 7970 650d 0a20 2020 2020 2020 2020  _type..         
-0000ea60: 2020 2064 6973 735f 6764 6620 3d20 6770     diss_gdf = gp
-0000ea70: 642e 636c 6970 2864 6973 735f 6764 662c  d.clip(diss_gdf,
-0000ea80: 2062 626f 785f 6764 6629 2020 2320 2c20   bbox_gdf)  # , 
-0000ea90: 6b65 6570 5f67 656f 6d5f 7479 7065 3d54  keep_geom_type=T
-0000eaa0: 7275 6529 0d0a 2020 2020 2020 2020 2020  rue)..          
-0000eab0: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
-0000eac0: 6e63 6528 6469 7373 5f67 6466 2c20 6770  nce(diss_gdf, gp
-0000ead0: 642e 4765 6f44 6174 6146 7261 6d65 290d  d.GeoDataFrame).
-0000eae0: 0a0d 0a20 2020 2020 2020 2023 204f 6e6c  ...        # Onl
-0000eaf0: 7920 6b65 6570 2067 656f 6d65 7472 6965  y keep geometrie
-0000eb00: 7320 6f66 2074 6865 2070 7269 6d69 7469  s of the primiti
-0000eb10: 7665 2074 7970 6520 7370 6563 6966 6965  ve type specifie
-0000eb20: 6420 6166 7465 7220 636c 6970 2e2e 2e0d  d after clip....
-0000eb30: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
-0000eb40: 6973 696e 7374 616e 6365 2864 6973 735f  isinstance(diss_
-0000eb50: 6764 662c 2067 7064 2e47 656f 4461 7461  gdf, gpd.GeoData
-0000eb60: 4672 616d 6529 0d0a 2020 2020 2020 2020  Frame)..        
-0000eb70: 6469 7373 5f67 6466 2e67 656f 6d65 7472  diss_gdf.geometr
-0000eb80: 7920 3d20 6765 6f73 6572 6965 735f 7574  y = geoseries_ut
-0000eb90: 696c 2e67 656f 6d65 7472 795f 636f 6c6c  il.geometry_coll
-0000eba0: 6563 7469 6f6e 5f65 7874 7261 6374 280d  ection_extract(.
-0000ebb0: 0a20 2020 2020 2020 2020 2020 2064 6973  .            dis
-0000ebc0: 735f 6764 662e 6765 6f6d 6574 7279 2c20  s_gdf.geometry, 
-0000ebd0: 696e 7075 745f 6765 6f6d 6574 7279 7479  input_geometryty
-0000ebe0: 7065 2e74 6f5f 7072 696d 6974 6976 6574  pe.to_primitivet
-0000ebf0: 7970 650d 0a20 2020 2020 2020 2029 0d0a  ype..        )..
-0000ec00: 0d0a 2020 2020 2020 2020 7065 7266 696e  ..        perfin
-0000ec10: 666f 5b22 7469 6d65 5f63 6c69 7022 5d20  fo["time_clip"] 
-0000ec20: 3d20 2864 6174 6574 696d 652e 6e6f 7728  = (datetime.now(
-0000ec30: 2920 2d20 7374 6172 745f 636c 6970 292e  ) - start_clip).
-0000ec40: 746f 7461 6c5f 7365 636f 6e64 7328 290d  total_seconds().
-0000ec50: 0a0d 0a20 2020 2023 2044 726f 7020 726f  ...    # Drop ro
-0000ec60: 7773 2077 6974 6820 4e6f 6e65 2f65 6d70  ws with None/emp
-0000ec70: 7479 2067 656f 6d65 7472 6965 730d 0a20  ty geometries.. 
-0000ec80: 2020 2064 6973 735f 6764 6620 3d20 6469     diss_gdf = di
-0000ec90: 7373 5f67 6466 5b7e 6469 7373 5f67 6466  ss_gdf[~diss_gdf
-0000eca0: 2e67 656f 6d65 7472 792e 6973 6e61 2829  .geometry.isna()
-0000ecb0: 5d0d 0a20 2020 2064 6973 735f 6764 6620  ]..    diss_gdf 
-0000ecc0: 3d20 6469 7373 5f67 6466 5b7e 6469 7373  = diss_gdf[~diss
-0000ecd0: 5f67 6466 2e67 656f 6d65 7472 792e 6973  _gdf.geometry.is
-0000ece0: 5f65 6d70 7479 5d0d 0a0d 0a20 2020 2023  _empty]....    #
-0000ecf0: 2049 6620 7468 6572 6520 6973 206e 6f20   If there is no 
-0000ed00: 7265 7375 6c74 2c20 7265 7475 726e 0d0a  result, return..
-0000ed10: 2020 2020 6966 206c 656e 2864 6973 735f      if len(diss_
-0000ed20: 6764 6629 203d 3d20 303a 0d0a 2020 2020  gdf) == 0:..    
-0000ed30: 2020 2020 6d65 7373 6167 6520 3d20 6622      message = f"
-0000ed40: 5265 7375 6c74 2069 7320 656d 7074 7920  Result is empty 
-0000ed50: 666f 7220 7b69 6e70 7574 5f70 6174 687d  for {input_path}
-0000ed60: 220d 0a20 2020 2020 2020 2072 6574 7572  "..        retur
-0000ed70: 6e5f 696e 666f 5b22 6d65 7373 6167 6522  n_info["message"
-0000ed80: 5d20 3d20 6d65 7373 6167 650d 0a20 2020  ] = message..   
-0000ed90: 2020 2020 2072 6574 7572 6e5f 696e 666f       return_info
-0000eda0: 5b22 7065 7266 696e 666f 225d 203d 2070  ["perfinfo"] = p
-0000edb0: 6572 6669 6e66 6f0d 0a20 2020 2020 2020  erfinfo..       
-0000edc0: 2072 6574 7572 6e5f 696e 666f 5b22 746f   return_info["to
-0000edd0: 7461 6c5f 7469 6d65 225d 203d 2028 6461  tal_time"] = (da
-0000ede0: 7465 7469 6d65 2e6e 6f77 2829 202d 2073  tetime.now() - s
-0000edf0: 7461 7274 5f74 696d 6529 2e74 6f74 616c  tart_time).total
-0000ee00: 5f73 6563 6f6e 6473 2829 0d0a 2020 2020  _seconds()..    
-0000ee10: 2020 2020 7265 7475 726e 2072 6574 7572      return retur
-0000ee20: 6e5f 696e 666f 0d0a 0d0a 2020 2020 2320  n_info....    # 
-0000ee30: 4164 6420 636f 6c75 6d6e 2077 6974 6820  Add column with 
-0000ee40: 7469 6c65 5f69 640d 0a20 2020 2069 6620  tile_id..    if 
-0000ee50: 7469 6c65 5f69 6420 6973 206e 6f74 204e  tile_id is not N
-0000ee60: 6f6e 653a 0d0a 2020 2020 2020 2020 6469  one:..        di
-0000ee70: 7373 5f67 6466 5b22 7469 6c65 5f69 6422  ss_gdf["tile_id"
-0000ee80: 5d20 3d20 7469 6c65 5f69 640d 0a0d 0a20  ] = tile_id.... 
-0000ee90: 2020 2023 2053 6176 6520 7468 6520 7265     # Save the re
-0000eea0: 7375 6c74 2074 6f20 6465 7374 696e 6174  sult to destinat
-0000eeb0: 696f 6e20 6669 6c65 2873 290d 0a20 2020  ion file(s)..   
-0000eec0: 2073 7461 7274 5f74 6f5f 6669 6c65 203d   start_to_file =
-0000eed0: 2064 6174 6574 696d 652e 6e6f 7728 290d   datetime.now().
-0000eee0: 0a0d 0a20 2020 2023 2049 6620 7468 6520  ...    # If the 
-0000eef0: 7469 6c65 7320 646f 6e27 7420 6e65 6564  tiles don't need
-0000ef00: 2074 6f20 6265 206d 6572 6765 6420 6166   to be merged af
-0000ef10: 7465 7277 6172 6473 2c20 7765 2063 616e  terwards, we can
-0000ef20: 206a 7573 7420 7361 7665 2074 6865 2072   just save the r
-0000ef30: 6573 756c 7420 6173 0d0a 2020 2020 2320  esult as..    # 
-0000ef40: 6974 2069 732e 0d0a 2020 2020 6966 2073  it is...    if s
-0000ef50: 7472 286f 7574 7075 745f 6e6f 746f 6e62  tr(output_notonb
-0000ef60: 6f72 6465 725f 7061 7468 2920 3d3d 2073  order_path) == s
-0000ef70: 7472 286f 7574 7075 745f 6f6e 626f 7264  tr(output_onbord
-0000ef80: 6572 5f70 6174 6829 3a0d 0a20 2020 2020  er_path):..     
-0000ef90: 2020 2023 2061 7373 6572 7420 746f 2065     # assert to e
-0000efa0: 7661 6465 2070 794c 616e 6365 2077 6172  vade pyLance war
-0000efb0: 6e69 6e67 0d0a 2020 2020 2020 2020 6173  ning..        as
-0000efc0: 7365 7274 2069 7369 6e73 7461 6e63 6528  sert isinstance(
-0000efd0: 6469 7373 5f67 6466 2c20 6770 642e 4765  diss_gdf, gpd.Ge
-0000efe0: 6f44 6174 6146 7261 6d65 290d 0a20 2020  oDataFrame)..   
-0000eff0: 2020 2020 2023 2055 7365 2066 6f72 6365       # Use force
-0000f000: 5f6d 756c 7469 7479 7065 2c20 746f 2065  _multitype, to e
-0000f010: 7661 6465 2077 6172 6e69 6e67 7320 7768  vade warnings wh
-0000f020: 656e 2073 6f6d 6520 6261 7463 6865 7320  en some batches 
-0000f030: 636f 6e74 6169 6e0d 0a20 2020 2020 2020  contain..       
-0000f040: 2023 2073 696e 676c 6574 7970 6520 616e   # singletype an
-0000f050: 6420 736f 6d65 2063 6f6e 7461 696e 206d  d some contain m
-0000f060: 756c 7469 7479 7065 2067 656f 6d65 7472  ultitype geometr
-0000f070: 6965 730d 0a20 2020 2020 2020 2067 666f  ies..        gfo
-0000f080: 2e74 6f5f 6669 6c65 280d 0a20 2020 2020  .to_file(..     
-0000f090: 2020 2020 2020 2064 6973 735f 6764 662c         diss_gdf,
-0000f0a0: 0d0a 2020 2020 2020 2020 2020 2020 6f75  ..            ou
-0000f0b0: 7470 7574 5f6e 6f74 6f6e 626f 7264 6572  tput_notonborder
-0000f0c0: 5f70 6174 682c 0d0a 2020 2020 2020 2020  _path,..        
-0000f0d0: 2020 2020 6c61 7965 723d 6f75 7470 7574      layer=output
-0000f0e0: 5f6c 6179 6572 2c0d 0a20 2020 2020 2020  _layer,..       
-0000f0f0: 2020 2020 2066 6f72 6365 5f6d 756c 7469       force_multi
-0000f100: 7479 7065 3d54 7275 652c 0d0a 2020 2020  type=True,..    
-0000f110: 2020 2020 2020 2020 696e 6465 783d 4661          index=Fa
-0000f120: 6c73 652c 0d0a 2020 2020 2020 2020 2020  lse,..          
-0000f130: 2020 6372 6561 7465 5f73 7061 7469 616c    create_spatial
-0000f140: 5f69 6e64 6578 3d46 616c 7365 2c0d 0a20  _index=False,.. 
-0000f150: 2020 2020 2020 2029 0d0a 2020 2020 656c         )..    el
-0000f160: 7365 3a0d 0a20 2020 2020 2020 2023 2049  se:..        # I
-0000f170: 6620 6e6f 742c 2073 6176 6520 7468 6520  f not, save the 
-0000f180: 706f 6c79 676f 6e73 206f 6e20 7468 6520  polygons on the 
-0000f190: 626f 7264 6572 2073 6570 6572 6174 656c  border seperatel
-0000f1a0: 790d 0a20 2020 2020 2020 2062 626f 785f  y..        bbox_
-0000f1b0: 6c69 6e65 735f 6764 6620 3d20 6770 642e  lines_gdf = gpd.
-0000f1c0: 4765 6f44 6174 6146 7261 6d65 280d 0a20  GeoDataFrame(.. 
-0000f1d0: 2020 2020 2020 2020 2020 2067 656f 6d65             geome
-0000f1e0: 7472 793d 6765 6f73 6572 6965 735f 7574  try=geoseries_ut
-0000f1f0: 696c 2e70 6f6c 7967 6f6e 735f 746f 5f6c  il.polygons_to_l
-0000f200: 696e 6573 2820 2023 2074 7970 653a 2069  ines(  # type: i
-0000f210: 676e 6f72 650d 0a20 2020 2020 2020 2020  gnore..         
-0000f220: 2020 2020 2020 2067 7064 2e47 656f 5365         gpd.GeoSe
-0000f230: 7269 6573 285b 7368 5f67 656f 6d2e 626f  ries([sh_geom.bo
-0000f240: 7828 6262 6f78 5b30 5d2c 2062 626f 785b  x(bbox[0], bbox[
-0000f250: 315d 2c20 6262 6f78 5b32 5d2c 2062 626f  1], bbox[2], bbo
-0000f260: 785b 335d 295d 290d 0a20 2020 2020 2020  x[3])])..       
-0000f270: 2020 2020 2029 2c0d 0a20 2020 2020 2020       ),..       
-0000f280: 2020 2020 2063 7273 3d69 6e70 7574 5f67       crs=input_g
-0000f290: 6466 2e63 7273 2c20 2023 2074 7970 653a  df.crs,  # type:
-0000f2a0: 2069 676e 6f72 650d 0a20 2020 2020 2020   ignore..       
-0000f2b0: 2029 0d0a 2020 2020 2020 2020 6f6e 626f   )..        onbo
-0000f2c0: 7264 6572 5f67 6466 203d 2067 7064 2e73  rder_gdf = gpd.s
-0000f2d0: 6a6f 696e 2864 6973 735f 6764 662c 2062  join(diss_gdf, b
-0000f2e0: 626f 785f 6c69 6e65 735f 6764 662c 2070  box_lines_gdf, p
-0000f2f0: 7265 6469 6361 7465 3d22 696e 7465 7273  redicate="inters
-0000f300: 6563 7473 2229 0d0a 2020 2020 2020 2020  ects")..        
-0000f310: 6f6e 626f 7264 6572 5f67 6466 2e64 726f  onborder_gdf.dro
-0000f320: 7028 2269 6e64 6578 5f72 6967 6874 222c  p("index_right",
-0000f330: 2061 7869 733d 312c 2069 6e70 6c61 6365   axis=1, inplace
-0000f340: 3d54 7275 6529 0d0a 2020 2020 2020 2020  =True)..        
-0000f350: 6966 206c 656e 286f 6e62 6f72 6465 725f  if len(onborder_
-0000f360: 6764 6629 203e 2030 3a0d 0a20 2020 2020  gdf) > 0:..     
-0000f370: 2020 2020 2020 2023 2061 7373 6572 7420         # assert 
-0000f380: 746f 2065 7661 6465 2070 794c 616e 6365  to evade pyLance
-0000f390: 2077 6172 6e69 6e67 0d0a 2020 2020 2020   warning..      
-0000f3a0: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
-0000f3b0: 6e73 7461 6e63 6528 6f6e 626f 7264 6572  nstance(onborder
-0000f3c0: 5f67 6466 2c20 6770 642e 4765 6f44 6174  _gdf, gpd.GeoDat
-0000f3d0: 6146 7261 6d65 290d 0a20 2020 2020 2020  aFrame)..       
-0000f3e0: 2020 2020 2023 2055 7365 2066 6f72 6365       # Use force
-0000f3f0: 5f6d 756c 7469 7479 7065 2c20 746f 2065  _multitype, to e
-0000f400: 7661 6465 2077 6172 6e69 6e67 7320 7768  vade warnings wh
-0000f410: 656e 2073 6f6d 6520 6261 7463 6865 7320  en some batches 
-0000f420: 636f 6e74 6169 6e0d 0a20 2020 2020 2020  contain..       
-0000f430: 2020 2020 2023 2073 696e 676c 6574 7970       # singletyp
-0000f440: 6520 616e 6420 736f 6d65 2063 6f6e 7461  e and some conta
-0000f450: 696e 206d 756c 7469 7479 7065 2067 656f  in multitype geo
-0000f460: 6d65 7472 6965 730d 0a20 2020 2020 2020  metries..       
-0000f470: 2020 2020 2067 666f 2e74 6f5f 6669 6c65       gfo.to_file
-0000f480: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-0000f490: 2020 206f 6e62 6f72 6465 725f 6764 662c     onborder_gdf,
-0000f4a0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000f4b0: 2020 6f75 7470 7574 5f6f 6e62 6f72 6465    output_onborde
-0000f4c0: 725f 7061 7468 2c0d 0a20 2020 2020 2020  r_path,..       
-0000f4d0: 2020 2020 2020 2020 206c 6179 6572 3d6f           layer=o
-0000f4e0: 7574 7075 745f 6c61 7965 722c 0d0a 2020  utput_layer,..  
-0000f4f0: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-0000f500: 7263 655f 6d75 6c74 6974 7970 653d 5472  rce_multitype=Tr
-0000f510: 7565 2c0d 0a20 2020 2020 2020 2020 2020  ue,..           
-0000f520: 2020 2020 2063 7265 6174 655f 7370 6174       create_spat
-0000f530: 6961 6c5f 696e 6465 783d 4661 6c73 652c  ial_index=False,
-0000f540: 0d0a 2020 2020 2020 2020 2020 2020 290d  ..            ).
-0000f550: 0a0d 0a20 2020 2020 2020 206e 6f74 6f6e  ...        noton
-0000f560: 626f 7264 6572 5f67 6466 203d 2064 6973  border_gdf = dis
-0000f570: 735f 6764 665b 7e64 6973 735f 6764 662e  s_gdf[~diss_gdf.
-0000f580: 696e 6465 782e 6973 696e 286f 6e62 6f72  index.isin(onbor
-0000f590: 6465 725f 6764 662e 696e 6465 7829 5d0d  der_gdf.index)].
-0000f5a0: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
-0000f5b0: 6e6f 746f 6e62 6f72 6465 725f 6764 6629  notonborder_gdf)
-0000f5c0: 203e 2030 3a0d 0a20 2020 2020 2020 2020   > 0:..         
-0000f5d0: 2020 2023 2061 7373 6572 7420 746f 2065     # assert to e
-0000f5e0: 7661 6465 2070 794c 616e 6365 2077 6172  vade pyLance war
-0000f5f0: 6e69 6e67 0d0a 2020 2020 2020 2020 2020  ning..          
-0000f600: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
-0000f610: 6e63 6528 6e6f 746f 6e62 6f72 6465 725f  nce(notonborder_
-0000f620: 6764 662c 2067 7064 2e47 656f 4461 7461  gdf, gpd.GeoData
-0000f630: 4672 616d 6529 0d0a 2020 2020 2020 2020  Frame)..        
-0000f640: 2020 2020 2320 5573 6520 666f 7263 655f      # Use force_
-0000f650: 6d75 6c74 6974 7970 652c 2074 6f20 6576  multitype, to ev
-0000f660: 6164 6520 7761 726e 696e 6773 2077 6865  ade warnings whe
-0000f670: 6e20 736f 6d65 2062 6174 6368 6573 2063  n some batches c
-0000f680: 6f6e 7461 696e 0d0a 2020 2020 2020 2020  ontain..        
-0000f690: 2020 2020 2320 7369 6e67 6c65 7479 7065      # singletype
-0000f6a0: 2061 6e64 2073 6f6d 6520 636f 6e74 6169   and some contai
-0000f6b0: 6e20 6d75 6c74 6974 7970 6520 6765 6f6d  n multitype geom
-0000f6c0: 6574 7269 6573 0d0a 2020 2020 2020 2020  etries..        
-0000f6d0: 2020 2020 6766 6f2e 746f 5f66 696c 6528      gfo.to_file(
-0000f6e0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000f6f0: 2020 6e6f 746f 6e62 6f72 6465 725f 6764    notonborder_gd
-0000f700: 662c 0d0a 2020 2020 2020 2020 2020 2020  f,..            
-0000f710: 2020 2020 6f75 7470 7574 5f6e 6f74 6f6e      output_noton
-0000f720: 626f 7264 6572 5f70 6174 682c 0d0a 2020  border_path,..  
-0000f730: 2020 2020 2020 2020 2020 2020 2020 6c61                la
-0000f740: 7965 723d 6f75 7470 7574 5f6c 6179 6572  yer=output_layer
-0000f750: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000f760: 2020 2066 6f72 6365 5f6d 756c 7469 7479     force_multity
-0000f770: 7065 3d54 7275 652c 0d0a 2020 2020 2020  pe=True,..      
-0000f780: 2020 2020 2020 2020 2020 696e 6465 783d            index=
-0000f790: 4661 6c73 652c 0d0a 2020 2020 2020 2020  False,..        
-0000f7a0: 2020 2020 2020 2020 6372 6561 7465 5f73          create_s
-0000f7b0: 7061 7469 616c 5f69 6e64 6578 3d46 616c  patial_index=Fal
-0000f7c0: 7365 2c0d 0a20 2020 2020 2020 2020 2020  se,..           
-0000f7d0: 2029 0d0a 2020 2020 7065 7266 696e 666f   )..    perfinfo
-0000f7e0: 5b22 7469 6d65 5f74 6f5f 6669 6c65 225d  ["time_to_file"]
-0000f7f0: 203d 2028 6461 7465 7469 6d65 2e6e 6f77   = (datetime.now
-0000f800: 2829 202d 2073 7461 7274 5f74 6f5f 6669  () - start_to_fi
-0000f810: 6c65 292e 746f 7461 6c5f 7365 636f 6e64  le).total_second
-0000f820: 7328 290d 0a0d 0a20 2020 2023 2046 696e  s()....    # Fin
-0000f830: 616c 6973 652e 2e2e 0d0a 2020 2020 6d65  alise.....    me
-0000f840: 7373 6167 6520 3d20 6622 6469 7373 6f6c  ssage = f"dissol
-0000f850: 7665 2072 6561 6479 2069 6e20 7b64 6174  ve ready in {dat
-0000f860: 6574 696d 652e 6e6f 7728 292d 7374 6172  etime.now()-star
-0000f870: 745f 7469 6d65 7d20 6f6e 207b 696e 7075  t_time} on {inpu
-0000f880: 745f 7061 7468 7d21 220d 0a20 2020 206c  t_path}!"..    l
-0000f890: 6f67 6765 722e 6465 6275 6728 6d65 7373  ogger.debug(mess
-0000f8a0: 6167 6529 0d0a 0d0a 2020 2020 2320 436f  age)....    # Co
-0000f8b0: 6c6c 6563 7420 7065 7266 696e 666f 0d0a  llect perfinfo..
-0000f8c0: 2020 2020 746f 7461 6c5f 7065 7266 5f74      total_perf_t
-0000f8d0: 696d 6520 3d20 300d 0a20 2020 2070 6572  ime = 0..    per
-0000f8e0: 6673 7472 696e 6720 3d20 2222 0d0a 2020  fstring = ""..  
-0000f8f0: 2020 666f 7220 7065 7266 636f 6465 2069    for perfcode i
-0000f900: 6e20 7065 7266 696e 666f 3a0d 0a20 2020  n perfinfo:..   
-0000f910: 2020 2020 2074 6f74 616c 5f70 6572 665f       total_perf_
-0000f920: 7469 6d65 202b 3d20 7065 7266 696e 666f  time += perfinfo
-0000f930: 5b70 6572 6663 6f64 655d 0d0a 2020 2020  [perfcode]..    
-0000f940: 2020 2020 7065 7266 7374 7269 6e67 202b      perfstring +
-0000f950: 3d20 6622 7b70 6572 6663 6f64 657d 3a20  = f"{perfcode}: 
-0000f960: 7b70 6572 6669 6e66 6f5b 7065 7266 636f  {perfinfo[perfco
-0000f970: 6465 5d3a 2e32 667d 2c20 220d 0a20 2020  de]:.2f}, "..   
-0000f980: 2072 6574 7572 6e5f 696e 666f 5b22 746f   return_info["to
-0000f990: 7461 6c5f 7469 6d65 225d 203d 2028 6461  tal_time"] = (da
-0000f9a0: 7465 7469 6d65 2e6e 6f77 2829 202d 2073  tetime.now() - s
-0000f9b0: 7461 7274 5f74 696d 6529 2e74 6f74 616c  tart_time).total
-0000f9c0: 5f73 6563 6f6e 6473 2829 0d0a 2020 2020  _seconds()..    
-0000f9d0: 7065 7266 696e 666f 5b22 756e 6163 636f  perfinfo["unacco
-0000f9e0: 756e 7465 6422 5d20 3d20 7265 7475 726e  unted"] = return
-0000f9f0: 5f69 6e66 6f5b 2274 6f74 616c 5f74 696d  _info["total_tim
-0000fa00: 6522 5d20 2d20 746f 7461 6c5f 7065 7266  e"] - total_perf
-0000fa10: 5f74 696d 650d 0a20 2020 2070 6572 6673  _time..    perfs
-0000fa20: 7472 696e 6720 2b3d 2066 2275 6e61 6363  tring += f"unacc
-0000fa30: 6f75 6e74 6564 3a20 7b70 6572 6669 6e66  ounted: {perfinf
-0000fa40: 6f5b 2775 6e61 6363 6f75 6e74 6564 275d  o['unaccounted']
-0000fa50: 3a2e 3266 7d22 0d0a 0d0a 2020 2020 2320  :.2f}"....    # 
-0000fa60: 5265 7475 726e 0d0a 2020 2020 7265 7475  Return..    retu
-0000fa70: 726e 5f69 6e66 6f5b 2270 6572 6669 6e66  rn_info["perfinf
-0000fa80: 6f22 5d20 3d20 7065 7266 696e 666f 0d0a  o"] = perfinfo..
-0000fa90: 2020 2020 7265 7475 726e 5f69 6e66 6f5b      return_info[
-0000faa0: 2270 6572 6673 7472 696e 6722 5d20 3d20  "perfstring"] = 
-0000fab0: 7065 7266 7374 7269 6e67 0d0a 2020 2020  perfstring..    
-0000fac0: 7265 7475 726e 5f69 6e66 6f5b 226d 6573  return_info["mes
-0000fad0: 7361 6765 225d 203d 206d 6573 7361 6765  sage"] = message
-0000fae0: 0d0a 2020 2020 7265 7475 726e 2072 6574  ..    return ret
-0000faf0: 7572 6e5f 696e 666f 0d0a 0d0a 0d0a 6465  urn_info......de
-0000fb00: 6620 5f64 6973 736f 6c76 6528 0d0a 2020  f _dissolve(..  
-0000fb10: 2020 6466 3a20 6770 642e 4765 6f44 6174    df: gpd.GeoDat
-0000fb20: 6146 7261 6d65 2c0d 0a20 2020 2062 793d  aFrame,..    by=
-0000fb30: 4e6f 6e65 2c0d 0a20 2020 2061 6767 6675  None,..    aggfu
-0000fb40: 6e63 3a20 4f70 7469 6f6e 616c 5b55 6e69  nc: Optional[Uni
-0000fb50: 6f6e 5b73 7472 2c20 6469 6374 5d5d 203d  on[str, dict]] =
-0000fb60: 2022 6669 7273 7422 2c0d 0a20 2020 2061   "first",..    a
-0000fb70: 735f 696e 6465 783d 5472 7565 2c0d 0a20  s_index=True,.. 
-0000fb80: 2020 206c 6576 656c 3d4e 6f6e 652c 0d0a     level=None,..
-0000fb90: 2020 2020 736f 7274 3d54 7275 652c 0d0a      sort=True,..
-0000fba0: 2020 2020 6f62 7365 7276 6564 3d46 616c      observed=Fal
-0000fbb0: 7365 2c0d 0a20 2020 2064 726f 706e 613d  se,..    dropna=
-0000fbc0: 5472 7565 2c0d 0a29 202d 3e20 6770 642e  True,..) -> gpd.
-0000fbd0: 4765 6f44 6174 6146 7261 6d65 3a0d 0a20  GeoDataFrame:.. 
-0000fbe0: 2020 2022 2222 0d0a 2020 2020 4469 7373     """..    Diss
-0000fbf0: 6f6c 7665 2067 656f 6d65 7472 6965 7320  olve geometries 
-0000fc00: 7769 7468 696e 2060 6772 6f75 7062 7960  within `groupby`
-0000fc10: 2069 6e74 6f20 7369 6e67 6c65 206f 6273   into single obs
-0000fc20: 6572 7661 7469 6f6e 2e0d 0a20 2020 2054  ervation...    T
-0000fc30: 6869 7320 6973 2061 6363 6f6d 706c 6973  his is accomplis
-0000fc40: 6865 6420 6279 2061 7070 6c79 696e 6720  hed by applying 
-0000fc50: 7468 6520 6075 6e61 7279 5f75 6e69 6f6e  the `unary_union
-0000fc60: 6020 6d65 7468 6f64 0d0a 2020 2020 746f  ` method..    to
-0000fc70: 2061 6c6c 2067 656f 6d65 7472 6965 7320   all geometries 
-0000fc80: 7769 7468 696e 2061 2067 726f 7570 7365  within a groupse
-0000fc90: 6c66 2e0d 0a20 2020 204f 6273 6572 7661  lf...    Observa
-0000fca0: 7469 6f6e 7320 6173 736f 6369 6174 6564  tions associated
-0000fcb0: 2077 6974 6820 6561 6368 2060 6772 6f75   with each `grou
-0000fcc0: 7062 7960 2067 726f 7570 2077 696c 6c20  pby` group will 
-0000fcd0: 6265 2061 6767 7265 6761 7465 640d 0a20  be aggregated.. 
-0000fce0: 2020 2075 7369 6e67 2074 6865 2060 6167     using the `ag
-0000fcf0: 6766 756e 6360 2e0d 0a20 2020 2050 6172  gfunc`...    Par
-0000fd00: 616d 6574 6572 730d 0a20 2020 202d 2d2d  ameters..    ---
-0000fd10: 2d2d 2d2d 2d2d 2d0d 0a20 2020 2062 7920  -------..    by 
-0000fd20: 3a20 7374 7269 6e67 2c20 6465 6661 756c  : string, defaul
-0000fd30: 7420 4e6f 6e65 0d0a 2020 2020 2020 2020  t None..        
-0000fd40: 436f 6c75 6d6e 2077 686f 7365 2076 616c  Column whose val
-0000fd50: 7565 7320 6465 6669 6e65 2067 726f 7570  ues define group
-0000fd60: 7320 746f 2062 6520 6469 7373 6f6c 7665  s to be dissolve
-0000fd70: 642e 2049 6620 4e6f 6e65 2c0d 0a20 2020  d. If None,..   
-0000fd80: 2020 2020 2077 686f 6c65 2047 656f 4461       whole GeoDa
-0000fd90: 7461 4672 616d 6520 6973 2063 6f6e 7369  taFrame is consi
-0000fda0: 6465 7265 6420 6120 7369 6e67 6c65 2067  dered a single g
-0000fdb0: 726f 7570 2e0d 0a20 2020 2061 6767 6675  roup...    aggfu
-0000fdc0: 6e63 203a 2066 756e 6374 696f 6e2c 2073  nc : function, s
-0000fdd0: 7472 696e 6720 6f72 2064 6963 742c 2064  tring or dict, d
-0000fde0: 6566 6175 6c74 2022 6669 7273 7422 0d0a  efault "first"..
-0000fdf0: 2020 2020 2020 2020 4167 6772 6567 6174          Aggregat
-0000fe00: 696f 6e20 6675 6e63 7469 6f6e 2066 6f72  ion function for
-0000fe10: 206d 616e 6970 756c 6174 696f 6e20 6f66   manipulation of
-0000fe20: 2064 6174 6120 6173 736f 6369 6174 6564   data associated
-0000fe30: 0d0a 2020 2020 2020 2020 7769 7468 2065  ..        with e
-0000fe40: 6163 6820 6772 6f75 702e 2050 6173 7365  ach group. Passe
-0000fe50: 6420 746f 2070 616e 6461 7320 6067 726f  d to pandas `gro
-0000fe60: 7570 6279 2e61 6767 6020 6d65 7468 6f64  upby.agg` method
-0000fe70: 2e0d 0a20 2020 2061 735f 696e 6465 7820  ...    as_index 
-0000fe80: 3a20 626f 6f6c 6561 6e2c 2064 6566 6175  : boolean, defau
-0000fe90: 6c74 2054 7275 650d 0a20 2020 2020 2020  lt True..       
-0000fea0: 2049 6620 7472 7565 2c20 6772 6f75 7062   If true, groupb
-0000feb0: 7920 636f 6c75 6d6e 7320 6265 636f 6d65  y columns become
-0000fec0: 2069 6e64 6578 206f 6620 7265 7375 6c74   index of result
-0000fed0: 2e0d 0a20 2020 206c 6576 656c 203a 2069  ...    level : i
-0000fee0: 6e74 206f 7220 7374 7220 6f72 2073 6571  nt or str or seq
-0000fef0: 7565 6e63 6520 6f66 2069 6e74 206f 7220  uence of int or 
-0000ff00: 7365 7175 656e 6365 206f 6620 7374 722c  sequence of str,
-0000ff10: 2064 6566 6175 6c74 204e 6f6e 650d 0a20   default None.. 
-0000ff20: 2020 2020 2020 2049 6620 7468 6520 6178         If the ax
-0000ff30: 6973 2069 7320 6120 4d75 6c74 6949 6e64  is is a MultiInd
-0000ff40: 6578 2028 6869 6572 6172 6368 6963 616c  ex (hierarchical
-0000ff50: 292c 2067 726f 7570 2062 7920 610d 0a20  ), group by a.. 
-0000ff60: 2020 2020 2020 2070 6172 7469 6375 6c61         particula
-0000ff70: 7220 6c65 7665 6c20 6f72 206c 6576 656c  r level or level
-0000ff80: 732e 0d0a 2020 2020 2020 2020 2e2e 2076  s...        .. v
-0000ff90: 6572 7369 6f6e 6164 6465 643a 3a20 302e  ersionadded:: 0.
-0000ffa0: 392e 300d 0a20 2020 2073 6f72 7420 3a20  9.0..    sort : 
-0000ffb0: 626f 6f6c 2c20 6465 6661 756c 7420 5472  bool, default Tr
-0000ffc0: 7565 0d0a 2020 2020 2020 2020 536f 7274  ue..        Sort
-0000ffd0: 2067 726f 7570 206b 6579 732e 2047 6574   group keys. Get
-0000ffe0: 2062 6574 7465 7220 7065 7266 6f72 6d61   better performa
-0000fff0: 6e63 6520 6279 2074 7572 6e69 6e67 2074  nce by turning t
-00010000: 6869 7320 6f66 662e 0d0a 2020 2020 2020  his off...      
-00010010: 2020 4e6f 7465 2074 6869 7320 646f 6573    Note this does
-00010020: 206e 6f74 2069 6e66 6c75 656e 6365 2074   not influence t
-00010030: 6865 206f 7264 6572 206f 6620 6f62 7365  he order of obse
-00010040: 7276 6174 696f 6e73 2077 6974 6869 6e0d  rvations within.
-00010050: 0a20 2020 2020 2020 2065 6163 6820 6772  .        each gr
-00010060: 6f75 702e 2047 726f 7570 6279 2070 7265  oup. Groupby pre
-00010070: 7365 7276 6573 2074 6865 206f 7264 6572  serves the order
-00010080: 206f 6620 726f 7773 2077 6974 6869 6e20   of rows within 
-00010090: 6561 6368 2067 726f 7570 2e0d 0a20 2020  each group...   
-000100a0: 2020 2020 202e 2e20 7665 7273 696f 6e61       .. versiona
-000100b0: 6464 6564 3a3a 2030 2e39 2e30 0d0a 2020  dded:: 0.9.0..  
-000100c0: 2020 6f62 7365 7276 6564 203a 2062 6f6f    observed : boo
-000100d0: 6c2c 2064 6566 6175 6c74 2046 616c 7365  l, default False
-000100e0: 0d0a 2020 2020 2020 2020 5468 6973 206f  ..        This o
-000100f0: 6e6c 7920 6170 706c 6965 7320 6966 2061  nly applies if a
-00010100: 6e79 206f 6620 7468 6520 6772 6f75 7065  ny of the groupe
-00010110: 7273 2061 7265 2043 6174 6567 6f72 6963  rs are Categoric
-00010120: 616c 732e 0d0a 2020 2020 2020 2020 4966  als...        If
-00010130: 2054 7275 653a 206f 6e6c 7920 7368 6f77   True: only show
-00010140: 206f 6273 6572 7665 6420 7661 6c75 6573   observed values
-00010150: 2066 6f72 2063 6174 6567 6f72 6963 616c   for categorical
-00010160: 2067 726f 7570 6572 732e 0d0a 2020 2020   groupers...    
-00010170: 2020 2020 4966 2046 616c 7365 3a20 7368      If False: sh
-00010180: 6f77 2061 6c6c 2076 616c 7565 7320 666f  ow all values fo
-00010190: 7220 6361 7465 676f 7269 6361 6c20 6772  r categorical gr
-000101a0: 6f75 7065 7273 2e0d 0a20 2020 2020 2020  oupers...       
-000101b0: 202e 2e20 7665 7273 696f 6e61 6464 6564   .. versionadded
-000101c0: 3a3a 2030 2e39 2e30 0d0a 2020 2020 6472  :: 0.9.0..    dr
-000101d0: 6f70 6e61 203a 2062 6f6f 6c2c 2064 6566  opna : bool, def
-000101e0: 6175 6c74 2054 7275 650d 0a20 2020 2020  ault True..     
-000101f0: 2020 2049 6620 5472 7565 2c20 616e 6420     If True, and 
-00010200: 6966 2067 726f 7570 206b 6579 7320 636f  if group keys co
-00010210: 6e74 6169 6e20 4e41 2076 616c 7565 732c  ntain NA values,
-00010220: 204e 4120 7661 6c75 6573 0d0a 2020 2020   NA values..    
-00010230: 2020 2020 746f 6765 7468 6572 2077 6974      together wit
-00010240: 6820 726f 772f 636f 6c75 6d6e 2077 696c  h row/column wil
-00010250: 6c20 6265 2064 726f 7070 6564 2e20 4966  l be dropped. If
-00010260: 2046 616c 7365 2c20 4e41 0d0a 2020 2020   False, NA..    
-00010270: 2020 2020 7661 6c75 6573 2077 696c 6c20      values will 
-00010280: 616c 736f 2062 6520 7472 6561 7465 6420  also be treated 
-00010290: 6173 2074 6865 206b 6579 2069 6e20 6772  as the key in gr
-000102a0: 6f75 7073 2e0d 0a20 2020 2020 2020 2054  oups...        T
-000102b0: 6869 7320 7061 7261 6d65 7465 7220 6973  his parameter is
-000102c0: 206e 6f74 2073 7570 706f 7274 6564 2066   not supported f
-000102d0: 6f72 2070 616e 6461 7320 3c20 312e 312e  or pandas < 1.1.
-000102e0: 302e 0d0a 2020 2020 2020 2020 4120 7761  0...        A wa
-000102f0: 726e 696e 6720 7769 6c6c 2062 6520 656d  rning will be em
-00010300: 6974 7465 6420 666f 7220 6561 726c 6965  itted for earlie
-00010310: 7220 7061 6e64 6173 2076 6572 7369 6f6e  r pandas version
-00010320: 730d 0a20 2020 2020 2020 2069 6620 6120  s..        if a 
-00010330: 6e6f 6e2d 6465 6661 756c 7420 7661 6c75  non-default valu
-00010340: 6520 6973 2067 6976 656e 2066 6f72 2074  e is given for t
-00010350: 6869 7320 7061 7261 6d65 7465 722e 0d0a  his parameter...
-00010360: 2020 2020 2020 2020 2e2e 2076 6572 7369          .. versi
-00010370: 6f6e 6164 6465 643a 3a20 302e 392e 300d  onadded:: 0.9.0.
-00010380: 0a20 2020 2052 6574 7572 6e73 0d0a 2020  .    Returns..  
-00010390: 2020 2d2d 2d2d 2d2d 2d0d 0a20 2020 2047    -------..    G
-000103a0: 656f 4461 7461 4672 616d 650d 0a20 2020  eoDataFrame..   
-000103b0: 2045 7861 6d70 6c65 730d 0a20 2020 202d   Examples..    -
-000103c0: 2d2d 2d2d 2d2d 2d0d 0a20 2020 203e 3e3e  -------..    >>>
-000103d0: 2066 726f 6d20 7368 6170 656c 792e 6765   from shapely.ge
-000103e0: 6f6d 6574 7279 2069 6d70 6f72 7420 506f  ometry import Po
-000103f0: 696e 740d 0a20 2020 203e 3e3e 2064 203d  int..    >>> d =
-00010400: 207b 0d0a 2020 2020 2e2e 2e20 2020 2020   {..    ...     
-00010410: 2263 6f6c 3122 3a20 5b22 6e61 6d65 3122  "col1": ["name1"
-00010420: 2c20 226e 616d 6532 222c 2022 6e61 6d65  , "name2", "name
-00010430: 3122 5d2c 0d0a 2020 2020 2e2e 2e20 2020  1"],..    ...   
-00010440: 2020 2267 656f 6d65 7472 7922 3a20 5b50    "geometry": [P
-00010450: 6f69 6e74 2831 2c20 3229 2c20 506f 696e  oint(1, 2), Poin
-00010460: 7428 322c 2031 292c 2050 6f69 6e74 2830  t(2, 1), Point(0
-00010470: 2c20 3129 5d2c 0d0a 2020 2020 2e2e 2e20  , 1)],..    ... 
-00010480: 7d0d 0a20 2020 203e 3e3e 2067 6466 203d  }..    >>> gdf =
-00010490: 2067 656f 7061 6e64 6173 2e47 656f 4461   geopandas.GeoDa
-000104a0: 7461 4672 616d 6528 642c 2063 7273 3d34  taFrame(d, crs=4
-000104b0: 3332 3629 0d0a 2020 2020 3e3e 3e20 6764  326)..    >>> gd
-000104c0: 660d 0a20 2020 2020 2020 2063 6f6c 3120  f..        col1 
-000104d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000104e0: 6765 6f6d 6574 7279 0d0a 2020 2020 3020  geometry..    0 
-000104f0: 206e 616d 6531 2020 504f 494e 5420 2831   name1  POINT (1
-00010500: 2e30 3030 3030 2032 2e30 3030 3030 290d  .00000 2.00000).
-00010510: 0a20 2020 2031 2020 6e61 6d65 3220 2050  .    1  name2  P
-00010520: 4f49 4e54 2028 322e 3030 3030 3020 312e  OINT (2.00000 1.
-00010530: 3030 3030 3029 0d0a 2020 2020 3220 206e  00000)..    2  n
-00010540: 616d 6531 2020 504f 494e 5420 2830 2e30  ame1  POINT (0.0
-00010550: 3030 3030 2031 2e30 3030 3030 290d 0a20  0000 1.00000).. 
-00010560: 2020 203e 3e3e 2064 6973 736f 6c76 6564     >>> dissolved
-00010570: 203d 2067 6466 2e64 6973 736f 6c76 6528   = gdf.dissolve(
-00010580: 2763 6f6c 3127 290d 0a20 2020 203e 3e3e  'col1')..    >>>
-00010590: 2064 6973 736f 6c76 6564 2020 2320 646f   dissolved  # do
-000105a0: 6374 6573 743a 202b 534b 4950 0d0a 2020  ctest: +SKIP..  
-000105b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000105c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000105d0: 2020 2020 2020 2020 2020 2020 2020 6765                ge
-000105e0: 6f6d 6574 7279 0d0a 2020 2020 636f 6c31  ometry..    col1
-000105f0: 0d0a 2020 2020 6e61 6d65 3120 204d 554c  ..    name1  MUL
-00010600: 5449 504f 494e 5420 2830 2e30 3030 3030  TIPOINT (0.00000
-00010610: 2031 2e30 3030 3030 2c20 312e 3030 3030   1.00000, 1.0000
-00010620: 3020 322e 3030 3030 3029 0d0a 2020 2020  0 2.00000)..    
-00010630: 6e61 6d65 3220 2020 2020 2020 2020 2020  name2           
-00010640: 2020 2020 2020 2020 2020 2020 2050 4f49               POI
-00010650: 4e54 2028 322e 3030 3030 3020 312e 3030  NT (2.00000 1.00
-00010660: 3030 3029 0d0a 2020 2020 5365 6520 616c  000)..    See al
-00010670: 736f 0d0a 2020 2020 2d2d 2d2d 2d2d 2d2d  so..    --------
-00010680: 0d0a 2020 2020 4765 6f44 6174 6146 7261  ..    GeoDataFra
-00010690: 6d65 2e65 7870 6c6f 6465 203a 2065 7870  me.explode : exp
-000106a0: 6c6f 6465 206d 756c 7469 2d70 6172 7420  lode multi-part 
-000106b0: 6765 6f6d 6574 7269 6573 2069 6e74 6f20  geometries into 
-000106c0: 7369 6e67 6c65 2067 656f 6d65 7472 6965  single geometrie
-000106d0: 730d 0a20 2020 2022 2222 0d0a 0d0a 2020  s..    """....  
-000106e0: 2020 6966 2062 7920 6973 204e 6f6e 6520    if by is None 
-000106f0: 616e 6420 6c65 7665 6c20 6973 204e 6f6e  and level is Non
-00010700: 653a 0d0a 2020 2020 2020 2020 6279 5f6c  e:..        by_l
-00010710: 6f63 616c 203d 206e 702e 7a65 726f 7328  ocal = np.zeros(
-00010720: 6c65 6e28 6466 292c 2064 7479 7065 3d22  len(df), dtype="
-00010730: 696e 7436 3422 290d 0a20 2020 2065 6c73  int64")..    els
-00010740: 653a 0d0a 2020 2020 2020 2020 6279 5f6c  e:..        by_l
-00010750: 6f63 616c 203d 2062 790d 0a0d 0a20 2020  ocal = by....   
-00010760: 2067 726f 7570 6279 5f6b 7761 7267 7320   groupby_kwargs 
-00010770: 3d20 6469 6374 280d 0a20 2020 2020 2020  = dict(..       
-00010780: 2062 793d 6279 5f6c 6f63 616c 2c20 6c65   by=by_local, le
-00010790: 7665 6c3d 6c65 7665 6c2c 2073 6f72 743d  vel=level, sort=
-000107a0: 736f 7274 2c20 6f62 7365 7276 6564 3d6f  sort, observed=o
-000107b0: 6273 6572 7665 642c 2064 726f 706e 613d  bserved, dropna=
-000107c0: 6472 6f70 6e61 0d0a 2020 2020 290d 0a20  dropna..    ).. 
-000107d0: 2020 2022 2222 0d0a 2020 2020 6966 206e     """..    if n
-000107e0: 6f74 2063 6f6d 7061 742e 5041 4e44 4153  ot compat.PANDAS
-000107f0: 5f47 455f 3131 3a0d 0a20 2020 2020 2020  _GE_11:..       
-00010800: 2067 726f 7570 6279 5f6b 7761 7267 732e   groupby_kwargs.
-00010810: 706f 7028 2264 726f 706e 6122 290d 0a0d  pop("dropna")...
-00010820: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
-00010830: 6472 6f70 6e61 3a20 2023 2049 6620 7468  dropna:  # If th
-00010840: 6579 2070 6173 7365 6420 6120 6e6f 6e2d  ey passed a non-
-00010850: 6465 6661 756c 7420 6472 6f70 6e61 2076  default dropna v
-00010860: 616c 7565 0d0a 2020 2020 2020 2020 2020  alue..          
-00010870: 2020 7761 726e 696e 6773 2e77 6172 6e28    warnings.warn(
-00010880: 2264 726f 706e 6120 6b77 6172 6720 6973  "dropna kwarg is
-00010890: 206e 6f74 2073 7570 706f 7274 6564 2066   not supported f
-000108a0: 6f72 2070 616e 6461 7320 3c20 312e 312e  or pandas < 1.1.
-000108b0: 3022 290d 0a20 2020 2022 2222 0d0a 0d0a  0")..    """....
-000108c0: 2020 2020 2320 5072 6f63 6573 7320 6e6f      # Process no
-000108d0: 6e2d 7370 6174 6961 6c20 636f 6d70 6f6e  n-spatial compon
-000108e0: 656e 740d 0a20 2020 2064 6174 6120 3d20  ent..    data = 
-000108f0: 7064 2e44 6174 6146 7261 6d65 2864 662e  pd.DataFrame(df.
-00010900: 6472 6f70 2863 6f6c 756d 6e73 3d64 662e  drop(columns=df.
-00010910: 6765 6f6d 6574 7279 2e6e 616d 6529 290d  geometry.name)).
-00010920: 0a0d 0a20 2020 2069 6620 6167 6766 756e  ...    if aggfun
-00010930: 6320 6973 206e 6f74 204e 6f6e 6520 616e  c is not None an
-00010940: 6420 6973 696e 7374 616e 6365 2861 6767  d isinstance(agg
-00010950: 6675 6e63 2c20 6469 6374 2920 616e 6420  func, dict) and 
-00010960: 2274 6f5f 6a73 6f6e 2220 696e 2061 6767  "to_json" in agg
-00010970: 6675 6e63 3a0d 0a20 2020 2020 2020 2061  func:..        a
-00010980: 6767 5f63 6f6c 756d 6e73 203d 206c 6973  gg_columns = lis
-00010990: 7428 7365 7428 6167 6766 756e 635b 2274  t(set(aggfunc["t
-000109a0: 6f5f 6a73 6f6e 225d 2929 0d0a 2020 2020  o_json"]))..    
-000109b0: 2020 2020 6167 6772 6567 6174 6564 5f64      aggregated_d
-000109c0: 6174 6120 3d20 280d 0a20 2020 2020 2020  ata = (..       
-000109d0: 2020 2020 2064 6174 612e 6772 6f75 7062       data.groupb
-000109e0: 7928 2a2a 6772 6f75 7062 795f 6b77 6172  y(**groupby_kwar
-000109f0: 6773 290d 0a20 2020 2020 2020 2020 2020  gs)..           
-00010a00: 202e 6170 706c 7928 6c61 6d62 6461 2067   .apply(lambda g
-00010a10: 3a20 675b 6167 675f 636f 6c75 6d6e 735d  : g[agg_columns]
-00010a20: 2e74 6f5f 6a73 6f6e 286f 7269 656e 743d  .to_json(orient=
-00010a30: 2272 6563 6f72 6473 2229 290d 0a20 2020  "records"))..   
-00010a40: 2020 2020 2020 2020 202e 746f 5f66 7261           .to_fra
-00010a50: 6d65 286e 616d 653d 225f 5f44 4953 534f  me(name="__DISSO
-00010a60: 4c56 455f 544f 4a53 4f4e 2229 0d0a 2020  LVE_TOJSON")..  
-00010a70: 2020 2020 2020 290d 0a20 2020 2065 6c69        )..    eli
-00010a80: 6620 6973 696e 7374 616e 6365 2861 6767  f isinstance(agg
-00010a90: 6675 6e63 2c20 7374 7229 2061 6e64 2061  func, str) and a
-00010aa0: 6767 6675 6e63 203d 3d20 226d 6572 6765  ggfunc == "merge
-00010ab0: 5f6a 736f 6e5f 6c69 7374 7322 3a0d 0a20  _json_lists":.. 
-00010ac0: 2020 2020 2020 2023 204d 6572 6765 2061         # Merge a
-00010ad0: 6e64 2066 6c61 7474 656e 2074 6865 206a  nd flatten the j
-00010ae0: 736f 6e20 6c69 7374 7320 696e 2074 6865  son lists in the
-00010af0: 2067 726f 7570 730d 0a20 2020 2020 2020   groups..       
-00010b00: 2064 6566 2067 726f 7570 5f66 6c61 7474   def group_flatt
-00010b10: 656e 5f6a 736f 6e5f 6c69 7374 2867 293a  en_json_list(g):
-00010b20: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-00010b30: 4576 616c 7561 7465 2061 6c6c 2067 726f  Evaluate all gro
-00010b40: 7570 6564 2072 6f77 7320 746f 206a 736f  uped rows to jso
-00010b50: 6e20 6f62 6a65 6374 732e 2054 6869 7320  n objects. This 
-00010b60: 7265 7375 6c74 7320 696e 2061 206c 6973  results in a lis
-00010b70: 7420 6f66 0d0a 2020 2020 2020 2020 2020  t of..          
-00010b80: 2020 2320 6c69 7374 7320 6f66 206a 736f    # lists of jso
-00010b90: 6e20 6f62 6a65 6374 732e 0d0a 2020 2020  n objects...    
-00010ba0: 2020 2020 2020 2020 6a73 6f6e 5f6e 6573          json_nes
-00010bb0: 7465 645f 6c69 7374 7320 3d20 5b0d 0a20  ted_lists = [.. 
-00010bc0: 2020 2020 2020 2020 2020 2020 2020 206a                 j
-00010bd0: 736f 6e2e 6c6f 6164 7328 6a73 6f6e 5f76  son.loads(json_v
-00010be0: 616c 7565 7329 2066 6f72 206a 736f 6e5f  alues) for json_
-00010bf0: 7661 6c75 6573 2069 6e20 675b 225f 5f44  values in g["__D
-00010c00: 4953 534f 4c56 455f 544f 4a53 4f4e 225d  ISSOLVE_TOJSON"]
-00010c10: 0d0a 2020 2020 2020 2020 2020 2020 5d0d  ..            ].
-00010c20: 0a0d 0a20 2020 2020 2020 2020 2020 2023  ...            #
-00010c30: 2045 7874 7261 6374 2074 6865 2072 6f77   Extract the row
-00010c40: 7320 6672 6f6d 2074 6865 206e 6573 7465  s from the neste
-00010c50: 6420 6c69 7374 7320 2b20 7075 7420 696e  d lists + put in
-00010c60: 2061 2066 6c61 7420 6c69 7374 2061 7320   a flat list as 
-00010c70: 7374 7269 6e67 730d 0a20 2020 2020 2020  strings..       
-00010c80: 2020 2020 206a 736f 6e73 7472 5f66 6c61       jsonstr_fla
-00010c90: 7420 3d20 5b0d 0a20 2020 2020 2020 2020  t = [..         
-00010ca0: 2020 2020 2020 206a 736f 6e2e 6475 6d70         json.dump
-00010cb0: 7328 6a73 6f6e 5f76 616c 7565 290d 0a20  s(json_value).. 
-00010cc0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00010cd0: 6f72 206a 736f 6e5f 7661 6c75 6573 2069  or json_values i
-00010ce0: 6e20 6a73 6f6e 5f6e 6573 7465 645f 6c69  n json_nested_li
-00010cf0: 7374 730d 0a20 2020 2020 2020 2020 2020  sts..           
-00010d00: 2020 2020 2066 6f72 206a 736f 6e5f 7661       for json_va
-00010d10: 6c75 6520 696e 206a 736f 6e5f 7661 6c75  lue in json_valu
-00010d20: 6573 0d0a 2020 2020 2020 2020 2020 2020  es..            
-00010d30: 5d0d 0a0d 0a20 2020 2020 2020 2020 2020  ]....           
-00010d40: 2023 2052 656d 6f76 6520 6475 706c 6963   # Remove duplic
-00010d50: 6174 6573 0d0a 2020 2020 2020 2020 2020  ates..          
-00010d60: 2020 6a73 6f6e 7373 7472 5f64 6973 7469    jsonsstr_disti
-00010d70: 6e63 7420 3d20 7365 7428 6a73 6f6e 7374  nct = set(jsonst
-00010d80: 725f 666c 6174 290d 0a0d 0a20 2020 2020  r_flat)....     
-00010d90: 2020 2020 2020 2023 2043 6f6e 7665 7274         # Convert
-00010da0: 2074 6865 2064 6174 6120 6167 6169 6e20   the data again 
-00010db0: 746f 2061 206c 6973 7420 6f66 206a 736f  to a list of jso
-00010dc0: 6e20 6f62 6a65 6374 730d 0a20 2020 2020  n objects..     
-00010dd0: 2020 2020 2020 206a 736f 6e5f 6469 7374         json_dist
-00010de0: 696e 6374 203d 205b 6a73 6f6e 2e6c 6f61  inct = [json.loa
-00010df0: 6473 286a 736f 6e5f 7661 6c75 6529 2066  ds(json_value) f
-00010e00: 6f72 206a 736f 6e5f 7661 6c75 6520 696e  or json_value in
-00010e10: 206a 736f 6e73 7374 725f 6469 7374 696e   jsonsstr_distin
-00010e20: 6374 5d0d 0a0d 0a20 2020 2020 2020 2020  ct]....         
-00010e30: 2020 2023 2052 6574 7572 6e20 6173 206a     # Return as j
-00010e40: 736f 6e20 7374 7269 6e67 0d0a 2020 2020  son string..    
-00010e50: 2020 2020 2020 2020 7265 7475 726e 206a          return j
-00010e60: 736f 6e2e 6475 6d70 7328 6a73 6f6e 5f64  son.dumps(json_d
-00010e70: 6973 7469 6e63 7429 0d0a 0d0a 2020 2020  istinct)....    
-00010e80: 2020 2020 6167 6772 6567 6174 6564 5f64      aggregated_d
-00010e90: 6174 6120 3d20 280d 0a20 2020 2020 2020  ata = (..       
-00010ea0: 2020 2020 2064 6174 612e 6772 6f75 7062       data.groupb
-00010eb0: 7928 2a2a 6772 6f75 7062 795f 6b77 6172  y(**groupby_kwar
-00010ec0: 6773 290d 0a20 2020 2020 2020 2020 2020  gs)..           
-00010ed0: 202e 6170 706c 7928 6c61 6d62 6461 2067   .apply(lambda g
-00010ee0: 3a20 6772 6f75 705f 666c 6174 7465 6e5f  : group_flatten_
-00010ef0: 6a73 6f6e 5f6c 6973 7428 6729 290d 0a20  json_list(g)).. 
-00010f00: 2020 2020 2020 2020 2020 202e 746f 5f66             .to_f
-00010f10: 7261 6d65 286e 616d 653d 225f 5f44 4953  rame(name="__DIS
-00010f20: 534f 4c56 455f 544f 4a53 4f4e 2229 0d0a  SOLVE_TOJSON")..
-00010f30: 2020 2020 2020 2020 290d 0a20 2020 2065          )..    e
-00010f40: 6c73 653a 0d0a 2020 2020 2020 2020 6167  lse:..        ag
-00010f50: 6772 6567 6174 6564 5f64 6174 6120 3d20  gregated_data = 
-00010f60: 6461 7461 2e67 726f 7570 6279 282a 2a67  data.groupby(**g
-00010f70: 726f 7570 6279 5f6b 7761 7267 7329 2e61  roupby_kwargs).a
-00010f80: 6767 2861 6767 6675 6e63 2920 2023 2074  gg(aggfunc)  # t
-00010f90: 7970 653a 2069 676e 6f72 650d 0a20 2020  ype: ignore..   
-00010fa0: 2020 2020 2023 2043 6865 636b 2069 6620       # Check if 
-00010fb0: 616c 6c20 636f 6c75 6d6e 7320 7765 7265  all columns were
-00010fc0: 2070 726f 7065 726c 7920 6167 6772 6567   properly aggreg
-00010fd0: 6174 6564 0d0a 2020 2020 2020 2020 6173  ated..        as
-00010fe0: 7365 7274 2062 795f 6c6f 6361 6c20 6973  sert by_local is
-00010ff0: 206e 6f74 204e 6f6e 650d 0a20 2020 2020   not None..     
-00011000: 2020 2063 6f6c 756d 6e73 5f74 6f5f 6167     columns_to_ag
-00011010: 6720 3d20 5b63 6f6c 756d 6e20 666f 7220  g = [column for 
-00011020: 636f 6c75 6d6e 2069 6e20 6461 7461 2e63  column in data.c
-00011030: 6f6c 756d 6e73 2069 6620 636f 6c75 6d6e  olumns if column
-00011040: 206e 6f74 2069 6e20 6279 5f6c 6f63 616c   not in by_local
-00011050: 5d0d 0a20 2020 2020 2020 2069 6620 6c65  ]..        if le
-00011060: 6e28 636f 6c75 6d6e 735f 746f 5f61 6767  n(columns_to_agg
-00011070: 2920 213d 206c 656e 2861 6767 7265 6761  ) != len(aggrega
-00011080: 7465 645f 6461 7461 2e63 6f6c 756d 6e73  ted_data.columns
-00011090: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-000110a0: 6472 6f70 7065 645f 636f 6c75 6d6e 7320  dropped_columns 
-000110b0: 3d20 5b0d 0a20 2020 2020 2020 2020 2020  = [..           
-000110c0: 2020 2020 2063 6f6c 756d 6e0d 0a20 2020       column..   
-000110d0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-000110e0: 2063 6f6c 756d 6e20 696e 2063 6f6c 756d   column in colum
-000110f0: 6e73 5f74 6f5f 6167 670d 0a20 2020 2020  ns_to_agg..     
-00011100: 2020 2020 2020 2020 2020 2069 6620 636f             if co
-00011110: 6c75 6d6e 206e 6f74 2069 6e20 6167 6772  lumn not in aggr
-00011120: 6567 6174 6564 5f64 6174 612e 636f 6c75  egated_data.colu
-00011130: 6d6e 730d 0a20 2020 2020 2020 2020 2020  mns..           
-00011140: 205d 0d0a 2020 2020 2020 2020 2020 2020   ]..            
-00011150: 7261 6973 6520 4578 6365 7074 696f 6e28  raise Exception(
-00011160: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00011170: 2020 6622 436f 6c75 6d6e 2873 2920 7b64    f"Column(s) {d
-00011180: 726f 7070 6564 5f63 6f6c 756d 6e73 7d20  ropped_columns} 
-00011190: 6172 6520 6e6f 7420 7375 7070 6f72 7465  are not supporte
-000111a0: 6420 666f 7220 6167 6772 6567 6174 696f  d for aggregatio
-000111b0: 6e2c 2073 746f 7022 0d0a 2020 2020 2020  n, stop"..      
-000111c0: 2020 2020 2020 290d 0a0d 0a20 2020 2023        )....    #
-000111d0: 2050 726f 6365 7373 2073 7061 7469 616c   Process spatial
-000111e0: 2063 6f6d 706f 6e65 6e74 0d0a 2020 2020   component..    
-000111f0: 6465 6620 6d65 7267 655f 6765 6f6d 6574  def merge_geomet
-00011200: 7269 6573 2862 6c6f 636b 293a 0d0a 2020  ries(block):..  
-00011210: 2020 2020 2020 6d65 7267 6564 5f67 656f        merged_geo
-00011220: 6d20 3d20 626c 6f63 6b2e 756e 6172 795f  m = block.unary_
-00011230: 756e 696f 6e0d 0a20 2020 2020 2020 2072  union..        r
-00011240: 6574 7572 6e20 6d65 7267 6564 5f67 656f  eturn merged_geo
-00011250: 6d0d 0a0d 0a20 2020 2067 203d 2064 662e  m....    g = df.
-00011260: 6772 6f75 7062 7928 6772 6f75 705f 6b65  groupby(group_ke
-00011270: 7973 3d46 616c 7365 2c20 2a2a 6772 6f75  ys=False, **grou
-00011280: 7062 795f 6b77 6172 6773 295b 6466 2e67  pby_kwargs)[df.g
-00011290: 656f 6d65 7472 792e 6e61 6d65 5d2e 6167  eometry.name].ag
-000112a0: 6728 0d0a 2020 2020 2020 2020 6d65 7267  g(..        merg
-000112b0: 655f 6765 6f6d 6574 7269 6573 0d0a 2020  e_geometries..  
-000112c0: 2020 290d 0a0d 0a20 2020 2023 2041 6767    )....    # Agg
-000112d0: 7265 6761 7465 0d0a 2020 2020 6167 6772  regate..    aggr
-000112e0: 6567 6174 6564 5f67 656f 6d65 7472 7920  egated_geometry 
-000112f0: 3d20 6770 642e 4765 6f44 6174 6146 7261  = gpd.GeoDataFra
-00011300: 6d65 280d 0a20 2020 2020 2020 2064 6174  me(..        dat
-00011310: 613d 672c 2067 656f 6d65 7472 793d 6466  a=g, geometry=df
-00011320: 2e67 656f 6d65 7472 792e 6e61 6d65 2c20  .geometry.name, 
-00011330: 6372 733d 6466 2e63 7273 2020 2320 7479  crs=df.crs  # ty
-00011340: 7065 3a20 6967 6e6f 7265 0d0a 2020 2020  pe: ignore..    
-00011350: 290d 0a20 2020 2023 2052 6563 6f6d 6269  )..    # Recombi
-00011360: 6e65 0d0a 2020 2020 6167 6772 6567 6174  ne..    aggregat
-00011370: 6564 203d 2061 6767 7265 6761 7465 645f  ed = aggregated_
-00011380: 6765 6f6d 6574 7279 2e6a 6f69 6e28 6167  geometry.join(ag
-00011390: 6772 6567 6174 6564 5f64 6174 6129 0d0a  gregated_data)..
-000113a0: 0d0a 2020 2020 2320 5265 7365 7420 6966  ..    # Reset if
-000113b0: 2072 6571 7565 7374 6564 0d0a 2020 2020   requested..    
-000113c0: 6966 206e 6f74 2061 735f 696e 6465 783a  if not as_index:
-000113d0: 0d0a 2020 2020 2020 2020 6167 6772 6567  ..        aggreg
-000113e0: 6174 6564 203d 2061 6767 7265 6761 7465  ated = aggregate
-000113f0: 642e 7265 7365 745f 696e 6465 7828 290d  d.reset_index().
-00011400: 0a0d 0a20 2020 2023 204d 616b 6520 7375  ...    # Make su
-00011410: 7265 206f 7574 7075 7420 7479 7065 7320  re output types 
-00011420: 6f66 2067 726f 7570 6564 2063 6f6c 756d  of grouped colum
-00011430: 6e73 2061 7265 2074 6865 2073 616d 6520  ns are the same 
-00011440: 6173 2069 6e70 7574 2074 7970 6573 2e0d  as input types..
-00011450: 0a20 2020 2023 2045 2e67 2e20 6f62 6a65  .    # E.g. obje
-00011460: 6374 2063 6f6c 756d 6e73 2062 6563 6f6d  ct columns becom
-00011470: 6520 666c 6f61 7420 6966 2061 6c6c 2076  e float if all v
-00011480: 616c 7565 7320 6172 6520 4e6f 6e65 2e0d  alues are None..
-00011490: 0a20 2020 2069 6620 6279 2069 7320 6e6f  .    if by is no
-000114a0: 7420 4e6f 6e65 3a0d 0a20 2020 2020 2020  t None:..       
-000114b0: 2069 6620 6973 696e 7374 616e 6365 2862   if isinstance(b
-000114c0: 792c 2073 7472 293a 0d0a 2020 2020 2020  y, str):..      
-000114d0: 2020 2020 2020 6966 2062 7920 696e 2061        if by in a
-000114e0: 6767 7265 6761 7465 642e 636f 6c75 6d6e  ggregated.column
-000114f0: 7320 616e 6420 6466 5b62 795d 2e64 7479  s and df[by].dty
-00011500: 7065 2021 3d20 6167 6772 6567 6174 6564  pe != aggregated
-00011510: 5b62 795d 2e64 7479 7065 3a0d 0a20 2020  [by].dtype:..   
-00011520: 2020 2020 2020 2020 2020 2020 2061 6767               agg
-00011530: 7265 6761 7465 645b 6279 5d20 3d20 6167  regated[by] = ag
-00011540: 6772 6567 6174 6564 5b62 795d 2e61 7374  gregated[by].ast
-00011550: 7970 6528 6466 5b62 795d 2e64 7479 7065  ype(df[by].dtype
-00011560: 2920 2023 2074 7970 653a 2069 676e 6f72  )  # type: ignor
-00011570: 650d 0a20 2020 2020 2020 2065 6c69 6620  e..        elif 
-00011580: 6973 696e 7374 616e 6365 2862 792c 2049  isinstance(by, I
-00011590: 7465 7261 626c 6529 3a0d 0a20 2020 2020  terable):..     
-000115a0: 2020 2020 2020 2066 6f72 2063 6f6c 2069         for col i
-000115b0: 6e20 6279 3a0d 0a20 2020 2020 2020 2020  n by:..         
-000115c0: 2020 2020 2020 2069 6620 636f 6c20 696e         if col in
-000115d0: 2061 6767 7265 6761 7465 642e 636f 6c75   aggregated.colu
-000115e0: 6d6e 7320 616e 6420 6466 5b63 6f6c 5d2e  mns and df[col].
-000115f0: 6474 7970 6520 213d 2061 6767 7265 6761  dtype != aggrega
-00011600: 7465 645b 636f 6c5d 2e64 7479 7065 3a0d  ted[col].dtype:.
-00011610: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011620: 2020 2020 2061 6767 7265 6761 7465 645b       aggregated[
-00011630: 636f 6c5d 203d 2061 6767 7265 6761 7465  col] = aggregate
-00011640: 645b 636f 6c5d 2e61 7374 7970 6528 6466  d[col].astype(df
-00011650: 5b63 6f6c 5d2e 6474 7970 6529 0d0a 0d0a  [col].dtype)....
-00011660: 2020 2020 6173 7365 7274 2069 7369 6e73      assert isins
-00011670: 7461 6e63 6528 6167 6772 6567 6174 6564  tance(aggregated
-00011680: 2c20 6770 642e 4765 6f44 6174 6146 7261  , gpd.GeoDataFra
-00011690: 6d65 290d 0a20 2020 2072 6574 7572 6e20  me)..    return 
-000116a0: 6167 6772 6567 6174 6564 0d0a 0d0a 0d0a  aggregated......
-000116b0: 6465 6620 5f61 6464 5f6f 7264 6572 6279  def _add_orderby
-000116c0: 5f63 6f6c 756d 6e28 7061 7468 3a20 5061  _column(path: Pa
-000116d0: 7468 2c20 6c61 7965 723a 2073 7472 2c20  th, layer: str, 
-000116e0: 6e61 6d65 3a20 7374 7229 3a0d 0a20 2020  name: str):..   
-000116f0: 2023 2050 7265 7061 7265 2074 6865 2065   # Prepare the e
-00011700: 7870 7265 7373 696f 6e20 746f 2063 616c  xpression to cal
-00011710: 6375 6c61 7465 2074 6865 206f 7264 6572  culate the order
-00011720: 6279 2063 6f6c 756d 6e2e 0d0a 2020 2020  by column...    
-00011730: 2320 496e 2061 2073 7061 7469 616c 2066  # In a spatial f
-00011740: 696c 652c 2061 2073 7061 7469 616c 206f  ile, a spatial o
-00011750: 7264 6572 2077 696c 6c20 6d61 6b65 206c  rder will make l
-00011760: 6174 6572 2075 7365 206d 6f72 6520 6566  ater use more ef
-00011770: 6669 6369 c3ab 6e74 2c0d 0a20 2020 2023  fici..nt,..    #
-00011780: 2073 6f20 7573 6520 6120 6765 6f68 6173   so use a geohas
-00011790: 682e 0d0a 2020 2020 6c61 7965 7269 6e66  h...    layerinf
-000117a0: 6f20 3d20 6766 6f2e 6765 745f 6c61 7965  o = gfo.get_laye
-000117b0: 7269 6e66 6f28 7061 7468 290d 0a20 2020  rinfo(path)..   
-000117c0: 2069 6620 6c61 7965 7269 6e66 6f2e 6372   if layerinfo.cr
-000117d0: 7320 6973 206e 6f74 204e 6f6e 6520 616e  s is not None an
-000117e0: 6420 6c61 7965 7269 6e66 6f2e 6372 732e  d layerinfo.crs.
-000117f0: 6973 5f67 656f 6772 6170 6869 633a 0d0a  is_geographic:..
-00011800: 2020 2020 2020 2020 2320 4966 2074 6865          # If the
-00011810: 2063 6f6f 7264 696e 6174 6573 2061 7265   coordinates are
-00011820: 2067 656f 6772 6170 6869 6320 2869 6e20   geographic (in 
-00011830: 6c61 742f 6c6f 6e20 6465 6772 6565 7329  lat/lon degrees)
-00011840: 2c20 6f6b 0d0a 2020 2020 2020 2020 6578  , ok..        ex
-00011850: 7072 6573 7369 6f6e 203d 2066 2253 545f  pression = f"ST_
-00011860: 4765 6f48 6173 6828 7b6c 6179 6572 696e  GeoHash({layerin
-00011870: 666f 2e67 656f 6d65 7472 7963 6f6c 756d  fo.geometrycolum
-00011880: 6e7d 2c20 3130 2922 0d0a 2020 2020 656c  n}, 10)"..    el
-00011890: 7365 3a0d 0a20 2020 2020 2020 2023 2049  se:..        # I
-000118a0: 6620 7468 6579 2061 7265 206e 6f74 2067  f they are not g
-000118b0: 656f 6772 6170 6869 6320 2869 6e20 6c61  eographic (in la
-000118c0: 742f 6c6f 6e20 6465 6772 6565 7329 2c20  t/lon degrees), 
-000118d0: 7468 6579 206e 6565 6420 746f 2062 650d  they need to be.
-000118e0: 0a20 2020 2020 2020 2023 2063 6f6e 7665  .        # conve
-000118f0: 7274 6564 2074 6f20 7e20 6465 6772 6565  rted to ~ degree
-00011900: 7320 746f 2062 6520 6162 6c65 2074 6f20  s to be able to 
-00011910: 6361 6c63 756c 6174 6520 6120 6765 6f68  calculate a geoh
-00011920: 6173 682e 0d0a 0d0a 2020 2020 2020 2020  ash.....        
-00011930: 2320 5072 6f70 6572 6c79 2063 616c 6375  # Properly calcu
-00011940: 6c61 7469 6e67 2074 6865 2074 7261 6e73  lating the trans
-00011950: 666f 726d 6174 696f 6e20 746f 2065 672e  formation to eg.
-00011960: 2057 4753 2069 7320 7465 7272 6962 6c79   WGS is terribly
-00011970: 2073 6c6f 772e 2e2e 0d0a 2020 2020 2020   slow.....      
-00011980: 2020 2320 6578 7072 6573 7369 6f6e 203d    # expression =
-00011990: 2066 2222 2253 545f 4765 6f48 6173 6828   f"""ST_GeoHash(
-000119a0: 5354 5f54 7261 6e73 666f 726d 284d 616b  ST_Transform(Mak
-000119b0: 6550 6f69 6e74 280d 0a20 2020 2020 2020  ePoint(..       
-000119c0: 2023 2020 2020 2020 2028 4d62 724d 6178   #       (MbrMax
-000119d0: 5828 6765 6f6d 292b 4d62 724d 696e 5828  X(geom)+MbrMinX(
-000119e0: 6765 6f6d 2929 2f32 2c0d 0a20 2020 2020  geom))/2,..     
-000119f0: 2020 2023 2020 2020 2020 2028 4d62 724d     #       (MbrM
-00011a00: 696e 5928 6765 6f6d 292b 4d62 724d 6178  inY(geom)+MbrMax
-00011a10: 5928 6765 6f6d 2929 2f32 2c20 5354 5f53  Y(geom))/2, ST_S
-00011a20: 5249 4428 6765 6f6d 2929 2c20 3433 3236  RID(geom)), 4326
-00011a30: 292c 2031 3029 2222 220d 0a20 2020 2020  ), 10)"""..     
-00011a40: 2020 2023 2053 6f2c 2064 6f20 736f 6d65     # So, do some
-00011a50: 7468 696e 6720 656c 7365 2074 6861 7427  thing else that'
-00011a60: 7320 6661 7374 6572 2061 6e64 2073 7469  s faster and sti
-00011a70: 6c6c 2067 6976 6573 2061 2067 6f6f 640d  ll gives a good.
-00011a80: 0a20 2020 2020 2020 2023 2067 656f 6772  .        # geogr
-00011a90: 6170 6869 6320 636c 7573 7465 7269 6e67  aphic clustering
-00011aa0: 2e0d 0a20 2020 2020 2020 2074 6f5f 6765  ...        to_ge
-00011ab0: 6f67 7261 7068 6963 5f66 6163 746f 725f  ographic_factor_
-00011ac0: 6170 7072 6f78 203d 2039 3020 2f20 6d61  approx = 90 / ma
-00011ad0: 7828 6c61 7965 7269 6e66 6f2e 746f 7461  x(layerinfo.tota
-00011ae0: 6c5f 626f 756e 6473 290d 0a20 2020 2020  l_bounds)..     
-00011af0: 2020 2065 7870 7265 7373 696f 6e20 3d20     expression = 
-00011b00: 6622 2222 5354 5f47 656f 4861 7368 284d  f"""ST_GeoHash(M
-00011b10: 616b 6550 6f69 6e74 280d 0a20 2020 2020  akePoint(..     
-00011b20: 2020 2020 2020 2020 2020 2028 284d 6272             ((Mbr
-00011b30: 4d61 7858 287b 6c61 7965 7269 6e66 6f2e  MaxX({layerinfo.
-00011b40: 6765 6f6d 6574 7279 636f 6c75 6d6e 7d29  geometrycolumn})
-00011b50: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00011b60: 2020 2020 2b4d 6272 4d69 6e58 287b 6c61      +MbrMinX({la
-00011b70: 7965 7269 6e66 6f2e 6765 6f6d 6574 7279  yerinfo.geometry
-00011b80: 636f 6c75 6d6e 7d29 292f 320d 0a20 2020  column}))/2..   
-00011b90: 2020 2020 2020 2020 2020 2020 2029 2a7b               )*{
-00011ba0: 746f 5f67 656f 6772 6170 6869 635f 6661  to_geographic_fa
-00011bb0: 6374 6f72 5f61 7070 726f 787d 2c0d 0a20  ctor_approx},.. 
-00011bc0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-00011bd0: 284d 6272 4d69 6e59 287b 6c61 7965 7269  (MbrMinY({layeri
-00011be0: 6e66 6f2e 6765 6f6d 6574 7279 636f 6c75  nfo.geometrycolu
-00011bf0: 6d6e 7d29 0d0a 2020 2020 2020 2020 2020  mn})..          
-00011c00: 2020 2020 2020 2020 2b4d 6272 4d61 7859          +MbrMaxY
-00011c10: 287b 6c61 7965 7269 6e66 6f2e 6765 6f6d  ({layerinfo.geom
-00011c20: 6574 7279 636f 6c75 6d6e 7d29 292f 320d  etrycolumn}))/2.
-00011c30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011c40: 2029 2a7b 746f 5f67 656f 6772 6170 6869   )*{to_geographi
-00011c50: 635f 6661 6374 6f72 5f61 7070 726f 787d  c_factor_approx}
-00011c60: 2c20 3433 3236 292c 2031 3029 2222 220d  , 4326), 10)""".
-00011c70: 0a0d 0a20 2020 2023 204e 6f77 2077 6520  ...    # Now we 
-00011c80: 6361 6e20 6163 7475 616c 6c79 2061 6464  can actually add
-00011c90: 2074 6865 2063 6f6c 756d 6e2e 0d0a 2020   the column...  
-00011ca0: 2020 6766 6f2e 6164 645f 636f 6c75 6d6e    gfo.add_column
-00011cb0: 2870 6174 683d 7061 7468 2c20 6e61 6d65  (path=path, name
-00011cc0: 3d6e 616d 652c 2074 7970 653d 6766 6f2e  =name, type=gfo.
-00011cd0: 4461 7461 5479 7065 2e54 4558 542c 2065  DataType.TEXT, e
-00011ce0: 7870 7265 7373 696f 6e3d 6578 7072 6573  xpression=expres
-00011cf0: 7369 6f6e 290d 0a20 2020 2073 716c 6974  sion)..    sqlit
-00011d00: 655f 7374 6d74 203d 2066 2743 5245 4154  e_stmt = f'CREAT
-00011d10: 4520 494e 4445 5820 7b6e 616d 657d 5f69  E INDEX {name}_i
-00011d20: 6478 204f 4e20 227b 6c61 7965 727d 2228  dx ON "{layer}"(
-00011d30: 7b6e 616d 657d 2927 0d0a 2020 2020 6766  {name})'..    gf
-00011d40: 6f2e 6578 6563 7574 655f 7371 6c28 7061  o.execute_sql(pa
-00011d50: 7468 3d70 6174 682c 2073 716c 5f73 746d  th=path, sql_stm
-00011d60: 743d 7371 6c69 7465 5f73 746d 7429 0d0a  t=sqlite_stmt)..
+0000ca60: 2020 2020 6473 743d 6f75 7470 7574 5f6f      dst=output_o
+0000ca70: 6e62 6f72 6465 725f 7061 7468 2c0a 2020  nborder_path,.  
+0000ca80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ca90: 2020 2020 2020 2020 2020 6372 6561 7465            create
+0000caa0: 5f73 7061 7469 616c 5f69 6e64 6578 3d46  _spatial_index=F
+0000cab0: 616c 7365 2c0a 2020 2020 2020 2020 2020  alse,.          
+0000cac0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000cad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cae0: 2020 2020 2020 2020 6766 6f2e 7265 6d6f          gfo.remo
+0000caf0: 7665 286f 7574 7075 745f 6f6e 626f 7264  ve(output_onbord
+0000cb00: 6572 5f74 6d70 5f70 6172 7469 616c 5f70  er_tmp_partial_p
+0000cb10: 6174 6829 0a0a 2020 2020 2020 2020 2020  ath)..          
+0000cb20: 2020 6578 6365 7074 2045 7863 6570 7469    except Excepti
+0000cb30: 6f6e 2061 7320 6578 3a0a 2020 2020 2020  on as ex:.      
+0000cb40: 2020 2020 2020 2020 2020 6261 7463 685f            batch_
+0000cb50: 6964 203d 2066 7574 7572 655f 746f 5f62  id = future_to_b
+0000cb60: 6174 6368 5f69 645b 6675 7475 7265 5d0a  atch_id[future].
+0000cb70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cb80: 6d65 7373 6167 6520 3d20 6622 4572 726f  message = f"Erro
+0000cb90: 7220 6578 6563 7574 696e 6720 7b62 6174  r executing {bat
+0000cba0: 6368 6573 5b62 6174 6368 5f69 645d 7d3a  ches[batch_id]}:
+0000cbb0: 207b 6578 7d22 0a20 2020 2020 2020 2020   {ex}".         
+0000cbc0: 2020 2020 2020 206c 6f67 6765 722e 6578         logger.ex
+0000cbd0: 6365 7074 696f 6e28 6d65 7373 6167 6529  ception(message)
+0000cbe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000cbf0: 2063 616c 6375 6c61 7465 5f70 6f6f 6c2e   calculate_pool.
+0000cc00: 7368 7574 646f 776e 2829 0a20 2020 2020  shutdown().     
+0000cc10: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+0000cc20: 2045 7863 6570 7469 6f6e 286d 6573 7361   Exception(messa
+0000cc30: 6765 2920 6672 6f6d 2065 780a 0a20 2020  ge) from ex..   
+0000cc40: 2020 2020 2020 2020 2023 204c 6f67 2074           # Log t
+0000cc50: 6865 2070 726f 6772 6573 7320 616e 6420  he progress and 
+0000cc60: 7072 6564 6963 7469 6f6e 2073 7065 6564  prediction speed
+0000cc70: 0a20 2020 2020 2020 2020 2020 205f 6765  .            _ge
+0000cc80: 6e65 7261 6c5f 7574 696c 2e72 6570 6f72  neral_util.repor
+0000cc90: 745f 7072 6f67 7265 7373 280a 2020 2020  t_progress(.    
+0000cca0: 2020 2020 2020 2020 2020 2020 7374 6172              star
+0000ccb0: 745f 7469 6d65 2c20 6e62 5f62 6174 6368  t_time, nb_batch
+0000ccc0: 6573 5f64 6f6e 652c 206e 625f 6261 7463  es_done, nb_batc
+0000ccd0: 6865 732c 2022 6469 7373 6f6c 7665 220a  hes, "dissolve".
+0000cce0: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+0000ccf0: 2020 206c 6f67 6765 722e 696e 666f 2866     logger.info(f
+0000cd00: 2244 6973 736f 6c76 6520 7061 7373 2072  "Dissolve pass r
+0000cd10: 6561 6479 2c20 746f 6f6b 207b 6461 7465  eady, took {date
+0000cd20: 7469 6d65 2e6e 6f77 2829 2d73 7461 7274  time.now()-start
+0000cd30: 5f74 696d 657d 2122 290a 0a20 2020 2072  _time}!")..    r
+0000cd40: 6574 7572 6e20 7265 7375 6c74 5f69 6e66  eturn result_inf
+0000cd50: 6f0a 0a0a 6465 6620 5f64 6973 736f 6c76  o...def _dissolv
+0000cd60: 655f 706f 6c79 676f 6e73 280a 2020 2020  e_polygons(.    
+0000cd70: 696e 7075 745f 7061 7468 3a20 5061 7468  input_path: Path
+0000cd80: 2c0a 2020 2020 6f75 7470 7574 5f6e 6f74  ,.    output_not
+0000cd90: 6f6e 626f 7264 6572 5f70 6174 683a 2050  onborder_path: P
+0000cda0: 6174 682c 0a20 2020 206f 7574 7075 745f  ath,.    output_
+0000cdb0: 6f6e 626f 7264 6572 5f70 6174 683a 2050  onborder_path: P
+0000cdc0: 6174 682c 0a20 2020 2065 7870 6c6f 6465  ath,.    explode
+0000cdd0: 636f 6c6c 6563 7469 6f6e 733a 2062 6f6f  collections: boo
+0000cde0: 6c2c 0a20 2020 2067 726f 7570 6279 5f63  l,.    groupby_c
+0000cdf0: 6f6c 756d 6e73 3a20 4f70 7469 6f6e 616c  olumns: Optional
+0000ce00: 5b49 7465 7261 626c 655b 7374 725d 5d2c  [Iterable[str]],
+0000ce10: 0a20 2020 2061 6767 5f63 6f6c 756d 6e73  .    agg_columns
+0000ce20: 3a20 4f70 7469 6f6e 616c 5b64 6963 745d  : Optional[dict]
+0000ce30: 2c0a 2020 2020 696e 7075 745f 6765 6f6d  ,.    input_geom
+0000ce40: 6574 7279 7479 7065 3a20 4765 6f6d 6574  etrytype: Geomet
+0000ce50: 7279 5479 7065 2c0a 2020 2020 696e 7075  ryType,.    inpu
+0000ce60: 745f 6c61 7965 723a 204f 7074 696f 6e61  t_layer: Optiona
+0000ce70: 6c5b 7374 725d 2c0a 2020 2020 6f75 7470  l[str],.    outp
+0000ce80: 7574 5f6c 6179 6572 3a20 4f70 7469 6f6e  ut_layer: Option
+0000ce90: 616c 5b73 7472 5d2c 0a20 2020 2062 626f  al[str],.    bbo
+0000cea0: 783a 2054 7570 6c65 5b66 6c6f 6174 2c20  x: Tuple[float, 
+0000ceb0: 666c 6f61 742c 2066 6c6f 6174 2c20 666c  float, float, fl
+0000cec0: 6f61 745d 2c0a 2020 2020 7469 6c65 5f69  oat],.    tile_i
+0000ced0: 643a 204f 7074 696f 6e61 6c5b 696e 745d  d: Optional[int]
+0000cee0: 2c0a 2920 2d3e 2064 6963 743a 0a20 2020  ,.) -> dict:.   
+0000cef0: 2023 2049 6e69 740a 2020 2020 7065 7266   # Init.    perf
+0000cf00: 696e 666f 203d 207b 7d0a 2020 2020 7374  info = {}.    st
+0000cf10: 6172 745f 7469 6d65 203d 2064 6174 6574  art_time = datet
+0000cf20: 696d 652e 6e6f 7728 290a 2020 2020 7265  ime.now().    re
+0000cf30: 7475 726e 5f69 6e66 6f20 3d20 7b0a 2020  turn_info = {.  
+0000cf40: 2020 2020 2020 2269 6e70 7574 5f70 6174        "input_pat
+0000cf50: 6822 3a20 696e 7075 745f 7061 7468 2c0a  h": input_path,.
+0000cf60: 2020 2020 2020 2020 226f 7574 7075 745f          "output_
+0000cf70: 6e6f 746f 6e62 6f72 6465 725f 7061 7468  notonborder_path
+0000cf80: 223a 206f 7574 7075 745f 6e6f 746f 6e62  ": output_notonb
+0000cf90: 6f72 6465 725f 7061 7468 2c0a 2020 2020  order_path,.    
+0000cfa0: 2020 2020 226f 7574 7075 745f 6f6e 626f      "output_onbo
+0000cfb0: 7264 6572 5f70 6174 6822 3a20 6f75 7470  rder_path": outp
+0000cfc0: 7574 5f6f 6e62 6f72 6465 725f 7061 7468  ut_onborder_path
+0000cfd0: 2c0a 2020 2020 2020 2020 2262 626f 7822  ,.        "bbox"
+0000cfe0: 3a20 6262 6f78 2c0a 2020 2020 2020 2020  : bbox,.        
+0000cff0: 2274 696c 655f 6964 223a 2074 696c 655f  "tile_id": tile_
+0000d000: 6964 2c0a 2020 2020 2020 2020 226e 625f  id,.        "nb_
+0000d010: 726f 7773 5f64 6f6e 6522 3a20 302c 0a20  rows_done": 0,. 
+0000d020: 2020 2020 2020 2022 746f 7461 6c5f 7469         "total_ti
+0000d030: 6d65 223a 2030 2c0a 2020 2020 2020 2020  me": 0,.        
+0000d040: 2270 6572 6669 6e66 6f22 3a20 2222 2c0a  "perfinfo": "",.
+0000d050: 2020 2020 7d0a 0a20 2020 2023 2052 6561      }..    # Rea
+0000d060: 6420 616c 6c20 7265 636f 7264 7320 7468  d all records th
+0000d070: 6174 2061 7265 2069 6e20 7468 6520 6262  at are in the bb
+0000d080: 6f78 0a20 2020 2072 6574 7279 5f63 6f75  ox.    retry_cou
+0000d090: 6e74 203d 2030 0a20 2020 2073 7461 7274  nt = 0.    start
+0000d0a0: 5f72 6561 6420 3d20 6461 7465 7469 6d65  _read = datetime
+0000d0b0: 2e6e 6f77 2829 0a20 2020 2061 6767 5f63  .now().    agg_c
+0000d0c0: 6f6c 756d 6e73 5f6e 6565 6465 6420 3d20  olumns_needed = 
+0000d0d0: 4e6f 6e65 0a20 2020 2077 6869 6c65 2054  None.    while T
+0000d0e0: 7275 653a 0a20 2020 2020 2020 2074 7279  rue:.        try
+0000d0f0: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
+0000d100: 6c75 6d6e 735f 746f 5f72 6561 6420 3d20  lumns_to_read = 
+0000d110: 7365 7428 290a 2020 2020 2020 2020 2020  set().          
+0000d120: 2020 696e 666f 203d 2067 666f 2e67 6574    info = gfo.get
+0000d130: 5f6c 6179 6572 696e 666f 2869 6e70 7574  _layerinfo(input
+0000d140: 5f70 6174 682c 2069 6e70 7574 5f6c 6179  _path, input_lay
+0000d150: 6572 290a 2020 2020 2020 2020 2020 2020  er).            
+0000d160: 6966 2067 726f 7570 6279 5f63 6f6c 756d  if groupby_colum
+0000d170: 6e73 2069 7320 6e6f 7420 4e6f 6e65 3a0a  ns is not None:.
+0000d180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d190: 636f 6c75 6d6e 735f 746f 5f72 6561 642e  columns_to_read.
+0000d1a0: 7570 6461 7465 2867 726f 7570 6279 5f63  update(groupby_c
+0000d1b0: 6f6c 756d 6e73 290a 2020 2020 2020 2020  olumns).        
+0000d1c0: 2020 2020 6669 645f 6173 5f69 6e64 6578      fid_as_index
+0000d1d0: 203d 2046 616c 7365 0a20 2020 2020 2020   = False.       
+0000d1e0: 2020 2020 2069 6620 6167 675f 636f 6c75       if agg_colu
+0000d1f0: 6d6e 7320 6973 206e 6f74 204e 6f6e 653a  mns is not None:
+0000d200: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d210: 2066 6964 5f61 735f 696e 6465 7820 3d20   fid_as_index = 
+0000d220: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
+0000d230: 2020 2020 2069 6620 225f 5f44 4953 534f       if "__DISSO
+0000d240: 4c56 455f 544f 4a53 4f4e 2220 696e 2069  LVE_TOJSON" in i
+0000d250: 6e66 6f2e 636f 6c75 6d6e 733a 0a20 2020  nfo.columns:.   
+0000d260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d270: 2023 2049 6620 7765 2061 7265 206e 6f74   # If we are not
+0000d280: 2069 6e20 7468 6520 6669 7273 7420 7061   in the first pa
+0000d290: 7373 2c20 7468 6520 636f 6c75 6d6e 7320  ss, the columns 
+0000d2a0: 746f 2062 6520 7265 6164 0a20 2020 2020  to be read.     
+0000d2b0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000d2c0: 2061 7265 2061 6c72 6561 6479 2069 6e20   are already in 
+0000d2d0: 7468 6520 6a73 6f6e 2063 6f6c 756d 6e0a  the json column.
+0000d2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d2f0: 2020 2020 636f 6c75 6d6e 735f 746f 5f72      columns_to_r
+0000d300: 6561 642e 6164 6428 225f 5f44 4953 534f  ead.add("__DISSO
+0000d310: 4c56 455f 544f 4a53 4f4e 2229 0a20 2020  LVE_TOJSON").   
+0000d320: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+0000d330: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000d340: 2020 2020 2020 2023 2054 6865 2066 6972         # The fir
+0000d350: 7374 2070 6173 732c 2073 6f20 7265 6164  st pass, so read
+0000d360: 2061 6c6c 2072 656c 6576 616e 7420 636f   all relevant co
+0000d370: 6c75 6d6e 7320 746f 2063 6f64 650a 2020  lumns to code.  
+0000d380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d390: 2020 2320 7468 656d 2069 6e20 6a73 6f6e    # them in json
+0000d3a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d3b0: 2020 2020 2069 6620 226a 736f 6e22 2069       if "json" i
+0000d3c0: 6e20 6167 675f 636f 6c75 6d6e 733a 0a20  n agg_columns:. 
+0000d3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d3e0: 2020 2020 2020 2061 6767 5f63 6f6c 756d         agg_colum
+0000d3f0: 6e73 5f6e 6565 6465 6420 3d20 6167 675f  ns_needed = agg_
+0000d400: 636f 6c75 6d6e 735b 226a 736f 6e22 5d0a  columns["json"].
+0000d410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d420: 2020 2020 656c 6966 2022 636f 6c75 6d6e      elif "column
+0000d430: 7322 2069 6e20 6167 675f 636f 6c75 6d6e  s" in agg_column
+0000d440: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+0000d450: 2020 2020 2020 2020 2020 2061 6767 5f63             agg_c
+0000d460: 6f6c 756d 6e73 5f6e 6565 6465 6420 3d20  olumns_needed = 
+0000d470: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
+0000d480: 2020 2020 2020 2020 2020 2020 2020 6167                ag
+0000d490: 675f 636f 6c75 6d6e 5b22 636f 6c75 6d6e  g_column["column
+0000d4a0: 225d 0a20 2020 2020 2020 2020 2020 2020  "].             
+0000d4b0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0000d4c0: 6f72 2061 6767 5f63 6f6c 756d 6e20 696e  or agg_column in
+0000d4d0: 2061 6767 5f63 6f6c 756d 6e73 5b22 636f   agg_columns["co
+0000d4e0: 6c75 6d6e 7322 5d0a 2020 2020 2020 2020  lumns"].        
+0000d4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d500: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0000d510: 2020 2020 2020 6966 2061 6767 5f63 6f6c        if agg_col
+0000d520: 756d 6e73 5f6e 6565 6465 6420 6973 206e  umns_needed is n
+0000d530: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+0000d540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d550: 2063 6f6c 756d 6e73 5f74 6f5f 7265 6164   columns_to_read
+0000d560: 2e75 7064 6174 6528 6167 675f 636f 6c75  .update(agg_colu
+0000d570: 6d6e 735f 6e65 6564 6564 290a 0a20 2020  mns_needed)..   
+0000d580: 2020 2020 2020 2020 2069 6e70 7574 5f67           input_g
+0000d590: 6466 203d 2067 666f 2e72 6561 645f 6669  df = gfo.read_fi
+0000d5a0: 6c65 280a 2020 2020 2020 2020 2020 2020  le(.            
+0000d5b0: 2020 2020 7061 7468 3d69 6e70 7574 5f70      path=input_p
+0000d5c0: 6174 682c 0a20 2020 2020 2020 2020 2020  ath,.           
+0000d5d0: 2020 2020 206c 6179 6572 3d69 6e70 7574       layer=input
+0000d5e0: 5f6c 6179 6572 2c0a 2020 2020 2020 2020  _layer,.        
+0000d5f0: 2020 2020 2020 2020 6262 6f78 3d62 626f          bbox=bbo
+0000d600: 782c 0a20 2020 2020 2020 2020 2020 2020  x,.             
+0000d610: 2020 2063 6f6c 756d 6e73 3d63 6f6c 756d     columns=colum
+0000d620: 6e73 5f74 6f5f 7265 6164 2c0a 2020 2020  ns_to_read,.    
+0000d630: 2020 2020 2020 2020 2020 2020 6669 645f              fid_
+0000d640: 6173 5f69 6e64 6578 3d66 6964 5f61 735f  as_index=fid_as_
+0000d650: 696e 6465 782c 0a20 2020 2020 2020 2020  index,.         
+0000d660: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
+0000d670: 2020 6966 2061 6767 5f63 6f6c 756d 6e73    if agg_columns
+0000d680: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+0000d690: 2020 2020 2020 2020 2020 2020 2020 696e                in
+0000d6a0: 7075 745f 6764 665b 2266 6964 5f6f 7269  put_gdf["fid_ori
+0000d6b0: 6722 5d20 3d20 696e 7075 745f 6764 662e  g"] = input_gdf.
+0000d6c0: 696e 6465 780a 2020 2020 2020 2020 2020  index.          
+0000d6d0: 2020 2020 2020 6966 2061 6767 5f63 6f6c        if agg_col
+0000d6e0: 756d 6e73 5f6e 6565 6465 6420 6973 206e  umns_needed is n
+0000d6f0: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+0000d700: 2020 2020 2020 2020 2020 2020 2061 6767               agg
+0000d710: 5f63 6f6c 756d 6e73 5f6e 6565 6465 642e  _columns_needed.
+0000d720: 6170 7065 6e64 2822 6669 645f 6f72 6967  append("fid_orig
+0000d730: 2229 0a0a 2020 2020 2020 2020 2020 2020  ")..            
+0000d740: 6272 6561 6b0a 2020 2020 2020 2020 6578  break.        ex
+0000d750: 6365 7074 2045 7863 6570 7469 6f6e 2061  cept Exception a
+0000d760: 7320 6578 3a0a 2020 2020 2020 2020 2020  s ex:.          
+0000d770: 2020 6966 2073 7472 2865 7829 203d 3d20    if str(ex) == 
+0000d780: 2264 6174 6162 6173 6520 6973 206c 6f63  "database is loc
+0000d790: 6b65 6422 3a0a 2020 2020 2020 2020 2020  ked":.          
+0000d7a0: 2020 2020 2020 6966 2072 6574 7279 5f63        if retry_c
+0000d7b0: 6f75 6e74 203c 2031 303a 0a20 2020 2020  ount < 10:.     
+0000d7c0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0000d7d0: 6574 7279 5f63 6f75 6e74 202b 3d20 310a  etry_count += 1.
+0000d7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d7f0: 2020 2020 7469 6d65 2e73 6c65 6570 2831      time.sleep(1
+0000d800: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000d810: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000d820: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+0000d830: 6520 4578 6365 7074 696f 6e28 2272 6574  e Exception("ret
+0000d840: 7269 6564 2031 3020 7469 6d65 732c 2064  ried 10 times, d
+0000d850: 6174 6162 6173 6520 7374 696c 6c20 6c6f  atabase still lo
+0000d860: 636b 6564 2229 2066 726f 6d20 6578 0a20  cked") from ex. 
+0000d870: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+0000d880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d890: 2072 6169 7365 2065 780a 0a20 2020 2023   raise ex..    #
+0000d8a0: 2043 6865 636b 2072 6573 756c 740a 2020   Check result.  
+0000d8b0: 2020 7065 7266 696e 666f 5b22 7469 6d65    perfinfo["time
+0000d8c0: 5f72 6561 6422 5d20 3d20 2864 6174 6574  _read"] = (datet
+0000d8d0: 696d 652e 6e6f 7728 2920 2d20 7374 6172  ime.now() - star
+0000d8e0: 745f 7265 6164 292e 746f 7461 6c5f 7365  t_read).total_se
+0000d8f0: 636f 6e64 7328 290a 2020 2020 7265 7475  conds().    retu
+0000d900: 726e 5f69 6e66 6f5b 226e 625f 726f 7773  rn_info["nb_rows
+0000d910: 5f64 6f6e 6522 5d20 3d20 6c65 6e28 696e  _done"] = len(in
+0000d920: 7075 745f 6764 6629 0a20 2020 2069 6620  put_gdf).    if 
+0000d930: 7265 7475 726e 5f69 6e66 6f5b 226e 625f  return_info["nb_
+0000d940: 726f 7773 5f64 6f6e 6522 5d20 3d3d 2030  rows_done"] == 0
+0000d950: 3a0a 2020 2020 2020 2020 6d65 7373 6167  :.        messag
+0000d960: 6520 3d20 6622 4e6f 2069 6e70 7574 2067  e = f"No input g
+0000d970: 656f 6d65 7472 6965 7320 666f 756e 6420  eometries found 
+0000d980: 696e 207b 696e 7075 745f 7061 7468 7d22  in {input_path}"
+0000d990: 0a20 2020 2020 2020 206c 6f67 6765 722e  .        logger.
+0000d9a0: 696e 666f 286d 6573 7361 6765 290a 2020  info(message).  
+0000d9b0: 2020 2020 2020 7265 7475 726e 5f69 6e66        return_inf
+0000d9c0: 6f5b 226d 6573 7361 6765 225d 203d 206d  o["message"] = m
+0000d9d0: 6573 7361 6765 0a20 2020 2020 2020 2072  essage.        r
+0000d9e0: 6574 7572 6e5f 696e 666f 5b22 746f 7461  eturn_info["tota
+0000d9f0: 6c5f 7469 6d65 225d 203d 2028 6461 7465  l_time"] = (date
+0000da00: 7469 6d65 2e6e 6f77 2829 202d 2073 7461  time.now() - sta
+0000da10: 7274 5f74 696d 6529 2e74 6f74 616c 5f73  rt_time).total_s
+0000da20: 6563 6f6e 6473 2829 0a20 2020 2020 2020  econds().       
+0000da30: 2072 6574 7572 6e20 7265 7475 726e 5f69   return return_i
+0000da40: 6e66 6f0a 0a20 2020 2023 204e 6f77 2074  nfo..    # Now t
+0000da50: 6865 2072 6561 6c20 7072 6f63 6573 7369  he real processi
+0000da60: 6e67 0a20 2020 2069 6620 6167 675f 636f  ng.    if agg_co
+0000da70: 6c75 6d6e 7320 6973 206e 6f74 204e 6f6e  lumns is not Non
+0000da80: 653a 0a20 2020 2020 2020 2069 6620 225f  e:.        if "_
+0000da90: 5f44 4953 534f 4c56 455f 544f 4a53 4f4e  _DISSOLVE_TOJSON
+0000daa0: 2220 6e6f 7420 696e 2069 6e70 7574 5f67  " not in input_g
+0000dab0: 6466 2e63 6f6c 756d 6e73 3a0a 2020 2020  df.columns:.    
+0000dac0: 2020 2020 2020 2020 2320 4669 7273 7420          # First 
+0000dad0: 7061 7373 202d 3e20 7075 7420 7265 6c65  pass -> put rele
+0000dae0: 7661 6e74 2063 6f6c 756d 6e73 2069 6e20  vant columns in 
+0000daf0: 6a73 6f6e 2066 6965 6c64 0a20 2020 2020  json field.     
+0000db00: 2020 2020 2020 2061 6767 6675 6e63 203d         aggfunc =
+0000db10: 207b 2274 6f5f 6a73 6f6e 223a 2061 6767   {"to_json": agg
+0000db20: 5f63 6f6c 756d 6e73 5f6e 6565 6465 647d  _columns_needed}
+0000db30: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0000db40: 2020 2020 2020 2020 2020 2023 2043 6f6c             # Col
+0000db50: 756d 6e73 2061 6c72 6561 6479 2063 6f64  umns already cod
+0000db60: 6564 2069 6e20 6120 6a73 6f6e 2063 6f6c  ed in a json col
+0000db70: 756d 6e2c 2073 6f20 6d65 7267 6520 6a73  umn, so merge js
+0000db80: 6f6e 206c 6973 7473 0a20 2020 2020 2020  on lists.       
+0000db90: 2020 2020 2061 6767 6675 6e63 203d 2022       aggfunc = "
+0000dba0: 6d65 7267 655f 6a73 6f6e 5f6c 6973 7473  merge_json_lists
+0000dbb0: 220a 2020 2020 656c 7365 3a0a 2020 2020  ".    else:.    
+0000dbc0: 2020 2020 6167 6766 756e 6320 3d20 2266      aggfunc = "f
+0000dbd0: 6972 7374 220a 2020 2020 7374 6172 745f  irst".    start_
+0000dbe0: 6469 7373 6f6c 7665 203d 2064 6174 6574  dissolve = datet
+0000dbf0: 696d 652e 6e6f 7728 290a 2020 2020 6469  ime.now().    di
+0000dc00: 7373 5f67 6466 203d 205f 6469 7373 6f6c  ss_gdf = _dissol
+0000dc10: 7665 280a 2020 2020 2020 2020 6466 3d69  ve(.        df=i
+0000dc20: 6e70 7574 5f67 6466 2c20 6279 3d67 726f  nput_gdf, by=gro
+0000dc30: 7570 6279 5f63 6f6c 756d 6e73 2c20 6167  upby_columns, ag
+0000dc40: 6766 756e 633d 6167 6766 756e 632c 2061  gfunc=aggfunc, a
+0000dc50: 735f 696e 6465 783d 4661 6c73 652c 2064  s_index=False, d
+0000dc60: 726f 706e 613d 4661 6c73 650a 2020 2020  ropna=False.    
+0000dc70: 290a 2020 2020 7065 7266 696e 666f 5b22  ).    perfinfo["
+0000dc80: 7469 6d65 5f64 6973 736f 6c76 6522 5d20  time_dissolve"] 
+0000dc90: 3d20 2864 6174 6574 696d 652e 6e6f 7728  = (datetime.now(
+0000dca0: 2920 2d20 7374 6172 745f 6469 7373 6f6c  ) - start_dissol
+0000dcb0: 7665 292e 746f 7461 6c5f 7365 636f 6e64  ve).total_second
+0000dcc0: 7328 290a 0a20 2020 2023 2049 6620 6578  s()..    # If ex
+0000dcd0: 706c 6f64 6563 6f6c 6c65 6374 696f 6e73  plodecollections
+0000dce0: 2069 7320 5472 7565 2061 6e64 2046 6f72   is True and For
+0000dcf0: 2070 6f6c 7967 6f6e 732c 2065 7870 6c6f   polygons, explo
+0000dd00: 6465 206d 756c 7469 2d67 656f 6d65 7472  de multi-geometr
+0000dd10: 6965 732e 0a20 2020 2023 2049 6620 6e65  ies..    # If ne
+0000dd20: 6564 6564 2074 6865 7920 7769 6c6c 2062  eded they will b
+0000dd30: 6520 2763 6f6c 6c65 6374 6564 2720 6166  e 'collected' af
+0000dd40: 7465 7277 6172 6473 2074 6f20 6d75 6c74  terwards to mult
+0000dd50: 6970 6f6c 7967 6f6e 7320 6167 6169 6e2e  ipolygons again.
+0000dd60: 0a20 2020 2069 6620 6578 706c 6f64 6563  .    if explodec
+0000dd70: 6f6c 6c65 6374 696f 6e73 2069 7320 5472  ollections is Tr
+0000dd80: 7565 206f 7220 696e 7075 745f 6765 6f6d  ue or input_geom
+0000dd90: 6574 7279 7479 7065 2069 6e20 5b0a 2020  etrytype in [.  
+0000dda0: 2020 2020 2020 4765 6f6d 6574 7279 5479        GeometryTy
+0000ddb0: 7065 2e50 4f4c 5947 4f4e 2c0a 2020 2020  pe.POLYGON,.    
+0000ddc0: 2020 2020 4765 6f6d 6574 7279 5479 7065      GeometryType
+0000ddd0: 2e4d 554c 5449 504f 4c59 474f 4e2c 0a20  .MULTIPOLYGON,. 
+0000dde0: 2020 205d 3a0a 2020 2020 2020 2020 2320     ]:.        # 
+0000ddf0: 6173 7365 7274 2074 6f20 6576 6164 6520  assert to evade 
+0000de00: 7079 4c61 6e63 6520 7761 726e 696e 670a  pyLance warning.
+0000de10: 2020 2020 2020 2020 6173 7365 7274 2069          assert i
+0000de20: 7369 6e73 7461 6e63 6528 6469 7373 5f67  sinstance(diss_g
+0000de30: 6466 2c20 6770 642e 4765 6f44 6174 6146  df, gpd.GeoDataF
+0000de40: 7261 6d65 290a 2020 2020 2020 2020 6469  rame).        di
+0000de50: 7373 5f67 6466 203d 2064 6973 735f 6764  ss_gdf = diss_gd
+0000de60: 662e 6578 706c 6f64 6528 6967 6e6f 7265  f.explode(ignore
+0000de70: 5f69 6e64 6578 3d54 7275 6529 0a0a 2020  _index=True)..  
+0000de80: 2020 2320 436c 6970 2074 6865 2072 6573    # Clip the res
+0000de90: 756c 7420 6f6e 2074 6865 2062 6f72 6465  ult on the borde
+0000dea0: 7273 206f 6620 7468 6520 6262 6f78 206e  rs of the bbox n
+0000deb0: 6f74 2074 6f20 6861 7665 206f 7665 726c  ot to have overl
+0000dec0: 6170 730a 2020 2020 2320 6265 7477 6565  aps.    # betwee
+0000ded0: 6e20 7468 6520 6469 6666 6572 656e 7420  n the different 
+0000dee0: 7469 6c65 732e 0a20 2020 2023 2049 6620  tiles..    # If 
+0000def0: 7468 6973 2069 7320 6e6f 7420 6170 706c  this is not appl
+0000df00: 6965 642c 2074 6869 7320 7265 7375 6c74  ied, this result
+0000df10: 7320 696e 2073 6f6d 6520 6765 6f6d 6574  s in some geomet
+0000df20: 7269 6573 206e 6f74 2062 6569 6e67 206d  ries not being m
+0000df30: 6572 6765 640a 2020 2020 2320 6f72 2069  erged.    # or i
+0000df40: 6e20 6475 706c 6963 6174 6573 2e0a 2020  n duplicates..  
+0000df50: 2020 2320 5245 4d41 524b 3a20 666f 7220    # REMARK: for 
+0000df60: 286d 756c 7469 296c 696e 6573 7472 696e  (multi)linestrin
+0000df70: 6773 2c20 7468 6520 656e 6470 6f69 6e74  gs, the endpoint
+0000df80: 7320 6372 6561 7465 6420 6279 2074 6865  s created by the
+0000df90: 2063 6c69 7020 6172 6520 6e6f 740a 2020   clip are not.  
+0000dfa0: 2020 2320 616c 7761 7973 2074 6865 2073    # always the s
+0000dfb0: 616d 6520 6475 6520 746f 2072 6f75 6e64  ame due to round
+0000dfc0: 696e 672c 2073 6f20 6469 7373 6f6c 7669  ing, so dissolvi
+0000dfd0: 6e67 2069 6e20 6120 6e65 7874 2070 6173  ng in a next pas
+0000dfe0: 7320 646f 6573 6e27 740a 2020 2020 2320  s doesn't.    # 
+0000dff0: 616c 7761 7973 2072 6573 756c 7420 696e  always result in
+0000e000: 206c 696e 6573 7472 696e 6773 2062 6569   linestrings bei
+0000e010: 6e67 2072 652d 636f 6e6e 6563 7465 642e  ng re-connected.
+0000e020: 2e2e 2042 6563 6175 7365 2064 6973 736f  .. Because disso
+0000e030: 6c76 696e 670a 2020 2020 2320 6c69 6e65  lving.    # line
+0000e040: 7320 6973 6e27 7420 736f 2063 6f6d 7075  s isn't so compu
+0000e050: 7461 7469 6f6e 616c 6c79 2068 6561 7679  tationally heavy
+0000e060: 2061 6e79 7761 792c 2064 726f 7020 7375   anyway, drop su
+0000e070: 7070 6f72 7420 6865 7265 2e0a 2020 2020  pport here..    
+0000e080: 6966 2062 626f 7820 6973 206e 6f74 204e  if bbox is not N
+0000e090: 6f6e 653a 0a20 2020 2020 2020 2073 7461  one:.        sta
+0000e0a0: 7274 5f63 6c69 7020 3d20 6461 7465 7469  rt_clip = dateti
+0000e0b0: 6d65 2e6e 6f77 2829 0a20 2020 2020 2020  me.now().       
+0000e0c0: 2062 626f 785f 706f 6c79 676f 6e20 3d20   bbox_polygon = 
+0000e0d0: 7368 5f67 656f 6d2e 506f 6c79 676f 6e28  sh_geom.Polygon(
+0000e0e0: 0a20 2020 2020 2020 2020 2020 205b 0a20  .            [. 
+0000e0f0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+0000e100: 6262 6f78 5b30 5d2c 2062 626f 785b 315d  bbox[0], bbox[1]
+0000e110: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+0000e120: 2020 2028 6262 6f78 5b30 5d2c 2062 626f     (bbox[0], bbo
+0000e130: 785b 335d 292c 0a20 2020 2020 2020 2020  x[3]),.         
+0000e140: 2020 2020 2020 2028 6262 6f78 5b32 5d2c         (bbox[2],
+0000e150: 2062 626f 785b 335d 292c 0a20 2020 2020   bbox[3]),.     
+0000e160: 2020 2020 2020 2020 2020 2028 6262 6f78             (bbox
+0000e170: 5b32 5d2c 2062 626f 785b 315d 292c 0a20  [2], bbox[1]),. 
+0000e180: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+0000e190: 6262 6f78 5b30 5d2c 2062 626f 785b 315d  bbox[0], bbox[1]
+0000e1a0: 292c 0a20 2020 2020 2020 2020 2020 205d  ),.            ]
+0000e1b0: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
+0000e1c0: 2020 2062 626f 785f 6764 6620 3d20 6770     bbox_gdf = gp
+0000e1d0: 642e 4765 6f44 6174 6146 7261 6d65 280a  d.GeoDataFrame(.
+0000e1e0: 2020 2020 2020 2020 2020 2020 6461 7461              data
+0000e1f0: 3d5b 315d 2c20 6765 6f6d 6574 7279 3d5b  =[1], geometry=[
+0000e200: 6262 6f78 5f70 6f6c 7967 6f6e 5d2c 2063  bbox_polygon], c
+0000e210: 7273 3d69 6e70 7574 5f67 6466 2e63 7273  rs=input_gdf.crs
+0000e220: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
+0000e230: 0a20 2020 2020 2020 2029 0a0a 2020 2020  .        )..    
+0000e240: 2020 2020 2320 4361 7463 6820 6972 7265      # Catch irre
+0000e250: 6c65 7661 6e74 2070 616e 6461 7320 6675  levant pandas fu
+0000e260: 7475 7265 2077 6172 6e69 6e67 0a20 2020  ture warning.   
+0000e270: 2020 2020 2023 2054 4f44 4f3a 2077 6865       # TODO: whe
+0000e280: 6e20 7265 6d6f 7665 6420 696e 206c 6174  n removed in lat
+0000e290: 6572 2076 6572 7369 6f6e 206f 6620 7061  er version of pa
+0000e2a0: 6e64 6173 2c20 6361 6e20 6265 2072 656d  ndas, can be rem
+0000e2b0: 6f76 6564 2068 6572 650a 2020 2020 2020  oved here.      
+0000e2c0: 2020 7769 7468 2077 6172 6e69 6e67 732e    with warnings.
+0000e2d0: 6361 7463 685f 7761 726e 696e 6773 2829  catch_warnings()
+0000e2e0: 3a0a 2020 2020 2020 2020 2020 2020 6d65  :.            me
+0000e2f0: 7373 6167 6520 3d20 280a 2020 2020 2020  ssage = (.      
+0000e300: 2020 2020 2020 2020 2020 2249 6e20 6120            "In a 
+0000e310: 6675 7475 7265 2076 6572 7369 6f6e 2c20  future version, 
+0000e320: 6064 662e 696c 6f63 5b3a 2c20 695d 203d  `df.iloc[:, i] =
+0000e330: 206e 6577 7661 6c73 6020 7769 6c6c 2061   newvals` will a
+0000e340: 7474 656d 7074 2074 6f20 220a 2020 2020  ttempt to ".    
+0000e350: 2020 2020 2020 2020 2020 2020 2273 6574              "set
+0000e360: 2074 6865 2076 616c 7565 7320 696e 706c   the values inpl
+0000e370: 6163 6520 696e 7374 6561 6420 6f66 2061  ace instead of a
+0000e380: 6c77 6179 7320 7365 7474 696e 6720 6120  lways setting a 
+0000e390: 6e65 7720 6172 7261 792e 220a 2020 2020  new array.".    
+0000e3a0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0000e3b0: 2020 2020 2020 7761 726e 696e 6773 2e66        warnings.f
+0000e3c0: 696c 7465 7277 6172 6e69 6e67 7328 0a20  ilterwarnings(. 
+0000e3d0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+0000e3e0: 6374 696f 6e3d 2269 676e 6f72 6522 2c20  ction="ignore", 
+0000e3f0: 6361 7465 676f 7279 3d46 7574 7572 6557  category=FutureW
+0000e400: 6172 6e69 6e67 2c20 6d65 7373 6167 653d  arning, message=
+0000e410: 7265 2e65 7363 6170 6528 6d65 7373 6167  re.escape(messag
+0000e420: 6529 0a20 2020 2020 2020 2020 2020 2029  e).            )
+0000e430: 0a20 2020 2020 2020 2020 2020 2023 206b  .            # k
+0000e440: 6565 705f 6765 6f6d 5f74 7970 653d 5472  eep_geom_type=Tr
+0000e450: 7565 2067 6176 6520 736f 6d65 7469 6d65  ue gave sometime
+0000e460: 7320 6572 726f 722c 2061 6e64 2073 7469  s error, and sti
+0000e470: 6c6c 2064 6f65 7320 696e 2030 2e39 2e30  ll does in 0.9.0
+0000e480: 0a20 2020 2020 2020 2020 2020 2023 2073  .            # s
+0000e490: 6f20 7573 6520 6f77 6e20 696d 706c 656d  o use own implem
+0000e4a0: 656e 7461 7469 6f6e 206f 6620 6b65 6570  entation of keep
+0000e4b0: 5f67 656f 6d5f 7479 7065 0a20 2020 2020  _geom_type.     
+0000e4c0: 2020 2020 2020 2064 6973 735f 6764 6620         diss_gdf 
+0000e4d0: 3d20 6770 642e 636c 6970 2864 6973 735f  = gpd.clip(diss_
+0000e4e0: 6764 662c 2062 626f 785f 6764 6629 2020  gdf, bbox_gdf)  
+0000e4f0: 2320 2c20 6b65 6570 5f67 656f 6d5f 7479  # , keep_geom_ty
+0000e500: 7065 3d54 7275 6529 0a20 2020 2020 2020  pe=True).       
+0000e510: 2020 2020 2061 7373 6572 7420 6973 696e       assert isin
+0000e520: 7374 616e 6365 2864 6973 735f 6764 662c  stance(diss_gdf,
+0000e530: 2067 7064 2e47 656f 4461 7461 4672 616d   gpd.GeoDataFram
+0000e540: 6529 0a0a 2020 2020 2020 2020 2320 4f6e  e)..        # On
+0000e550: 6c79 206b 6565 7020 6765 6f6d 6574 7269  ly keep geometri
+0000e560: 6573 206f 6620 7468 6520 7072 696d 6974  es of the primit
+0000e570: 6976 6520 7479 7065 2073 7065 6369 6669  ive type specifi
+0000e580: 6564 2061 6674 6572 2063 6c69 702e 2e2e  ed after clip...
+0000e590: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+0000e5a0: 6973 696e 7374 616e 6365 2864 6973 735f  isinstance(diss_
+0000e5b0: 6764 662c 2067 7064 2e47 656f 4461 7461  gdf, gpd.GeoData
+0000e5c0: 4672 616d 6529 0a20 2020 2020 2020 2064  Frame).        d
+0000e5d0: 6973 735f 6764 662e 6765 6f6d 6574 7279  iss_gdf.geometry
+0000e5e0: 203d 2067 656f 7365 7269 6573 5f75 7469   = geoseries_uti
+0000e5f0: 6c2e 6765 6f6d 6574 7279 5f63 6f6c 6c65  l.geometry_colle
+0000e600: 6374 696f 6e5f 6578 7472 6163 7428 0a20  ction_extract(. 
+0000e610: 2020 2020 2020 2020 2020 2064 6973 735f             diss_
+0000e620: 6764 662e 6765 6f6d 6574 7279 2c20 696e  gdf.geometry, in
+0000e630: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
+0000e640: 2e74 6f5f 7072 696d 6974 6976 6574 7970  .to_primitivetyp
+0000e650: 650a 2020 2020 2020 2020 290a 0a20 2020  e.        )..   
+0000e660: 2020 2020 2070 6572 6669 6e66 6f5b 2274       perfinfo["t
+0000e670: 696d 655f 636c 6970 225d 203d 2028 6461  ime_clip"] = (da
+0000e680: 7465 7469 6d65 2e6e 6f77 2829 202d 2073  tetime.now() - s
+0000e690: 7461 7274 5f63 6c69 7029 2e74 6f74 616c  tart_clip).total
+0000e6a0: 5f73 6563 6f6e 6473 2829 0a0a 2020 2020  _seconds()..    
+0000e6b0: 2320 4472 6f70 2072 6f77 7320 7769 7468  # Drop rows with
+0000e6c0: 204e 6f6e 652f 656d 7074 7920 6765 6f6d   None/empty geom
+0000e6d0: 6574 7269 6573 0a20 2020 2064 6973 735f  etries.    diss_
+0000e6e0: 6764 6620 3d20 6469 7373 5f67 6466 5b7e  gdf = diss_gdf[~
+0000e6f0: 6469 7373 5f67 6466 2e67 656f 6d65 7472  diss_gdf.geometr
+0000e700: 792e 6973 6e61 2829 5d0a 2020 2020 6469  y.isna()].    di
+0000e710: 7373 5f67 6466 203d 2064 6973 735f 6764  ss_gdf = diss_gd
+0000e720: 665b 7e64 6973 735f 6764 662e 6765 6f6d  f[~diss_gdf.geom
+0000e730: 6574 7279 2e69 735f 656d 7074 795d 0a0a  etry.is_empty]..
+0000e740: 2020 2020 2320 4966 2074 6865 7265 2069      # If there i
+0000e750: 7320 6e6f 2072 6573 756c 742c 2072 6574  s no result, ret
+0000e760: 7572 6e0a 2020 2020 6966 206c 656e 2864  urn.    if len(d
+0000e770: 6973 735f 6764 6629 203d 3d20 303a 0a20  iss_gdf) == 0:. 
+0000e780: 2020 2020 2020 206d 6573 7361 6765 203d         message =
+0000e790: 2066 2252 6573 756c 7420 6973 2065 6d70   f"Result is emp
+0000e7a0: 7479 2066 6f72 207b 696e 7075 745f 7061  ty for {input_pa
+0000e7b0: 7468 7d22 0a20 2020 2020 2020 2072 6574  th}".        ret
+0000e7c0: 7572 6e5f 696e 666f 5b22 6d65 7373 6167  urn_info["messag
+0000e7d0: 6522 5d20 3d20 6d65 7373 6167 650a 2020  e"] = message.  
+0000e7e0: 2020 2020 2020 7265 7475 726e 5f69 6e66        return_inf
+0000e7f0: 6f5b 2270 6572 6669 6e66 6f22 5d20 3d20  o["perfinfo"] = 
+0000e800: 7065 7266 696e 666f 0a20 2020 2020 2020  perfinfo.       
+0000e810: 2072 6574 7572 6e5f 696e 666f 5b22 746f   return_info["to
+0000e820: 7461 6c5f 7469 6d65 225d 203d 2028 6461  tal_time"] = (da
+0000e830: 7465 7469 6d65 2e6e 6f77 2829 202d 2073  tetime.now() - s
+0000e840: 7461 7274 5f74 696d 6529 2e74 6f74 616c  tart_time).total
+0000e850: 5f73 6563 6f6e 6473 2829 0a20 2020 2020  _seconds().     
+0000e860: 2020 2072 6574 7572 6e20 7265 7475 726e     return return
+0000e870: 5f69 6e66 6f0a 0a20 2020 2023 2041 6464  _info..    # Add
+0000e880: 2063 6f6c 756d 6e20 7769 7468 2074 696c   column with til
+0000e890: 655f 6964 0a20 2020 2069 6620 7469 6c65  e_id.    if tile
+0000e8a0: 5f69 6420 6973 206e 6f74 204e 6f6e 653a  _id is not None:
+0000e8b0: 0a20 2020 2020 2020 2064 6973 735f 6764  .        diss_gd
+0000e8c0: 665b 2274 696c 655f 6964 225d 203d 2074  f["tile_id"] = t
+0000e8d0: 696c 655f 6964 0a0a 2020 2020 2320 5361  ile_id..    # Sa
+0000e8e0: 7665 2074 6865 2072 6573 756c 7420 746f  ve the result to
+0000e8f0: 2064 6573 7469 6e61 7469 6f6e 2066 696c   destination fil
+0000e900: 6528 7329 0a20 2020 2073 7461 7274 5f74  e(s).    start_t
+0000e910: 6f5f 6669 6c65 203d 2064 6174 6574 696d  o_file = datetim
+0000e920: 652e 6e6f 7728 290a 0a20 2020 2023 2049  e.now()..    # I
+0000e930: 6620 7468 6520 7469 6c65 7320 646f 6e27  f the tiles don'
+0000e940: 7420 6e65 6564 2074 6f20 6265 206d 6572  t need to be mer
+0000e950: 6765 6420 6166 7465 7277 6172 6473 2c20  ged afterwards, 
+0000e960: 7765 2063 616e 206a 7573 7420 7361 7665  we can just save
+0000e970: 2074 6865 2072 6573 756c 7420 6173 0a20   the result as. 
+0000e980: 2020 2023 2069 7420 6973 2e0a 2020 2020     # it is..    
+0000e990: 6966 2073 7472 286f 7574 7075 745f 6e6f  if str(output_no
+0000e9a0: 746f 6e62 6f72 6465 725f 7061 7468 2920  tonborder_path) 
+0000e9b0: 3d3d 2073 7472 286f 7574 7075 745f 6f6e  == str(output_on
+0000e9c0: 626f 7264 6572 5f70 6174 6829 3a0a 2020  border_path):.  
+0000e9d0: 2020 2020 2020 2320 6173 7365 7274 2074        # assert t
+0000e9e0: 6f20 6576 6164 6520 7079 4c61 6e63 6520  o evade pyLance 
+0000e9f0: 7761 726e 696e 670a 2020 2020 2020 2020  warning.        
+0000ea00: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
+0000ea10: 6528 6469 7373 5f67 6466 2c20 6770 642e  e(diss_gdf, gpd.
+0000ea20: 4765 6f44 6174 6146 7261 6d65 290a 2020  GeoDataFrame).  
+0000ea30: 2020 2020 2020 2320 5573 6520 666f 7263        # Use forc
+0000ea40: 655f 6d75 6c74 6974 7970 652c 2074 6f20  e_multitype, to 
+0000ea50: 6576 6164 6520 7761 726e 696e 6773 2077  evade warnings w
+0000ea60: 6865 6e20 736f 6d65 2062 6174 6368 6573  hen some batches
+0000ea70: 2063 6f6e 7461 696e 0a20 2020 2020 2020   contain.       
+0000ea80: 2023 2073 696e 676c 6574 7970 6520 616e   # singletype an
+0000ea90: 6420 736f 6d65 2063 6f6e 7461 696e 206d  d some contain m
+0000eaa0: 756c 7469 7479 7065 2067 656f 6d65 7472  ultitype geometr
+0000eab0: 6965 730a 2020 2020 2020 2020 6766 6f2e  ies.        gfo.
+0000eac0: 746f 5f66 696c 6528 0a20 2020 2020 2020  to_file(.       
+0000ead0: 2020 2020 2064 6973 735f 6764 662c 0a20       diss_gdf,. 
+0000eae0: 2020 2020 2020 2020 2020 206f 7574 7075             outpu
+0000eaf0: 745f 6e6f 746f 6e62 6f72 6465 725f 7061  t_notonborder_pa
+0000eb00: 7468 2c0a 2020 2020 2020 2020 2020 2020  th,.            
+0000eb10: 6c61 7965 723d 6f75 7470 7574 5f6c 6179  layer=output_lay
+0000eb20: 6572 2c0a 2020 2020 2020 2020 2020 2020  er,.            
+0000eb30: 666f 7263 655f 6d75 6c74 6974 7970 653d  force_multitype=
+0000eb40: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
+0000eb50: 2020 696e 6465 783d 4661 6c73 652c 0a20    index=False,. 
+0000eb60: 2020 2020 2020 2020 2020 2063 7265 6174             creat
+0000eb70: 655f 7370 6174 6961 6c5f 696e 6465 783d  e_spatial_index=
+0000eb80: 4661 6c73 652c 0a20 2020 2020 2020 2029  False,.        )
+0000eb90: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+0000eba0: 2020 2023 2049 6620 6e6f 742c 2073 6176     # If not, sav
+0000ebb0: 6520 7468 6520 706f 6c79 676f 6e73 206f  e the polygons o
+0000ebc0: 6e20 7468 6520 626f 7264 6572 2073 6570  n the border sep
+0000ebd0: 6572 6174 656c 790a 2020 2020 2020 2020  erately.        
+0000ebe0: 6262 6f78 5f6c 696e 6573 5f67 6466 203d  bbox_lines_gdf =
+0000ebf0: 2067 7064 2e47 656f 4461 7461 4672 616d   gpd.GeoDataFram
+0000ec00: 6528 0a20 2020 2020 2020 2020 2020 2067  e(.            g
+0000ec10: 656f 6d65 7472 793d 6765 6f73 6572 6965  eometry=geoserie
+0000ec20: 735f 7574 696c 2e70 6f6c 7967 6f6e 735f  s_util.polygons_
+0000ec30: 746f 5f6c 696e 6573 2820 2023 2074 7970  to_lines(  # typ
+0000ec40: 653a 2069 676e 6f72 650a 2020 2020 2020  e: ignore.      
+0000ec50: 2020 2020 2020 2020 2020 6770 642e 4765            gpd.Ge
+0000ec60: 6f53 6572 6965 7328 5b73 685f 6765 6f6d  oSeries([sh_geom
+0000ec70: 2e62 6f78 2862 626f 785b 305d 2c20 6262  .box(bbox[0], bb
+0000ec80: 6f78 5b31 5d2c 2062 626f 785b 325d 2c20  ox[1], bbox[2], 
+0000ec90: 6262 6f78 5b33 5d29 5d29 0a20 2020 2020  bbox[3])]).     
+0000eca0: 2020 2020 2020 2029 2c0a 2020 2020 2020         ),.      
+0000ecb0: 2020 2020 2020 6372 733d 696e 7075 745f        crs=input_
+0000ecc0: 6764 662e 6372 732c 2020 2320 7479 7065  gdf.crs,  # type
+0000ecd0: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
+0000ece0: 2029 0a20 2020 2020 2020 206f 6e62 6f72   ).        onbor
+0000ecf0: 6465 725f 6764 6620 3d20 6770 642e 736a  der_gdf = gpd.sj
+0000ed00: 6f69 6e28 6469 7373 5f67 6466 2c20 6262  oin(diss_gdf, bb
+0000ed10: 6f78 5f6c 696e 6573 5f67 6466 2c20 7072  ox_lines_gdf, pr
+0000ed20: 6564 6963 6174 653d 2269 6e74 6572 7365  edicate="interse
+0000ed30: 6374 7322 290a 2020 2020 2020 2020 6f6e  cts").        on
+0000ed40: 626f 7264 6572 5f67 6466 2e64 726f 7028  border_gdf.drop(
+0000ed50: 2269 6e64 6578 5f72 6967 6874 222c 2061  "index_right", a
+0000ed60: 7869 733d 312c 2069 6e70 6c61 6365 3d54  xis=1, inplace=T
+0000ed70: 7275 6529 0a20 2020 2020 2020 2069 6620  rue).        if 
+0000ed80: 6c65 6e28 6f6e 626f 7264 6572 5f67 6466  len(onborder_gdf
+0000ed90: 2920 3e20 303a 0a20 2020 2020 2020 2020  ) > 0:.         
+0000eda0: 2020 2023 2061 7373 6572 7420 746f 2065     # assert to e
+0000edb0: 7661 6465 2070 794c 616e 6365 2077 6172  vade pyLance war
+0000edc0: 6e69 6e67 0a20 2020 2020 2020 2020 2020  ning.           
+0000edd0: 2061 7373 6572 7420 6973 696e 7374 616e   assert isinstan
+0000ede0: 6365 286f 6e62 6f72 6465 725f 6764 662c  ce(onborder_gdf,
+0000edf0: 2067 7064 2e47 656f 4461 7461 4672 616d   gpd.GeoDataFram
+0000ee00: 6529 0a20 2020 2020 2020 2020 2020 2023  e).            #
+0000ee10: 2055 7365 2066 6f72 6365 5f6d 756c 7469   Use force_multi
+0000ee20: 7479 7065 2c20 746f 2065 7661 6465 2077  type, to evade w
+0000ee30: 6172 6e69 6e67 7320 7768 656e 2073 6f6d  arnings when som
+0000ee40: 6520 6261 7463 6865 7320 636f 6e74 6169  e batches contai
+0000ee50: 6e0a 2020 2020 2020 2020 2020 2020 2320  n.            # 
+0000ee60: 7369 6e67 6c65 7479 7065 2061 6e64 2073  singletype and s
+0000ee70: 6f6d 6520 636f 6e74 6169 6e20 6d75 6c74  ome contain mult
+0000ee80: 6974 7970 6520 6765 6f6d 6574 7269 6573  itype geometries
+0000ee90: 0a20 2020 2020 2020 2020 2020 2067 666f  .            gfo
+0000eea0: 2e74 6f5f 6669 6c65 280a 2020 2020 2020  .to_file(.      
+0000eeb0: 2020 2020 2020 2020 2020 6f6e 626f 7264            onbord
+0000eec0: 6572 5f67 6466 2c0a 2020 2020 2020 2020  er_gdf,.        
+0000eed0: 2020 2020 2020 2020 6f75 7470 7574 5f6f          output_o
+0000eee0: 6e62 6f72 6465 725f 7061 7468 2c0a 2020  nborder_path,.  
+0000eef0: 2020 2020 2020 2020 2020 2020 2020 6c61                la
+0000ef00: 7965 723d 6f75 7470 7574 5f6c 6179 6572  yer=output_layer
+0000ef10: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000ef20: 2020 666f 7263 655f 6d75 6c74 6974 7970    force_multityp
+0000ef30: 653d 5472 7565 2c0a 2020 2020 2020 2020  e=True,.        
+0000ef40: 2020 2020 2020 2020 6372 6561 7465 5f73          create_s
+0000ef50: 7061 7469 616c 5f69 6e64 6578 3d46 616c  patial_index=Fal
+0000ef60: 7365 2c0a 2020 2020 2020 2020 2020 2020  se,.            
+0000ef70: 290a 0a20 2020 2020 2020 206e 6f74 6f6e  )..        noton
+0000ef80: 626f 7264 6572 5f67 6466 203d 2064 6973  border_gdf = dis
+0000ef90: 735f 6764 665b 7e64 6973 735f 6764 662e  s_gdf[~diss_gdf.
+0000efa0: 696e 6465 782e 6973 696e 286f 6e62 6f72  index.isin(onbor
+0000efb0: 6465 725f 6764 662e 696e 6465 7829 5d0a  der_gdf.index)].
+0000efc0: 2020 2020 2020 2020 6966 206c 656e 286e          if len(n
+0000efd0: 6f74 6f6e 626f 7264 6572 5f67 6466 2920  otonborder_gdf) 
+0000efe0: 3e20 303a 0a20 2020 2020 2020 2020 2020  > 0:.           
+0000eff0: 2023 2061 7373 6572 7420 746f 2065 7661   # assert to eva
+0000f000: 6465 2070 794c 616e 6365 2077 6172 6e69  de pyLance warni
+0000f010: 6e67 0a20 2020 2020 2020 2020 2020 2061  ng.            a
+0000f020: 7373 6572 7420 6973 696e 7374 616e 6365  ssert isinstance
+0000f030: 286e 6f74 6f6e 626f 7264 6572 5f67 6466  (notonborder_gdf
+0000f040: 2c20 6770 642e 4765 6f44 6174 6146 7261  , gpd.GeoDataFra
+0000f050: 6d65 290a 2020 2020 2020 2020 2020 2020  me).            
+0000f060: 2320 5573 6520 666f 7263 655f 6d75 6c74  # Use force_mult
+0000f070: 6974 7970 652c 2074 6f20 6576 6164 6520  itype, to evade 
+0000f080: 7761 726e 696e 6773 2077 6865 6e20 736f  warnings when so
+0000f090: 6d65 2062 6174 6368 6573 2063 6f6e 7461  me batches conta
+0000f0a0: 696e 0a20 2020 2020 2020 2020 2020 2023  in.            #
+0000f0b0: 2073 696e 676c 6574 7970 6520 616e 6420   singletype and 
+0000f0c0: 736f 6d65 2063 6f6e 7461 696e 206d 756c  some contain mul
+0000f0d0: 7469 7479 7065 2067 656f 6d65 7472 6965  titype geometrie
+0000f0e0: 730a 2020 2020 2020 2020 2020 2020 6766  s.            gf
+0000f0f0: 6f2e 746f 5f66 696c 6528 0a20 2020 2020  o.to_file(.     
+0000f100: 2020 2020 2020 2020 2020 206e 6f74 6f6e             noton
+0000f110: 626f 7264 6572 5f67 6466 2c0a 2020 2020  border_gdf,.    
+0000f120: 2020 2020 2020 2020 2020 2020 6f75 7470              outp
+0000f130: 7574 5f6e 6f74 6f6e 626f 7264 6572 5f70  ut_notonborder_p
+0000f140: 6174 682c 0a20 2020 2020 2020 2020 2020  ath,.           
+0000f150: 2020 2020 206c 6179 6572 3d6f 7574 7075       layer=outpu
+0000f160: 745f 6c61 7965 722c 0a20 2020 2020 2020  t_layer,.       
+0000f170: 2020 2020 2020 2020 2066 6f72 6365 5f6d           force_m
+0000f180: 756c 7469 7479 7065 3d54 7275 652c 0a20  ultitype=True,. 
+0000f190: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000f1a0: 6e64 6578 3d46 616c 7365 2c0a 2020 2020  ndex=False,.    
+0000f1b0: 2020 2020 2020 2020 2020 2020 6372 6561              crea
+0000f1c0: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
+0000f1d0: 3d46 616c 7365 2c0a 2020 2020 2020 2020  =False,.        
+0000f1e0: 2020 2020 290a 2020 2020 7065 7266 696e      ).    perfin
+0000f1f0: 666f 5b22 7469 6d65 5f74 6f5f 6669 6c65  fo["time_to_file
+0000f200: 225d 203d 2028 6461 7465 7469 6d65 2e6e  "] = (datetime.n
+0000f210: 6f77 2829 202d 2073 7461 7274 5f74 6f5f  ow() - start_to_
+0000f220: 6669 6c65 292e 746f 7461 6c5f 7365 636f  file).total_seco
+0000f230: 6e64 7328 290a 0a20 2020 2023 2046 696e  nds()..    # Fin
+0000f240: 616c 6973 652e 2e2e 0a20 2020 206d 6573  alise....    mes
+0000f250: 7361 6765 203d 2066 2264 6973 736f 6c76  sage = f"dissolv
+0000f260: 6520 7265 6164 7920 696e 207b 6461 7465  e ready in {date
+0000f270: 7469 6d65 2e6e 6f77 2829 2d73 7461 7274  time.now()-start
+0000f280: 5f74 696d 657d 206f 6e20 7b69 6e70 7574  _time} on {input
+0000f290: 5f70 6174 687d 2122 0a20 2020 206c 6f67  _path}!".    log
+0000f2a0: 6765 722e 6465 6275 6728 6d65 7373 6167  ger.debug(messag
+0000f2b0: 6529 0a0a 2020 2020 2320 436f 6c6c 6563  e)..    # Collec
+0000f2c0: 7420 7065 7266 696e 666f 0a20 2020 2074  t perfinfo.    t
+0000f2d0: 6f74 616c 5f70 6572 665f 7469 6d65 203d  otal_perf_time =
+0000f2e0: 2030 0a20 2020 2070 6572 6673 7472 696e   0.    perfstrin
+0000f2f0: 6720 3d20 2222 0a20 2020 2066 6f72 2070  g = "".    for p
+0000f300: 6572 6663 6f64 6520 696e 2070 6572 6669  erfcode in perfi
+0000f310: 6e66 6f3a 0a20 2020 2020 2020 2074 6f74  nfo:.        tot
+0000f320: 616c 5f70 6572 665f 7469 6d65 202b 3d20  al_perf_time += 
+0000f330: 7065 7266 696e 666f 5b70 6572 6663 6f64  perfinfo[perfcod
+0000f340: 655d 0a20 2020 2020 2020 2070 6572 6673  e].        perfs
+0000f350: 7472 696e 6720 2b3d 2066 227b 7065 7266  tring += f"{perf
+0000f360: 636f 6465 7d3a 207b 7065 7266 696e 666f  code}: {perfinfo
+0000f370: 5b70 6572 6663 6f64 655d 3a2e 3266 7d2c  [perfcode]:.2f},
+0000f380: 2022 0a20 2020 2072 6574 7572 6e5f 696e   ".    return_in
+0000f390: 666f 5b22 746f 7461 6c5f 7469 6d65 225d  fo["total_time"]
+0000f3a0: 203d 2028 6461 7465 7469 6d65 2e6e 6f77   = (datetime.now
+0000f3b0: 2829 202d 2073 7461 7274 5f74 696d 6529  () - start_time)
+0000f3c0: 2e74 6f74 616c 5f73 6563 6f6e 6473 2829  .total_seconds()
+0000f3d0: 0a20 2020 2070 6572 6669 6e66 6f5b 2275  .    perfinfo["u
+0000f3e0: 6e61 6363 6f75 6e74 6564 225d 203d 2072  naccounted"] = r
+0000f3f0: 6574 7572 6e5f 696e 666f 5b22 746f 7461  eturn_info["tota
+0000f400: 6c5f 7469 6d65 225d 202d 2074 6f74 616c  l_time"] - total
+0000f410: 5f70 6572 665f 7469 6d65 0a20 2020 2070  _perf_time.    p
+0000f420: 6572 6673 7472 696e 6720 2b3d 2066 2275  erfstring += f"u
+0000f430: 6e61 6363 6f75 6e74 6564 3a20 7b70 6572  naccounted: {per
+0000f440: 6669 6e66 6f5b 2775 6e61 6363 6f75 6e74  finfo['unaccount
+0000f450: 6564 275d 3a2e 3266 7d22 0a0a 2020 2020  ed']:.2f}"..    
+0000f460: 2320 5265 7475 726e 0a20 2020 2072 6574  # Return.    ret
+0000f470: 7572 6e5f 696e 666f 5b22 7065 7266 696e  urn_info["perfin
+0000f480: 666f 225d 203d 2070 6572 6669 6e66 6f0a  fo"] = perfinfo.
+0000f490: 2020 2020 7265 7475 726e 5f69 6e66 6f5b      return_info[
+0000f4a0: 2270 6572 6673 7472 696e 6722 5d20 3d20  "perfstring"] = 
+0000f4b0: 7065 7266 7374 7269 6e67 0a20 2020 2072  perfstring.    r
+0000f4c0: 6574 7572 6e5f 696e 666f 5b22 6d65 7373  eturn_info["mess
+0000f4d0: 6167 6522 5d20 3d20 6d65 7373 6167 650a  age"] = message.
+0000f4e0: 2020 2020 7265 7475 726e 2072 6574 7572      return retur
+0000f4f0: 6e5f 696e 666f 0a0a 0a64 6566 205f 6469  n_info...def _di
+0000f500: 7373 6f6c 7665 280a 2020 2020 6466 3a20  ssolve(.    df: 
+0000f510: 6770 642e 4765 6f44 6174 6146 7261 6d65  gpd.GeoDataFrame
+0000f520: 2c0a 2020 2020 6279 3d4e 6f6e 652c 0a20  ,.    by=None,. 
+0000f530: 2020 2061 6767 6675 6e63 3a20 4f70 7469     aggfunc: Opti
+0000f540: 6f6e 616c 5b55 6e69 6f6e 5b73 7472 2c20  onal[Union[str, 
+0000f550: 6469 6374 5d5d 203d 2022 6669 7273 7422  dict]] = "first"
+0000f560: 2c0a 2020 2020 6173 5f69 6e64 6578 3d54  ,.    as_index=T
+0000f570: 7275 652c 0a20 2020 206c 6576 656c 3d4e  rue,.    level=N
+0000f580: 6f6e 652c 0a20 2020 2073 6f72 743d 5472  one,.    sort=Tr
+0000f590: 7565 2c0a 2020 2020 6f62 7365 7276 6564  ue,.    observed
+0000f5a0: 3d46 616c 7365 2c0a 2020 2020 6472 6f70  =False,.    drop
+0000f5b0: 6e61 3d54 7275 652c 0a29 202d 3e20 6770  na=True,.) -> gp
+0000f5c0: 642e 4765 6f44 6174 6146 7261 6d65 3a0a  d.GeoDataFrame:.
+0000f5d0: 2020 2020 2222 220a 2020 2020 4469 7373      """.    Diss
+0000f5e0: 6f6c 7665 2067 656f 6d65 7472 6965 7320  olve geometries 
+0000f5f0: 7769 7468 696e 2060 6772 6f75 7062 7960  within `groupby`
+0000f600: 2069 6e74 6f20 7369 6e67 6c65 206f 6273   into single obs
+0000f610: 6572 7661 7469 6f6e 2e0a 2020 2020 5468  ervation..    Th
+0000f620: 6973 2069 7320 6163 636f 6d70 6c69 7368  is is accomplish
+0000f630: 6564 2062 7920 6170 706c 7969 6e67 2074  ed by applying t
+0000f640: 6865 2060 756e 6172 795f 756e 696f 6e60  he `unary_union`
+0000f650: 206d 6574 686f 640a 2020 2020 746f 2061   method.    to a
+0000f660: 6c6c 2067 656f 6d65 7472 6965 7320 7769  ll geometries wi
+0000f670: 7468 696e 2061 2067 726f 7570 7365 6c66  thin a groupself
+0000f680: 2e0a 2020 2020 4f62 7365 7276 6174 696f  ..    Observatio
+0000f690: 6e73 2061 7373 6f63 6961 7465 6420 7769  ns associated wi
+0000f6a0: 7468 2065 6163 6820 6067 726f 7570 6279  th each `groupby
+0000f6b0: 6020 6772 6f75 7020 7769 6c6c 2062 6520  ` group will be 
+0000f6c0: 6167 6772 6567 6174 6564 0a20 2020 2075  aggregated.    u
+0000f6d0: 7369 6e67 2074 6865 2060 6167 6766 756e  sing the `aggfun
+0000f6e0: 6360 2e0a 2020 2020 5061 7261 6d65 7465  c`..    Paramete
+0000f6f0: 7273 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d  rs.    ---------
+0000f700: 2d0a 2020 2020 6279 203a 2073 7472 696e  -.    by : strin
+0000f710: 672c 2064 6566 6175 6c74 204e 6f6e 650a  g, default None.
+0000f720: 2020 2020 2020 2020 436f 6c75 6d6e 2077          Column w
+0000f730: 686f 7365 2076 616c 7565 7320 6465 6669  hose values defi
+0000f740: 6e65 2067 726f 7570 7320 746f 2062 6520  ne groups to be 
+0000f750: 6469 7373 6f6c 7665 642e 2049 6620 4e6f  dissolved. If No
+0000f760: 6e65 2c0a 2020 2020 2020 2020 7768 6f6c  ne,.        whol
+0000f770: 6520 4765 6f44 6174 6146 7261 6d65 2069  e GeoDataFrame i
+0000f780: 7320 636f 6e73 6964 6572 6564 2061 2073  s considered a s
+0000f790: 696e 676c 6520 6772 6f75 702e 0a20 2020  ingle group..   
+0000f7a0: 2061 6767 6675 6e63 203a 2066 756e 6374   aggfunc : funct
+0000f7b0: 696f 6e2c 2073 7472 696e 6720 6f72 2064  ion, string or d
+0000f7c0: 6963 742c 2064 6566 6175 6c74 2022 6669  ict, default "fi
+0000f7d0: 7273 7422 0a20 2020 2020 2020 2041 6767  rst".        Agg
+0000f7e0: 7265 6761 7469 6f6e 2066 756e 6374 696f  regation functio
+0000f7f0: 6e20 666f 7220 6d61 6e69 7075 6c61 7469  n for manipulati
+0000f800: 6f6e 206f 6620 6461 7461 2061 7373 6f63  on of data assoc
+0000f810: 6961 7465 640a 2020 2020 2020 2020 7769  iated.        wi
+0000f820: 7468 2065 6163 6820 6772 6f75 702e 2050  th each group. P
+0000f830: 6173 7365 6420 746f 2070 616e 6461 7320  assed to pandas 
+0000f840: 6067 726f 7570 6279 2e61 6767 6020 6d65  `groupby.agg` me
+0000f850: 7468 6f64 2e0a 2020 2020 6173 5f69 6e64  thod..    as_ind
+0000f860: 6578 203a 2062 6f6f 6c65 616e 2c20 6465  ex : boolean, de
+0000f870: 6661 756c 7420 5472 7565 0a20 2020 2020  fault True.     
+0000f880: 2020 2049 6620 7472 7565 2c20 6772 6f75     If true, grou
+0000f890: 7062 7920 636f 6c75 6d6e 7320 6265 636f  pby columns beco
+0000f8a0: 6d65 2069 6e64 6578 206f 6620 7265 7375  me index of resu
+0000f8b0: 6c74 2e0a 2020 2020 6c65 7665 6c20 3a20  lt..    level : 
+0000f8c0: 696e 7420 6f72 2073 7472 206f 7220 7365  int or str or se
+0000f8d0: 7175 656e 6365 206f 6620 696e 7420 6f72  quence of int or
+0000f8e0: 2073 6571 7565 6e63 6520 6f66 2073 7472   sequence of str
+0000f8f0: 2c20 6465 6661 756c 7420 4e6f 6e65 0a20  , default None. 
+0000f900: 2020 2020 2020 2049 6620 7468 6520 6178         If the ax
+0000f910: 6973 2069 7320 6120 4d75 6c74 6949 6e64  is is a MultiInd
+0000f920: 6578 2028 6869 6572 6172 6368 6963 616c  ex (hierarchical
+0000f930: 292c 2067 726f 7570 2062 7920 610a 2020  ), group by a.  
+0000f940: 2020 2020 2020 7061 7274 6963 756c 6172        particular
+0000f950: 206c 6576 656c 206f 7220 6c65 7665 6c73   level or levels
+0000f960: 2e0a 2020 2020 2020 2020 2e2e 2076 6572  ..        .. ver
+0000f970: 7369 6f6e 6164 6465 643a 3a20 302e 392e  sionadded:: 0.9.
+0000f980: 300a 2020 2020 736f 7274 203a 2062 6f6f  0.    sort : boo
+0000f990: 6c2c 2064 6566 6175 6c74 2054 7275 650a  l, default True.
+0000f9a0: 2020 2020 2020 2020 536f 7274 2067 726f          Sort gro
+0000f9b0: 7570 206b 6579 732e 2047 6574 2062 6574  up keys. Get bet
+0000f9c0: 7465 7220 7065 7266 6f72 6d61 6e63 6520  ter performance 
+0000f9d0: 6279 2074 7572 6e69 6e67 2074 6869 7320  by turning this 
+0000f9e0: 6f66 662e 0a20 2020 2020 2020 204e 6f74  off..        Not
+0000f9f0: 6520 7468 6973 2064 6f65 7320 6e6f 7420  e this does not 
+0000fa00: 696e 666c 7565 6e63 6520 7468 6520 6f72  influence the or
+0000fa10: 6465 7220 6f66 206f 6273 6572 7661 7469  der of observati
+0000fa20: 6f6e 7320 7769 7468 696e 0a20 2020 2020  ons within.     
+0000fa30: 2020 2065 6163 6820 6772 6f75 702e 2047     each group. G
+0000fa40: 726f 7570 6279 2070 7265 7365 7276 6573  roupby preserves
+0000fa50: 2074 6865 206f 7264 6572 206f 6620 726f   the order of ro
+0000fa60: 7773 2077 6974 6869 6e20 6561 6368 2067  ws within each g
+0000fa70: 726f 7570 2e0a 2020 2020 2020 2020 2e2e  roup..        ..
+0000fa80: 2076 6572 7369 6f6e 6164 6465 643a 3a20   versionadded:: 
+0000fa90: 302e 392e 300a 2020 2020 6f62 7365 7276  0.9.0.    observ
+0000faa0: 6564 203a 2062 6f6f 6c2c 2064 6566 6175  ed : bool, defau
+0000fab0: 6c74 2046 616c 7365 0a20 2020 2020 2020  lt False.       
+0000fac0: 2054 6869 7320 6f6e 6c79 2061 7070 6c69   This only appli
+0000fad0: 6573 2069 6620 616e 7920 6f66 2074 6865  es if any of the
+0000fae0: 2067 726f 7570 6572 7320 6172 6520 4361   groupers are Ca
+0000faf0: 7465 676f 7269 6361 6c73 2e0a 2020 2020  tegoricals..    
+0000fb00: 2020 2020 4966 2054 7275 653a 206f 6e6c      If True: onl
+0000fb10: 7920 7368 6f77 206f 6273 6572 7665 6420  y show observed 
+0000fb20: 7661 6c75 6573 2066 6f72 2063 6174 6567  values for categ
+0000fb30: 6f72 6963 616c 2067 726f 7570 6572 732e  orical groupers.
+0000fb40: 0a20 2020 2020 2020 2049 6620 4661 6c73  .        If Fals
+0000fb50: 653a 2073 686f 7720 616c 6c20 7661 6c75  e: show all valu
+0000fb60: 6573 2066 6f72 2063 6174 6567 6f72 6963  es for categoric
+0000fb70: 616c 2067 726f 7570 6572 732e 0a20 2020  al groupers..   
+0000fb80: 2020 2020 202e 2e20 7665 7273 696f 6e61       .. versiona
+0000fb90: 6464 6564 3a3a 2030 2e39 2e30 0a20 2020  dded:: 0.9.0.   
+0000fba0: 2064 726f 706e 6120 3a20 626f 6f6c 2c20   dropna : bool, 
+0000fbb0: 6465 6661 756c 7420 5472 7565 0a20 2020  default True.   
+0000fbc0: 2020 2020 2049 6620 5472 7565 2c20 616e       If True, an
+0000fbd0: 6420 6966 2067 726f 7570 206b 6579 7320  d if group keys 
+0000fbe0: 636f 6e74 6169 6e20 4e41 2076 616c 7565  contain NA value
+0000fbf0: 732c 204e 4120 7661 6c75 6573 0a20 2020  s, NA values.   
+0000fc00: 2020 2020 2074 6f67 6574 6865 7220 7769       together wi
+0000fc10: 7468 2072 6f77 2f63 6f6c 756d 6e20 7769  th row/column wi
+0000fc20: 6c6c 2062 6520 6472 6f70 7065 642e 2049  ll be dropped. I
+0000fc30: 6620 4661 6c73 652c 204e 410a 2020 2020  f False, NA.    
+0000fc40: 2020 2020 7661 6c75 6573 2077 696c 6c20      values will 
+0000fc50: 616c 736f 2062 6520 7472 6561 7465 6420  also be treated 
+0000fc60: 6173 2074 6865 206b 6579 2069 6e20 6772  as the key in gr
+0000fc70: 6f75 7073 2e0a 2020 2020 2020 2020 5468  oups..        Th
+0000fc80: 6973 2070 6172 616d 6574 6572 2069 7320  is parameter is 
+0000fc90: 6e6f 7420 7375 7070 6f72 7465 6420 666f  not supported fo
+0000fca0: 7220 7061 6e64 6173 203c 2031 2e31 2e30  r pandas < 1.1.0
+0000fcb0: 2e0a 2020 2020 2020 2020 4120 7761 726e  ..        A warn
+0000fcc0: 696e 6720 7769 6c6c 2062 6520 656d 6974  ing will be emit
+0000fcd0: 7465 6420 666f 7220 6561 726c 6965 7220  ted for earlier 
+0000fce0: 7061 6e64 6173 2076 6572 7369 6f6e 730a  pandas versions.
+0000fcf0: 2020 2020 2020 2020 6966 2061 206e 6f6e          if a non
+0000fd00: 2d64 6566 6175 6c74 2076 616c 7565 2069  -default value i
+0000fd10: 7320 6769 7665 6e20 666f 7220 7468 6973  s given for this
+0000fd20: 2070 6172 616d 6574 6572 2e0a 2020 2020   parameter..    
+0000fd30: 2020 2020 2e2e 2076 6572 7369 6f6e 6164      .. versionad
+0000fd40: 6465 643a 3a20 302e 392e 300a 2020 2020  ded:: 0.9.0.    
+0000fd50: 5265 7475 726e 730a 2020 2020 2d2d 2d2d  Returns.    ----
+0000fd60: 2d2d 2d0a 2020 2020 4765 6f44 6174 6146  ---.    GeoDataF
+0000fd70: 7261 6d65 0a20 2020 2045 7861 6d70 6c65  rame.    Example
+0000fd80: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 0a20  s.    --------. 
+0000fd90: 2020 203e 3e3e 2066 726f 6d20 7368 6170     >>> from shap
+0000fda0: 656c 792e 6765 6f6d 6574 7279 2069 6d70  ely.geometry imp
+0000fdb0: 6f72 7420 506f 696e 740a 2020 2020 3e3e  ort Point.    >>
+0000fdc0: 3e20 6420 3d20 7b0a 2020 2020 2e2e 2e20  > d = {.    ... 
+0000fdd0: 2020 2020 2263 6f6c 3122 3a20 5b22 6e61      "col1": ["na
+0000fde0: 6d65 3122 2c20 226e 616d 6532 222c 2022  me1", "name2", "
+0000fdf0: 6e61 6d65 3122 5d2c 0a20 2020 202e 2e2e  name1"],.    ...
+0000fe00: 2020 2020 2022 6765 6f6d 6574 7279 223a       "geometry":
+0000fe10: 205b 506f 696e 7428 312c 2032 292c 2050   [Point(1, 2), P
+0000fe20: 6f69 6e74 2832 2c20 3129 2c20 506f 696e  oint(2, 1), Poin
+0000fe30: 7428 302c 2031 295d 2c0a 2020 2020 2e2e  t(0, 1)],.    ..
+0000fe40: 2e20 7d0a 2020 2020 3e3e 3e20 6764 6620  . }.    >>> gdf 
+0000fe50: 3d20 6765 6f70 616e 6461 732e 4765 6f44  = geopandas.GeoD
+0000fe60: 6174 6146 7261 6d65 2864 2c20 6372 733d  ataFrame(d, crs=
+0000fe70: 3433 3236 290a 2020 2020 3e3e 3e20 6764  4326).    >>> gd
+0000fe80: 660a 2020 2020 2020 2020 636f 6c31 2020  f.        col1  
+0000fe90: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+0000fea0: 656f 6d65 7472 790a 2020 2020 3020 206e  eometry.    0  n
+0000feb0: 616d 6531 2020 504f 494e 5420 2831 2e30  ame1  POINT (1.0
+0000fec0: 3030 3030 2032 2e30 3030 3030 290a 2020  0000 2.00000).  
+0000fed0: 2020 3120 206e 616d 6532 2020 504f 494e    1  name2  POIN
+0000fee0: 5420 2832 2e30 3030 3030 2031 2e30 3030  T (2.00000 1.000
+0000fef0: 3030 290a 2020 2020 3220 206e 616d 6531  00).    2  name1
+0000ff00: 2020 504f 494e 5420 2830 2e30 3030 3030    POINT (0.00000
+0000ff10: 2031 2e30 3030 3030 290a 2020 2020 3e3e   1.00000).    >>
+0000ff20: 3e20 6469 7373 6f6c 7665 6420 3d20 6764  > dissolved = gd
+0000ff30: 662e 6469 7373 6f6c 7665 2827 636f 6c31  f.dissolve('col1
+0000ff40: 2729 0a20 2020 203e 3e3e 2064 6973 736f  ').    >>> disso
+0000ff50: 6c76 6564 2020 2320 646f 6374 6573 743a  lved  # doctest:
+0000ff60: 202b 534b 4950 0a20 2020 2020 2020 2020   +SKIP.         
+0000ff70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ff80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ff90: 2020 2020 2020 2067 656f 6d65 7472 790a         geometry.
+0000ffa0: 2020 2020 636f 6c31 0a20 2020 206e 616d      col1.    nam
+0000ffb0: 6531 2020 4d55 4c54 4950 4f49 4e54 2028  e1  MULTIPOINT (
+0000ffc0: 302e 3030 3030 3020 312e 3030 3030 302c  0.00000 1.00000,
+0000ffd0: 2031 2e30 3030 3030 2032 2e30 3030 3030   1.00000 2.00000
+0000ffe0: 290a 2020 2020 6e61 6d65 3220 2020 2020  ).    name2     
+0000fff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010000: 2020 2050 4f49 4e54 2028 322e 3030 3030     POINT (2.0000
+00010010: 3020 312e 3030 3030 3029 0a20 2020 2053  0 1.00000).    S
+00010020: 6565 2061 6c73 6f0a 2020 2020 2d2d 2d2d  ee also.    ----
+00010030: 2d2d 2d2d 0a20 2020 2047 656f 4461 7461  ----.    GeoData
+00010040: 4672 616d 652e 6578 706c 6f64 6520 3a20  Frame.explode : 
+00010050: 6578 706c 6f64 6520 6d75 6c74 692d 7061  explode multi-pa
+00010060: 7274 2067 656f 6d65 7472 6965 7320 696e  rt geometries in
+00010070: 746f 2073 696e 676c 6520 6765 6f6d 6574  to single geomet
+00010080: 7269 6573 0a20 2020 2022 2222 0a0a 2020  ries.    """..  
+00010090: 2020 6966 2062 7920 6973 204e 6f6e 6520    if by is None 
+000100a0: 616e 6420 6c65 7665 6c20 6973 204e 6f6e  and level is Non
+000100b0: 653a 0a20 2020 2020 2020 2062 795f 6c6f  e:.        by_lo
+000100c0: 6361 6c20 3d20 6e70 2e7a 6572 6f73 286c  cal = np.zeros(l
+000100d0: 656e 2864 6629 2c20 6474 7970 653d 2269  en(df), dtype="i
+000100e0: 6e74 3634 2229 0a20 2020 2065 6c73 653a  nt64").    else:
+000100f0: 0a20 2020 2020 2020 2062 795f 6c6f 6361  .        by_loca
+00010100: 6c20 3d20 6279 0a0a 2020 2020 6772 6f75  l = by..    grou
+00010110: 7062 795f 6b77 6172 6773 203d 2064 6963  pby_kwargs = dic
+00010120: 7428 0a20 2020 2020 2020 2062 793d 6279  t(.        by=by
+00010130: 5f6c 6f63 616c 2c20 6c65 7665 6c3d 6c65  _local, level=le
+00010140: 7665 6c2c 2073 6f72 743d 736f 7274 2c20  vel, sort=sort, 
+00010150: 6f62 7365 7276 6564 3d6f 6273 6572 7665  observed=observe
+00010160: 642c 2064 726f 706e 613d 6472 6f70 6e61  d, dropna=dropna
+00010170: 0a20 2020 2029 0a20 2020 2022 2222 0a20  .    ).    """. 
+00010180: 2020 2069 6620 6e6f 7420 636f 6d70 6174     if not compat
+00010190: 2e50 414e 4441 535f 4745 5f31 313a 0a20  .PANDAS_GE_11:. 
+000101a0: 2020 2020 2020 2067 726f 7570 6279 5f6b         groupby_k
+000101b0: 7761 7267 732e 706f 7028 2264 726f 706e  wargs.pop("dropn
+000101c0: 6122 290a 0a20 2020 2020 2020 2069 6620  a")..        if 
+000101d0: 6e6f 7420 6472 6f70 6e61 3a20 2023 2049  not dropna:  # I
+000101e0: 6620 7468 6579 2070 6173 7365 6420 6120  f they passed a 
+000101f0: 6e6f 6e2d 6465 6661 756c 7420 6472 6f70  non-default drop
+00010200: 6e61 2076 616c 7565 0a20 2020 2020 2020  na value.       
+00010210: 2020 2020 2077 6172 6e69 6e67 732e 7761       warnings.wa
+00010220: 726e 2822 6472 6f70 6e61 206b 7761 7267  rn("dropna kwarg
+00010230: 2069 7320 6e6f 7420 7375 7070 6f72 7465   is not supporte
+00010240: 6420 666f 7220 7061 6e64 6173 203c 2031  d for pandas < 1
+00010250: 2e31 2e30 2229 0a20 2020 2022 2222 0a0a  .1.0").    """..
+00010260: 2020 2020 2320 5072 6f63 6573 7320 6e6f      # Process no
+00010270: 6e2d 7370 6174 6961 6c20 636f 6d70 6f6e  n-spatial compon
+00010280: 656e 740a 2020 2020 6461 7461 203d 2070  ent.    data = p
+00010290: 642e 4461 7461 4672 616d 6528 6466 2e64  d.DataFrame(df.d
+000102a0: 726f 7028 636f 6c75 6d6e 733d 6466 2e67  rop(columns=df.g
+000102b0: 656f 6d65 7472 792e 6e61 6d65 2929 0a0a  eometry.name))..
+000102c0: 2020 2020 6966 2061 6767 6675 6e63 2069      if aggfunc i
+000102d0: 7320 6e6f 7420 4e6f 6e65 2061 6e64 2069  s not None and i
+000102e0: 7369 6e73 7461 6e63 6528 6167 6766 756e  sinstance(aggfun
+000102f0: 632c 2064 6963 7429 2061 6e64 2022 746f  c, dict) and "to
+00010300: 5f6a 736f 6e22 2069 6e20 6167 6766 756e  _json" in aggfun
+00010310: 633a 0a20 2020 2020 2020 2061 6767 5f63  c:.        agg_c
+00010320: 6f6c 756d 6e73 203d 206c 6973 7428 7365  olumns = list(se
+00010330: 7428 6167 6766 756e 635b 2274 6f5f 6a73  t(aggfunc["to_js
+00010340: 6f6e 225d 2929 0a20 2020 2020 2020 2061  on"])).        a
+00010350: 6767 7265 6761 7465 645f 6461 7461 203d  ggregated_data =
+00010360: 2028 0a20 2020 2020 2020 2020 2020 2064   (.            d
+00010370: 6174 612e 6772 6f75 7062 7928 2a2a 6772  ata.groupby(**gr
+00010380: 6f75 7062 795f 6b77 6172 6773 290a 2020  oupby_kwargs).  
+00010390: 2020 2020 2020 2020 2020 2e61 7070 6c79            .apply
+000103a0: 286c 616d 6264 6120 673a 2067 5b61 6767  (lambda g: g[agg
+000103b0: 5f63 6f6c 756d 6e73 5d2e 746f 5f6a 736f  _columns].to_jso
+000103c0: 6e28 6f72 6965 6e74 3d22 7265 636f 7264  n(orient="record
+000103d0: 7322 2929 0a20 2020 2020 2020 2020 2020  s")).           
+000103e0: 202e 746f 5f66 7261 6d65 286e 616d 653d   .to_frame(name=
+000103f0: 225f 5f44 4953 534f 4c56 455f 544f 4a53  "__DISSOLVE_TOJS
+00010400: 4f4e 2229 0a20 2020 2020 2020 2029 0a20  ON").        ). 
+00010410: 2020 2065 6c69 6620 6973 696e 7374 616e     elif isinstan
+00010420: 6365 2861 6767 6675 6e63 2c20 7374 7229  ce(aggfunc, str)
+00010430: 2061 6e64 2061 6767 6675 6e63 203d 3d20   and aggfunc == 
+00010440: 226d 6572 6765 5f6a 736f 6e5f 6c69 7374  "merge_json_list
+00010450: 7322 3a0a 2020 2020 2020 2020 2320 4d65  s":.        # Me
+00010460: 7267 6520 616e 6420 666c 6174 7465 6e20  rge and flatten 
+00010470: 7468 6520 6a73 6f6e 206c 6973 7473 2069  the json lists i
+00010480: 6e20 7468 6520 6772 6f75 7073 0a20 2020  n the groups.   
+00010490: 2020 2020 2064 6566 2067 726f 7570 5f66       def group_f
+000104a0: 6c61 7474 656e 5f6a 736f 6e5f 6c69 7374  latten_json_list
+000104b0: 2867 293a 0a20 2020 2020 2020 2020 2020  (g):.           
+000104c0: 2023 2045 7661 6c75 6174 6520 616c 6c20   # Evaluate all 
+000104d0: 6772 6f75 7065 6420 726f 7773 2074 6f20  grouped rows to 
+000104e0: 6a73 6f6e 206f 626a 6563 7473 2e20 5468  json objects. Th
+000104f0: 6973 2072 6573 756c 7473 2069 6e20 6120  is results in a 
+00010500: 6c69 7374 206f 660a 2020 2020 2020 2020  list of.        
+00010510: 2020 2020 2320 6c69 7374 7320 6f66 206a      # lists of j
+00010520: 736f 6e20 6f62 6a65 6374 732e 0a20 2020  son objects..   
+00010530: 2020 2020 2020 2020 206a 736f 6e5f 6e65           json_ne
+00010540: 7374 6564 5f6c 6973 7473 203d 205b 0a20  sted_lists = [. 
+00010550: 2020 2020 2020 2020 2020 2020 2020 206a                 j
+00010560: 736f 6e2e 6c6f 6164 7328 6a73 6f6e 5f76  son.loads(json_v
+00010570: 616c 7565 7329 2066 6f72 206a 736f 6e5f  alues) for json_
+00010580: 7661 6c75 6573 2069 6e20 675b 225f 5f44  values in g["__D
+00010590: 4953 534f 4c56 455f 544f 4a53 4f4e 225d  ISSOLVE_TOJSON"]
+000105a0: 0a20 2020 2020 2020 2020 2020 205d 0a0a  .            ]..
+000105b0: 2020 2020 2020 2020 2020 2020 2320 4578              # Ex
+000105c0: 7472 6163 7420 7468 6520 726f 7773 2066  tract the rows f
+000105d0: 726f 6d20 7468 6520 6e65 7374 6564 206c  rom the nested l
+000105e0: 6973 7473 202b 2070 7574 2069 6e20 6120  ists + put in a 
+000105f0: 666c 6174 206c 6973 7420 6173 2073 7472  flat list as str
+00010600: 696e 6773 0a20 2020 2020 2020 2020 2020  ings.           
+00010610: 206a 736f 6e73 7472 5f66 6c61 7420 3d20   jsonstr_flat = 
+00010620: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
+00010630: 2020 6a73 6f6e 2e64 756d 7073 286a 736f    json.dumps(jso
+00010640: 6e5f 7661 6c75 6529 0a20 2020 2020 2020  n_value).       
+00010650: 2020 2020 2020 2020 2066 6f72 206a 736f           for jso
+00010660: 6e5f 7661 6c75 6573 2069 6e20 6a73 6f6e  n_values in json
+00010670: 5f6e 6573 7465 645f 6c69 7374 730a 2020  _nested_lists.  
+00010680: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+00010690: 7220 6a73 6f6e 5f76 616c 7565 2069 6e20  r json_value in 
+000106a0: 6a73 6f6e 5f76 616c 7565 730a 2020 2020  json_values.    
+000106b0: 2020 2020 2020 2020 5d0a 0a20 2020 2020          ]..     
+000106c0: 2020 2020 2020 2023 2052 656d 6f76 6520         # Remove 
+000106d0: 6475 706c 6963 6174 6573 0a20 2020 2020  duplicates.     
+000106e0: 2020 2020 2020 206a 736f 6e73 7374 725f         jsonsstr_
+000106f0: 6469 7374 696e 6374 203d 2073 6574 286a  distinct = set(j
+00010700: 736f 6e73 7472 5f66 6c61 7429 0a0a 2020  sonstr_flat)..  
+00010710: 2020 2020 2020 2020 2020 2320 436f 6e76            # Conv
+00010720: 6572 7420 7468 6520 6461 7461 2061 6761  ert the data aga
+00010730: 696e 2074 6f20 6120 6c69 7374 206f 6620  in to a list of 
+00010740: 6a73 6f6e 206f 626a 6563 7473 0a20 2020  json objects.   
+00010750: 2020 2020 2020 2020 206a 736f 6e5f 6469           json_di
+00010760: 7374 696e 6374 203d 205b 6a73 6f6e 2e6c  stinct = [json.l
+00010770: 6f61 6473 286a 736f 6e5f 7661 6c75 6529  oads(json_value)
+00010780: 2066 6f72 206a 736f 6e5f 7661 6c75 6520   for json_value 
+00010790: 696e 206a 736f 6e73 7374 725f 6469 7374  in jsonsstr_dist
+000107a0: 696e 6374 5d0a 0a20 2020 2020 2020 2020  inct]..         
+000107b0: 2020 2023 2052 6574 7572 6e20 6173 206a     # Return as j
+000107c0: 736f 6e20 7374 7269 6e67 0a20 2020 2020  son string.     
+000107d0: 2020 2020 2020 2072 6574 7572 6e20 6a73         return js
+000107e0: 6f6e 2e64 756d 7073 286a 736f 6e5f 6469  on.dumps(json_di
+000107f0: 7374 696e 6374 290a 0a20 2020 2020 2020  stinct)..       
+00010800: 2061 6767 7265 6761 7465 645f 6461 7461   aggregated_data
+00010810: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
+00010820: 2064 6174 612e 6772 6f75 7062 7928 2a2a   data.groupby(**
+00010830: 6772 6f75 7062 795f 6b77 6172 6773 290a  groupby_kwargs).
+00010840: 2020 2020 2020 2020 2020 2020 2e61 7070              .app
+00010850: 6c79 286c 616d 6264 6120 673a 2067 726f  ly(lambda g: gro
+00010860: 7570 5f66 6c61 7474 656e 5f6a 736f 6e5f  up_flatten_json_
+00010870: 6c69 7374 2867 2929 0a20 2020 2020 2020  list(g)).       
+00010880: 2020 2020 202e 746f 5f66 7261 6d65 286e       .to_frame(n
+00010890: 616d 653d 225f 5f44 4953 534f 4c56 455f  ame="__DISSOLVE_
+000108a0: 544f 4a53 4f4e 2229 0a20 2020 2020 2020  TOJSON").       
+000108b0: 2029 0a20 2020 2065 6c73 653a 0a20 2020   ).    else:.   
+000108c0: 2020 2020 2061 6767 7265 6761 7465 645f       aggregated_
+000108d0: 6461 7461 203d 2064 6174 612e 6772 6f75  data = data.grou
+000108e0: 7062 7928 2a2a 6772 6f75 7062 795f 6b77  pby(**groupby_kw
+000108f0: 6172 6773 292e 6167 6728 6167 6766 756e  args).agg(aggfun
+00010900: 6329 2020 2320 7479 7065 3a20 6967 6e6f  c)  # type: igno
+00010910: 7265 0a20 2020 2020 2020 2023 2043 6865  re.        # Che
+00010920: 636b 2069 6620 616c 6c20 636f 6c75 6d6e  ck if all column
+00010930: 7320 7765 7265 2070 726f 7065 726c 7920  s were properly 
+00010940: 6167 6772 6567 6174 6564 0a20 2020 2020  aggregated.     
+00010950: 2020 2061 7373 6572 7420 6279 5f6c 6f63     assert by_loc
+00010960: 616c 2069 7320 6e6f 7420 4e6f 6e65 0a20  al is not None. 
+00010970: 2020 2020 2020 2063 6f6c 756d 6e73 5f74         columns_t
+00010980: 6f5f 6167 6720 3d20 5b63 6f6c 756d 6e20  o_agg = [column 
+00010990: 666f 7220 636f 6c75 6d6e 2069 6e20 6461  for column in da
+000109a0: 7461 2e63 6f6c 756d 6e73 2069 6620 636f  ta.columns if co
+000109b0: 6c75 6d6e 206e 6f74 2069 6e20 6279 5f6c  lumn not in by_l
+000109c0: 6f63 616c 5d0a 2020 2020 2020 2020 6966  ocal].        if
+000109d0: 206c 656e 2863 6f6c 756d 6e73 5f74 6f5f   len(columns_to_
+000109e0: 6167 6729 2021 3d20 6c65 6e28 6167 6772  agg) != len(aggr
+000109f0: 6567 6174 6564 5f64 6174 612e 636f 6c75  egated_data.colu
+00010a00: 6d6e 7329 3a0a 2020 2020 2020 2020 2020  mns):.          
+00010a10: 2020 6472 6f70 7065 645f 636f 6c75 6d6e    dropped_column
+00010a20: 7320 3d20 5b0a 2020 2020 2020 2020 2020  s = [.          
+00010a30: 2020 2020 2020 636f 6c75 6d6e 0a20 2020        column.   
+00010a40: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+00010a50: 2063 6f6c 756d 6e20 696e 2063 6f6c 756d   column in colum
+00010a60: 6e73 5f74 6f5f 6167 670a 2020 2020 2020  ns_to_agg.      
+00010a70: 2020 2020 2020 2020 2020 6966 2063 6f6c            if col
+00010a80: 756d 6e20 6e6f 7420 696e 2061 6767 7265  umn not in aggre
+00010a90: 6761 7465 645f 6461 7461 2e63 6f6c 756d  gated_data.colum
+00010aa0: 6e73 0a20 2020 2020 2020 2020 2020 205d  ns.            ]
+00010ab0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+00010ac0: 7365 2045 7863 6570 7469 6f6e 280a 2020  se Exception(.  
+00010ad0: 2020 2020 2020 2020 2020 2020 2020 6622                f"
+00010ae0: 436f 6c75 6d6e 2873 2920 7b64 726f 7070  Column(s) {dropp
+00010af0: 6564 5f63 6f6c 756d 6e73 7d20 6172 6520  ed_columns} are 
+00010b00: 6e6f 7420 7375 7070 6f72 7465 6420 666f  not supported fo
+00010b10: 7220 6167 6772 6567 6174 696f 6e2c 2073  r aggregation, s
+00010b20: 746f 7022 0a20 2020 2020 2020 2020 2020  top".           
+00010b30: 2029 0a0a 2020 2020 2320 5072 6f63 6573   )..    # Proces
+00010b40: 7320 7370 6174 6961 6c20 636f 6d70 6f6e  s spatial compon
+00010b50: 656e 740a 2020 2020 6465 6620 6d65 7267  ent.    def merg
+00010b60: 655f 6765 6f6d 6574 7269 6573 2862 6c6f  e_geometries(blo
+00010b70: 636b 293a 0a20 2020 2020 2020 206d 6572  ck):.        mer
+00010b80: 6765 645f 6765 6f6d 203d 2062 6c6f 636b  ged_geom = block
+00010b90: 2e75 6e61 7279 5f75 6e69 6f6e 0a20 2020  .unary_union.   
+00010ba0: 2020 2020 2072 6574 7572 6e20 6d65 7267       return merg
+00010bb0: 6564 5f67 656f 6d0a 0a20 2020 2067 203d  ed_geom..    g =
+00010bc0: 2064 662e 6772 6f75 7062 7928 6772 6f75   df.groupby(grou
+00010bd0: 705f 6b65 7973 3d46 616c 7365 2c20 2a2a  p_keys=False, **
+00010be0: 6772 6f75 7062 795f 6b77 6172 6773 295b  groupby_kwargs)[
+00010bf0: 6466 2e67 656f 6d65 7472 792e 6e61 6d65  df.geometry.name
+00010c00: 5d2e 6167 6728 0a20 2020 2020 2020 206d  ].agg(.        m
+00010c10: 6572 6765 5f67 656f 6d65 7472 6965 730a  erge_geometries.
+00010c20: 2020 2020 290a 0a20 2020 2023 2041 6767      )..    # Agg
+00010c30: 7265 6761 7465 0a20 2020 2061 6767 7265  regate.    aggre
+00010c40: 6761 7465 645f 6765 6f6d 6574 7279 203d  gated_geometry =
+00010c50: 2067 7064 2e47 656f 4461 7461 4672 616d   gpd.GeoDataFram
+00010c60: 6528 0a20 2020 2020 2020 2064 6174 613d  e(.        data=
+00010c70: 672c 2067 656f 6d65 7472 793d 6466 2e67  g, geometry=df.g
+00010c80: 656f 6d65 7472 792e 6e61 6d65 2c20 6372  eometry.name, cr
+00010c90: 733d 6466 2e63 7273 2020 2320 7479 7065  s=df.crs  # type
+00010ca0: 3a20 6967 6e6f 7265 0a20 2020 2029 0a20  : ignore.    ). 
+00010cb0: 2020 2023 2052 6563 6f6d 6269 6e65 0a20     # Recombine. 
+00010cc0: 2020 2061 6767 7265 6761 7465 6420 3d20     aggregated = 
+00010cd0: 6167 6772 6567 6174 6564 5f67 656f 6d65  aggregated_geome
+00010ce0: 7472 792e 6a6f 696e 2861 6767 7265 6761  try.join(aggrega
+00010cf0: 7465 645f 6461 7461 290a 0a20 2020 2023  ted_data)..    #
+00010d00: 2052 6573 6574 2069 6620 7265 7175 6573   Reset if reques
+00010d10: 7465 640a 2020 2020 6966 206e 6f74 2061  ted.    if not a
+00010d20: 735f 696e 6465 783a 0a20 2020 2020 2020  s_index:.       
+00010d30: 2061 6767 7265 6761 7465 6420 3d20 6167   aggregated = ag
+00010d40: 6772 6567 6174 6564 2e72 6573 6574 5f69  gregated.reset_i
+00010d50: 6e64 6578 2829 0a0a 2020 2020 2320 4d61  ndex()..    # Ma
+00010d60: 6b65 2073 7572 6520 6f75 7470 7574 2074  ke sure output t
+00010d70: 7970 6573 206f 6620 6772 6f75 7065 6420  ypes of grouped 
+00010d80: 636f 6c75 6d6e 7320 6172 6520 7468 6520  columns are the 
+00010d90: 7361 6d65 2061 7320 696e 7075 7420 7479  same as input ty
+00010da0: 7065 732e 0a20 2020 2023 2045 2e67 2e20  pes..    # E.g. 
+00010db0: 6f62 6a65 6374 2063 6f6c 756d 6e73 2062  object columns b
+00010dc0: 6563 6f6d 6520 666c 6f61 7420 6966 2061  ecome float if a
+00010dd0: 6c6c 2076 616c 7565 7320 6172 6520 4e6f  ll values are No
+00010de0: 6e65 2e0a 2020 2020 6966 2062 7920 6973  ne..    if by is
+00010df0: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00010e00: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+00010e10: 2862 792c 2073 7472 293a 0a20 2020 2020  (by, str):.     
+00010e20: 2020 2020 2020 2069 6620 6279 2069 6e20         if by in 
+00010e30: 6167 6772 6567 6174 6564 2e63 6f6c 756d  aggregated.colum
+00010e40: 6e73 2061 6e64 2064 665b 6279 5d2e 6474  ns and df[by].dt
+00010e50: 7970 6520 213d 2061 6767 7265 6761 7465  ype != aggregate
+00010e60: 645b 6279 5d2e 6474 7970 653a 0a20 2020  d[by].dtype:.   
+00010e70: 2020 2020 2020 2020 2020 2020 2061 6767               agg
+00010e80: 7265 6761 7465 645b 6279 5d20 3d20 6167  regated[by] = ag
+00010e90: 6772 6567 6174 6564 5b62 795d 2e61 7374  gregated[by].ast
+00010ea0: 7970 6528 6466 5b62 795d 2e64 7479 7065  ype(df[by].dtype
+00010eb0: 2920 2023 2074 7970 653a 2069 676e 6f72  )  # type: ignor
+00010ec0: 650a 2020 2020 2020 2020 656c 6966 2069  e.        elif i
+00010ed0: 7369 6e73 7461 6e63 6528 6279 2c20 4974  sinstance(by, It
+00010ee0: 6572 6162 6c65 293a 0a20 2020 2020 2020  erable):.       
+00010ef0: 2020 2020 2066 6f72 2063 6f6c 2069 6e20       for col in 
+00010f00: 6279 3a0a 2020 2020 2020 2020 2020 2020  by:.            
+00010f10: 2020 2020 6966 2063 6f6c 2069 6e20 6167      if col in ag
+00010f20: 6772 6567 6174 6564 2e63 6f6c 756d 6e73  gregated.columns
+00010f30: 2061 6e64 2064 665b 636f 6c5d 2e64 7479   and df[col].dty
+00010f40: 7065 2021 3d20 6167 6772 6567 6174 6564  pe != aggregated
+00010f50: 5b63 6f6c 5d2e 6474 7970 653a 0a20 2020  [col].dtype:.   
+00010f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010f70: 2061 6767 7265 6761 7465 645b 636f 6c5d   aggregated[col]
+00010f80: 203d 2061 6767 7265 6761 7465 645b 636f   = aggregated[co
+00010f90: 6c5d 2e61 7374 7970 6528 6466 5b63 6f6c  l].astype(df[col
+00010fa0: 5d2e 6474 7970 6529 0a0a 2020 2020 6173  ].dtype)..    as
+00010fb0: 7365 7274 2069 7369 6e73 7461 6e63 6528  sert isinstance(
+00010fc0: 6167 6772 6567 6174 6564 2c20 6770 642e  aggregated, gpd.
+00010fd0: 4765 6f44 6174 6146 7261 6d65 290a 2020  GeoDataFrame).  
+00010fe0: 2020 7265 7475 726e 2061 6767 7265 6761    return aggrega
+00010ff0: 7465 640a 0a0a 6465 6620 5f61 6464 5f6f  ted...def _add_o
+00011000: 7264 6572 6279 5f63 6f6c 756d 6e28 7061  rderby_column(pa
+00011010: 7468 3a20 5061 7468 2c20 6c61 7965 723a  th: Path, layer:
+00011020: 2073 7472 2c20 6e61 6d65 3a20 7374 7229   str, name: str)
+00011030: 3a0a 2020 2020 2320 5072 6570 6172 6520  :.    # Prepare 
+00011040: 7468 6520 6578 7072 6573 7369 6f6e 2074  the expression t
+00011050: 6f20 6361 6c63 756c 6174 6520 7468 6520  o calculate the 
+00011060: 6f72 6465 7262 7920 636f 6c75 6d6e 2e0a  orderby column..
+00011070: 2020 2020 2320 496e 2061 2073 7061 7469      # In a spati
+00011080: 616c 2066 696c 652c 2061 2073 7061 7469  al file, a spati
+00011090: 616c 206f 7264 6572 2077 696c 6c20 6d61  al order will ma
+000110a0: 6b65 206c 6174 6572 2075 7365 206d 6f72  ke later use mor
+000110b0: 6520 6566 6669 6369 c3ab 6e74 2c0a 2020  e effici..nt,.  
+000110c0: 2020 2320 736f 2075 7365 2061 2067 656f    # so use a geo
+000110d0: 6861 7368 2e0a 2020 2020 6c61 7965 7269  hash..    layeri
+000110e0: 6e66 6f20 3d20 6766 6f2e 6765 745f 6c61  nfo = gfo.get_la
+000110f0: 7965 7269 6e66 6f28 7061 7468 290a 2020  yerinfo(path).  
+00011100: 2020 6966 206c 6179 6572 696e 666f 2e63    if layerinfo.c
+00011110: 7273 2069 7320 6e6f 7420 4e6f 6e65 2061  rs is not None a
+00011120: 6e64 206c 6179 6572 696e 666f 2e63 7273  nd layerinfo.crs
+00011130: 2e69 735f 6765 6f67 7261 7068 6963 3a0a  .is_geographic:.
+00011140: 2020 2020 2020 2020 2320 4966 2074 6865          # If the
+00011150: 2063 6f6f 7264 696e 6174 6573 2061 7265   coordinates are
+00011160: 2067 656f 6772 6170 6869 6320 2869 6e20   geographic (in 
+00011170: 6c61 742f 6c6f 6e20 6465 6772 6565 7329  lat/lon degrees)
+00011180: 2c20 6f6b 0a20 2020 2020 2020 2065 7870  , ok.        exp
+00011190: 7265 7373 696f 6e20 3d20 6622 5354 5f47  ression = f"ST_G
+000111a0: 656f 4861 7368 287b 6c61 7965 7269 6e66  eoHash({layerinf
+000111b0: 6f2e 6765 6f6d 6574 7279 636f 6c75 6d6e  o.geometrycolumn
+000111c0: 7d2c 2031 3029 220a 2020 2020 656c 7365  }, 10)".    else
+000111d0: 3a0a 2020 2020 2020 2020 2320 4966 2074  :.        # If t
+000111e0: 6865 7920 6172 6520 6e6f 7420 6765 6f67  hey are not geog
+000111f0: 7261 7068 6963 2028 696e 206c 6174 2f6c  raphic (in lat/l
+00011200: 6f6e 2064 6567 7265 6573 292c 2074 6865  on degrees), the
+00011210: 7920 6e65 6564 2074 6f20 6265 0a20 2020  y need to be.   
+00011220: 2020 2020 2023 2063 6f6e 7665 7274 6564       # converted
+00011230: 2074 6f20 7e20 6465 6772 6565 7320 746f   to ~ degrees to
+00011240: 2062 6520 6162 6c65 2074 6f20 6361 6c63   be able to calc
+00011250: 756c 6174 6520 6120 6765 6f68 6173 682e  ulate a geohash.
+00011260: 0a0a 2020 2020 2020 2020 2320 5072 6f70  ..        # Prop
+00011270: 6572 6c79 2063 616c 6375 6c61 7469 6e67  erly calculating
+00011280: 2074 6865 2074 7261 6e73 666f 726d 6174   the transformat
+00011290: 696f 6e20 746f 2065 672e 2057 4753 2069  ion to eg. WGS i
+000112a0: 7320 7465 7272 6962 6c79 2073 6c6f 772e  s terribly slow.
+000112b0: 2e2e 0a20 2020 2020 2020 2023 2065 7870  ...        # exp
+000112c0: 7265 7373 696f 6e20 3d20 6622 2222 5354  ression = f"""ST
+000112d0: 5f47 656f 4861 7368 2853 545f 5472 616e  _GeoHash(ST_Tran
+000112e0: 7366 6f72 6d28 4d61 6b65 506f 696e 7428  sform(MakePoint(
+000112f0: 0a20 2020 2020 2020 2023 2020 2020 2020  .        #      
+00011300: 2028 4d62 724d 6178 5828 6765 6f6d 292b   (MbrMaxX(geom)+
+00011310: 4d62 724d 696e 5828 6765 6f6d 2929 2f32  MbrMinX(geom))/2
+00011320: 2c0a 2020 2020 2020 2020 2320 2020 2020  ,.        #     
+00011330: 2020 284d 6272 4d69 6e59 2867 656f 6d29    (MbrMinY(geom)
+00011340: 2b4d 6272 4d61 7859 2867 656f 6d29 292f  +MbrMaxY(geom))/
+00011350: 322c 2053 545f 5352 4944 2867 656f 6d29  2, ST_SRID(geom)
+00011360: 292c 2034 3332 3629 2c20 3130 2922 2222  ), 4326), 10)"""
+00011370: 0a20 2020 2020 2020 2023 2053 6f2c 2064  .        # So, d
+00011380: 6f20 736f 6d65 7468 696e 6720 656c 7365  o something else
+00011390: 2074 6861 7427 7320 6661 7374 6572 2061   that's faster a
+000113a0: 6e64 2073 7469 6c6c 2067 6976 6573 2061  nd still gives a
+000113b0: 2067 6f6f 640a 2020 2020 2020 2020 2320   good.        # 
+000113c0: 6765 6f67 7261 7068 6963 2063 6c75 7374  geographic clust
+000113d0: 6572 696e 672e 0a20 2020 2020 2020 2074  ering..        t
+000113e0: 6f5f 6765 6f67 7261 7068 6963 5f66 6163  o_geographic_fac
+000113f0: 746f 725f 6170 7072 6f78 203d 2039 3020  tor_approx = 90 
+00011400: 2f20 6d61 7828 6c61 7965 7269 6e66 6f2e  / max(layerinfo.
+00011410: 746f 7461 6c5f 626f 756e 6473 290a 2020  total_bounds).  
+00011420: 2020 2020 2020 6578 7072 6573 7369 6f6e        expression
+00011430: 203d 2066 2222 2253 545f 4765 6f48 6173   = f"""ST_GeoHas
+00011440: 6828 4d61 6b65 506f 696e 7428 0a20 2020  h(MakePoint(.   
+00011450: 2020 2020 2020 2020 2020 2020 2028 284d               ((M
+00011460: 6272 4d61 7858 287b 6c61 7965 7269 6e66  brMaxX({layerinf
+00011470: 6f2e 6765 6f6d 6574 7279 636f 6c75 6d6e  o.geometrycolumn
+00011480: 7d29 0a20 2020 2020 2020 2020 2020 2020  }).             
+00011490: 2020 2020 202b 4d62 724d 696e 5828 7b6c       +MbrMinX({l
+000114a0: 6179 6572 696e 666f 2e67 656f 6d65 7472  ayerinfo.geometr
+000114b0: 7963 6f6c 756d 6e7d 2929 2f32 0a20 2020  ycolumn}))/2.   
+000114c0: 2020 2020 2020 2020 2020 2020 2029 2a7b               )*{
+000114d0: 746f 5f67 656f 6772 6170 6869 635f 6661  to_geographic_fa
+000114e0: 6374 6f72 5f61 7070 726f 787d 2c0a 2020  ctor_approx},.  
+000114f0: 2020 2020 2020 2020 2020 2020 2020 2828                ((
+00011500: 4d62 724d 696e 5928 7b6c 6179 6572 696e  MbrMinY({layerin
+00011510: 666f 2e67 656f 6d65 7472 7963 6f6c 756d  fo.geometrycolum
+00011520: 6e7d 290a 2020 2020 2020 2020 2020 2020  n}).            
+00011530: 2020 2020 2020 2b4d 6272 4d61 7859 287b        +MbrMaxY({
+00011540: 6c61 7965 7269 6e66 6f2e 6765 6f6d 6574  layerinfo.geomet
+00011550: 7279 636f 6c75 6d6e 7d29 292f 320a 2020  rycolumn}))/2.  
+00011560: 2020 2020 2020 2020 2020 2020 2020 292a                )*
+00011570: 7b74 6f5f 6765 6f67 7261 7068 6963 5f66  {to_geographic_f
+00011580: 6163 746f 725f 6170 7072 6f78 7d2c 2034  actor_approx}, 4
+00011590: 3332 3629 2c20 3130 2922 2222 0a0a 2020  326), 10)"""..  
+000115a0: 2020 2320 4e6f 7720 7765 2063 616e 2061    # Now we can a
+000115b0: 6374 7561 6c6c 7920 6164 6420 7468 6520  ctually add the 
+000115c0: 636f 6c75 6d6e 2e0a 2020 2020 6766 6f2e  column..    gfo.
+000115d0: 6164 645f 636f 6c75 6d6e 2870 6174 683d  add_column(path=
+000115e0: 7061 7468 2c20 6e61 6d65 3d6e 616d 652c  path, name=name,
+000115f0: 2074 7970 653d 6766 6f2e 4461 7461 5479   type=gfo.DataTy
+00011600: 7065 2e54 4558 542c 2065 7870 7265 7373  pe.TEXT, express
+00011610: 696f 6e3d 6578 7072 6573 7369 6f6e 290a  ion=expression).
+00011620: 2020 2020 7371 6c69 7465 5f73 746d 7420      sqlite_stmt 
+00011630: 3d20 6627 4352 4541 5445 2049 4e44 4558  = f'CREATE INDEX
+00011640: 207b 6e61 6d65 7d5f 6964 7820 4f4e 2022   {name}_idx ON "
+00011650: 7b6c 6179 6572 7d22 287b 6e61 6d65 7d29  {layer}"({name})
+00011660: 270a 2020 2020 6766 6f2e 6578 6563 7574  '.    gfo.execut
+00011670: 655f 7371 6c28 7061 7468 3d70 6174 682c  e_sql(path=path,
+00011680: 2073 716c 5f73 746d 743d 7371 6c69 7465   sql_stmt=sqlite
+00011690: 5f73 746d 7429 0a                        _stmt).
```

### Comparing `geofileops-0.8.0a1/geofileops/util/_geoops_ogr.py` & `geofileops-0.8.0a2/geofileops/util/_geoops_ogr.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,174 +1,174 @@
-from datetime import datetime
-import logging
-from pathlib import Path
-from typing import List, Literal, Optional, Tuple, Union
-
-from shapely import wkt
-
-import geofileops as gfo
-from geofileops.util import _ogr_util
-from geofileops.util.geometry_util import GeometryType
-
-################################################################################
-# Some init
-################################################################################
-
-logger = logging.getLogger(__name__)
-
-################################################################################
-# Functions
-################################################################################
-
-
-def clip_by_geometry(
-    input_path: Path,
-    output_path: Path,
-    clip_geometry: Union[Tuple[float, float, float, float], str],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    spatial_filter = None
-    if isinstance(clip_geometry, str):
-        geom = wkt.loads(clip_geometry)
-        spatial_filter = tuple(geom.bounds)
-
-    options = {"LAYER_CREATION.SPATIAL_INDEX": True}
-    _run_ogr(
-        operation="clip_by_geometry",
-        input_path=input_path,
-        output_path=output_path,
-        spatial_filter=spatial_filter,
-        clip_geometry=clip_geometry,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        options=options,
-        force=force,
-    )
-
-
-def export_by_bounds(
-    input_path: Path,
-    output_path: Path,
-    bounds: Tuple[float, float, float, float],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    options = {"LAYER_CREATION.SPATIAL_INDEX": True}
-    _run_ogr(
-        operation="export_by_bounds",
-        input_path=input_path,
-        output_path=output_path,
-        spatial_filter=bounds,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        options=options,
-        force=force,
-    )
-
-
-def warp(
-    input_path: Path,
-    output_path: Path,
-    gcps: List[Tuple[float, float, float, float, Optional[float]]],
-    algorithm: str = "polynomial",
-    order: Optional[int] = None,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    warp = {
-        "gcps": gcps,
-        "algorithm": algorithm,
-        "order": order,
-    }
-
-    _run_ogr(
-        operation="warp",
-        input_path=input_path,
-        output_path=output_path,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        warp=warp,
-        force=force,
-    )
-
-
-def _run_ogr(
-    operation: str,
-    input_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    input_srs: Union[int, str, None] = None,
-    output_srs: Union[int, str, None] = None,
-    reproject: bool = False,
-    spatial_filter: Optional[Tuple[float, float, float, float]] = None,
-    clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
-    sql_stmt: Optional[str] = None,
-    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
-    transaction_size: int = 65536,
-    append: bool = False,
-    update: bool = False,
-    explodecollections: bool = False,
-    force_output_geometrytype: Optional[GeometryType] = None,
-    options: dict = {},
-    columns: Optional[List[str]] = None,
-    warp: Optional[dict] = None,
-    force: bool = False,
-) -> bool:
-    # Init
-    start_time = datetime.now()
-    if input_layer is None:
-        input_layer = gfo.get_only_layer(input_path)
-    if output_path.exists():
-        if force:
-            gfo.remove(output_path)
-        else:
-            logger.info(f"Stop {operation}: output exists already {output_path}")
-            return True
-
-    if input_layer is None:
-        input_layer = gfo.get_only_layer(input_path)
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-
-    info = _ogr_util.VectorTranslateInfo(
-        input_path=input_path,
-        output_path=output_path,
-        input_layers=input_layer,
-        output_layer=output_layer,
-        input_srs=input_srs,
-        output_srs=output_srs,
-        reproject=reproject,
-        spatial_filter=spatial_filter,
-        clip_geometry=clip_geometry,
-        sql_stmt=sql_stmt,
-        sql_dialect=sql_dialect,
-        transaction_size=transaction_size,
-        append=append,
-        update=update,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        options=options,
-        columns=columns,
-        warp=warp,
-    )
-
-    # Run + return result
-    result = _ogr_util.vector_translate_by_info(info)
-    logger.info(f"{operation} ready, took {datetime.now()-start_time}!")
-    return result
+from datetime import datetime
+import logging
+from pathlib import Path
+from typing import List, Literal, Optional, Tuple, Union
+
+from shapely import wkt
+
+import geofileops as gfo
+from geofileops.util import _ogr_util
+from geofileops.util.geometry_util import GeometryType
+
+################################################################################
+# Some init
+################################################################################
+
+logger = logging.getLogger(__name__)
+
+################################################################################
+# Functions
+################################################################################
+
+
+def clip_by_geometry(
+    input_path: Path,
+    output_path: Path,
+    clip_geometry: Union[Tuple[float, float, float, float], str],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    spatial_filter = None
+    if isinstance(clip_geometry, str):
+        geom = wkt.loads(clip_geometry)
+        spatial_filter = tuple(geom.bounds)
+
+    options = {"LAYER_CREATION.SPATIAL_INDEX": True}
+    _run_ogr(
+        operation="clip_by_geometry",
+        input_path=input_path,
+        output_path=output_path,
+        spatial_filter=spatial_filter,
+        clip_geometry=clip_geometry,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        options=options,
+        force=force,
+    )
+
+
+def export_by_bounds(
+    input_path: Path,
+    output_path: Path,
+    bounds: Tuple[float, float, float, float],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    options = {"LAYER_CREATION.SPATIAL_INDEX": True}
+    _run_ogr(
+        operation="export_by_bounds",
+        input_path=input_path,
+        output_path=output_path,
+        spatial_filter=bounds,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        options=options,
+        force=force,
+    )
+
+
+def warp(
+    input_path: Path,
+    output_path: Path,
+    gcps: List[Tuple[float, float, float, float, Optional[float]]],
+    algorithm: str = "polynomial",
+    order: Optional[int] = None,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    warp = {
+        "gcps": gcps,
+        "algorithm": algorithm,
+        "order": order,
+    }
+
+    _run_ogr(
+        operation="warp",
+        input_path=input_path,
+        output_path=output_path,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        warp=warp,
+        force=force,
+    )
+
+
+def _run_ogr(
+    operation: str,
+    input_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    input_srs: Union[int, str, None] = None,
+    output_srs: Union[int, str, None] = None,
+    reproject: bool = False,
+    spatial_filter: Optional[Tuple[float, float, float, float]] = None,
+    clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
+    sql_stmt: Optional[str] = None,
+    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
+    transaction_size: int = 65536,
+    append: bool = False,
+    update: bool = False,
+    explodecollections: bool = False,
+    force_output_geometrytype: Optional[GeometryType] = None,
+    options: dict = {},
+    columns: Optional[List[str]] = None,
+    warp: Optional[dict] = None,
+    force: bool = False,
+) -> bool:
+    # Init
+    start_time = datetime.now()
+    if input_layer is None:
+        input_layer = gfo.get_only_layer(input_path)
+    if output_path.exists():
+        if force:
+            gfo.remove(output_path)
+        else:
+            logger.info(f"Stop {operation}: output exists already {output_path}")
+            return True
+
+    if input_layer is None:
+        input_layer = gfo.get_only_layer(input_path)
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+
+    info = _ogr_util.VectorTranslateInfo(
+        input_path=input_path,
+        output_path=output_path,
+        input_layers=input_layer,
+        output_layer=output_layer,
+        input_srs=input_srs,
+        output_srs=output_srs,
+        reproject=reproject,
+        spatial_filter=spatial_filter,
+        clip_geometry=clip_geometry,
+        sql_stmt=sql_stmt,
+        sql_dialect=sql_dialect,
+        transaction_size=transaction_size,
+        append=append,
+        update=update,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        options=options,
+        columns=columns,
+        warp=warp,
+    )
+
+    # Run + return result
+    result = _ogr_util.vector_translate_by_info(info)
+    logger.info(f"{operation} ready, took {datetime.now()-start_time}!")
+    return result
```

### Comparing `geofileops-0.8.0a1/geofileops/util/_geoops_sql.py` & `geofileops-0.8.0a2/geofileops/util/_geoops_sql.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,2518 +1,2537 @@
-# -*- coding: utf-8 -*-
-"""
-Module containing the implementation of Geofile operations using a sql statement.
-"""
-
-from concurrent import futures
-from datetime import datetime
-import logging
-import logging.config
-import math
-import multiprocessing
-from pathlib import Path
-import shutil
-import string
-from typing import Iterable, List, Literal, Optional, Union
-
-import pandas as pd
-
-import geofileops as gfo
-from geofileops import GeofileType, GeometryType, PrimitiveType
-from geofileops import fileops
-from geofileops.fileops import _append_to_nolock
-from . import _general_util
-from . import _io_util
-from . import _ogr_sql_util
-from . import _ogr_util
-from ..helpers import _parameter_helper
-from . import _processing_util
-from . import _sqlite_util
-
-################################################################################
-# Some init
-################################################################################
-
-logger = logging.getLogger(__name__)
-
-################################################################################
-# Operations on one layer
-################################################################################
-
-
-def buffer(
-    input_path: Path,
-    output_path: Path,
-    distance: float,
-    quadrantsegments: int = 5,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Init + prepare sql template for this operation
-    # ----------------------------------------------
-    if distance < 0:
-        # For a double sided buffer, a negative buffer is only relevant for polygon
-        # types, so only keep polygon results. Negative buffer creates invalid stuff,
-        # so use collectionextract to keep only polygons.
-        sql_template = f"""
-            SELECT ST_CollectionExtract(
-                       ST_buffer({{geometrycolumn}}, {distance}, {quadrantsegments}), 3
-                   ) AS geom
-                  {{columns_to_select_str}}
-              FROM "{{input_layer}}" layer
-             WHERE 1=1
-               {{batch_filter}}
-        """
-    else:
-        sql_template = f"""
-            SELECT ST_Buffer({{geometrycolumn}}, {distance}, {quadrantsegments}) AS geom
-                  {{columns_to_select_str}}
-              FROM "{{input_layer}}" layer
-             WHERE 1=1
-               {{batch_filter}}
-        """
-
-    # Buffer operation always results in polygons...
-    if explodecollections:
-        force_output_geometrytype = GeometryType.POLYGON
-    else:
-        force_output_geometrytype = GeometryType.MULTIPOLYGON
-
-    # Go!
-    # ---
-    return _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="buffer",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        sql_dialect="SQLITE",
-        filter_null_geoms=True,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def convexhull(
-    input_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Init + prepare sql template for this operation
-    # ----------------------------------------------
-    input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
-    sql_template = """
-        SELECT ST_ConvexHull({geometrycolumn}) AS geom
-                {columns_to_select_str}
-          FROM "{input_layer}" layer
-         WHERE 1=1
-           {batch_filter}
-    """
-
-    # Go!
-    # ---
-    # Output geometry type same as input geometry type
-    return _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="convexhull",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=input_layerinfo.geometrytype,
-        sql_dialect="SQLITE",
-        filter_null_geoms=True,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def delete_duplicate_geometries(
-    input_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    # The query as written doesn't give correct results when parallellized,
-    # but it isn't useful to do it for this operation.
-    sql_template = """
-        SELECT {geometrycolumn} AS geom
-              {columns_to_select_str}
-          FROM "{input_layer}" layer
-         WHERE layer.rowid IN (
-                SELECT MIN(layer_sub.rowid) AS rowid_to_keep
-                  FROM "{input_layer}" layer_sub
-                 GROUP BY layer_sub.{geometrycolumn}
-            )
-    """
-
-    # Go!
-    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
-    return _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="delete_duplicate_geometries",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=input_layer_info.geometrytype,
-        sql_dialect="SQLITE",
-        filter_null_geoms=True,
-        nb_parallel=1,
-        batchsize=-1,
-        force=force,
-    )
-
-
-def isvalid(
-    input_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    validate_attribute_data: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-) -> bool:
-    # Prepare sql template for this operation
-    sql_template = """
-        SELECT ST_IsValidDetail({geometrycolumn}) AS geom
-              ,ST_IsValid({geometrycolumn}) AS isvalid
-              ,ST_IsValidReason({geometrycolumn}) AS isvalidreason
-              {columns_to_select_str}
-          FROM "{input_layer}" layer
-         WHERE ST_IsValid({geometrycolumn}) <> 1
-           {batch_filter}
-    """
-
-    _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="isvalid",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=GeometryType.POINT,
-        sql_dialect="SQLITE",
-        filter_null_geoms=True,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-    # Check the number of invalid files
-    nb_invalid_geoms = 0
-    if output_path.exists():
-        nb_invalid_geoms = gfo.get_layerinfo(output_path).featurecount
-        if nb_invalid_geoms == 0:
-            # Empty result, so everything was valid: remove output file
-            gfo.remove(output_path)
-
-    # If output is sqlite based, check if all data can be read
-    if validate_attribute_data:
-        try:
-            input_geofiletype = GeofileType(input_path)
-            if input_geofiletype.is_spatialite_based:
-                _sqlite_util.test_data_integrity(path=input_path)
-                logger.debug("test_data_integrity was succesfull")
-        except Exception:
-            logger.exception(
-                f"nb_invalid_geoms: {nb_invalid_geoms} + some attributes could not be "
-                "read!"
-            )
-            return False
-
-    if nb_invalid_geoms > 0:
-        logger.info(f"Found {nb_invalid_geoms} invalid geoms in {output_path}")
-        return False
-
-    # Nothing invalid found
-    return True
-
-
-def makevalid(
-    input_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Optional[GeometryType] = None,
-    precision: Optional[float] = None,
-    validate_attribute_data: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # If output file exists already, either clean up or return...
-    operation_name = "makevalid"
-    if not force and output_path.exists():
-        logger.info(f"Stop {operation_name}: output exists already {output_path}")
-        return
-
-    # Init + prepare sql template for this operation
-    # ----------------------------------------------
-    input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
-
-    # Specify output_geometrytype, because otherwise makevalid results in
-    # column type 'GEOMETRY'/'UNKNOWN(ANY)'
-    if force_output_geometrytype is None:
-        force_output_geometrytype = input_layerinfo.geometrytype
-
-    # First compose the operation to be done on the geometries
-    # If the number of decimals of coordinates should be limited
-    if precision is not None:
-        operation = f"SnapToGrid({{geometrycolumn}}, {precision})"
-    else:
-        operation = "{geometrycolumn}"
-
-    # Prepare sql template for this operation
-    operation = f"ST_MakeValid({operation})"
-
-    # If we want a specific geometrytype as result, extract it
-    if force_output_geometrytype is not GeometryType.GEOMETRYCOLLECTION:
-        primitivetypeid = force_output_geometrytype.to_primitivetype.value
-        operation = f"ST_CollectionExtract({operation}, {primitivetypeid})"
-
-    # Now we can prepare the entire statement
-    sql_template = f"""
-        SELECT {operation} AS geom
-                {{columns_to_select_str}}
-            FROM "{{input_layer}}" layer
-            WHERE 1=1
-            {{batch_filter}}
-    """
-
-    _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name=operation_name,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        sql_dialect="SQLITE",
-        filter_null_geoms=True,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-    # If output is a geopackage, check if all data can be read
-    if validate_attribute_data:
-        output_geofiletype = GeofileType(input_path)
-        if output_geofiletype.is_spatialite_based:
-            _sqlite_util.test_data_integrity(path=input_path)
-
-
-def select(
-    input_path: Path,
-    output_path: Path,
-    sql_stmt: str,
-    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = "SQLITE",
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Optional[GeometryType] = None,
-    nb_parallel: int = 1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Check if output exists already here, to evade to much logging to be written
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop select: output exists already {output_path}")
-            return
-    logger.debug(f"  -> select to execute:\n{sql_stmt}")
-
-    # If no output geometrytype is specified, use the geometrytype of the input layer
-    if force_output_geometrytype is None:
-        force_output_geometrytype = gfo.get_layerinfo(
-            input_path, input_layer
-        ).geometrytype
-        logger.info(
-            "No force_output_geometrytype specified, so defaults to input layer "
-            f"geometrytype: {force_output_geometrytype}"
-        )
-
-    # Go!
-    return _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_stmt,
-        operation_name="select",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        sql_dialect=sql_dialect,
-        filter_null_geoms=False,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def simplify(
-    input_path: Path,
-    output_path: Path,
-    tolerance: float,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Init + prepare sql template for this operation
-    # ----------------------------------------------
-    sql_template = f"""
-        SELECT ST_SimplifyPreserveTopology({{geometrycolumn}}, {tolerance}) AS geom
-                {{columns_to_select_str}}
-            FROM "{{input_layer}}" layer
-            WHERE 1=1
-            {{batch_filter}}
-    """
-
-    # Output geometry type same as input geometry type
-    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
-    return _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="simplify",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=input_layer_info.geometrytype,
-        sql_dialect="SQLITE",
-        filter_null_geoms=True,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def _single_layer_vector_operation(
-    input_path: Path,
-    output_path: Path,
-    sql_template: str,
-    operation_name: str,
-    input_layer: Optional[str],
-    output_layer: Optional[str],
-    columns: Optional[List[str]],
-    explodecollections: bool,
-    force_output_geometrytype: Optional[GeometryType],
-    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]],
-    filter_null_geoms: bool,
-    nb_parallel: int,
-    batchsize: int,
-    force: bool,
-):
-    # Init
-    start_time = datetime.now()
-
-    # Check input parameters...
-    if not input_path.exists():
-        raise ValueError(f"{operation_name}: input_path doesn't exist: {input_path}")
-    if input_path == output_path:
-        raise ValueError(f"{operation_name}: output_path must not equal input_path")
-
-    # Check/get layer names
-    if input_layer is None:
-        input_layer = gfo.get_only_layer(input_path)
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-
-    # If output file exists already, either clean up or return...
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop {operation_name}: output exists already {output_path}")
-            return
-        else:
-            gfo.remove(output_path)
-
-    # Get layer info of the input layer
-    input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
-
-    # Calculate
-    tempdir = _io_util.create_tempdir(f"geofileops/{operation_name.replace(' ', '_')}")
-    try:
-        processing_params = _prepare_processing_params(
-            input1_path=input_path,
-            input1_layer=input_layer,
-            input1_layer_alias="layer",
-            tempdir=tempdir,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            convert_to_spatialite_based=False,
-        )
-        # If None is returned, just stop.
-        if processing_params is None or processing_params.batches is None:
-            return
-
-        # If multiple batches, there should be a batch_filter placeholder sql_template
-        if len(processing_params.batches) > 1:
-            placeholders = [
-                name for _, name, _, _ in string.Formatter().parse(sql_template) if name
-            ]
-            if "batch_filter" not in placeholders:
-                raise ValueError(
-                    "Number batches > 1 requires a batch_filter placeholder in "
-                    f"sql_template {sql_template}"
-                )
-
-        # Format column string for use in select
-        column_formatter = _ogr_sql_util.ColumnFormatter(
-            columns_asked=columns,
-            columns_in_layer=input_layerinfo.columns,
-            fid_column=input_layerinfo.fid_column,
-        )
-
-        # Prepare output filename
-        tmp_output_path = tempdir / output_path.name
-        nb_done = 0
-
-        # Processing in threads is 2x faster for small datasets (on Windows)
-        calculate_in_threads = True if input_layerinfo.featurecount <= 100 else False
-        with _processing_util.PooledExecutorFactory(
-            threadpool=calculate_in_threads,
-            max_workers=processing_params.nb_parallel,
-            initializer=_processing_util.initialize_worker(),
-        ) as calculate_pool:
-            batches = {}
-            future_to_batch_id = {}
-            for batch_id in processing_params.batches:
-                batches[batch_id] = {}
-                batches[batch_id]["layer"] = output_layer
-
-                tmp_partial_output_path = (
-                    tempdir / f"{output_path.stem}_{batch_id}{output_path.suffix}"
-                )
-                batches[batch_id]["tmp_partial_output_path"] = tmp_partial_output_path
-
-                # Now we have everything to format sql statement
-                sql_stmt = sql_template.format(
-                    geometrycolumn=input_layerinfo.geometrycolumn,
-                    columns_to_select_str=column_formatter.prefixed_aliased(),
-                    input_layer=processing_params.batches[batch_id]["layer"],
-                    batch_filter=processing_params.batches[batch_id]["batch_filter"],
-                )
-
-                # Make sure no NULL geoms are outputted...
-                if filter_null_geoms is True:
-                    sql_stmt = f"""
-                        SELECT sub.* FROM
-                          ( {sql_stmt}
-                          ) sub
-                         WHERE sub.geom IS NOT NULL
-                    """
-
-                batches[batch_id]["sql_stmt"] = sql_stmt
-
-                # Remark: this temp file doesn't need spatial index, and even if only
-                # one batch creating the index immediately isn't faster.
-                translate_info = _ogr_util.VectorTranslateInfo(
-                    input_path=processing_params.batches[batch_id]["path"],
-                    output_path=tmp_partial_output_path,
-                    output_layer=output_layer,
-                    sql_stmt=sql_stmt,
-                    sql_dialect=sql_dialect,
-                    explodecollections=explodecollections,
-                    force_output_geometrytype=force_output_geometrytype,
-                    options={"LAYER_CREATION.SPATIAL_INDEX": False},
-                )
-                future = calculate_pool.submit(
-                    _ogr_util.vector_translate_by_info, info=translate_info
-                )
-                future_to_batch_id[future] = batch_id
-
-            # Loop till all parallel processes are ready, but process each one
-            # that is ready already.
-            # Calculating can be done in parallel, but only one process can write to
-            # the same file at the time.
-            for future in futures.as_completed(future_to_batch_id):
-                try:
-                    _ = future.result()
-                except Exception as ex:
-                    batch_id = future_to_batch_id[future]
-                    logger.exception(f"Error executing {batches[batch_id]}")
-                    raise Exception(f"Error executing {batches[batch_id]}") from ex
-
-                # Start copy of the result to a common file
-                # Remark: give higher priority, because this is the slowest factor
-                batch_id = future_to_batch_id[future]
-                tmp_partial_output_path = batches[batch_id]["tmp_partial_output_path"]
-
-                if tmp_partial_output_path.exists():
-                    # If there is only one batch, just rename
-                    if len(processing_params.batches) == 1:
-                        gfo.move(tmp_partial_output_path, tmp_output_path)
-                    else:
-                        fileops._append_to_nolock(
-                            src=tmp_partial_output_path,
-                            dst=tmp_output_path,
-                            explodecollections=explodecollections,
-                            force_output_geometrytype=force_output_geometrytype,
-                            create_spatial_index=False,
-                        )
-                        gfo.remove(tmp_partial_output_path)
-                else:
-                    logger.debug(f"Result file {tmp_partial_output_path} was empty")
-
-                # Log the progress and prediction speed
-                nb_done += 1
-                _general_util.report_progress(
-                    start_time,
-                    nb_done,
-                    len(batches),
-                    operation_name,
-                    nb_parallel=nb_parallel,
-                )
-
-        # Round up and clean up
-        # Now create spatial index and move to output location
-        if tmp_output_path.exists():
-            gfo.create_spatial_index(path=tmp_output_path, layer=output_layer)
-            output_path.parent.mkdir(parents=True, exist_ok=True)
-            gfo.move(tmp_output_path, output_path)
-        else:
-            logger.debug(f"Result of {operation_name} was empty!")
-
-    finally:
-        # Clean tmp dir
-        shutil.rmtree(tempdir)
-        logger.info(f"Processing ready, took {datetime.now()-start_time}!")
-
-
-################################################################################
-# Operations on two layers
-################################################################################
-
-
-def clip(
-    input_path: Path,
-    clip_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    input_columns: Optional[List[str]] = None,
-    clip_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-    input_columns_prefix: str = "",
-    output_with_spatial_index: bool = True,
-):
-    # Init
-    # In the query, important to only extract the geometry types that are expected
-    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
-    primitivetypeid = input_layer_info.geometrytype.to_primitivetype.value
-
-    # If the input type is not point, force the output type to multi,
-    # because erase clip cause eg. polygons to be split to multipolygons...
-    force_output_geometrytype = input_layer_info.geometrytype
-    if force_output_geometrytype is not GeometryType.POINT:
-        force_output_geometrytype = input_layer_info.geometrytype.to_multitype
-
-    # Prepare sql template for this operation
-    # Remarks:
-    #   - ST_intersection(geometry , NULL) gives NULL as result! -> hence the CASE
-    #   - use of the with instead of an inline view is a lot faster
-    #   - WHERE geom IS NOT NULL to evade rows with a NULL geom, they give issues in
-    #     later operations
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_template = f"""
-        SELECT * FROM
-          ( WITH layer2_unioned AS (
-              SELECT layer1.rowid AS layer1_rowid
-                    ,ST_union(layer2.{{input2_geometrycolumn}}) AS geom
-                FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                  ON layer1.fid = layer1tree.id
-                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                  ON layer2.fid = layer2tree.id
-               WHERE 1=1
-                 {{batch_filter}}
-                 AND layer1tree.minx <= layer2tree.maxx
-                 AND layer1tree.maxx >= layer2tree.minx
-                 AND layer1tree.miny <= layer2tree.maxy
-                 AND layer1tree.maxy >= layer2tree.miny
-                 AND ST_Intersects(
-                        layer1.{{input1_geometrycolumn}},
-                        layer2.{{input2_geometrycolumn}}) = 1
-                 AND ST_Touches(
-                        layer1.{{input1_geometrycolumn}},
-                        layer2.{{input2_geometrycolumn}}) = 0
-               GROUP BY layer1.rowid
-            )
-            SELECT CASE WHEN layer2_unioned.geom IS NULL THEN NULL
-                        ELSE ST_CollectionExtract(
-                               ST_intersection(layer1.{{input1_geometrycolumn}},
-                                               layer2_unioned.geom), {primitivetypeid})
-                   END as geom
-                  {{layer1_columns_prefix_alias_str}}
-              FROM {{input1_databasename}}."{{input1_layer}}" layer1
-              JOIN layer2_unioned ON layer1.rowid = layer2_unioned.layer1_rowid
-             WHERE 1=1
-               {{batch_filter}}
-          )
-         WHERE geom IS NOT NULL
-           AND ST_NPoints(geom) > 0
-           -- ST_CollectionExtract outputs empty, but not NULL geoms in spatialite 4.3
-    """
-
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input_path,
-        input2_path=clip_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="clip",
-        input1_layer=input_layer,
-        input1_columns=input_columns,
-        input1_columns_prefix=input_columns_prefix,
-        input2_layer=clip_layer,
-        input2_columns=None,
-        input2_columns_prefix="",
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        output_with_spatial_index=output_with_spatial_index,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def erase(
-    input_path: Path,
-    erase_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    input_columns: Optional[List[str]] = None,
-    erase_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-    input_columns_prefix: str = "",
-    output_with_spatial_index: bool = True,
-):
-    # Init
-    # In the query, important to only extract the geometry types that are expected
-    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
-    primitivetypeid = input_layer_info.geometrytype.to_primitivetype.value
-
-    # If the input type is not point, force the output type to multi,
-    # because erase can cause eg. polygons to be split to multipolygons...
-    force_output_geometrytype = input_layer_info.geometrytype
-    if force_output_geometrytype is not GeometryType.POINT:
-        force_output_geometrytype = input_layer_info.geometrytype.to_multitype
-
-    # Prepare sql template for this operation
-    # Remarks:
-    #   - ST_difference(geometry , NULL) gives NULL as result! -> hence the CASE
-    #   - use of the with instead of an inline view is a lot faster
-    #   - WHERE geom IS NOT NULL to evade rows with a NULL geom, they give issues in
-    #     later operations
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_template = f"""
-        SELECT * FROM
-          ( WITH layer2_unioned AS (
-              SELECT layer1.rowid AS layer1_rowid
-                    ,ST_union(layer2.{{input2_geometrycolumn}}) AS geom
-                FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                  ON layer1.fid = layer1tree.id
-                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                  ON layer2.fid = layer2tree.id
-               WHERE 1=1
-                 {{batch_filter}}
-                 AND layer1tree.minx <= layer2tree.maxx
-                 AND layer1tree.maxx >= layer2tree.minx
-                 AND layer1tree.miny <= layer2tree.maxy
-                 AND layer1tree.maxy >= layer2tree.miny
-                 AND ST_Intersects(
-                        layer1.{{input1_geometrycolumn}},
-                        layer2.{{input2_geometrycolumn}}) = 1
-                 AND ST_Touches(
-                        layer1.{{input1_geometrycolumn}},
-                        layer2.{{input2_geometrycolumn}}) = 0
-               GROUP BY layer1.rowid
-            )
-            SELECT CASE WHEN layer2_unioned.geom IS NULL
-                        THEN layer1.{{input1_geometrycolumn}}
-                        ELSE ST_CollectionExtract(
-                                ST_difference(
-                                    layer1.{{input1_geometrycolumn}},
-                                    layer2_unioned.geom),
-                                    {primitivetypeid})
-                   END as geom
-                  {{layer1_columns_prefix_alias_str}}
-              FROM {{input1_databasename}}."{{input1_layer}}" layer1
-              LEFT JOIN layer2_unioned ON layer1.rowid = layer2_unioned.layer1_rowid
-             WHERE 1=1
-               {{batch_filter}}
-          )
-         WHERE geom IS NOT NULL
-           AND ST_NPoints(geom) > 0
-           -- ST_CollectionExtract outputs empty, but not NULL geoms in spatialite 4.3
-    """
-
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input_path,
-        input2_path=erase_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="erase",
-        input1_layer=input_layer,
-        input1_columns=input_columns,
-        input1_columns_prefix=input_columns_prefix,
-        input2_layer=erase_layer,
-        input2_columns=[],
-        input2_columns_prefix="",
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-        output_with_spatial_index=output_with_spatial_index,
-    )
-
-
-def export_by_location(
-    input_path: Path,
-    input_to_compare_with_path: Path,
-    output_path: Path,
-    min_area_intersect: Optional[float] = None,
-    area_inters_column_name: Optional[str] = "area_inters",
-    input_layer: Optional[str] = None,
-    input_columns: Optional[List[str]] = None,
-    input_to_compare_with_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Prepare sql template for this operation
-    # TODO: test performance difference between the following two queries
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_template = f"""
-        SELECT layer1.{{input1_geometrycolumn}} AS geom
-              {{layer1_columns_prefix_alias_str}}
-          FROM {{input1_databasename}}."{{input1_layer}}" layer1
-          JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-            ON layer1.fid = layer1tree.id
-         WHERE 1=1
-           {{batch_filter}}
-           AND EXISTS (
-              SELECT 1
-                FROM {{input2_databasename}}."{{input2_layer}}" layer2
-                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                  ON layer2.fid = layer2tree.id
-               WHERE layer1tree.minx <= layer2tree.maxx
-                 AND layer1tree.maxx >= layer2tree.minx
-                 AND layer1tree.miny <= layer2tree.maxy
-                 AND layer1tree.maxy >= layer2tree.miny
-                 AND ST_intersects(layer1.{{input1_geometrycolumn}},
-                                   layer2.{{input2_geometrycolumn}}) = 1
-                 AND ST_touches(layer1.{{input1_geometrycolumn}},
-                                layer2.{{input2_geometrycolumn}}) = 0)
-    """
-
-    # Calculate intersect area if necessary
-    area_inters_column_expression = ""
-    if area_inters_column_name is not None or min_area_intersect is not None:
-        if area_inters_column_name is None:
-            area_inters_column_name = "area_inters"
-        area_inters_column_expression = f"""
-            ,ST_area(ST_intersection(
-                 ST_union(layer1.{{input1_geometrycolumn}}),
-                 ST_union(layer2.{{input2_geometrycolumn}})
-             )) AS {area_inters_column_name}
-        """
-
-    # Prepare sql template for this operation
-    sql_template = f"""
-        SELECT ST_union(layer1.{{input1_geometrycolumn}}) as geom
-              {{layer1_columns_prefix_str}}
-              {area_inters_column_expression}
-          FROM {{input1_databasename}}."{{input1_layer}}" layer1
-          JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-            ON layer1.fid = layer1tree.id
-          JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-          JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-            ON layer2.fid = layer2tree.id
-         WHERE 1=1
-           {{batch_filter}}
-           AND layer1tree.minx <= layer2tree.maxx
-           AND layer1tree.maxx >= layer2tree.minx
-           AND layer1tree.miny <= layer2tree.maxy
-           AND layer1tree.maxy >= layer2tree.miny
-           AND ST_Intersects(layer1.{{input1_geometrycolumn}},
-                             layer2.{{input2_geometrycolumn}}) = 1
-           AND ST_Touches(layer1.{{input1_geometrycolumn}},
-                          layer2.{{input2_geometrycolumn}}) = 0
-         GROUP BY layer1.rowid {{layer1_columns_prefix_str}}
-    """
-
-    # Filter on intersect area if necessary
-    if min_area_intersect is not None:
-        sql_template = f"""
-            SELECT sub.* FROM
-              ( {sql_template}
-              ) sub
-             WHERE sub.{area_inters_column_name} >= {min_area_intersect}
-        """
-
-    # Go!
-    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
-    return _two_layer_vector_operation(
-        input1_path=input_path,
-        input2_path=input_to_compare_with_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="export_by_location",
-        input1_layer=input_layer,
-        input1_columns=input_columns,
-        input1_columns_prefix="",
-        input2_layer=input_to_compare_with_layer,
-        input2_columns=[],
-        input2_columns_prefix="",
-        output_layer=output_layer,
-        explodecollections=False,
-        force_output_geometrytype=input_layer_info.geometrytype,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def export_by_distance(
-    input_to_select_from_path: Path,
-    input_to_compare_with_path: Path,
-    output_path: Path,
-    max_distance: float,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input2_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Prepare sql template for this operation
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_template = f"""
-        SELECT geom
-              {{layer1_columns_prefix_alias_str}}
-          FROM {{input1_databasename}}."{{input1_layer}}" layer1
-          JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-            ON layer1.fid = layer1tree.id
-         WHERE 1=1
-               {{batch_filter}}
-               AND EXISTS (
-                    SELECT 1
-                      FROM {{input2_databasename}}."{{input2_layer}}" layer2
-                      JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                        ON layer2.fid = layer2tree.id
-                     WHERE (layer1tree.minx-{max_distance}) <= layer2tree.maxx
-                       AND (layer1tree.maxx+{max_distance}) >= layer2tree.minx
-                       AND (layer1tree.miny-{max_distance}) <= layer2tree.maxy
-                       AND (layer1tree.maxy+{max_distance}) >= layer2tree.miny
-                       AND ST_distance(
-                            layer1.{{input1_geometrycolumn}},
-                            layer2.{{input2_geometrycolumn}}) <= {max_distance})
-    """
-
-    input_layer_info = gfo.get_layerinfo(input_to_select_from_path, input1_layer)
-
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input_to_select_from_path,
-        input2_path=input_to_compare_with_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="export_by_distance",
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix="",
-        input2_layer=input2_layer,
-        input2_columns=[],
-        input2_columns_prefix="",
-        output_layer=output_layer,
-        explodecollections=False,
-        force_output_geometrytype=input_layer_info.geometrytype,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def intersection(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # In the query, important to only extract the geometry types that are expected
-    # TODO: test for geometrycollection, line, point,...
-    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
-    input2_layer_info = gfo.get_layerinfo(input2_path, input2_layer)
-    primitivetype_to_extract = PrimitiveType(
-        min(
-            input1_layer_info.geometrytype.to_primitivetype.value,
-            input2_layer_info.geometrytype.to_primitivetype.value,
-        )
-    )
-
-    # For the output file, if output is going to be polygon or linestring, force
-    # MULTI variant to evade ugly warnings
-    force_output_geometrytype = primitivetype_to_extract.to_multitype
-
-    # Prepare sql template for this operation
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_template = f"""
-        SELECT sub.geom
-             {{layer1_columns_from_subselect_str}}
-             {{layer2_columns_from_subselect_str}}
-          FROM
-            ( SELECT ST_CollectionExtract(
-                       ST_Intersection(
-                            layer1.{{input1_geometrycolumn}},
-                            layer2.{{input2_geometrycolumn}}),
-                            {primitivetype_to_extract.value}) as geom
-                    {{layer1_columns_prefix_alias_str}}
-                    {{layer2_columns_prefix_alias_str}}
-                FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                  ON layer1.fid = layer1tree.id
-                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                  ON layer2.fid = layer2tree.id
-               WHERE 1=1
-                 {{batch_filter}}
-                 AND layer1tree.minx <= layer2tree.maxx
-                 AND layer1tree.maxx >= layer2tree.minx
-                 AND layer1tree.miny <= layer2tree.maxy
-                 AND layer1tree.maxy >= layer2tree.miny
-                 AND ST_Intersects(
-                        layer1.{{input1_geometrycolumn}},
-                        layer2.{{input2_geometrycolumn}}) = 1
-                 AND ST_Touches(
-                        layer1.{{input1_geometrycolumn}},
-                        layer2.{{input2_geometrycolumn}}) = 0
-            ) sub
-         WHERE sub.geom IS NOT NULL
-    """
-
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="intersection",
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def join_by_location(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    spatial_relations_query: str = "intersects is True",
-    discard_nonmatching: bool = True,
-    min_area_intersect: Optional[float] = None,
-    area_inters_column_name: Optional[str] = None,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Prepare sql template for this operation
-    # Prepare intersection area columns/filter
-    area_inters_column_expression = ""
-    area_inters_column_in_output = ""
-    area_inters_column_0_in_output = ""
-    area_inters_filter = ""
-    if area_inters_column_name is not None or min_area_intersect is not None:
-        if area_inters_column_name is not None:
-            area_inters_column_name_touse = area_inters_column_name
-            area_inters_column_in_output = f',"{area_inters_column_name}"'
-            area_inters_column_0_in_output = f',0 AS "{area_inters_column_name}"'
-        else:
-            area_inters_column_name_touse = "area_inters"
-        area_inters_column_expression = (
-            ",ST_area(ST_intersection(sub_filter.geom, sub_filter.l2_geom)) "
-            f'as "{area_inters_column_name_touse}"'
-        )
-        if min_area_intersect is not None:
-            area_inters_filter = (
-                f'WHERE sub_area."{area_inters_column_name_touse}" '
-                f">= {min_area_intersect}"
-            )
-
-    # Prepare spatial relations filter
-    if spatial_relations_query != "intersects is True":
-        # joining should only be possible on features that at least have an
-        # interaction! So, add "intersects is True" to query to evade errors!
-        spatial_relations_query = f"({spatial_relations_query}) and intersects is True"
-    spatial_relations_filter = _prepare_spatial_relations_filter(
-        spatial_relations_query
-    )
-
-    # Prepare sql template
-    #
-    # Remark: use "LIMIT -1 OFFSET 0" to evade that the sqlite query optimizer
-    #     "flattens" the subquery, as that makes checking the spatial
-    #     relations (using ST_RelateMatch) very slow!
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_template = f"""
-        WITH layer1_relations_filtered AS (
-          SELECT sub_area.*
-            FROM (
-              SELECT sub_filter.*
-                    {area_inters_column_expression}
-                FROM (
-                  SELECT layer1.{{input1_geometrycolumn}} as geom
-                        ,layer1.fid l1_fid
-                        ,layer2.{{input2_geometrycolumn}} as l2_geom
-                        {{layer1_columns_prefix_alias_str}}
-                        {{layer2_columns_prefix_alias_str}}
-                        ,ST_relate(layer1.{{input1_geometrycolumn}},
-                                   layer2.{{input2_geometrycolumn}}) as spatial_relation
-                    FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                    JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                      ON layer1.fid = layer1tree.id
-                    JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                    JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                      ON layer2.fid = layer2tree.id
-                   WHERE 1=1
-                     {{batch_filter}}
-                     AND layer1tree.minx <= layer2tree.maxx
-                     AND layer1tree.maxx >= layer2tree.minx
-                     AND layer1tree.miny <= layer2tree.maxy
-                     AND layer1tree.maxy >= layer2tree.miny
-                   LIMIT -1 OFFSET 0
-                  ) sub_filter
-               WHERE {spatial_relations_filter.format(
-                    spatial_relation="sub_filter.spatial_relation")}
-               LIMIT -1 OFFSET 0
-              ) sub_area
-           {area_inters_filter}
-          )
-        SELECT sub.geom
-              {{layer1_columns_from_subselect_str}}
-              {{layer2_columns_from_subselect_str}}
-              ,sub.spatial_relation
-              {area_inters_column_in_output}
-          FROM layer1_relations_filtered sub
-    """
-
-    # If a left join is asked, add all features from layer1 that weren't
-    # matched.
-    if discard_nonmatching is False:
-        sql_template = f"""
-            {sql_template}
-            UNION ALL
-            SELECT layer1.{{input1_geometrycolumn}} as geom
-                  {{layer1_columns_prefix_alias_str}}
-                  {{layer2_columns_prefix_alias_null_str}}
-                  ,NULL as spatial_relation
-                  {area_inters_column_0_in_output}
-              FROM {{input1_databasename}}."{{input1_layer}}" layer1
-             WHERE 1=1
-               {{batch_filter}}
-               AND layer1.fid NOT IN (
-                   SELECT l1_fid FROM layer1_relations_filtered)
-        """
-
-    # Go!
-    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
-    return _two_layer_vector_operation(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="join_by_location",
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        force_output_geometrytype=input1_layer_info.geometrytype,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def _prepare_spatial_relations_filter(query: str) -> str:
-    named_spatial_relations = {
-        # "disjoint": ["FF*FF****"],
-        "equals": ["TFFF*FFF*"],
-        "touches": ["FT*******", "F**T*****", "F***T****"],
-        "within": ["T*F**F***"],
-        "overlaps": ["T*T***T**", "1*T***T**"],
-        "crosses": ["T*T******", "T*****T**", "0********"],
-        "intersects": ["T********", "*T*******", "***T*****", "****T****"],
-        "contains": ["T*****FF*"],
-        "covers": ["T*****FF*", "*T****FF*", "***T**FF*", "****T*FF*"],
-        "coveredby": ["T*F**F***", "*TF**F***", "**FT*F***", "**F*TF***"],
-    }
-
-    # Parse query and replace things that need to be replaced
-    import re
-
-    query_tokens = re.split("([ =()])", query)
-
-    query_tokens_prepared = []
-    nb_unclosed_brackets = 0
-    for token in query_tokens:
-        if token == "":
-            continue
-        elif token in [" ", "\n", "\t", "and", "or"]:
-            query_tokens_prepared.append(token)
-        elif token == "(":
-            nb_unclosed_brackets += 1
-            query_tokens_prepared.append(token)
-        elif token == ")":
-            nb_unclosed_brackets -= 1
-            query_tokens_prepared.append(token)
-        elif token == "is":
-            query_tokens_prepared.append("=")
-        elif token == "True":
-            query_tokens_prepared.append("1")
-        elif token == "False":
-            query_tokens_prepared.append("0")
-        elif token in named_spatial_relations:
-            match_list = []
-            for spatial_relation in named_spatial_relations[token]:
-                match = (
-                    f"ST_RelateMatch({{spatial_relation}}, '{spatial_relation}') = 1"
-                )
-                match_list.append(match)
-            query_tokens_prepared.append(f"({' or '.join(match_list)})")
-        elif len(token) == 9 and re.fullmatch("^[FT012*]+$", token) is not None:
-            token_prepared = f"ST_RelateMatch({{spatial_relation}}, '{token}')"
-            query_tokens_prepared.append(token_prepared)
-        else:
-            raise ValueError(
-                f"Unexpected token in query (query is case sensitive!): {token}"
-            )
-
-    # If there are unclosed brackets, raise
-    if nb_unclosed_brackets > 0:
-        raise ValueError(f"not all brackets are closed in query {query}")
-    elif nb_unclosed_brackets < 0:
-        raise ValueError(f"more closing brackets than opening ones in query {query}")
-
-    result = f"({''.join(query_tokens_prepared)})"
-    return result
-
-
-def join_nearest(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    nb_nearest: int,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Init some things...
-    # Because there is preprocessing done in this function, check output path
-    # here already
-    if output_path.exists() and force is False:
-        logger.info(f"Stop join_nearest: output exists already {output_path}")
-        return
-    if input1_layer is None:
-        input1_layer = gfo.get_only_layer(input1_path)
-    if input2_layer is None:
-        input2_layer = gfo.get_only_layer(input2_path)
-
-    # Prepare input files
-    # To use knn index, the input layers need to be in sqlite file format
-    # (not a .gpkg!), so prepare this
-    if input1_path == input2_path and GeofileType(input1_path) == GeofileType.SQLite:
-        # Input files already ok...
-        input1_tmp_path = input1_path
-        input1_tmp_layer = input1_layer
-        input2_tmp_path = input2_path
-        input2_tmp_layer = input2_layer
-    else:
-        # Put input2 layer in sqlite gfo...
-        tempdir = _io_util.create_tempdir("geofileops/join_nearest")
-        input1_tmp_path = tempdir / "both_input_layers.sqlite"
-        input1_tmp_layer = "input1_layer"
-        gfo.convert(
-            src=input1_path,
-            src_layer=input1_layer,
-            dst=input1_tmp_path,
-            dst_layer=input1_tmp_layer,
-            preserve_fid=True,
-        )
-
-        # Add input2 layer to sqlite gfo...
-        input2_tmp_path = input1_tmp_path
-        input2_tmp_layer = "input2_layer"
-        gfo.append_to(
-            src=input2_path,
-            src_layer=input2_layer,
-            dst=input2_tmp_path,
-            dst_layer=input2_tmp_layer,
-            preserve_fid=True,
-        )
-
-    # Remark: the 2 input layers need to be in one file!
-    sql_template = f"""
-        SELECT layer1.{{input1_geometrycolumn}} as geom
-              {{layer1_columns_prefix_alias_str}}
-              {{layer2_columns_prefix_alias_str}}
-              ,k.pos, k.distance
-          FROM {{input1_databasename}}."{{input1_layer}}" layer1
-          JOIN {{input2_databasename}}.knn k
-          JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-            ON layer2.rowid = k.fid
-         WHERE k.f_table_name = '{{input2_layer}}'
-           AND k.f_geometry_column = '{{input2_geometrycolumn}}'
-           AND k.ref_geometry = layer1.{{input1_geometrycolumn}}
-           AND k.max_items = {nb_nearest}
-           {{batch_filter}}
-    """
-
-    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
-
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input1_tmp_path,
-        input2_path=input2_tmp_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="join_nearest",
-        input1_layer=input1_tmp_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_tmp_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        force_output_geometrytype=input1_layer_info.geometrytype,
-        explodecollections=explodecollections,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-        use_ogr=True,
-    )
-
-
-def select_two_layers(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    sql_stmt: str,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    force_output_geometrytype: Optional[GeometryType] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = 1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        sql_template=sql_stmt,
-        operation_name="select_two_layers",
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def split(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = 1,
-    batchsize: int = -1,
-    force: bool = False,
-    output_with_spatial_index: bool = True,
-):
-    # In the query, important to only extract the geometry types that are
-    # expected, so the primitive type of input1_layer
-    # TODO: test for geometrycollection, line, point,...
-    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
-    primitivetype_to_extract = input1_layer_info.geometrytype.to_primitivetype
-
-    # For the output file, force MULTI variant to evade ugly warnings
-    force_output_geometrytype = primitivetype_to_extract.to_multitype
-
-    # Prepare sql template for this operation
-    # Remarks:
-    #   - ST_difference(geometry , NULL) gives NULL as result! -> hence the CASE
-    #   - the group by layer1.rowid should be directly in the subquery. If it is
-    #     applied on an (other) with it is slow.
-    #   - a left join is a lot faster and memory efficient than a NOT IN or NOT EXISTS.
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_template = f"""
-        SELECT * FROM
-          ( WITH layer2_unioned AS (
-              SELECT layer1.rowid AS layer1_rowid
-                    ,ST_union(layer2.{{input2_geometrycolumn}}) AS geom
-                FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                  ON layer1.fid = layer1tree.id
-                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                  ON layer2.fid = layer2tree.id
-               WHERE 1=1
-                 {{batch_filter}}
-                 AND layer1tree.minx <= layer2tree.maxx
-                 AND layer1tree.maxx >= layer2tree.minx
-                 AND layer1tree.miny <= layer2tree.maxy
-                 AND layer1tree.maxy >= layer2tree.miny
-                 AND ST_Intersects(layer1.{{input1_geometrycolumn}},
-                                   layer2.{{input2_geometrycolumn}}) = 1
-                 AND ST_Touches(layer1.{{input1_geometrycolumn}},
-                                layer2.{{input2_geometrycolumn}}) = 0
-               GROUP BY layer1.rowid
-            )
-            SELECT ST_CollectionExtract(
-                        ST_intersection(layer1.{{input1_geometrycolumn}},
-                                        layer2.{{input2_geometrycolumn}}),
-                        {primitivetype_to_extract.value}) as geom
-                  {{layer1_columns_prefix_alias_str}}
-                  {{layer2_columns_prefix_alias_str}}
-              FROM {{input1_databasename}}."{{input1_layer}}" layer1
-              JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                ON layer1.fid = layer1tree.id
-              JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-              JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                ON layer2.fid = layer2tree.id
-             WHERE 1=1
-               {{batch_filter}}
-               AND layer1tree.minx <= layer2tree.maxx
-               AND layer1tree.maxx >= layer2tree.minx
-               AND layer1tree.miny <= layer2tree.maxy
-               AND layer1tree.maxy >= layer2tree.miny
-               AND ST_Intersects(layer1.{{input1_geometrycolumn}},
-                                 layer2.{{input2_geometrycolumn}}) = 1
-               AND ST_Touches(layer1.{{input1_geometrycolumn}},
-                              layer2.{{input2_geometrycolumn}}) = 0
-            UNION ALL
-            SELECT CASE WHEN layer2_unioned.geom IS NULL
-                        THEN layer1.{{input1_geometrycolumn}}
-                        ELSE ST_CollectionExtract(
-                                ST_difference(layer1.{{input1_geometrycolumn}},
-                                              layer2_unioned.geom),
-                                {primitivetype_to_extract.value})
-                   END as geom
-                  {{layer1_columns_prefix_alias_str}}
-                  {{layer2_columns_prefix_alias_null_str}}
-              FROM {{input1_databasename}}."{{input1_layer}}" layer1
-              LEFT JOIN layer2_unioned ON layer1.rowid = layer2_unioned.layer1_rowid
-             WHERE 1=1
-               {{batch_filter}}
-           )
-         WHERE geom IS NOT NULL
-           AND ST_NPoints(geom) > 0
-    """
-
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="split",
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-        output_with_spatial_index=output_with_spatial_index,
-    )
-
-
-def symmetric_difference(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # A symmetric difference can be simulated by doing an "erase" of input1
-    # and input2 and then append the result of an erase of input2 with
-    # input1...
-
-    # Because both erase calculations will be towards temp files,
-    # we need to do some additional init + checks here...
-    if force is False and output_path.exists():
-        return
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-
-    tempdir = _io_util.create_tempdir("geofileops/symmdiff")
-    try:
-        # First erase input2 from input1 to a temporary output file
-        erase1_output_path = tempdir / "layer1_erase_layer2_output.gpkg"
-        erase(
-            input_path=input1_path,
-            erase_path=input2_path,
-            output_path=erase1_output_path,
-            input_layer=input1_layer,
-            input_columns=input1_columns,
-            input_columns_prefix=input1_columns_prefix,
-            erase_layer=input2_layer,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-            output_with_spatial_index=False,
-        )
-
-        if input2_columns is None or len(input2_columns) > 0:
-            input2_info = gfo.get_layerinfo(input2_path)
-            columns_to_add = (
-                input2_columns if input2_columns is not None else input2_info.columns
-            )
-            for column in columns_to_add:
-                gfo.add_column(
-                    erase1_output_path,
-                    name=f"{input2_columns_prefix}{column}",
-                    type=input2_info.columns[column].gdal_type,
-                )
-
-        # Now erase input1 from input2 to another temporary output file
-        erase2_output_path = tempdir / "layer2_erase_layer1_output.gpkg"
-        erase(
-            input_path=input2_path,
-            erase_path=input1_path,
-            output_path=erase2_output_path,
-            input_layer=input2_layer,
-            input_columns=input2_columns,
-            input_columns_prefix=input2_columns_prefix,
-            erase_layer=input1_layer,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-            output_with_spatial_index=False,
-        )
-
-        # Now append
-        _append_to_nolock(
-            src=erase2_output_path,
-            dst=erase1_output_path,
-            src_layer=output_layer,
-            dst_layer=output_layer,
-        )
-
-        # Convert or add spatial index
-        tmp_output_path = erase1_output_path
-        if erase1_output_path.suffix != output_path.suffix:
-            # Output file should be in diffent format, so convert
-            tmp_output_path = tempdir / output_path.name
-            gfo.convert(src=erase1_output_path, dst=tmp_output_path)
-        else:
-            # Create spatial index
-            gfo.create_spatial_index(path=tmp_output_path, layer=output_layer)
-
-        # Now we are ready to move the result to the final spot...
-        if output_path.exists():
-            gfo.remove(output_path)
-        gfo.move(tmp_output_path, output_path)
-
-    finally:
-        shutil.rmtree(tempdir)
-
-
-def union(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # A union can be simulated by doing a "split" of input1 and input2 and
-    # then append the result of an erase of input2 with input1...
-
-    # Because the calculations in split and erase will be towards temp files,
-    # we need to do some additional init + checks here...
-    if force is False and output_path.exists():
-        return
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-
-    start_time = datetime.now()
-    tempdir = _io_util.create_tempdir("geofileops/union")
-    try:
-        # First split input1 with input2 to a temporary output gfo...
-        split_output_path = tempdir / "split_output.gpkg"
-        split(
-            input1_path=input1_path,
-            input2_path=input2_path,
-            output_path=split_output_path,
-            input1_layer=input1_layer,
-            input1_columns=input1_columns,
-            input1_columns_prefix=input1_columns_prefix,
-            input2_layer=input2_layer,
-            input2_columns=input2_columns,
-            input2_columns_prefix=input2_columns_prefix,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-            output_with_spatial_index=False,
-        )
-
-        # Now erase input1 from input2 to another temporary output gfo...
-        erase_output_path = tempdir / "erase_output.gpkg"
-        erase(
-            input_path=input2_path,
-            erase_path=input1_path,
-            output_path=erase_output_path,
-            input_layer=input2_layer,
-            input_columns=input2_columns,
-            input_columns_prefix=input2_columns_prefix,
-            erase_layer=input1_layer,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-            output_with_spatial_index=False,
-        )
-
-        # Now append
-        _append_to_nolock(
-            src=erase_output_path,
-            dst=split_output_path,
-            src_layer=output_layer,
-            dst_layer=output_layer,
-        )
-
-        # Convert or add spatial index
-        tmp_output_path = split_output_path
-        if split_output_path.suffix != output_path.suffix:
-            # Output file should be in different format, so convert
-            tmp_output_path = tempdir / output_path.name
-            gfo.convert(src=split_output_path, dst=tmp_output_path)
-        else:
-            # Create spatial index
-            gfo.create_spatial_index(path=tmp_output_path, layer=output_layer)
-
-        # Now we are ready to move the result to the final spot...
-        if output_path.exists():
-            gfo.remove(output_path)
-        gfo.move(tmp_output_path, output_path)
-
-    finally:
-        shutil.rmtree(tempdir)
-
-    logger.info(f"union ready, took {datetime.now()-start_time}!")
-
-
-def _two_layer_vector_operation(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    sql_template: str,
-    operation_name: str,
-    input1_layer: Optional[str],
-    input1_columns: Optional[List[str]],
-    input1_columns_prefix: str,
-    input2_layer: Optional[str],
-    input2_columns: Optional[List[str]],
-    input2_columns_prefix: str,
-    output_layer: Optional[str],
-    explodecollections: bool,
-    force_output_geometrytype: Optional[GeometryType],
-    nb_parallel: int,
-    batchsize: int,
-    force: bool,
-    use_ogr: bool = False,
-    output_with_spatial_index: bool = True,
-):
-    """
-    Executes an operation that needs 2 input files.
-
-    Args:
-        input1_path (str): the file to export features from
-        input2_path (str): the file to check intersections with
-        output_path (str): output file
-        input1_layer (str, optional): [description]. Defaults to None.
-        input1_columns
-        input1_columns_prefix
-        input2_layer (str, optional): [description]. Defaults to None.
-        input2_columns
-        input2_columns_prefix
-        output_layer (str, optional): [description]. Defaults to None.
-        explodecollections (bool, optional): Explode collecions in output.
-            Defaults to False.
-        force_output_geometrytype (GeometryType, optional): Defaults to None.
-        use_ogr (bool, optional): If True, ogr is used to do the processing,
-            In this case different input files (input1_path, input2_path) are
-            NOT supported. If False, sqlite3 is used directly.
-            Defaults to False.
-        nb_parallel (int, optional): [description]. Defaults to -1.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): [description]. Defaults to False.
-        output_with_spatial_index (bool, optional): True to create output file with
-            spatial index. Defaults to True.
-
-    Raises:
-        ValueError: [description]
-    """
-    # Init
-    if not input1_path.exists():
-        raise ValueError(f"{operation_name}: input1_path doesn't exist: {input1_path}")
-    if not input2_path.exists():
-        raise ValueError(f"{operation_name}: input2_path doesn't exist: {input2_path}")
-    if input1_path == output_path or input2_path == output_path:
-        raise ValueError(
-            f"{operation_name}: output_path must not equal one of input paths"
-        )
-    if use_ogr is True and input1_path != input2_path:
-        raise ValueError(
-            f"{operation_name}: if use_ogr True, input1_path == input2_path!"
-        )
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop {operation_name}: output exists already {output_path}")
-            return
-        else:
-            gfo.remove(output_path)
-
-    # Check if spatialite is properly installed to execute this query
-    _sqlite_util.check_runtimedependencies()
-
-    # Init layer info
-    start_time = datetime.now()
-    if input1_layer is None:
-        input1_layer = gfo.get_only_layer(input1_path)
-    if input2_layer is None:
-        input2_layer = gfo.get_only_layer(input2_path)
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-    tempdir = _io_util.create_tempdir(f"geofileops/{operation_name}")
-
-    # Use get_layerinfo to check if the input files are valid
-    gfo.get_layerinfo(input1_path, input1_layer)
-    gfo.get_layerinfo(input2_path, input2_layer)
-
-    # Prepare output filename
-    tmp_output_path = tempdir / output_path.name
-    tmp_output_path.parent.mkdir(exist_ok=True, parents=True)
-    gfo.remove(tmp_output_path)
-
-    try:
-        # Prepare tmp files/batches
-        logger.info(
-            f"Prepare input (params) for {operation_name} with tempdir: {tempdir}"
-        )
-        processing_params = _prepare_processing_params(
-            input1_path=input1_path,
-            input1_layer=input1_layer,
-            input1_layer_alias="layer1",
-            input2_path=input2_path,
-            input2_layer=input2_layer,
-            tempdir=tempdir,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            convert_to_spatialite_based=True,
-        )
-        if processing_params is None or processing_params.batches is None:
-            return
-
-        # If multiple batches, there should be a batch_filter placeholder sql_template
-        if len(processing_params.batches) > 1:
-            placeholders = [
-                name for _, name, _, _ in string.Formatter().parse(sql_template) if name
-            ]
-            if "batch_filter" not in placeholders:
-                raise ValueError(
-                    "Number batches > 1 requires a batch_filter placeholder in "
-                    f"sql_template {sql_template}"
-                )
-
-        # Prepare column names,... to format the select
-        # Format column strings for use in select
-        assert processing_params.input1_path is not None
-        input1_tmp_layerinfo = gfo.get_layerinfo(
-            processing_params.input1_path, processing_params.input1_layer
-        )
-        input1_col_strs = _ogr_sql_util.ColumnFormatter(
-            columns_asked=input1_columns,
-            columns_in_layer=input1_tmp_layerinfo.columns,
-            fid_column=input1_tmp_layerinfo.fid_column,
-            table_alias="layer1",
-            column_alias_prefix=input1_columns_prefix,
-        )
-        assert processing_params.input2_path is not None
-        input2_tmp_layerinfo = gfo.get_layerinfo(
-            processing_params.input2_path, processing_params.input2_layer
-        )
-        input2_col_strs = _ogr_sql_util.ColumnFormatter(
-            columns_asked=input2_columns,
-            columns_in_layer=input2_tmp_layerinfo.columns,
-            fid_column=input2_tmp_layerinfo.fid_column,
-            table_alias="layer2",
-            column_alias_prefix=input2_columns_prefix,
-        )
-
-        # Check input crs'es
-        if input1_tmp_layerinfo.crs != input2_tmp_layerinfo.crs:
-            logger.warning(
-                "input1 has a different crs than input2: \n\tinput1: "
-                f"{input1_tmp_layerinfo.crs} \n\tinput2: {input2_tmp_layerinfo.crs}"
-            )
-
-        # Calculate
-        # Processing in threads is 2x faster for small datasets (on Windows)
-        calculate_in_threads = (
-            True if input1_tmp_layerinfo.featurecount <= 100 else False
-        )
-        logger.info(
-            f"Start {operation_name} ({processing_params.nb_parallel} parallel workers)"
-        )
-        with _processing_util.PooledExecutorFactory(
-            threadpool=calculate_in_threads,
-            max_workers=processing_params.nb_parallel,
-            initializer=_processing_util.initialize_worker(),
-        ) as calculate_pool:
-            # Start looping
-            batches = {}
-            future_to_batch_id = {}
-            for batch_id in processing_params.batches:
-                batches[batch_id] = {}
-                batches[batch_id]["layer"] = output_layer
-
-                tmp_partial_output_path = (
-                    tempdir / f"{output_path.stem}_{batch_id}.gpkg"
-                )
-                batches[batch_id]["tmp_partial_output_path"] = tmp_partial_output_path
-
-                # Keep input1_tmp_layer and input2_tmp_layer for backwards
-                # compatibility
-                sql_stmt = sql_template.format(
-                    input1_databasename="{input1_databasename}",
-                    input2_databasename="{input2_databasename}",
-                    layer1_columns_from_subselect_str=input1_col_strs.from_subselect(),
-                    layer1_columns_prefix_alias_str=input1_col_strs.prefixed_aliased(),
-                    layer1_columns_prefix_str=input1_col_strs.prefixed(),
-                    input1_layer=processing_params.batches[batch_id]["layer"],
-                    input1_tmp_layer=processing_params.batches[batch_id]["layer"],
-                    input1_geometrycolumn=input1_tmp_layerinfo.geometrycolumn,
-                    layer2_columns_from_subselect_str=input2_col_strs.from_subselect(),
-                    layer2_columns_prefix_alias_str=input2_col_strs.prefixed_aliased(),
-                    layer2_columns_prefix_str=input2_col_strs.prefixed(),
-                    layer2_columns_prefix_alias_null_str=input2_col_strs.null_aliased(),
-                    input2_layer=processing_params.input2_layer,
-                    input2_tmp_layer=processing_params.input2_layer,
-                    input2_geometrycolumn=input2_tmp_layerinfo.geometrycolumn,
-                    batch_filter=processing_params.batches[batch_id]["batch_filter"],
-                )
-
-                batches[batch_id]["sqlite_stmt"] = sql_stmt
-
-                # Remark: this temp file doesn't need spatial index
-                if use_ogr is False:
-                    # Use an aggressive speedy sqlite profile
-                    future = calculate_pool.submit(
-                        _sqlite_util.create_table_as_sql,
-                        input1_path=processing_params.batches[batch_id]["path"],
-                        input1_layer=processing_params.batches[batch_id]["layer"],
-                        input2_path=processing_params.input2_path,
-                        output_path=tmp_partial_output_path,
-                        sql_stmt=sql_stmt,
-                        output_layer=output_layer,
-                        output_geometrytype=force_output_geometrytype,
-                        create_spatial_index=False,
-                        profile=_sqlite_util.SqliteProfile.SPEED,
-                    )
-                    future_to_batch_id[future] = batch_id
-                else:
-                    # Use ogr to run the query
-                    #   * input2 path (= using attach) doesn't seem to work
-                    #   * ogr doesn't fill out database names, so do it now
-                    sql_stmt = sql_stmt.format(
-                        input1_databasename=processing_params.input1_databasename,
-                        input2_databasename=processing_params.input2_databasename,
-                    )
-
-                    future = calculate_pool.submit(
-                        _ogr_util.vector_translate,
-                        input_path=processing_params.batches[batch_id]["path"],
-                        output_path=tmp_partial_output_path,
-                        sql_stmt=sql_stmt,
-                        output_layer=output_layer,
-                        explodecollections=explodecollections,
-                        force_output_geometrytype=force_output_geometrytype,
-                        options={"LAYER_CREATION.SPATIAL_INDEX": False},
-                    )
-                future_to_batch_id[future] = batch_id
-
-            # Loop till all parallel processes are ready, but process each one
-            # that is ready already
-            nb_done = 0
-            _general_util.report_progress(
-                start_time,
-                nb_done,
-                len(processing_params.batches),
-                operation_name,
-                processing_params.nb_parallel,
-            )
-            for future in futures.as_completed(future_to_batch_id):
-                try:
-                    # Get the result
-                    result = future.result()
-                    if result is not None:
-                        logger.debug(result)
-
-                    # If the calculate gave results, copy/append to output
-                    batch_id = future_to_batch_id[future]
-                    tmp_partial_output_path = batches[batch_id][
-                        "tmp_partial_output_path"
-                    ]
-                    if (
-                        tmp_partial_output_path.exists()
-                        and tmp_partial_output_path.stat().st_size > 0
-                    ):
-                        # If only one batch, immediately create index.
-                        # Remark: copying the file using ogr is still necessary, even
-                        # if only 1 batch, because apparently gpkg created with
-                        # create_table_as_sql isn't 100% OK: impossible to create a
-                        # valid spatial index on it.
-                        create_spatial_index = False
-                        if (
-                            output_with_spatial_index
-                            and len(processing_params.batches) == 1
-                        ):
-                            create_spatial_index = True
-                        fileops._append_to_nolock(
-                            src=tmp_partial_output_path,
-                            dst=tmp_output_path,
-                            explodecollections=explodecollections,
-                            force_output_geometrytype=force_output_geometrytype,
-                            create_spatial_index=create_spatial_index,
-                        )
-                    else:
-                        logger.debug(f"Result file {tmp_partial_output_path} was empty")
-
-                    # Cleanup tmp partial file
-                    gfo.remove(tmp_partial_output_path, missing_ok=True)
-
-                except Exception as ex:
-                    batch_id = future_to_batch_id[future]
-                    raise Exception(f"Error executing {batches[batch_id]}") from ex
-
-                # Log the progress and prediction speed
-                nb_done += 1
-                _general_util.report_progress(
-                    start_time=start_time,
-                    nb_done=nb_done,
-                    nb_todo=len(processing_params.batches),
-                    operation=operation_name,
-                    nb_parallel=processing_params.nb_parallel,
-                )
-
-        # Round up and clean up
-        # Now create spatial index and move to output location
-        if tmp_output_path.exists():
-            if output_with_spatial_index:
-                gfo.create_spatial_index(
-                    path=tmp_output_path, layer=output_layer, exist_ok=True
-                )
-            if tmp_output_path != output_path:
-                output_path.parent.mkdir(parents=True, exist_ok=True)
-                gfo.move(tmp_output_path, output_path)
-        else:
-            logger.debug(f"Result of {operation_name} was empty!")
-
-        logger.info(f"{operation_name} ready, took {datetime.now()-start_time}!")
-    except Exception:
-        gfo.remove(output_path, missing_ok=True)
-        gfo.remove(tmp_output_path, missing_ok=True)
-        raise
-    finally:
-        shutil.rmtree(tempdir)
-
-
-class ProcessingParams:
-    def __init__(
-        self,
-        input1_path: Optional[Path] = None,
-        input1_layer: Optional[str] = None,
-        input1_databasename: Optional[str] = None,
-        input2_path: Optional[Path] = None,
-        input2_layer: Optional[str] = None,
-        input2_databasename: Optional[str] = None,
-        nb_parallel: int = -1,
-        batches: Optional[dict] = None,
-    ):
-        self.input1_path = input1_path
-        self.input1_layer = input1_layer
-        self.input1_databasename = input1_databasename
-        self.input2_path = input2_path
-        self.input2_layer = input2_layer
-        self.input2_databasename = input2_databasename
-        self.nb_parallel = nb_parallel
-        self.batches = batches
-
-
-def _prepare_processing_params(
-    input1_path: Path,
-    input1_layer: str,
-    tempdir: Path,
-    convert_to_spatialite_based: bool,
-    nb_parallel: int,
-    batchsize: int = -1,
-    input1_layer_alias: Optional[str] = None,
-    input2_path: Optional[Path] = None,
-    input2_layer: Optional[str] = None,
-) -> Optional[ProcessingParams]:
-    # Init
-    returnvalue = ProcessingParams(nb_parallel=nb_parallel)
-    input1_layerinfo = gfo.get_layerinfo(input1_path, input1_layer)
-
-    # Determine the optimal number of parallel processes + batches
-    if returnvalue.nb_parallel == -1:
-        # If no batch size specified, put at least 100 rows in a batch
-        if batchsize <= 0:
-            min_rows_per_batch = 100
-        else:
-            # If batchsize is specified, use the batch size
-            min_rows_per_batch = batchsize
-
-        max_parallel = max(int(input1_layerinfo.featurecount / min_rows_per_batch), 1)
-        returnvalue.nb_parallel = min(multiprocessing.cpu_count(), max_parallel)
-
-    # Determine optimal number of batches
-    # Remark: especially for 'select' operation, if nb_parallel is 1
-    #         nb_batches should be 1 (select might give wrong results)
-    if returnvalue.nb_parallel > 1:
-        # Limit number of rows processed in parallel to limit memory use
-        if batchsize > 0:
-            max_rows_parallel = batchsize * returnvalue.nb_parallel
-        else:
-            max_rows_parallel = 1000000
-            if input2_path is not None:
-                max_rows_parallel = 200000
-
-        # Adapt number of batches to max_rows_parallel
-        if input1_layerinfo.featurecount > max_rows_parallel:
-            # If more rows than can be handled simultanously in parallel
-            nb_batches = int(
-                input1_layerinfo.featurecount
-                / (max_rows_parallel / returnvalue.nb_parallel)
-            )
-        elif batchsize > 0:
-            # If a batchsize is specified, try to honer it
-            nb_batches = returnvalue.nb_parallel
-        else:
-            # If no batchsize specified and 2 layer processing, add some batches to
-            # reduce impact of possible unbalanced batches on total processing time.
-            nb_batches = returnvalue.nb_parallel
-            if input2_path is not None:
-                nb_batches = returnvalue.nb_parallel * 2
-
-    elif batchsize > 0:
-        nb_batches = math.ceil(input1_layerinfo.featurecount / batchsize)
-    else:
-        nb_batches = 1
-
-    # Prepare input files for the calculation
-    returnvalue.input1_layer = input1_layer
-    returnvalue.input2_layer = input2_layer
-
-    if convert_to_spatialite_based is False:
-        returnvalue.input1_path = input1_path
-        returnvalue.input2_path = input2_path
-    else:
-        # Check if the input files are of the correct geofiletype
-        input1_geofiletype = GeofileType(input1_path)
-        input2_geofiletype = None
-        if input2_path is not None:
-            input2_geofiletype = GeofileType(input2_path)
-
-        # If input files are of the same format + are spatialite compatible,
-        # just use them
-        if input1_geofiletype.is_spatialite_based and (
-            input2_geofiletype is None or input1_geofiletype == input2_geofiletype
-        ):
-            returnvalue.input1_path = input1_path
-            if input1_geofiletype == GeofileType.GPKG:
-                # HasSpatialindex doesn't work for spatialite file
-                gfo.create_spatial_index(input1_path, input1_layer, exist_ok=True)
-        else:
-            # If not ok, copy the input layer to gpkg
-            returnvalue.input1_path = tempdir / f"{input1_path.stem}.gpkg"
-            gfo.convert(
-                src=input1_path,
-                src_layer=input1_layer,
-                dst=returnvalue.input1_path,
-                dst_layer=returnvalue.input1_layer,
-                preserve_fid=True,
-            )
-
-        if input2_path is not None and input2_geofiletype is not None:
-            if (
-                input2_geofiletype == input1_geofiletype
-                and input2_geofiletype.is_spatialite_based
-            ):
-                returnvalue.input2_path = input2_path
-                if input2_geofiletype == GeofileType.GPKG:
-                    # HasSpatialindex doesn't work for spatialite file
-                    gfo.create_spatial_index(input2_path, input2_layer, exist_ok=True)
-            else:
-                # If not spatialite compatible, copy the input layer to gpkg
-                returnvalue.input2_path = tempdir / f"{input2_path.stem}.gpkg"
-                gfo.convert(
-                    src=input2_path,
-                    src_layer=input2_layer,
-                    dst=returnvalue.input2_path,
-                    dst_layer=returnvalue.input2_layer,
-                    preserve_fid=True,
-                )
-
-    # Fill out the database names to use in the sql statements
-    returnvalue.input1_databasename = "main"
-    if input2_path is None or input1_path == input2_path:
-        returnvalue.input2_databasename = returnvalue.input1_databasename
-    else:
-        returnvalue.input2_databasename = "input2"
-
-    # Prepare batches to process
-    # Get column names and info
-    layer1_info = gfo.get_layerinfo(returnvalue.input1_path, returnvalue.input1_layer)
-
-    # Check number of batches + appoint nb rows to batches
-    nb_rows_input_layer = layer1_info.featurecount
-    if nb_batches > int(nb_rows_input_layer / 10):
-        nb_batches = max(int(nb_rows_input_layer / 10), 1)
-
-    batches = {}
-    if nb_batches == 1:
-        # If only one batch, no filtering is needed
-        batches[0] = {}
-        batches[0]["layer"] = returnvalue.input1_layer
-        batches[0]["path"] = returnvalue.input1_path
-        batches[0]["batch_filter"] = ""
-    else:
-        # Determine the min_rowid and max_rowid
-        # Remark: SELECT MIN(rowid), MAX(rowid) FROM ... is a lot slower than UNION ALL!
-        sql_stmt = f"""
-            SELECT MIN(rowid) minmax_rowid FROM "{layer1_info.name}"
-            UNION ALL
-            SELECT MAX(rowid) minmax_rowid FROM "{layer1_info.name}"
-        """
-        batch_info_df = gfo.read_file(
-            path=returnvalue.input1_path, sql_stmt=sql_stmt, sql_dialect="SQLITE"
-        )
-        min_rowid = pd.to_numeric(batch_info_df["minmax_rowid"][0]).item()
-        max_rowid = pd.to_numeric(batch_info_df["minmax_rowid"][1]).item()
-
-        # Determine the exact batches to use
-        if ((max_rowid - min_rowid) / nb_rows_input_layer) < 1.1:
-            # If the rowid's are quite consecutive, use an imperfect, but
-            # fast distribution in batches
-            batch_info_list = []
-            nb_rows_per_batch = round(nb_rows_input_layer / nb_batches)
-            offset = 0
-            offset_per_batch = round((max_rowid - min_rowid) / nb_batches)
-            for batch_id in range(nb_batches):
-                start_rowid = offset
-                if batch_id < (nb_batches - 1):
-                    # End rowid for this batch is the next start_rowid - 1
-                    end_rowid = offset + offset_per_batch - 1
-                else:
-                    # For the last batch, take the max_rowid so no rowid's are
-                    # 'lost' due to rounding errors
-                    end_rowid = max_rowid
-                batch_info_list.append(
-                    (batch_id, nb_rows_per_batch, start_rowid, end_rowid)
-                )
-                offset += offset_per_batch
-            batch_info_df = pd.DataFrame(
-                batch_info_list, columns=["id", "nb_rows", "start_rowid", "end_rowid"]
-            )
-        else:
-            # The rowids are not consecutive, so determine the optimal rowid
-            # ranges for each batch so each batch has same number of elements
-            # Remark: this might take some seconds for larger datasets!
-            sql_stmt = f"""
-                SELECT batch_id AS id
-                      ,COUNT(*) AS nb_rows
-                      ,MIN(rowid) AS start_rowid
-                      ,MAX(rowid) AS end_rowid
-                  FROM
-                    ( SELECT rowid
-                            ,NTILE({nb_batches}) OVER (ORDER BY rowid) batch_id
-                        FROM "{layer1_info.name}"
-                    )
-                 GROUP BY batch_id;
-            """
-            batch_info_df = gfo.read_file(
-                path=returnvalue.input1_path, sql_stmt=sql_stmt
-            )
-
-        # Prepare the layer alias to use in the batch filter
-        layer_alias_d = ""
-        if input1_layer_alias is not None:
-            layer_alias_d = f"{input1_layer_alias}."
-
-        # Now loop over all batch ranges to build up the necessary filters
-        for batch_info in batch_info_df.itertuples():
-            # Fill out the batch properties
-            batches[batch_info.id] = {}
-            batches[batch_info.id]["layer"] = returnvalue.input1_layer
-            batches[batch_info.id]["path"] = returnvalue.input1_path
-
-            # The batch filter
-            if batch_info.id < nb_batches:
-                batches[batch_info.id]["batch_filter"] = (
-                    f"AND ({layer_alias_d}rowid >= {batch_info.start_rowid} "
-                    f"AND {layer_alias_d}rowid <= {batch_info.end_rowid}) "
-                )
-            else:
-                batches[batch_info.id][
-                    "batch_filter"
-                ] = f"AND {layer_alias_d}rowid >= {batch_info.start_rowid} "
-
-    # No use starting more processes than the number of batches...
-    if len(batches) < returnvalue.nb_parallel:
-        returnvalue.nb_parallel = len(batches)
-
-    returnvalue.batches = batches
-    return returnvalue
-
-
-def dissolve_singlethread(
-    input_path: Path,
-    output_path: Path,
-    groupby_columns: Union[str, Iterable[str], None] = None,
-    agg_columns: Optional[dict] = None,
-    explodecollections: bool = False,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    force: bool = False,
-):
-    """
-    Remark: this is not a parallelized version!!!
-    """
-    # Init
-    start_time = datetime.now()
-
-    # Check input params
-    if not input_path.exists():
-        raise ValueError(f"input_path doesn't exist: {input_path}")
-    if input_path == output_path:
-        raise ValueError("output_path must not equal input_path")
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop dissolve: Output exists already {output_path}")
-            return
-        else:
-            gfo.remove(output_path)
-
-    # Check layer names
-    if input_layer is None:
-        input_layer = gfo.get_only_layer(input_path)
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-
-    # Use get_layerinfo to check if the layer definition is OK
-    layerinfo = gfo.get_layerinfo(input_path, input_layer)
-    fid_column = layerinfo.fid_column if layerinfo.fid_column != "" else "rowid"
-    # Prepare some lists for later use
-    columns_available = list(layerinfo.columns) + ["fid"]
-    columns_available_upper = [column.upper() for column in columns_available]
-    groupby_columns_upper_dict = {}
-    if groupby_columns is not None:
-        groupby_columns_upper_dict = {col.upper(): col for col in groupby_columns}
-
-    # Prepare the strings regarding groupby_columns to use in the select statement.
-    if groupby_columns is not None:
-        # Standardize parameter to simplify the rest of the code
-        if isinstance(groupby_columns, str):
-            # If a string is passed, convert to list
-            groupby_columns = [groupby_columns]
-
-        # Check if all groupby columns exist
-        for column in groupby_columns:
-            if column.upper() not in columns_available_upper:
-                raise ValueError(f"column in groupby_columns not in input: {column}")
-
-        # Because the query uses a subselect, the groupby columns need to be prefixed.
-        columns_prefixed = [f'layer."{column}"' for column in groupby_columns]
-        groupby_columns_for_groupby_str = ", ".join(columns_prefixed)
-        columns_prefixed_aliased = [
-            f'layer."{column}" "{column}"' for column in groupby_columns
-        ]
-        groupby_columns_for_select_str = f", {', '.join(columns_prefixed_aliased)}"
-    else:
-        # Even if no groupby is provided, we still need to use a groupby clause,
-        # otherwise ST_union doesn't seem to work.
-        groupby_columns_for_groupby_str = "'1'"
-        groupby_columns_for_select_str = ""
-
-    # Prepare the strings regarding agg_columns to use in the select statement.
-    agg_columns_str = ""
-    if agg_columns is not None:
-        # Validate the dict structure, so we can assume everything is OK further on
-        _parameter_helper.validate_agg_columns(agg_columns)
-
-        # Start preparation of agg_columns_str
-        if "json" in agg_columns:
-            # Determine the columns to be put in json
-            columns = []
-            if agg_columns["json"] is None:
-                # If columns specified is None: all columns not in groupby_columns
-                for column in layerinfo.columns:
-                    if column.upper() not in groupby_columns_upper_dict:
-                        columns.append(column)
-            else:
-                for column in agg_columns["json"]:
-                    columns.append(column)
-            json_columns = [f"'{column}', layer.\"{column}\"" for column in columns]
-
-            # The fid should be added as well, but make name unique
-            fid_orig_column = "fid_orig"
-            for idx in range(0, 99999):
-                if idx != 0:
-                    fid_orig_column = f"fid_orig{idx}"
-                if fid_orig_column not in columns:
-                    break
-            json_columns.append(f"'{fid_orig_column}', layer.\"{fid_column}\"")
-
-            # Now we are ready to prepare final str
-            agg_columns_str = (
-                f", json_group_array(json_object({', '.join(json_columns)})) as json"
-            )
-        elif "columns" in agg_columns:
-            for agg_column in agg_columns["columns"]:
-                # Init
-                distinct_str = ""
-                extra_param_str = ""
-
-                # Prepare aggregation keyword
-                if agg_column["agg"].lower() in [
-                    "count",
-                    "sum",
-                    "min",
-                    "max",
-                    "median",
-                ]:
-                    aggregation_str = agg_column["agg"]
-                elif agg_column["agg"].lower() in ["mean", "avg"]:
-                    aggregation_str = "avg"
-                elif agg_column["agg"].lower() == "concat":
-                    aggregation_str = "group_concat"
-                    if "sep" in agg_column:
-                        extra_param_str = f", '{agg_column['sep']}'"
-                else:
-                    raise ValueError(f"aggregation {agg_column['agg']} not supported!")
-
-                # If distinct is specified, add the distinct keyword
-                if "distinct" in agg_column and agg_column["distinct"] is True:
-                    distinct_str = "DISTINCT "
-
-                # Prepare column name string
-                column = agg_column["column"]
-                if column.upper() not in columns_available_upper:
-                    raise ValueError(f"{column} not available in: {columns_available}")
-                if column.upper() == "FID":
-                    column_str = f'layer."{fid_column}"'
-                else:
-                    column_str = f'layer."{column}"'
-
-                # Now put everything together
-                agg_columns_str += (
-                    f", {aggregation_str}({distinct_str}{column_str}{extra_param_str}) "
-                    f'AS "{agg_column["as"]}"'
-                )
-
-    # Now prepare the sql statement
-    # Remark: calculating the area in the enclosing selects halves the processing time
-
-    # The operation to run on the geometry
-    operation = f"ST_union(layer.{layerinfo.geometrycolumn})"
-
-    # If the input is a linestring, also apply st_linemerge(), otherwise the individual
-    # lines are just concatenated together and common points are not removed, resulting
-    # in the original seperate lines again if explodecollections is True.
-    force_output_geometrytype = None
-    if layerinfo.geometrytype.to_primitivetype == PrimitiveType.LINESTRING:
-        operation = f"ST_LineMerge({operation})"
-        if explodecollections is True:
-            force_output_geometrytype = GeometryType.LINESTRING
-
-    # If there are no input features, the output geometry type needs to be specified
-    # so gdal can create an empty output file with the right geometry type.
-    if force_output_geometrytype is None and layerinfo.featurecount == 0:
-        force_output_geometrytype = layerinfo.geometrytype
-
-    sql_stmt = f"""
-        SELECT {operation} AS geom
-            {groupby_columns_for_select_str}
-            {agg_columns_str}
-        FROM "{input_layer}" layer
-        GROUP BY {groupby_columns_for_groupby_str}
-    """
-
-    _ogr_util.vector_translate(
-        input_path=input_path,
-        output_path=output_path,
-        output_layer=output_layer,
-        sql_stmt=sql_stmt,
-        sql_dialect="SQLITE",
-        force_output_geometrytype=force_output_geometrytype,
-        explodecollections=explodecollections,
-        options={"LAYER_CREATION.SPATIAL_INDEX": True},
-    )
-
-    logger.info(f"Processing ready, took {datetime.now()-start_time}!")
+# -*- coding: utf-8 -*-
+"""
+Module containing the implementation of Geofile operations using a sql statement.
+"""
+
+from concurrent import futures
+from datetime import datetime
+import logging
+import logging.config
+import math
+import multiprocessing
+from pathlib import Path
+import shutil
+import string
+from typing import Iterable, List, Literal, Optional, Union
+
+import pandas as pd
+
+import geofileops as gfo
+from geofileops import GeofileType, GeometryType, PrimitiveType
+from geofileops import fileops
+from geofileops.fileops import _append_to_nolock
+from . import _general_util
+from . import _io_util
+from . import _ogr_sql_util
+from . import _ogr_util
+from ..helpers import _parameter_helper
+from . import _processing_util
+from . import _sqlite_util
+
+################################################################################
+# Some init
+################################################################################
+
+logger = logging.getLogger(__name__)
+
+################################################################################
+# Operations on one layer
+################################################################################
+
+
+def buffer(
+    input_path: Path,
+    output_path: Path,
+    distance: float,
+    quadrantsegments: int = 5,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Init + prepare sql template for this operation
+    # ----------------------------------------------
+    if distance < 0:
+        # For a double sided buffer, a negative buffer is only relevant for polygon
+        # types, so only keep polygon results. Negative buffer creates invalid stuff,
+        # so use collectionextract to keep only polygons.
+        sql_template = f"""
+            SELECT ST_CollectionExtract(
+                       ST_buffer({{geometrycolumn}}, {distance}, {quadrantsegments}), 3
+                   ) AS geom
+                  {{columns_to_select_str}}
+              FROM "{{input_layer}}" layer
+             WHERE 1=1
+               {{batch_filter}}
+        """
+    else:
+        sql_template = f"""
+            SELECT ST_Buffer({{geometrycolumn}}, {distance}, {quadrantsegments}) AS geom
+                  {{columns_to_select_str}}
+              FROM "{{input_layer}}" layer
+             WHERE 1=1
+               {{batch_filter}}
+        """
+
+    # Buffer operation always results in polygons...
+    if explodecollections:
+        force_output_geometrytype = GeometryType.POLYGON
+    else:
+        force_output_geometrytype = GeometryType.MULTIPOLYGON
+
+    # Go!
+    # ---
+    return _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="buffer",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        sql_dialect="SQLITE",
+        filter_null_geoms=True,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def convexhull(
+    input_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Init + prepare sql template for this operation
+    # ----------------------------------------------
+    input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
+    sql_template = """
+        SELECT ST_ConvexHull({geometrycolumn}) AS geom
+                {columns_to_select_str}
+          FROM "{input_layer}" layer
+         WHERE 1=1
+           {batch_filter}
+    """
+
+    # Go!
+    # ---
+    # Output geometry type same as input geometry type
+    return _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="convexhull",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=input_layerinfo.geometrytype,
+        sql_dialect="SQLITE",
+        filter_null_geoms=True,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def delete_duplicate_geometries(
+    input_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    # The query as written doesn't give correct results when parallellized,
+    # but it isn't useful to do it for this operation.
+    sql_template = """
+        SELECT {geometrycolumn} AS geom
+              {columns_to_select_str}
+          FROM "{input_layer}" layer
+         WHERE layer.rowid IN (
+                SELECT MIN(layer_sub.rowid) AS rowid_to_keep
+                  FROM "{input_layer}" layer_sub
+                 GROUP BY layer_sub.{geometrycolumn}
+            )
+    """
+
+    # Go!
+    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
+    return _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="delete_duplicate_geometries",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=input_layer_info.geometrytype,
+        sql_dialect="SQLITE",
+        filter_null_geoms=True,
+        nb_parallel=1,
+        batchsize=-1,
+        force=force,
+    )
+
+
+def isvalid(
+    input_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    validate_attribute_data: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+) -> bool:
+    # Prepare sql template for this operation
+    sql_template = """
+        SELECT ST_IsValidDetail({geometrycolumn}) AS geom
+              ,ST_IsValid({geometrycolumn}) AS isvalid
+              ,ST_IsValidReason({geometrycolumn}) AS isvalidreason
+              {columns_to_select_str}
+          FROM "{input_layer}" layer
+         WHERE ST_IsValid({geometrycolumn}) <> 1
+           {batch_filter}
+    """
+
+    _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="isvalid",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=GeometryType.POINT,
+        sql_dialect="SQLITE",
+        filter_null_geoms=True,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+    # Check the number of invalid files
+    nb_invalid_geoms = 0
+    if output_path.exists():
+        nb_invalid_geoms = gfo.get_layerinfo(output_path).featurecount
+        if nb_invalid_geoms == 0:
+            # Empty result, so everything was valid: remove output file
+            gfo.remove(output_path)
+
+    # If output is sqlite based, check if all data can be read
+    if validate_attribute_data:
+        try:
+            input_geofiletype = GeofileType(input_path)
+            if input_geofiletype.is_spatialite_based:
+                _sqlite_util.test_data_integrity(path=input_path)
+                logger.debug("test_data_integrity was succesfull")
+        except Exception:
+            logger.exception(
+                f"nb_invalid_geoms: {nb_invalid_geoms} + some attributes could not be "
+                "read!"
+            )
+            return False
+
+    if nb_invalid_geoms > 0:
+        logger.info(f"Found {nb_invalid_geoms} invalid geoms in {output_path}")
+        return False
+
+    # Nothing invalid found
+    return True
+
+
+def makevalid(
+    input_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Optional[GeometryType] = None,
+    gridsize: Optional[float] = None,
+    validate_attribute_data: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # If output file exists already, either clean up or return...
+    operation_name = "makevalid"
+    if not force and output_path.exists():
+        logger.info(f"Stop {operation_name}: output exists already {output_path}")
+        return
+
+    # Init + prepare sql template for this operation
+    # ----------------------------------------------
+    operation = "{geometrycolumn}"
+
+    # If the precision needs to be reduced, snap to grid
+    if gridsize is not None:
+        operation = f"ST_SnapToGrid({operation}, {gridsize})"
+
+    # Prepare sql template for this operation
+    operation = f"ST_MakeValid({operation})"
+
+    # Determine output_geometrytype if it wasn't specified. Otherwise makevalid results
+    # in column type 'GEOMETRY'/'UNKNOWN(ANY)'
+    input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
+    if force_output_geometrytype is None:
+        force_output_geometrytype = input_layerinfo.geometrytype
+
+    # If we want a specific geometrytype, only extract the relevant type
+    if force_output_geometrytype is not GeometryType.GEOMETRYCOLLECTION:
+        primitivetypeid = force_output_geometrytype.to_primitivetype.value
+        operation = f"ST_CollectionExtract({operation}, {primitivetypeid})"
+
+    # Now we can prepare the entire statement
+    sql_template = f"""
+        SELECT {operation} AS geom
+                {{columns_to_select_str}}
+          FROM "{{input_layer}}" layer
+         WHERE 1=1
+           {{batch_filter}}
+    """
+
+    _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name=operation_name,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        sql_dialect="SQLITE",
+        filter_null_geoms=True,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+    # If asked and output is spatialite based, check if all data can be read
+    if validate_attribute_data:
+        output_geofiletype = GeofileType(input_path)
+        if output_geofiletype.is_spatialite_based:
+            _sqlite_util.test_data_integrity(path=input_path)
+
+
+def select(
+    input_path: Path,
+    output_path: Path,
+    sql_stmt: str,
+    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = "SQLITE",
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Optional[GeometryType] = None,
+    nb_parallel: int = 1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Check if output exists already here, to evade to much logging to be written
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop select: output exists already {output_path}")
+            return
+    logger.debug(f"  -> select to execute:\n{sql_stmt}")
+
+    # If no output geometrytype is specified, use the geometrytype of the input layer
+    if force_output_geometrytype is None:
+        force_output_geometrytype = gfo.get_layerinfo(
+            input_path, input_layer
+        ).geometrytype
+        logger.info(
+            "No force_output_geometrytype specified, so defaults to input layer "
+            f"geometrytype: {force_output_geometrytype}"
+        )
+
+    # Go!
+    return _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_stmt,
+        operation_name="select",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        sql_dialect=sql_dialect,
+        filter_null_geoms=False,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def simplify(
+    input_path: Path,
+    output_path: Path,
+    tolerance: float,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Init + prepare sql template for this operation
+    # ----------------------------------------------
+    sql_template = f"""
+        SELECT ST_SimplifyPreserveTopology({{geometrycolumn}}, {tolerance}) AS geom
+                {{columns_to_select_str}}
+            FROM "{{input_layer}}" layer
+            WHERE 1=1
+            {{batch_filter}}
+    """
+
+    # Output geometry type same as input geometry type
+    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
+    return _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="simplify",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=input_layer_info.geometrytype,
+        sql_dialect="SQLITE",
+        filter_null_geoms=True,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def _single_layer_vector_operation(
+    input_path: Path,
+    output_path: Path,
+    sql_template: str,
+    operation_name: str,
+    input_layer: Optional[str],
+    output_layer: Optional[str],
+    columns: Optional[List[str]],
+    explodecollections: bool,
+    force_output_geometrytype: Optional[GeometryType],
+    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]],
+    filter_null_geoms: bool,
+    nb_parallel: int,
+    batchsize: int,
+    force: bool,
+):
+    # Init
+    start_time = datetime.now()
+
+    # Check input parameters...
+    if not input_path.exists():
+        raise ValueError(f"{operation_name}: input_path doesn't exist: {input_path}")
+    if input_path == output_path:
+        raise ValueError(f"{operation_name}: output_path must not equal input_path")
+
+    # Check/get layer names
+    if input_layer is None:
+        input_layer = gfo.get_only_layer(input_path)
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+
+    # If output file exists already, either clean up or return...
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop {operation_name}: output exists already {output_path}")
+            return
+        else:
+            gfo.remove(output_path)
+
+    # Get layer info of the input layer
+    input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
+
+    # Calculate
+    tempdir = _io_util.create_tempdir(f"geofileops/{operation_name.replace(' ', '_')}")
+    try:
+        processing_params = _prepare_processing_params(
+            input1_path=input_path,
+            input1_layer=input_layer,
+            input1_layer_alias="layer",
+            tempdir=tempdir,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            convert_to_spatialite_based=False,
+        )
+        # If None is returned, just stop.
+        if processing_params is None or processing_params.batches is None:
+            return
+
+        # If multiple batches, there should be a batch_filter placeholder sql_template
+        nb_batches = len(processing_params.batches)
+        if nb_batches > 1:
+            placeholders = [
+                name for _, name, _, _ in string.Formatter().parse(sql_template) if name
+            ]
+            if "batch_filter" not in placeholders:
+                raise ValueError(
+                    "Number batches > 1 requires a batch_filter placeholder in "
+                    f"sql_template {sql_template}"
+                )
+
+        # Format column string for use in select
+        column_formatter = _ogr_sql_util.ColumnFormatter(
+            columns_asked=columns,
+            columns_in_layer=input_layerinfo.columns,
+            fid_column=input_layerinfo.fid_column,
+        )
+
+        # Prepare temp output filename
+        tmp_output_path = tempdir / output_path.name
+
+        # Processing in threads is 2x faster for small datasets (on Windows)
+        calculate_in_threads = True if input_layerinfo.featurecount <= 100 else False
+        with _processing_util.PooledExecutorFactory(
+            threadpool=calculate_in_threads,
+            max_workers=processing_params.nb_parallel,
+            initializer=_processing_util.initialize_worker(),
+        ) as calculate_pool:
+            batches = {}
+            future_to_batch_id = {}
+            for batch_id in processing_params.batches:
+                batches[batch_id] = {}
+                batches[batch_id]["layer"] = output_layer
+
+                tmp_partial_output_path = (
+                    tempdir / f"{output_path.stem}_{batch_id}{output_path.suffix}"
+                )
+                batches[batch_id]["tmp_partial_output_path"] = tmp_partial_output_path
+
+                # Now we have everything to format sql statement
+                sql_stmt = sql_template.format(
+                    geometrycolumn=input_layerinfo.geometrycolumn,
+                    columns_to_select_str=column_formatter.prefixed_aliased(),
+                    input_layer=processing_params.batches[batch_id]["layer"],
+                    batch_filter=processing_params.batches[batch_id]["batch_filter"],
+                )
+
+                # Make sure no NULL geoms are outputted...
+                if filter_null_geoms is True:
+                    sql_stmt = f"""
+                        SELECT sub.* FROM
+                          ( {sql_stmt}
+                          ) sub
+                         WHERE sub.geom IS NOT NULL
+                    """
+
+                batches[batch_id]["sql_stmt"] = sql_stmt
+
+                # If there is only one batch, it is faster to create the spatial index
+                # immediately. Otherwise no index needed, because partial files still
+                # need to be merged to one file later on.
+                create_spatial_index = False
+                if nb_batches == 1:
+                    create_spatial_index = True
+
+                translate_info = _ogr_util.VectorTranslateInfo(
+                    input_path=processing_params.batches[batch_id]["path"],
+                    output_path=tmp_partial_output_path,
+                    output_layer=output_layer,
+                    sql_stmt=sql_stmt,
+                    sql_dialect=sql_dialect,
+                    explodecollections=explodecollections,
+                    force_output_geometrytype=force_output_geometrytype,
+                    options={"LAYER_CREATION.SPATIAL_INDEX": create_spatial_index},
+                )
+                future = calculate_pool.submit(
+                    _ogr_util.vector_translate_by_info, info=translate_info
+                )
+                future_to_batch_id[future] = batch_id
+
+            # Loop till all parallel processes are ready, but process each one
+            # that is ready already.
+            # Calculating can be done in parallel, but only one process can write to
+            # the same file at the time.
+            nb_done = 0
+            _general_util.report_progress(
+                start_time, nb_done, nb_batches, operation_name, nb_parallel=nb_parallel
+            )
+            for future in futures.as_completed(future_to_batch_id):
+                try:
+                    _ = future.result()
+                except Exception as ex:
+                    batch_id = future_to_batch_id[future]
+                    error = str(ex).partition("\n")[0]
+                    message = f"Error <{error}> executing {batches[batch_id]}"
+                    logger.exception(message)
+                    raise Exception(message) from ex
+
+                # Start copy of the result to a common file
+                # Remark: give higher priority, because this is the slowest factor
+                batch_id = future_to_batch_id[future]
+                tmp_partial_output_path = batches[batch_id]["tmp_partial_output_path"]
+                nb_done += 1
+
+                # Normally all partial files should exist, but to be sure.
+                if not tmp_partial_output_path.exists():
+                    logger.warning(f"Result file {tmp_partial_output_path} not found")
+                    continue
+
+                # If there is only one batch, just rename because it is already OK
+                if nb_batches == 1:
+                    gfo.move(tmp_partial_output_path, tmp_output_path)
+                else:
+                    fileops._append_to_nolock(
+                        src=tmp_partial_output_path,
+                        dst=tmp_output_path,
+                        explodecollections=explodecollections,
+                        force_output_geometrytype=force_output_geometrytype,
+                        create_spatial_index=False,
+                    )
+                    gfo.remove(tmp_partial_output_path)
+
+                # Log the progress and prediction speed
+                _general_util.report_progress(
+                    start_time,
+                    nb_done,
+                    nb_batches,
+                    operation_name,
+                    nb_parallel=nb_parallel,
+                )
+
+        # Round up and clean up
+        # Now create spatial index and move to output location
+        if tmp_output_path.exists():
+            gfo.create_spatial_index(
+                path=tmp_output_path, layer=output_layer, exist_ok=True
+            )
+            output_path.parent.mkdir(parents=True, exist_ok=True)
+            gfo.move(tmp_output_path, output_path)
+        else:
+            logger.debug(f"Result of {operation_name} was empty!")
+
+    finally:
+        # Clean tmp dir
+        shutil.rmtree(tempdir, ignore_errors=True)
+        logger.info(f"Processing ready, took {datetime.now()-start_time}!")
+
+
+################################################################################
+# Operations on two layers
+################################################################################
+
+
+def clip(
+    input_path: Path,
+    clip_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    input_columns: Optional[List[str]] = None,
+    clip_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+    input_columns_prefix: str = "",
+    output_with_spatial_index: bool = True,
+):
+    # Init
+    # In the query, important to only extract the geometry types that are expected
+    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
+    primitivetypeid = input_layer_info.geometrytype.to_primitivetype.value
+
+    # If the input type is not point, force the output type to multi,
+    # because erase clip cause eg. polygons to be split to multipolygons...
+    force_output_geometrytype = input_layer_info.geometrytype
+    if force_output_geometrytype is not GeometryType.POINT:
+        force_output_geometrytype = input_layer_info.geometrytype.to_multitype
+
+    # Prepare sql template for this operation
+    # Remarks:
+    #   - ST_intersection(geometry , NULL) gives NULL as result! -> hence the CASE
+    #   - use of the with instead of an inline view is a lot faster
+    #   - WHERE geom IS NOT NULL to evade rows with a NULL geom, they give issues in
+    #     later operations
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_template = f"""
+        SELECT * FROM
+          ( WITH layer2_unioned AS (
+              SELECT layer1.rowid AS layer1_rowid
+                    ,ST_union(layer2.{{input2_geometrycolumn}}) AS geom
+                FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                  ON layer1.fid = layer1tree.id
+                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                  ON layer2.fid = layer2tree.id
+               WHERE 1=1
+                 {{batch_filter}}
+                 AND layer1tree.minx <= layer2tree.maxx
+                 AND layer1tree.maxx >= layer2tree.minx
+                 AND layer1tree.miny <= layer2tree.maxy
+                 AND layer1tree.maxy >= layer2tree.miny
+                 AND ST_Intersects(
+                        layer1.{{input1_geometrycolumn}},
+                        layer2.{{input2_geometrycolumn}}) = 1
+                 AND ST_Touches(
+                        layer1.{{input1_geometrycolumn}},
+                        layer2.{{input2_geometrycolumn}}) = 0
+               GROUP BY layer1.rowid
+            )
+            SELECT CASE WHEN layer2_unioned.geom IS NULL THEN NULL
+                        ELSE ST_CollectionExtract(
+                               ST_intersection(layer1.{{input1_geometrycolumn}},
+                                               layer2_unioned.geom), {primitivetypeid})
+                   END as geom
+                  {{layer1_columns_prefix_alias_str}}
+              FROM {{input1_databasename}}."{{input1_layer}}" layer1
+              JOIN layer2_unioned ON layer1.rowid = layer2_unioned.layer1_rowid
+             WHERE 1=1
+               {{batch_filter}}
+          )
+         WHERE geom IS NOT NULL
+           AND ST_NPoints(geom) > 0
+           -- ST_CollectionExtract outputs empty, but not NULL geoms in spatialite 4.3
+    """
+
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input_path,
+        input2_path=clip_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="clip",
+        input1_layer=input_layer,
+        input1_columns=input_columns,
+        input1_columns_prefix=input_columns_prefix,
+        input2_layer=clip_layer,
+        input2_columns=None,
+        input2_columns_prefix="",
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        output_with_spatial_index=output_with_spatial_index,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def erase(
+    input_path: Path,
+    erase_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    input_columns: Optional[List[str]] = None,
+    erase_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+    input_columns_prefix: str = "",
+    output_with_spatial_index: bool = True,
+):
+    # Init
+    # In the query, important to only extract the geometry types that are expected
+    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
+    primitivetypeid = input_layer_info.geometrytype.to_primitivetype.value
+
+    # If the input type is not point, force the output type to multi,
+    # because erase can cause eg. polygons to be split to multipolygons...
+    force_output_geometrytype = input_layer_info.geometrytype
+    if force_output_geometrytype is not GeometryType.POINT:
+        force_output_geometrytype = input_layer_info.geometrytype.to_multitype
+
+    # Prepare sql template for this operation
+    # Remarks:
+    #   - ST_difference(geometry , NULL) gives NULL as result! -> hence the CASE
+    #   - use of the with instead of an inline view is a lot faster
+    #   - WHERE geom IS NOT NULL to evade rows with a NULL geom, they give issues in
+    #     later operations
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_template = f"""
+        SELECT * FROM
+          ( WITH layer2_unioned AS (
+              SELECT layer1.rowid AS layer1_rowid
+                    ,ST_union(layer2.{{input2_geometrycolumn}}) AS geom
+                FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                  ON layer1.fid = layer1tree.id
+                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                  ON layer2.fid = layer2tree.id
+               WHERE 1=1
+                 {{batch_filter}}
+                 AND layer1tree.minx <= layer2tree.maxx
+                 AND layer1tree.maxx >= layer2tree.minx
+                 AND layer1tree.miny <= layer2tree.maxy
+                 AND layer1tree.maxy >= layer2tree.miny
+                 AND ST_Intersects(
+                        layer1.{{input1_geometrycolumn}},
+                        layer2.{{input2_geometrycolumn}}) = 1
+                 AND ST_Touches(
+                        layer1.{{input1_geometrycolumn}},
+                        layer2.{{input2_geometrycolumn}}) = 0
+               GROUP BY layer1.rowid
+            )
+            SELECT CASE WHEN layer2_unioned.geom IS NULL
+                        THEN layer1.{{input1_geometrycolumn}}
+                        ELSE ST_CollectionExtract(
+                                ST_difference(
+                                    layer1.{{input1_geometrycolumn}},
+                                    layer2_unioned.geom),
+                                    {primitivetypeid})
+                   END as geom
+                  {{layer1_columns_prefix_alias_str}}
+              FROM {{input1_databasename}}."{{input1_layer}}" layer1
+              LEFT JOIN layer2_unioned ON layer1.rowid = layer2_unioned.layer1_rowid
+             WHERE 1=1
+               {{batch_filter}}
+          )
+         WHERE geom IS NOT NULL
+           AND ST_NPoints(geom) > 0
+           -- ST_CollectionExtract outputs empty, but not NULL geoms in spatialite 4.3
+    """
+
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input_path,
+        input2_path=erase_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="erase",
+        input1_layer=input_layer,
+        input1_columns=input_columns,
+        input1_columns_prefix=input_columns_prefix,
+        input2_layer=erase_layer,
+        input2_columns=[],
+        input2_columns_prefix="",
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+        output_with_spatial_index=output_with_spatial_index,
+    )
+
+
+def export_by_location(
+    input_path: Path,
+    input_to_compare_with_path: Path,
+    output_path: Path,
+    min_area_intersect: Optional[float] = None,
+    area_inters_column_name: Optional[str] = "area_inters",
+    input_layer: Optional[str] = None,
+    input_columns: Optional[List[str]] = None,
+    input_to_compare_with_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Prepare sql template for this operation
+    # TODO: test performance difference between the following two queries
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_template = f"""
+        SELECT layer1.{{input1_geometrycolumn}} AS geom
+              {{layer1_columns_prefix_alias_str}}
+          FROM {{input1_databasename}}."{{input1_layer}}" layer1
+          JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+            ON layer1.fid = layer1tree.id
+         WHERE 1=1
+           {{batch_filter}}
+           AND EXISTS (
+              SELECT 1
+                FROM {{input2_databasename}}."{{input2_layer}}" layer2
+                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                  ON layer2.fid = layer2tree.id
+               WHERE layer1tree.minx <= layer2tree.maxx
+                 AND layer1tree.maxx >= layer2tree.minx
+                 AND layer1tree.miny <= layer2tree.maxy
+                 AND layer1tree.maxy >= layer2tree.miny
+                 AND ST_intersects(layer1.{{input1_geometrycolumn}},
+                                   layer2.{{input2_geometrycolumn}}) = 1
+                 AND ST_touches(layer1.{{input1_geometrycolumn}},
+                                layer2.{{input2_geometrycolumn}}) = 0)
+    """
+
+    # Calculate intersect area if necessary
+    area_inters_column_expression = ""
+    if area_inters_column_name is not None or min_area_intersect is not None:
+        if area_inters_column_name is None:
+            area_inters_column_name = "area_inters"
+        area_inters_column_expression = f"""
+            ,ST_area(ST_intersection(
+                 ST_union(layer1.{{input1_geometrycolumn}}),
+                 ST_union(layer2.{{input2_geometrycolumn}})
+             )) AS {area_inters_column_name}
+        """
+
+    # Prepare sql template for this operation
+    sql_template = f"""
+        SELECT ST_union(layer1.{{input1_geometrycolumn}}) as geom
+              {{layer1_columns_prefix_str}}
+              {area_inters_column_expression}
+          FROM {{input1_databasename}}."{{input1_layer}}" layer1
+          JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+            ON layer1.fid = layer1tree.id
+          JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+          JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+            ON layer2.fid = layer2tree.id
+         WHERE 1=1
+           {{batch_filter}}
+           AND layer1tree.minx <= layer2tree.maxx
+           AND layer1tree.maxx >= layer2tree.minx
+           AND layer1tree.miny <= layer2tree.maxy
+           AND layer1tree.maxy >= layer2tree.miny
+           AND ST_Intersects(layer1.{{input1_geometrycolumn}},
+                             layer2.{{input2_geometrycolumn}}) = 1
+           AND ST_Touches(layer1.{{input1_geometrycolumn}},
+                          layer2.{{input2_geometrycolumn}}) = 0
+         GROUP BY layer1.rowid {{layer1_columns_prefix_str}}
+    """
+
+    # Filter on intersect area if necessary
+    if min_area_intersect is not None:
+        sql_template = f"""
+            SELECT sub.* FROM
+              ( {sql_template}
+              ) sub
+             WHERE sub.{area_inters_column_name} >= {min_area_intersect}
+        """
+
+    # Go!
+    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
+    return _two_layer_vector_operation(
+        input1_path=input_path,
+        input2_path=input_to_compare_with_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="export_by_location",
+        input1_layer=input_layer,
+        input1_columns=input_columns,
+        input1_columns_prefix="",
+        input2_layer=input_to_compare_with_layer,
+        input2_columns=[],
+        input2_columns_prefix="",
+        output_layer=output_layer,
+        explodecollections=False,
+        force_output_geometrytype=input_layer_info.geometrytype,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def export_by_distance(
+    input_to_select_from_path: Path,
+    input_to_compare_with_path: Path,
+    output_path: Path,
+    max_distance: float,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input2_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Prepare sql template for this operation
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_template = f"""
+        SELECT geom
+              {{layer1_columns_prefix_alias_str}}
+          FROM {{input1_databasename}}."{{input1_layer}}" layer1
+          JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+            ON layer1.fid = layer1tree.id
+         WHERE 1=1
+               {{batch_filter}}
+               AND EXISTS (
+                    SELECT 1
+                      FROM {{input2_databasename}}."{{input2_layer}}" layer2
+                      JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                        ON layer2.fid = layer2tree.id
+                     WHERE (layer1tree.minx-{max_distance}) <= layer2tree.maxx
+                       AND (layer1tree.maxx+{max_distance}) >= layer2tree.minx
+                       AND (layer1tree.miny-{max_distance}) <= layer2tree.maxy
+                       AND (layer1tree.maxy+{max_distance}) >= layer2tree.miny
+                       AND ST_distance(
+                            layer1.{{input1_geometrycolumn}},
+                            layer2.{{input2_geometrycolumn}}) <= {max_distance})
+    """
+
+    input_layer_info = gfo.get_layerinfo(input_to_select_from_path, input1_layer)
+
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input_to_select_from_path,
+        input2_path=input_to_compare_with_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="export_by_distance",
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix="",
+        input2_layer=input2_layer,
+        input2_columns=[],
+        input2_columns_prefix="",
+        output_layer=output_layer,
+        explodecollections=False,
+        force_output_geometrytype=input_layer_info.geometrytype,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def intersection(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # In the query, important to only extract the geometry types that are expected
+    # TODO: test for geometrycollection, line, point,...
+    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
+    input2_layer_info = gfo.get_layerinfo(input2_path, input2_layer)
+    primitivetype_to_extract = PrimitiveType(
+        min(
+            input1_layer_info.geometrytype.to_primitivetype.value,
+            input2_layer_info.geometrytype.to_primitivetype.value,
+        )
+    )
+
+    # For the output file, if output is going to be polygon or linestring, force
+    # MULTI variant to evade ugly warnings
+    force_output_geometrytype = primitivetype_to_extract.to_multitype
+
+    # Prepare sql template for this operation
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_template = f"""
+        SELECT sub.geom
+             {{layer1_columns_from_subselect_str}}
+             {{layer2_columns_from_subselect_str}}
+          FROM
+            ( SELECT ST_CollectionExtract(
+                       ST_Intersection(
+                            layer1.{{input1_geometrycolumn}},
+                            layer2.{{input2_geometrycolumn}}),
+                            {primitivetype_to_extract.value}) as geom
+                    {{layer1_columns_prefix_alias_str}}
+                    {{layer2_columns_prefix_alias_str}}
+                FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                  ON layer1.fid = layer1tree.id
+                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                  ON layer2.fid = layer2tree.id
+               WHERE 1=1
+                 {{batch_filter}}
+                 AND layer1tree.minx <= layer2tree.maxx
+                 AND layer1tree.maxx >= layer2tree.minx
+                 AND layer1tree.miny <= layer2tree.maxy
+                 AND layer1tree.maxy >= layer2tree.miny
+                 AND ST_Intersects(
+                        layer1.{{input1_geometrycolumn}},
+                        layer2.{{input2_geometrycolumn}}) = 1
+                 AND ST_Touches(
+                        layer1.{{input1_geometrycolumn}},
+                        layer2.{{input2_geometrycolumn}}) = 0
+            ) sub
+         WHERE sub.geom IS NOT NULL
+    """
+
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="intersection",
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def join_by_location(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    spatial_relations_query: str = "intersects is True",
+    discard_nonmatching: bool = True,
+    min_area_intersect: Optional[float] = None,
+    area_inters_column_name: Optional[str] = None,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Prepare sql template for this operation
+    # Prepare intersection area columns/filter
+    area_inters_column_expression = ""
+    area_inters_column_in_output = ""
+    area_inters_column_0_in_output = ""
+    area_inters_filter = ""
+    if area_inters_column_name is not None or min_area_intersect is not None:
+        if area_inters_column_name is not None:
+            area_inters_column_name_touse = area_inters_column_name
+            area_inters_column_in_output = f',"{area_inters_column_name}"'
+            area_inters_column_0_in_output = f',0 AS "{area_inters_column_name}"'
+        else:
+            area_inters_column_name_touse = "area_inters"
+        area_inters_column_expression = (
+            ",ST_area(ST_intersection(sub_filter.geom, sub_filter.l2_geom)) "
+            f'as "{area_inters_column_name_touse}"'
+        )
+        if min_area_intersect is not None:
+            area_inters_filter = (
+                f'WHERE sub_area."{area_inters_column_name_touse}" '
+                f">= {min_area_intersect}"
+            )
+
+    # Prepare spatial relations filter
+    if spatial_relations_query != "intersects is True":
+        # joining should only be possible on features that at least have an
+        # interaction! So, add "intersects is True" to query to evade errors!
+        spatial_relations_query = f"({spatial_relations_query}) and intersects is True"
+    spatial_relations_filter = _prepare_spatial_relations_filter(
+        spatial_relations_query
+    )
+
+    # Prepare sql template
+    #
+    # Remark: use "LIMIT -1 OFFSET 0" to evade that the sqlite query optimizer
+    #     "flattens" the subquery, as that makes checking the spatial
+    #     relations (using ST_RelateMatch) very slow!
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_template = f"""
+        WITH layer1_relations_filtered AS (
+          SELECT sub_area.*
+            FROM (
+              SELECT sub_filter.*
+                    {area_inters_column_expression}
+                FROM (
+                  SELECT layer1.{{input1_geometrycolumn}} as geom
+                        ,layer1.fid l1_fid
+                        ,layer2.{{input2_geometrycolumn}} as l2_geom
+                        {{layer1_columns_prefix_alias_str}}
+                        {{layer2_columns_prefix_alias_str}}
+                        ,ST_relate(layer1.{{input1_geometrycolumn}},
+                                   layer2.{{input2_geometrycolumn}}) as spatial_relation
+                    FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                    JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                      ON layer1.fid = layer1tree.id
+                    JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                    JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                      ON layer2.fid = layer2tree.id
+                   WHERE 1=1
+                     {{batch_filter}}
+                     AND layer1tree.minx <= layer2tree.maxx
+                     AND layer1tree.maxx >= layer2tree.minx
+                     AND layer1tree.miny <= layer2tree.maxy
+                     AND layer1tree.maxy >= layer2tree.miny
+                   LIMIT -1 OFFSET 0
+                  ) sub_filter
+               WHERE {spatial_relations_filter.format(
+                    spatial_relation="sub_filter.spatial_relation")}
+               LIMIT -1 OFFSET 0
+              ) sub_area
+           {area_inters_filter}
+          )
+        SELECT sub.geom
+              {{layer1_columns_from_subselect_str}}
+              {{layer2_columns_from_subselect_str}}
+              ,sub.spatial_relation
+              {area_inters_column_in_output}
+          FROM layer1_relations_filtered sub
+    """
+
+    # If a left join is asked, add all features from layer1 that weren't
+    # matched.
+    if discard_nonmatching is False:
+        sql_template = f"""
+            {sql_template}
+            UNION ALL
+            SELECT layer1.{{input1_geometrycolumn}} as geom
+                  {{layer1_columns_prefix_alias_str}}
+                  {{layer2_columns_prefix_alias_null_str}}
+                  ,NULL as spatial_relation
+                  {area_inters_column_0_in_output}
+              FROM {{input1_databasename}}."{{input1_layer}}" layer1
+             WHERE 1=1
+               {{batch_filter}}
+               AND layer1.fid NOT IN (
+                   SELECT l1_fid FROM layer1_relations_filtered)
+        """
+
+    # Go!
+    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
+    return _two_layer_vector_operation(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="join_by_location",
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        force_output_geometrytype=input1_layer_info.geometrytype,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def _prepare_spatial_relations_filter(query: str) -> str:
+    named_spatial_relations = {
+        # "disjoint": ["FF*FF****"],
+        "equals": ["TFFF*FFF*"],
+        "touches": ["FT*******", "F**T*****", "F***T****"],
+        "within": ["T*F**F***"],
+        "overlaps": ["T*T***T**", "1*T***T**"],
+        "crosses": ["T*T******", "T*****T**", "0********"],
+        "intersects": ["T********", "*T*******", "***T*****", "****T****"],
+        "contains": ["T*****FF*"],
+        "covers": ["T*****FF*", "*T****FF*", "***T**FF*", "****T*FF*"],
+        "coveredby": ["T*F**F***", "*TF**F***", "**FT*F***", "**F*TF***"],
+    }
+
+    # Parse query and replace things that need to be replaced
+    import re
+
+    query_tokens = re.split("([ =()])", query)
+
+    query_tokens_prepared = []
+    nb_unclosed_brackets = 0
+    for token in query_tokens:
+        if token == "":
+            continue
+        elif token in [" ", "\n", "\t", "and", "or"]:
+            query_tokens_prepared.append(token)
+        elif token == "(":
+            nb_unclosed_brackets += 1
+            query_tokens_prepared.append(token)
+        elif token == ")":
+            nb_unclosed_brackets -= 1
+            query_tokens_prepared.append(token)
+        elif token == "is":
+            query_tokens_prepared.append("=")
+        elif token == "True":
+            query_tokens_prepared.append("1")
+        elif token == "False":
+            query_tokens_prepared.append("0")
+        elif token in named_spatial_relations:
+            match_list = []
+            for spatial_relation in named_spatial_relations[token]:
+                match = (
+                    f"ST_RelateMatch({{spatial_relation}}, '{spatial_relation}') = 1"
+                )
+                match_list.append(match)
+            query_tokens_prepared.append(f"({' or '.join(match_list)})")
+        elif len(token) == 9 and re.fullmatch("^[FT012*]+$", token) is not None:
+            token_prepared = f"ST_RelateMatch({{spatial_relation}}, '{token}')"
+            query_tokens_prepared.append(token_prepared)
+        else:
+            raise ValueError(
+                f"Unexpected token in query (query is case sensitive!): {token}"
+            )
+
+    # If there are unclosed brackets, raise
+    if nb_unclosed_brackets > 0:
+        raise ValueError(f"not all brackets are closed in query {query}")
+    elif nb_unclosed_brackets < 0:
+        raise ValueError(f"more closing brackets than opening ones in query {query}")
+
+    result = f"({''.join(query_tokens_prepared)})"
+    return result
+
+
+def join_nearest(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    nb_nearest: int,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Init some things...
+    # Because there is preprocessing done in this function, check output path
+    # here already
+    if output_path.exists() and force is False:
+        logger.info(f"Stop join_nearest: output exists already {output_path}")
+        return
+    if input1_layer is None:
+        input1_layer = gfo.get_only_layer(input1_path)
+    if input2_layer is None:
+        input2_layer = gfo.get_only_layer(input2_path)
+
+    # Prepare input files
+    # To use knn index, the input layers need to be in sqlite file format
+    # (not a .gpkg!), so prepare this
+    if input1_path == input2_path and GeofileType(input1_path) == GeofileType.SQLite:
+        # Input files already ok...
+        input1_tmp_path = input1_path
+        input1_tmp_layer = input1_layer
+        input2_tmp_path = input2_path
+        input2_tmp_layer = input2_layer
+    else:
+        # Put input2 layer in sqlite gfo...
+        tempdir = _io_util.create_tempdir("geofileops/join_nearest")
+        input1_tmp_path = tempdir / "both_input_layers.sqlite"
+        input1_tmp_layer = "input1_layer"
+        gfo.convert(
+            src=input1_path,
+            src_layer=input1_layer,
+            dst=input1_tmp_path,
+            dst_layer=input1_tmp_layer,
+            preserve_fid=True,
+        )
+
+        # Add input2 layer to sqlite gfo...
+        input2_tmp_path = input1_tmp_path
+        input2_tmp_layer = "input2_layer"
+        gfo.append_to(
+            src=input2_path,
+            src_layer=input2_layer,
+            dst=input2_tmp_path,
+            dst_layer=input2_tmp_layer,
+            preserve_fid=True,
+        )
+
+    # Remark: the 2 input layers need to be in one file!
+    sql_template = f"""
+        SELECT layer1.{{input1_geometrycolumn}} as geom
+              {{layer1_columns_prefix_alias_str}}
+              {{layer2_columns_prefix_alias_str}}
+              ,k.pos, k.distance
+          FROM {{input1_databasename}}."{{input1_layer}}" layer1
+          JOIN {{input2_databasename}}.knn k
+          JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+            ON layer2.rowid = k.fid
+         WHERE k.f_table_name = '{{input2_layer}}'
+           AND k.f_geometry_column = '{{input2_geometrycolumn}}'
+           AND k.ref_geometry = layer1.{{input1_geometrycolumn}}
+           AND k.max_items = {nb_nearest}
+           {{batch_filter}}
+    """
+
+    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
+
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input1_tmp_path,
+        input2_path=input2_tmp_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="join_nearest",
+        input1_layer=input1_tmp_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_tmp_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        force_output_geometrytype=input1_layer_info.geometrytype,
+        explodecollections=explodecollections,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+        use_ogr=True,
+    )
+
+
+def select_two_layers(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    sql_stmt: str,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    force_output_geometrytype: Optional[GeometryType] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = 1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        sql_template=sql_stmt,
+        operation_name="select_two_layers",
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def split(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = 1,
+    batchsize: int = -1,
+    force: bool = False,
+    output_with_spatial_index: bool = True,
+):
+    # In the query, important to only extract the geometry types that are
+    # expected, so the primitive type of input1_layer
+    # TODO: test for geometrycollection, line, point,...
+    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
+    primitivetype_to_extract = input1_layer_info.geometrytype.to_primitivetype
+
+    # For the output file, force MULTI variant to evade ugly warnings
+    force_output_geometrytype = primitivetype_to_extract.to_multitype
+
+    # Prepare sql template for this operation
+    # Remarks:
+    #   - ST_difference(geometry , NULL) gives NULL as result! -> hence the CASE
+    #   - the group by layer1.rowid should be directly in the subquery. If it is
+    #     applied on an (other) with it is slow.
+    #   - a left join is a lot faster and memory efficient than a NOT IN or NOT EXISTS.
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_template = f"""
+        SELECT * FROM
+          ( WITH layer2_unioned AS (
+              SELECT layer1.rowid AS layer1_rowid
+                    ,ST_union(layer2.{{input2_geometrycolumn}}) AS geom
+                FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                  ON layer1.fid = layer1tree.id
+                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                  ON layer2.fid = layer2tree.id
+               WHERE 1=1
+                 {{batch_filter}}
+                 AND layer1tree.minx <= layer2tree.maxx
+                 AND layer1tree.maxx >= layer2tree.minx
+                 AND layer1tree.miny <= layer2tree.maxy
+                 AND layer1tree.maxy >= layer2tree.miny
+                 AND ST_Intersects(layer1.{{input1_geometrycolumn}},
+                                   layer2.{{input2_geometrycolumn}}) = 1
+                 AND ST_Touches(layer1.{{input1_geometrycolumn}},
+                                layer2.{{input2_geometrycolumn}}) = 0
+               GROUP BY layer1.rowid
+            )
+            SELECT ST_CollectionExtract(
+                        ST_intersection(layer1.{{input1_geometrycolumn}},
+                                        layer2.{{input2_geometrycolumn}}),
+                        {primitivetype_to_extract.value}) as geom
+                  {{layer1_columns_prefix_alias_str}}
+                  {{layer2_columns_prefix_alias_str}}
+              FROM {{input1_databasename}}."{{input1_layer}}" layer1
+              JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                ON layer1.fid = layer1tree.id
+              JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+              JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                ON layer2.fid = layer2tree.id
+             WHERE 1=1
+               {{batch_filter}}
+               AND layer1tree.minx <= layer2tree.maxx
+               AND layer1tree.maxx >= layer2tree.minx
+               AND layer1tree.miny <= layer2tree.maxy
+               AND layer1tree.maxy >= layer2tree.miny
+               AND ST_Intersects(layer1.{{input1_geometrycolumn}},
+                                 layer2.{{input2_geometrycolumn}}) = 1
+               AND ST_Touches(layer1.{{input1_geometrycolumn}},
+                              layer2.{{input2_geometrycolumn}}) = 0
+            UNION ALL
+            SELECT CASE WHEN layer2_unioned.geom IS NULL
+                        THEN layer1.{{input1_geometrycolumn}}
+                        ELSE ST_CollectionExtract(
+                                ST_difference(layer1.{{input1_geometrycolumn}},
+                                              layer2_unioned.geom),
+                                {primitivetype_to_extract.value})
+                   END as geom
+                  {{layer1_columns_prefix_alias_str}}
+                  {{layer2_columns_prefix_alias_null_str}}
+              FROM {{input1_databasename}}."{{input1_layer}}" layer1
+              LEFT JOIN layer2_unioned ON layer1.rowid = layer2_unioned.layer1_rowid
+             WHERE 1=1
+               {{batch_filter}}
+           )
+         WHERE geom IS NOT NULL
+           AND ST_NPoints(geom) > 0
+    """
+
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="split",
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+        output_with_spatial_index=output_with_spatial_index,
+    )
+
+
+def symmetric_difference(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # A symmetric difference can be simulated by doing an "erase" of input1
+    # and input2 and then append the result of an erase of input2 with
+    # input1...
+
+    # Because both erase calculations will be towards temp files,
+    # we need to do some additional init + checks here...
+    if force is False and output_path.exists():
+        return
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+
+    tempdir = _io_util.create_tempdir("geofileops/symmdiff")
+    try:
+        # First erase input2 from input1 to a temporary output file
+        erase1_output_path = tempdir / "layer1_erase_layer2_output.gpkg"
+        erase(
+            input_path=input1_path,
+            erase_path=input2_path,
+            output_path=erase1_output_path,
+            input_layer=input1_layer,
+            input_columns=input1_columns,
+            input_columns_prefix=input1_columns_prefix,
+            erase_layer=input2_layer,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+            output_with_spatial_index=False,
+        )
+
+        if input2_columns is None or len(input2_columns) > 0:
+            input2_info = gfo.get_layerinfo(input2_path)
+            columns_to_add = (
+                input2_columns if input2_columns is not None else input2_info.columns
+            )
+            for column in columns_to_add:
+                gfo.add_column(
+                    erase1_output_path,
+                    name=f"{input2_columns_prefix}{column}",
+                    type=input2_info.columns[column].gdal_type,
+                )
+
+        # Now erase input1 from input2 to another temporary output file
+        erase2_output_path = tempdir / "layer2_erase_layer1_output.gpkg"
+        erase(
+            input_path=input2_path,
+            erase_path=input1_path,
+            output_path=erase2_output_path,
+            input_layer=input2_layer,
+            input_columns=input2_columns,
+            input_columns_prefix=input2_columns_prefix,
+            erase_layer=input1_layer,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+            output_with_spatial_index=False,
+        )
+
+        # Now append
+        _append_to_nolock(
+            src=erase2_output_path,
+            dst=erase1_output_path,
+            src_layer=output_layer,
+            dst_layer=output_layer,
+        )
+
+        # Convert or add spatial index
+        tmp_output_path = erase1_output_path
+        if erase1_output_path.suffix != output_path.suffix:
+            # Output file should be in diffent format, so convert
+            tmp_output_path = tempdir / output_path.name
+            gfo.convert(src=erase1_output_path, dst=tmp_output_path)
+        else:
+            # Create spatial index
+            gfo.create_spatial_index(path=tmp_output_path, layer=output_layer)
+
+        # Now we are ready to move the result to the final spot...
+        if output_path.exists():
+            gfo.remove(output_path)
+        gfo.move(tmp_output_path, output_path)
+
+    finally:
+        shutil.rmtree(tempdir)
+
+
+def union(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # A union can be simulated by doing a "split" of input1 and input2 and
+    # then append the result of an erase of input2 with input1...
+
+    # Because the calculations in split and erase will be towards temp files,
+    # we need to do some additional init + checks here...
+    if force is False and output_path.exists():
+        return
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+
+    start_time = datetime.now()
+    tempdir = _io_util.create_tempdir("geofileops/union")
+    try:
+        # First split input1 with input2 to a temporary output gfo...
+        split_output_path = tempdir / "split_output.gpkg"
+        split(
+            input1_path=input1_path,
+            input2_path=input2_path,
+            output_path=split_output_path,
+            input1_layer=input1_layer,
+            input1_columns=input1_columns,
+            input1_columns_prefix=input1_columns_prefix,
+            input2_layer=input2_layer,
+            input2_columns=input2_columns,
+            input2_columns_prefix=input2_columns_prefix,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+            output_with_spatial_index=False,
+        )
+
+        # Now erase input1 from input2 to another temporary output gfo...
+        erase_output_path = tempdir / "erase_output.gpkg"
+        erase(
+            input_path=input2_path,
+            erase_path=input1_path,
+            output_path=erase_output_path,
+            input_layer=input2_layer,
+            input_columns=input2_columns,
+            input_columns_prefix=input2_columns_prefix,
+            erase_layer=input1_layer,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+            output_with_spatial_index=False,
+        )
+
+        # Now append
+        _append_to_nolock(
+            src=erase_output_path,
+            dst=split_output_path,
+            src_layer=output_layer,
+            dst_layer=output_layer,
+        )
+
+        # Convert or add spatial index
+        tmp_output_path = split_output_path
+        if split_output_path.suffix != output_path.suffix:
+            # Output file should be in different format, so convert
+            tmp_output_path = tempdir / output_path.name
+            gfo.convert(src=split_output_path, dst=tmp_output_path)
+        else:
+            # Create spatial index
+            gfo.create_spatial_index(path=tmp_output_path, layer=output_layer)
+
+        # Now we are ready to move the result to the final spot...
+        if output_path.exists():
+            gfo.remove(output_path)
+        gfo.move(tmp_output_path, output_path)
+
+    finally:
+        shutil.rmtree(tempdir)
+
+    logger.info(f"union ready, took {datetime.now()-start_time}!")
+
+
+def _two_layer_vector_operation(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    sql_template: str,
+    operation_name: str,
+    input1_layer: Optional[str],
+    input1_columns: Optional[List[str]],
+    input1_columns_prefix: str,
+    input2_layer: Optional[str],
+    input2_columns: Optional[List[str]],
+    input2_columns_prefix: str,
+    output_layer: Optional[str],
+    explodecollections: bool,
+    force_output_geometrytype: Optional[GeometryType],
+    nb_parallel: int,
+    batchsize: int,
+    force: bool,
+    use_ogr: bool = False,
+    output_with_spatial_index: bool = True,
+):
+    """
+    Executes an operation that needs 2 input files.
+
+    Args:
+        input1_path (str): the file to export features from
+        input2_path (str): the file to check intersections with
+        output_path (str): output file
+        input1_layer (str, optional): [description]. Defaults to None.
+        input1_columns
+        input1_columns_prefix
+        input2_layer (str, optional): [description]. Defaults to None.
+        input2_columns
+        input2_columns_prefix
+        output_layer (str, optional): [description]. Defaults to None.
+        explodecollections (bool, optional): Explode collecions in output.
+            Defaults to False.
+        force_output_geometrytype (GeometryType, optional): Defaults to None.
+        use_ogr (bool, optional): If True, ogr is used to do the processing,
+            In this case different input files (input1_path, input2_path) are
+            NOT supported. If False, sqlite3 is used directly.
+            Defaults to False.
+        nb_parallel (int, optional): [description]. Defaults to -1.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): [description]. Defaults to False.
+        output_with_spatial_index (bool, optional): True to create output file with
+            spatial index. Defaults to True.
+
+    Raises:
+        ValueError: [description]
+    """
+    # Init
+    if not input1_path.exists():
+        raise ValueError(f"{operation_name}: input1_path doesn't exist: {input1_path}")
+    if not input2_path.exists():
+        raise ValueError(f"{operation_name}: input2_path doesn't exist: {input2_path}")
+    if input1_path == output_path or input2_path == output_path:
+        raise ValueError(
+            f"{operation_name}: output_path must not equal one of input paths"
+        )
+    if use_ogr is True and input1_path != input2_path:
+        raise ValueError(
+            f"{operation_name}: if use_ogr True, input1_path == input2_path!"
+        )
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop {operation_name}: output exists already {output_path}")
+            return
+        else:
+            gfo.remove(output_path)
+
+    # Check if spatialite is properly installed to execute this query
+    _sqlite_util.check_runtimedependencies()
+
+    # Init layer info
+    start_time = datetime.now()
+    if input1_layer is None:
+        input1_layer = gfo.get_only_layer(input1_path)
+    if input2_layer is None:
+        input2_layer = gfo.get_only_layer(input2_path)
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+    tempdir = _io_util.create_tempdir(f"geofileops/{operation_name}")
+
+    # Use get_layerinfo to check if the input files are valid
+    gfo.get_layerinfo(input1_path, input1_layer)
+    gfo.get_layerinfo(input2_path, input2_layer)
+
+    # Prepare output filename
+    tmp_output_path = tempdir / output_path.name
+    tmp_output_path.parent.mkdir(exist_ok=True, parents=True)
+    gfo.remove(tmp_output_path)
+
+    try:
+        # Prepare tmp files/batches
+        logger.info(
+            f"Prepare input (params) for {operation_name} with tempdir: {tempdir}"
+        )
+        processing_params = _prepare_processing_params(
+            input1_path=input1_path,
+            input1_layer=input1_layer,
+            input1_layer_alias="layer1",
+            input2_path=input2_path,
+            input2_layer=input2_layer,
+            tempdir=tempdir,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            convert_to_spatialite_based=True,
+        )
+        if processing_params is None or processing_params.batches is None:
+            return
+
+        # If multiple batches, there should be a batch_filter placeholder sql_template
+        nb_batches = len(processing_params.batches)
+        if nb_batches > 1:
+            placeholders = [
+                name for _, name, _, _ in string.Formatter().parse(sql_template) if name
+            ]
+            if "batch_filter" not in placeholders:
+                raise ValueError(
+                    "Number batches > 1 requires a batch_filter placeholder in "
+                    f"sql_template {sql_template}"
+                )
+
+        # Prepare column names,... to format the select
+        # Format column strings for use in select
+        assert processing_params.input1_path is not None
+        input1_tmp_layerinfo = gfo.get_layerinfo(
+            processing_params.input1_path, processing_params.input1_layer
+        )
+        input1_col_strs = _ogr_sql_util.ColumnFormatter(
+            columns_asked=input1_columns,
+            columns_in_layer=input1_tmp_layerinfo.columns,
+            fid_column=input1_tmp_layerinfo.fid_column,
+            table_alias="layer1",
+            column_alias_prefix=input1_columns_prefix,
+        )
+        assert processing_params.input2_path is not None
+        input2_tmp_layerinfo = gfo.get_layerinfo(
+            processing_params.input2_path, processing_params.input2_layer
+        )
+        input2_col_strs = _ogr_sql_util.ColumnFormatter(
+            columns_asked=input2_columns,
+            columns_in_layer=input2_tmp_layerinfo.columns,
+            fid_column=input2_tmp_layerinfo.fid_column,
+            table_alias="layer2",
+            column_alias_prefix=input2_columns_prefix,
+        )
+
+        # Check input crs'es
+        if input1_tmp_layerinfo.crs != input2_tmp_layerinfo.crs:
+            logger.warning(
+                "input1 has a different crs than input2: \n\tinput1: "
+                f"{input1_tmp_layerinfo.crs} \n\tinput2: {input2_tmp_layerinfo.crs}"
+            )
+
+        # Calculate
+        # Processing in threads is 2x faster for small datasets (on Windows)
+        calculate_in_threads = (
+            True if input1_tmp_layerinfo.featurecount <= 100 else False
+        )
+        logger.info(
+            f"Start {operation_name} ({processing_params.nb_parallel} parallel workers)"
+        )
+        with _processing_util.PooledExecutorFactory(
+            threadpool=calculate_in_threads,
+            max_workers=processing_params.nb_parallel,
+            initializer=_processing_util.initialize_worker(),
+        ) as calculate_pool:
+            # Start looping
+            batches = {}
+            future_to_batch_id = {}
+            for batch_id in processing_params.batches:
+                batches[batch_id] = {}
+                batches[batch_id]["layer"] = output_layer
+
+                tmp_partial_output_path = (
+                    tempdir / f"{output_path.stem}_{batch_id}.gpkg"
+                )
+                batches[batch_id]["tmp_partial_output_path"] = tmp_partial_output_path
+
+                # Keep input1_tmp_layer and input2_tmp_layer for backwards
+                # compatibility
+                sql_stmt = sql_template.format(
+                    input1_databasename="{input1_databasename}",
+                    input2_databasename="{input2_databasename}",
+                    layer1_columns_from_subselect_str=input1_col_strs.from_subselect(),
+                    layer1_columns_prefix_alias_str=input1_col_strs.prefixed_aliased(),
+                    layer1_columns_prefix_str=input1_col_strs.prefixed(),
+                    input1_layer=processing_params.batches[batch_id]["layer"],
+                    input1_tmp_layer=processing_params.batches[batch_id]["layer"],
+                    input1_geometrycolumn=input1_tmp_layerinfo.geometrycolumn,
+                    layer2_columns_from_subselect_str=input2_col_strs.from_subselect(),
+                    layer2_columns_prefix_alias_str=input2_col_strs.prefixed_aliased(),
+                    layer2_columns_prefix_str=input2_col_strs.prefixed(),
+                    layer2_columns_prefix_alias_null_str=input2_col_strs.null_aliased(),
+                    input2_layer=processing_params.input2_layer,
+                    input2_tmp_layer=processing_params.input2_layer,
+                    input2_geometrycolumn=input2_tmp_layerinfo.geometrycolumn,
+                    batch_filter=processing_params.batches[batch_id]["batch_filter"],
+                )
+
+                batches[batch_id]["sqlite_stmt"] = sql_stmt
+
+                # Remark: this temp file doesn't need spatial index
+                if use_ogr is False:
+                    # Use an aggressive speedy sqlite profile
+                    future = calculate_pool.submit(
+                        _sqlite_util.create_table_as_sql,
+                        input1_path=processing_params.batches[batch_id]["path"],
+                        input1_layer=processing_params.batches[batch_id]["layer"],
+                        input2_path=processing_params.input2_path,
+                        output_path=tmp_partial_output_path,
+                        sql_stmt=sql_stmt,
+                        output_layer=output_layer,
+                        output_geometrytype=force_output_geometrytype,
+                        create_spatial_index=False,
+                        profile=_sqlite_util.SqliteProfile.SPEED,
+                    )
+                    future_to_batch_id[future] = batch_id
+                else:
+                    # Use ogr to run the query
+                    #   * input2 path (= using attach) doesn't seem to work
+                    #   * ogr doesn't fill out database names, so do it now
+                    sql_stmt = sql_stmt.format(
+                        input1_databasename=processing_params.input1_databasename,
+                        input2_databasename=processing_params.input2_databasename,
+                    )
+
+                    future = calculate_pool.submit(
+                        _ogr_util.vector_translate,
+                        input_path=processing_params.batches[batch_id]["path"],
+                        output_path=tmp_partial_output_path,
+                        sql_stmt=sql_stmt,
+                        output_layer=output_layer,
+                        explodecollections=explodecollections,
+                        force_output_geometrytype=force_output_geometrytype,
+                        options={"LAYER_CREATION.SPATIAL_INDEX": False},
+                    )
+                future_to_batch_id[future] = batch_id
+
+            # Loop till all parallel processes are ready, but process each one
+            # that is ready already
+            nb_done = 0
+            _general_util.report_progress(
+                start_time,
+                nb_done,
+                nb_batches,
+                operation_name,
+                processing_params.nb_parallel,
+            )
+            for future in futures.as_completed(future_to_batch_id):
+                try:
+                    # Get the result
+                    result = future.result()
+                    if result is not None:
+                        logger.debug(result)
+                except Exception as ex:
+                    batch_id = future_to_batch_id[future]
+                    error = str(ex).partition("\n")[0]
+                    message = f"Error <{error}> executing {batches[batch_id]}"
+                    logger.exception(message)
+                    raise Exception(message) from ex
+
+                # If the calculate gave results, copy/append to output
+                batch_id = future_to_batch_id[future]
+                tmp_partial_output_path = batches[batch_id]["tmp_partial_output_path"]
+                nb_done += 1
+
+                # Normally all partial files should exist, but to be sure...
+                if not tmp_partial_output_path.exists():
+                    logger.warning(f"Result file {tmp_partial_output_path} not found")
+                    continue
+
+                # If there is only one tmp_partial file and it is already ok as
+                # output file, just rename/move it.
+                if (
+                    nb_batches == 1
+                    and not explodecollections
+                    and force_output_geometrytype is None
+                    and tmp_partial_output_path.suffix.lower()
+                    == tmp_output_path.suffix.lower()
+                ):
+                    gfo.move(tmp_partial_output_path, tmp_output_path)
+                else:
+                    # If there is only one batch, it is faster to create the spatial
+                    # index immediately
+                    create_spatial_index = False
+                    if nb_batches == 1 and output_with_spatial_index:
+                        create_spatial_index = True
+
+                    fileops._append_to_nolock(
+                        src=tmp_partial_output_path,
+                        dst=tmp_output_path,
+                        explodecollections=explodecollections,
+                        force_output_geometrytype=force_output_geometrytype,
+                        create_spatial_index=create_spatial_index,
+                        preserve_fid=False,
+                    )
+                    gfo.remove(tmp_partial_output_path)
+
+                # Log the progress and prediction speed
+                _general_util.report_progress(
+                    start_time=start_time,
+                    nb_done=nb_done,
+                    nb_todo=nb_batches,
+                    operation=operation_name,
+                    nb_parallel=processing_params.nb_parallel,
+                )
+
+        # Round up and clean up
+        # Now create spatial index and move to output location
+        if tmp_output_path.exists():
+            if output_with_spatial_index:
+                gfo.create_spatial_index(
+                    path=tmp_output_path, layer=output_layer, exist_ok=True
+                )
+            if tmp_output_path != output_path:
+                output_path.parent.mkdir(parents=True, exist_ok=True)
+                gfo.move(tmp_output_path, output_path)
+        else:
+            logger.debug(f"Result of {operation_name} was empty!")
+
+        logger.info(f"{operation_name} ready, took {datetime.now()-start_time}!")
+    except Exception:
+        gfo.remove(output_path, missing_ok=True)
+        gfo.remove(tmp_output_path, missing_ok=True)
+        raise
+    finally:
+        shutil.rmtree(tempdir, ignore_errors=True)
+
+
+class ProcessingParams:
+    def __init__(
+        self,
+        input1_path: Optional[Path] = None,
+        input1_layer: Optional[str] = None,
+        input1_databasename: Optional[str] = None,
+        input2_path: Optional[Path] = None,
+        input2_layer: Optional[str] = None,
+        input2_databasename: Optional[str] = None,
+        nb_parallel: int = -1,
+        batches: Optional[dict] = None,
+    ):
+        self.input1_path = input1_path
+        self.input1_layer = input1_layer
+        self.input1_databasename = input1_databasename
+        self.input2_path = input2_path
+        self.input2_layer = input2_layer
+        self.input2_databasename = input2_databasename
+        self.nb_parallel = nb_parallel
+        self.batches = batches
+
+
+def _prepare_processing_params(
+    input1_path: Path,
+    input1_layer: str,
+    tempdir: Path,
+    convert_to_spatialite_based: bool,
+    nb_parallel: int,
+    batchsize: int = -1,
+    input1_layer_alias: Optional[str] = None,
+    input2_path: Optional[Path] = None,
+    input2_layer: Optional[str] = None,
+) -> Optional[ProcessingParams]:
+    # Init
+    returnvalue = ProcessingParams(nb_parallel=nb_parallel)
+    input1_layerinfo = gfo.get_layerinfo(input1_path, input1_layer)
+
+    # Determine the optimal number of parallel processes + batches
+    if returnvalue.nb_parallel == -1:
+        # If no batch size specified, put at least 100 rows in a batch
+        if batchsize <= 0:
+            min_rows_per_batch = 100
+        else:
+            # If batchsize is specified, use the batch size
+            min_rows_per_batch = batchsize
+
+        max_parallel = max(int(input1_layerinfo.featurecount / min_rows_per_batch), 1)
+        returnvalue.nb_parallel = min(multiprocessing.cpu_count(), max_parallel)
+
+    # Determine optimal number of batches
+    # Remark: especially for 'select' operation, if nb_parallel is 1
+    #         nb_batches should be 1 (select might give wrong results)
+    if returnvalue.nb_parallel > 1:
+        # Limit number of rows processed in parallel to limit memory use
+        if batchsize > 0:
+            max_rows_parallel = batchsize * returnvalue.nb_parallel
+        else:
+            max_rows_parallel = 1000000
+            if input2_path is not None:
+                max_rows_parallel = 200000
+
+        # Adapt number of batches to max_rows_parallel
+        if input1_layerinfo.featurecount > max_rows_parallel:
+            # If more rows than can be handled simultanously in parallel
+            nb_batches = int(
+                input1_layerinfo.featurecount
+                / (max_rows_parallel / returnvalue.nb_parallel)
+            )
+        elif batchsize > 0:
+            # If a batchsize is specified, try to honer it
+            nb_batches = returnvalue.nb_parallel
+        else:
+            # If no batchsize specified and 2 layer processing, add some batches to
+            # reduce impact of possible unbalanced batches on total processing time.
+            nb_batches = returnvalue.nb_parallel
+            if input2_path is not None:
+                nb_batches = returnvalue.nb_parallel * 2
+
+    elif batchsize > 0:
+        nb_batches = math.ceil(input1_layerinfo.featurecount / batchsize)
+    else:
+        nb_batches = 1
+
+    # Prepare input files for the calculation
+    returnvalue.input1_layer = input1_layer
+    returnvalue.input2_layer = input2_layer
+
+    if convert_to_spatialite_based is False:
+        returnvalue.input1_path = input1_path
+        returnvalue.input2_path = input2_path
+    else:
+        # Check if the input files are of the correct geofiletype
+        input1_geofiletype = GeofileType(input1_path)
+        input2_geofiletype = None
+        if input2_path is not None:
+            input2_geofiletype = GeofileType(input2_path)
+
+        # If input files are of the same format + are spatialite compatible,
+        # just use them
+        if input1_geofiletype.is_spatialite_based and (
+            input2_geofiletype is None or input1_geofiletype == input2_geofiletype
+        ):
+            returnvalue.input1_path = input1_path
+            if input1_geofiletype == GeofileType.GPKG:
+                # HasSpatialindex doesn't work for spatialite file
+                gfo.create_spatial_index(input1_path, input1_layer, exist_ok=True)
+        else:
+            # If not ok, copy the input layer to gpkg
+            returnvalue.input1_path = tempdir / f"{input1_path.stem}.gpkg"
+            gfo.convert(
+                src=input1_path,
+                src_layer=input1_layer,
+                dst=returnvalue.input1_path,
+                dst_layer=returnvalue.input1_layer,
+                preserve_fid=True,
+            )
+
+        if input2_path is not None and input2_geofiletype is not None:
+            if (
+                input2_geofiletype == input1_geofiletype
+                and input2_geofiletype.is_spatialite_based
+            ):
+                returnvalue.input2_path = input2_path
+                if input2_geofiletype == GeofileType.GPKG:
+                    # HasSpatialindex doesn't work for spatialite file
+                    gfo.create_spatial_index(input2_path, input2_layer, exist_ok=True)
+            else:
+                # If not spatialite compatible, copy the input layer to gpkg
+                returnvalue.input2_path = tempdir / f"{input2_path.stem}.gpkg"
+                gfo.convert(
+                    src=input2_path,
+                    src_layer=input2_layer,
+                    dst=returnvalue.input2_path,
+                    dst_layer=returnvalue.input2_layer,
+                    preserve_fid=True,
+                )
+
+    # Fill out the database names to use in the sql statements
+    returnvalue.input1_databasename = "main"
+    if input2_path is None or input1_path == input2_path:
+        returnvalue.input2_databasename = returnvalue.input1_databasename
+    else:
+        returnvalue.input2_databasename = "input2"
+
+    # Prepare batches to process
+    # Get column names and info
+    layer1_info = gfo.get_layerinfo(returnvalue.input1_path, returnvalue.input1_layer)
+
+    # Check number of batches + appoint nb rows to batches
+    nb_rows_input_layer = layer1_info.featurecount
+    if nb_batches > int(nb_rows_input_layer / 10):
+        nb_batches = max(int(nb_rows_input_layer / 10), 1)
+
+    batches = {}
+    if nb_batches == 1:
+        # If only one batch, no filtering is needed
+        batches[0] = {}
+        batches[0]["layer"] = returnvalue.input1_layer
+        batches[0]["path"] = returnvalue.input1_path
+        batches[0]["batch_filter"] = ""
+    else:
+        # Determine the min_rowid and max_rowid
+        # Remark: SELECT MIN(rowid), MAX(rowid) FROM ... is a lot slower than UNION ALL!
+        sql_stmt = f"""
+            SELECT MIN(rowid) minmax_rowid FROM "{layer1_info.name}"
+            UNION ALL
+            SELECT MAX(rowid) minmax_rowid FROM "{layer1_info.name}"
+        """
+        batch_info_df = gfo.read_file(
+            path=returnvalue.input1_path, sql_stmt=sql_stmt, sql_dialect="SQLITE"
+        )
+        min_rowid = pd.to_numeric(batch_info_df["minmax_rowid"][0]).item()
+        max_rowid = pd.to_numeric(batch_info_df["minmax_rowid"][1]).item()
+
+        # Determine the exact batches to use
+        if ((max_rowid - min_rowid) / nb_rows_input_layer) < 1.1:
+            # If the rowid's are quite consecutive, use an imperfect, but
+            # fast distribution in batches
+            batch_info_list = []
+            nb_rows_per_batch = round(nb_rows_input_layer / nb_batches)
+            offset = 0
+            offset_per_batch = round((max_rowid - min_rowid) / nb_batches)
+            for batch_id in range(nb_batches):
+                start_rowid = offset
+                if batch_id < (nb_batches - 1):
+                    # End rowid for this batch is the next start_rowid - 1
+                    end_rowid = offset + offset_per_batch - 1
+                else:
+                    # For the last batch, take the max_rowid so no rowid's are
+                    # 'lost' due to rounding errors
+                    end_rowid = max_rowid
+                batch_info_list.append(
+                    (batch_id, nb_rows_per_batch, start_rowid, end_rowid)
+                )
+                offset += offset_per_batch
+            batch_info_df = pd.DataFrame(
+                batch_info_list, columns=["id", "nb_rows", "start_rowid", "end_rowid"]
+            )
+        else:
+            # The rowids are not consecutive, so determine the optimal rowid
+            # ranges for each batch so each batch has same number of elements
+            # Remark: this might take some seconds for larger datasets!
+            sql_stmt = f"""
+                SELECT batch_id AS id
+                      ,COUNT(*) AS nb_rows
+                      ,MIN(rowid) AS start_rowid
+                      ,MAX(rowid) AS end_rowid
+                  FROM
+                    ( SELECT rowid
+                            ,NTILE({nb_batches}) OVER (ORDER BY rowid) batch_id
+                        FROM "{layer1_info.name}"
+                    )
+                 GROUP BY batch_id;
+            """
+            batch_info_df = gfo.read_file(
+                path=returnvalue.input1_path, sql_stmt=sql_stmt
+            )
+
+        # Prepare the layer alias to use in the batch filter
+        layer_alias_d = ""
+        if input1_layer_alias is not None:
+            layer_alias_d = f"{input1_layer_alias}."
+
+        # Now loop over all batch ranges to build up the necessary filters
+        for batch_info in batch_info_df.itertuples():
+            # Fill out the batch properties
+            batches[batch_info.id] = {}
+            batches[batch_info.id]["layer"] = returnvalue.input1_layer
+            batches[batch_info.id]["path"] = returnvalue.input1_path
+
+            # The batch filter
+            if batch_info.id < nb_batches:
+                batches[batch_info.id]["batch_filter"] = (
+                    f"AND ({layer_alias_d}rowid >= {batch_info.start_rowid} "
+                    f"AND {layer_alias_d}rowid <= {batch_info.end_rowid}) "
+                )
+            else:
+                batches[batch_info.id][
+                    "batch_filter"
+                ] = f"AND {layer_alias_d}rowid >= {batch_info.start_rowid} "
+
+    # No use starting more processes than the number of batches...
+    if len(batches) < returnvalue.nb_parallel:
+        returnvalue.nb_parallel = len(batches)
+
+    returnvalue.batches = batches
+    return returnvalue
+
+
+def dissolve_singlethread(
+    input_path: Path,
+    output_path: Path,
+    groupby_columns: Union[str, Iterable[str], None] = None,
+    agg_columns: Optional[dict] = None,
+    explodecollections: bool = False,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    force: bool = False,
+):
+    """
+    Remark: this is not a parallelized version!!!
+    """
+    # Init
+    start_time = datetime.now()
+
+    # Check input params
+    if not input_path.exists():
+        raise ValueError(f"input_path doesn't exist: {input_path}")
+    if input_path == output_path:
+        raise ValueError("output_path must not equal input_path")
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop dissolve: Output exists already {output_path}")
+            return
+        else:
+            gfo.remove(output_path)
+
+    # Check layer names
+    if input_layer is None:
+        input_layer = gfo.get_only_layer(input_path)
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+
+    # Use get_layerinfo to check if the layer definition is OK
+    layerinfo = gfo.get_layerinfo(input_path, input_layer)
+    fid_column = layerinfo.fid_column if layerinfo.fid_column != "" else "rowid"
+    # Prepare some lists for later use
+    columns_available = list(layerinfo.columns) + ["fid"]
+    columns_available_upper = [column.upper() for column in columns_available]
+    groupby_columns_upper_dict = {}
+    if groupby_columns is not None:
+        groupby_columns_upper_dict = {col.upper(): col for col in groupby_columns}
+
+    # Prepare the strings regarding groupby_columns to use in the select statement.
+    if groupby_columns is not None:
+        # Standardize parameter to simplify the rest of the code
+        if isinstance(groupby_columns, str):
+            # If a string is passed, convert to list
+            groupby_columns = [groupby_columns]
+
+        # Check if all groupby columns exist
+        for column in groupby_columns:
+            if column.upper() not in columns_available_upper:
+                raise ValueError(f"column in groupby_columns not in input: {column}")
+
+        # Because the query uses a subselect, the groupby columns need to be prefixed.
+        columns_prefixed = [f'layer."{column}"' for column in groupby_columns]
+        groupby_columns_for_groupby_str = ", ".join(columns_prefixed)
+        columns_prefixed_aliased = [
+            f'layer."{column}" "{column}"' for column in groupby_columns
+        ]
+        groupby_columns_for_select_str = f", {', '.join(columns_prefixed_aliased)}"
+    else:
+        # Even if no groupby is provided, we still need to use a groupby clause,
+        # otherwise ST_union doesn't seem to work.
+        groupby_columns_for_groupby_str = "'1'"
+        groupby_columns_for_select_str = ""
+
+    # Prepare the strings regarding agg_columns to use in the select statement.
+    agg_columns_str = ""
+    if agg_columns is not None:
+        # Validate the dict structure, so we can assume everything is OK further on
+        _parameter_helper.validate_agg_columns(agg_columns)
+
+        # Start preparation of agg_columns_str
+        if "json" in agg_columns:
+            # Determine the columns to be put in json
+            columns = []
+            if agg_columns["json"] is None:
+                # If columns specified is None: all columns not in groupby_columns
+                for column in layerinfo.columns:
+                    if column.upper() not in groupby_columns_upper_dict:
+                        columns.append(column)
+            else:
+                for column in agg_columns["json"]:
+                    columns.append(column)
+            json_columns = [f"'{column}', layer.\"{column}\"" for column in columns]
+
+            # The fid should be added as well, but make name unique
+            fid_orig_column = "fid_orig"
+            for idx in range(0, 99999):
+                if idx != 0:
+                    fid_orig_column = f"fid_orig{idx}"
+                if fid_orig_column not in columns:
+                    break
+            json_columns.append(f"'{fid_orig_column}', layer.\"{fid_column}\"")
+
+            # Now we are ready to prepare final str
+            agg_columns_str = (
+                f", json_group_array(json_object({', '.join(json_columns)})) as json"
+            )
+        elif "columns" in agg_columns:
+            for agg_column in agg_columns["columns"]:
+                # Init
+                distinct_str = ""
+                extra_param_str = ""
+
+                # Prepare aggregation keyword
+                if agg_column["agg"].lower() in [
+                    "count",
+                    "sum",
+                    "min",
+                    "max",
+                    "median",
+                ]:
+                    aggregation_str = agg_column["agg"]
+                elif agg_column["agg"].lower() in ["mean", "avg"]:
+                    aggregation_str = "avg"
+                elif agg_column["agg"].lower() == "concat":
+                    aggregation_str = "group_concat"
+                    if "sep" in agg_column:
+                        extra_param_str = f", '{agg_column['sep']}'"
+                else:
+                    raise ValueError(f"aggregation {agg_column['agg']} not supported!")
+
+                # If distinct is specified, add the distinct keyword
+                if "distinct" in agg_column and agg_column["distinct"] is True:
+                    distinct_str = "DISTINCT "
+
+                # Prepare column name string
+                column = agg_column["column"]
+                if column.upper() not in columns_available_upper:
+                    raise ValueError(f"{column} not available in: {columns_available}")
+                if column.upper() == "FID":
+                    column_str = f'layer."{fid_column}"'
+                else:
+                    column_str = f'layer."{column}"'
+
+                # Now put everything together
+                agg_columns_str += (
+                    f", {aggregation_str}({distinct_str}{column_str}{extra_param_str}) "
+                    f'AS "{agg_column["as"]}"'
+                )
+
+    # Now prepare the sql statement
+    # Remark: calculating the area in the enclosing selects halves the processing time
+
+    # The operation to run on the geometry
+    operation = f"ST_union(layer.{layerinfo.geometrycolumn})"
+
+    # If the input is a linestring, also apply st_linemerge(), otherwise the individual
+    # lines are just concatenated together and common points are not removed, resulting
+    # in the original seperate lines again if explodecollections is True.
+    force_output_geometrytype = None
+    if layerinfo.geometrytype.to_primitivetype == PrimitiveType.LINESTRING:
+        operation = f"ST_LineMerge({operation})"
+        if explodecollections is True:
+            force_output_geometrytype = GeometryType.LINESTRING
+
+    # If there are no input features, the output geometry type needs to be specified
+    # so gdal can create an empty output file with the right geometry type.
+    if force_output_geometrytype is None and layerinfo.featurecount == 0:
+        force_output_geometrytype = layerinfo.geometrytype
+
+    sql_stmt = f"""
+        SELECT {operation} AS geom
+            {groupby_columns_for_select_str}
+            {agg_columns_str}
+        FROM "{input_layer}" layer
+        GROUP BY {groupby_columns_for_groupby_str}
+    """
+
+    _ogr_util.vector_translate(
+        input_path=input_path,
+        output_path=output_path,
+        output_layer=output_layer,
+        sql_stmt=sql_stmt,
+        sql_dialect="SQLITE",
+        force_output_geometrytype=force_output_geometrytype,
+        explodecollections=explodecollections,
+        options={"LAYER_CREATION.SPATIAL_INDEX": True},
+    )
+
+    logger.info(f"Processing ready, took {datetime.now()-start_time}!")
```

### Comparing `geofileops-0.8.0a1/geofileops/util/_io_util.py` & `geofileops-0.8.0a2/geofileops/util/_io_util.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,134 +1,134 @@
-# -*- coding: utf-8 -*-
-"""
-Module containing some utilities regarding io.
-"""
-
-import os
-from pathlib import Path
-import tempfile
-from typing import Optional, Tuple
-
-
-def create_tempdir(base_dirname: str, parent_dir: Optional[Path] = None) -> Path:
-    """
-    Creates a new tempdir in the default temp location.
-
-    Remark: the temp dir won't be cleaned up automatically!
-
-    Examples:
-
-        - base_dirname="foo" -> /tmp/foo_000001
-        - base_dirname="foo/bar" -> /tmp/foo/bar_000001
-
-    Args:
-        base_dirname (str): The name the tempdir will start with. The name will be
-            suffixed with a number to make the directory name unique. If a "/" is part
-            of the base_dirname a subdirectory will be created: e.g. "foo/bar".
-        parent_dir (Path, optional): The dir to create the tempdir in. If None, the
-            system temp dir is used. Defaults to None.
-
-    Raises:
-        Exception: if it wasn't possible to create the temp dir because there
-            wasn't found a unique directory name.
-
-    Returns:
-        Path: the path to the temp dir created.
-    """
-
-    if parent_dir is None:
-        parent_dir = Path(tempfile.gettempdir())
-
-    for i in range(1, 999999):
-        try:
-            tempdir = parent_dir / f"{base_dirname}_{i:06d}"
-            tempdir.mkdir(parents=True)
-            return tempdir
-        except FileExistsError:
-            continue
-
-    raise Exception(
-        f"Wasn't able to create a temporary dir with basedir: "
-        f"{parent_dir / base_dirname}"
-    )
-
-
-def get_tempfile_locked(
-    base_filename: str,
-    suffix: str = ".tmp",
-    dirname: Optional[str] = None,
-    tempdir: Optional[Path] = None,
-) -> Tuple[Path, Path]:
-    """
-    Formats a temp file path, and creates a corresponding lock file so you can
-    treat it immediately as being locked.
-
-    Args:
-        base_filename (str): The base filename to use. A numeric suffix will be
-            appended to make the filename unique.
-        suffix (str, optional): The suffix/extension of the tempfile.
-            Defaults to '.tmp'.
-        dirname (str, optional): Name of the subdir to put the tempfile in.
-            Defaults to None, then the tempfile created is put directly in the
-            root of the tempdir.
-        tempdir (Path, optional): Root temp dir to create the file in. If no
-            tempdir is specified, the default temp dir will be used.
-            Defaults to None.
-
-    Raises:
-        Exception: if it wasn't possible to create the temp dir because there
-            wasn't found a unique file name.
-
-    Returns:
-        Tuple[Path, Path]: First path is the temp file, second one is the lock file.
-    """
-    # If no dir specified, use default temp dir
-    if tempdir is None:
-        tempdir = Path(tempfile.gettempdir())
-    if dirname is not None:
-        tempdir = tempdir / dirname
-        tempdir.mkdir(parents=True, exist_ok=True)
-
-    # Now look for a unique filename based on the base_filename and put a lock file
-    for i in range(1, 999999):
-        tempfile_path = tempdir / f"{base_filename}_{i:06d}{suffix}"
-        tempfilelock_path = tempdir / f"{base_filename}_{i:06d}{suffix}.lock"
-        result = create_file_atomic(tempfilelock_path)
-        if result is True:
-            if not tempfile_path.exists():
-                # OK!
-                return (tempfile_path, tempfilelock_path)
-            else:
-                # Apparently the lock file didn't exist yet, but the file did.
-                # So delete lock file and try again.
-                tempfilelock_path.unlink()
-
-    raise Exception(
-        f"Wasn't able to create a temporary file with base_filename: {base_filename}, "
-        f"dir: {dir}"
-    )
-
-
-def create_file_atomic(filename) -> bool:
-    """
-    Create a lock file in an atomic way, so it is threadsafe.
-
-    Returns True if the file was created by this thread, False if the file existed
-    already.
-    """
-    try:
-        fd = os.open(filename, os.O_CREAT | os.O_EXCL)
-        os.close(fd)
-        return True
-    except FileExistsError:
-        return False
-    except IOError as ex:
-        if ex.errno == 13:
-            return False
-        else:
-            raise Exception("Error creating lock file {filename}") from ex
-
-
-def with_stem(path: Path, new_stem) -> Path:
-    # Remark: from python 3.9 this is available on any Path, but to evade
-    # having to require 3.9 for this, this hack...
-    return path.parent / f"{new_stem}{path.suffix}"
+# -*- coding: utf-8 -*-
+"""
+Module containing some utilities regarding io.
+"""
+
+import os
+from pathlib import Path
+import tempfile
+from typing import Optional, Tuple
+
+
+def create_tempdir(base_dirname: str, parent_dir: Optional[Path] = None) -> Path:
+    """
+    Creates a new tempdir in the default temp location.
+
+    Remark: the temp dir won't be cleaned up automatically!
+
+    Examples:
+
+        - base_dirname="foo" -> /tmp/foo_000001
+        - base_dirname="foo/bar" -> /tmp/foo/bar_000001
+
+    Args:
+        base_dirname (str): The name the tempdir will start with. The name will be
+            suffixed with a number to make the directory name unique. If a "/" is part
+            of the base_dirname a subdirectory will be created: e.g. "foo/bar".
+        parent_dir (Path, optional): The dir to create the tempdir in. If None, the
+            system temp dir is used. Defaults to None.
+
+    Raises:
+        Exception: if it wasn't possible to create the temp dir because there
+            wasn't found a unique directory name.
+
+    Returns:
+        Path: the path to the temp dir created.
+    """
+
+    if parent_dir is None:
+        parent_dir = Path(tempfile.gettempdir())
+
+    for i in range(1, 999999):
+        try:
+            tempdir = parent_dir / f"{base_dirname}_{i:06d}"
+            tempdir.mkdir(parents=True)
+            return tempdir
+        except FileExistsError:
+            continue
+
+    raise Exception(
+        f"Wasn't able to create a temporary dir with basedir: "
+        f"{parent_dir / base_dirname}"
+    )
+
+
+def get_tempfile_locked(
+    base_filename: str,
+    suffix: str = ".tmp",
+    dirname: Optional[str] = None,
+    tempdir: Optional[Path] = None,
+) -> Tuple[Path, Path]:
+    """
+    Formats a temp file path, and creates a corresponding lock file so you can
+    treat it immediately as being locked.
+
+    Args:
+        base_filename (str): The base filename to use. A numeric suffix will be
+            appended to make the filename unique.
+        suffix (str, optional): The suffix/extension of the tempfile.
+            Defaults to '.tmp'.
+        dirname (str, optional): Name of the subdir to put the tempfile in.
+            Defaults to None, then the tempfile created is put directly in the
+            root of the tempdir.
+        tempdir (Path, optional): Root temp dir to create the file in. If no
+            tempdir is specified, the default temp dir will be used.
+            Defaults to None.
+
+    Raises:
+        Exception: if it wasn't possible to create the temp dir because there
+            wasn't found a unique file name.
+
+    Returns:
+        Tuple[Path, Path]: First path is the temp file, second one is the lock file.
+    """
+    # If no dir specified, use default temp dir
+    if tempdir is None:
+        tempdir = Path(tempfile.gettempdir())
+    if dirname is not None:
+        tempdir = tempdir / dirname
+        tempdir.mkdir(parents=True, exist_ok=True)
+
+    # Now look for a unique filename based on the base_filename and put a lock file
+    for i in range(1, 999999):
+        tempfile_path = tempdir / f"{base_filename}_{i:06d}{suffix}"
+        tempfilelock_path = tempdir / f"{base_filename}_{i:06d}{suffix}.lock"
+        result = create_file_atomic(tempfilelock_path)
+        if result is True:
+            if not tempfile_path.exists():
+                # OK!
+                return (tempfile_path, tempfilelock_path)
+            else:
+                # Apparently the lock file didn't exist yet, but the file did.
+                # So delete lock file and try again.
+                tempfilelock_path.unlink()
+
+    raise Exception(
+        f"Wasn't able to create a temporary file with base_filename: {base_filename}, "
+        f"dir: {dir}"
+    )
+
+
+def create_file_atomic(filename) -> bool:
+    """
+    Create a lock file in an atomic way, so it is threadsafe.
+
+    Returns True if the file was created by this thread, False if the file existed
+    already.
+    """
+    try:
+        fd = os.open(filename, os.O_CREAT | os.O_EXCL)
+        os.close(fd)
+        return True
+    except FileExistsError:
+        return False
+    except IOError as ex:
+        if ex.errno == 13:
+            return False
+        else:
+            raise Exception("Error creating lock file {filename}") from ex
+
+
+def with_stem(path: Path, new_stem) -> Path:
+    # Remark: from python 3.9 this is available on any Path, but to evade
+    # having to require 3.9 for this, this hack...
+    return path.parent / f"{new_stem}{path.suffix}"
```

### Comparing `geofileops-0.8.0a1/geofileops/util/_ogr_sql_util.py` & `geofileops-0.8.0a2/geofileops/util/_ogr_sql_util.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,185 +1,185 @@
-# -*- coding: utf-8 -*-
-"""
-Module containing utilities regarding the formatting of sql statements meant for use
-with ogr.
-"""
-
-from typing import Iterable, List, Optional
-
-
-class ColumnFormatter:
-    """
-    Format strings with the columns for use in sql statements.
-
-    There are some specific hacks that are related to specific behaviours of ogr, mainly
-    regarding the handling of the special "fid" column.
-    """
-
-    _aliases_cache = None
-
-    def __init__(
-        self,
-        columns_asked: Optional[List[str]],
-        columns_in_layer: Iterable[str],
-        fid_column: str,
-        table_alias: str = "",
-        column_alias_prefix: str = "",
-    ):
-        """
-        Format strings with column names for use in sql statements.
-
-        Args:
-            columns_asked (Optional[List[str]]): the column names to read from the
-                file. If None, all available columns in the layer should be read.
-                In addition to standard columns, it is also possible to specify "fid",
-                a unique index available in all input files.
-                Note that the "fid" will be aliased even if column_alias_prefix is "",
-                eg. to "fid_1".
-            columns_in_layer (Iterable[str]): the column names of the columns available
-                in the layer that is being read from.
-            fid_column (str): fid column name as reported by the gdal GetFIDColumn()
-                function. For file types that don't store the fid this is "".
-            table_alias (str, optional): table alias to be used.
-                Defaults to "": no table alias.
-            column_alias_prefix (str, optional): prefix to use for column aliases.
-                Defaults to "": no prefix.
-
-        Raises:
-            ValueError: if columns are asked that are not available in the layer.
-        """
-        self._columns_in_layer = columns_in_layer
-        self._fid_column = fid_column
-        self._table_prefix = f"{table_alias}." if table_alias != "" else ""
-        self._table_alias = table_alias
-        self._columnname_prefix = column_alias_prefix
-
-        # Now prepare the actual column list to use
-        if columns_asked is not None:
-            # Add special column "fid" to available columns so it can be specified
-            columns_in_layer = list(columns_in_layer) + ["fid"]
-            # Case-insensitive check if input1_columns contains columns not in layer...
-            columns_in_layer_upper = {
-                column.upper(): column for column in columns_in_layer
-            }
-            missing_columns = [
-                col
-                for col in columns_asked
-                if (col.upper() not in columns_in_layer_upper)
-            ]
-            if len(missing_columns) > 0:
-                raise ValueError(
-                    "columns_asked contains columns not in columns_in_layer: "
-                    f"{missing_columns}. Available: {columns_in_layer}"
-                )
-
-            # Create column list to keep in the casing of the original columns
-            columns = [columns_in_layer_upper[col.upper()] for col in columns_asked]
-        else:
-            columns = list(columns_in_layer)
-            columns_asked = columns
-
-        self._columns = columns
-        self._columns_asked = columns_asked
-
-    def _columns_prefixed(self) -> List[str]:
-        columns_prefixed = [
-            f'{self._table_prefix}"{column}"' for column in self._columns
-        ]
-        columns_prefixed = self._fix_fid_columns(columns_prefixed)
-        return columns_prefixed
-
-    def _fix_fid_columns(self, columns: List[str]) -> List[str]:
-        """
-        The "fid" special column needs some extra treatment:
-            - if the fid_column name as reported by gdal is "", this means that the file
-              format doesn't actually save the fid (eg. shapefile) but uses a row number
-              in the file. When using sql in sql_dialect "SQLITE", "rowid" is the
-              equivalent.
-            - if the fid_column name as reported by gdal is "fid", ogr will treat the
-              selected column as "fid" in the destination file as well, even if an alias
-              is specified. To stop ogr from doing this, putting a CAST(... AS INT)
-              around it prevents ogr from recognizing it.
-              Remark: the ogr2ogr -unsetFid switch didn't help.
-            - if the fid_column name as reported by gdal is some other string, "fid"
-              just needs to be replaced by the fid_column value.
-        """
-        columns = list(columns)
-        fid_column_indexes = [
-            idx for idx, col in enumerate(self._columns) if col.upper() == "FID"
-        ]
-        if self._fid_column.lower() == "fid":
-            # Put CAST() around "fid"
-            for fid_column_index in fid_column_indexes:
-                columns[fid_column_index] = f"CAST({columns[fid_column_index]} AS INT)"
-        else:
-            # Replace "fid" by the fid_column or rowid
-            replace_fid_column = self._fid_column if self._fid_column != "" else "rowid"
-            for fid_column_index in fid_column_indexes:
-                columns[fid_column_index] = columns[fid_column_index].replace(
-                    self._columns[fid_column_index], replace_fid_column
-                )
-
-        return columns
-
-    def _aliases(self) -> List[str]:
-        if self._aliases_cache is not None:
-            return self._aliases_cache
-
-        # Use columns_asked to keep asked casing
-        aliases = [
-            f"{self._columnname_prefix}{column}" for column in self._columns_asked
-        ]
-
-        # If no prefix, create a unique alias for fid column(s)
-        if self._columnname_prefix == "":
-            for alias_idx, alias in enumerate(aliases):
-                if alias.lower() == "fid":
-                    # If alias "fid", change it + make sure the alias isn't in use yet
-                    for idx in range(1, 100):
-                        alias_with_id = f"{alias}_{idx}"
-                        if alias_with_id not in aliases:
-                            aliases[alias_idx] = alias_with_id
-                            break
-
-        self._aliases_cache = aliases
-        return self._aliases_cache
-
-    def quoted(self) -> str:
-        if len(self._columns) == 0:
-            return ""
-
-        columns_quoted = [f'"{column}"' for column in self._columns]
-        columns_quoted = self._fix_fid_columns(columns_quoted)
-        return f",{', '.join(columns_quoted)}"
-
-    def prefixed(self) -> str:
-        if len(self._columns) == 0:
-            return ""
-        return f",{', '.join(self._columns_prefixed())}"
-
-    def prefixed_aliased(self):
-        if len(self._columns) == 0:
-            return ""
-
-        columns_prefixed_aliased = [
-            f'{column_prefixed} "{column_alias}"'
-            for column_prefixed, column_alias in zip(
-                self._columns_prefixed(), self._aliases()
-            )
-        ]
-        return f",{', '.join(columns_prefixed_aliased)}"
-
-    def null_aliased(self):
-        if len(self._columns) == 0:
-            return ""
-
-        columns_null_aliased = [f'NULL "{alias}"' for alias in self._aliases()]
-        return f",{', '.join(columns_null_aliased)}"
-
-    def from_subselect(self, subselect_alias: str = "sub"):
-        if len(self._columns) == 0:
-            return ""
-
-        prefix = "" if subselect_alias == "" else f"{subselect_alias}."
-        columns_from_subselect = [f'{prefix}"{alias}"' for alias in self._aliases()]
-        return f",{', '.join(columns_from_subselect)}"
+# -*- coding: utf-8 -*-
+"""
+Module containing utilities regarding the formatting of sql statements meant for use
+with ogr.
+"""
+
+from typing import Iterable, List, Optional
+
+
+class ColumnFormatter:
+    """
+    Format strings with the columns for use in sql statements.
+
+    There are some specific hacks that are related to specific behaviours of ogr, mainly
+    regarding the handling of the special "fid" column.
+    """
+
+    _aliases_cache = None
+
+    def __init__(
+        self,
+        columns_asked: Optional[List[str]],
+        columns_in_layer: Iterable[str],
+        fid_column: str,
+        table_alias: str = "",
+        column_alias_prefix: str = "",
+    ):
+        """
+        Format strings with column names for use in sql statements.
+
+        Args:
+            columns_asked (Optional[List[str]]): the column names to read from the
+                file. If None, all available columns in the layer should be read.
+                In addition to standard columns, it is also possible to specify "fid",
+                a unique index available in all input files.
+                Note that the "fid" will be aliased even if column_alias_prefix is "",
+                eg. to "fid_1".
+            columns_in_layer (Iterable[str]): the column names of the columns available
+                in the layer that is being read from.
+            fid_column (str): fid column name as reported by the gdal GetFIDColumn()
+                function. For file types that don't store the fid this is "".
+            table_alias (str, optional): table alias to be used.
+                Defaults to "": no table alias.
+            column_alias_prefix (str, optional): prefix to use for column aliases.
+                Defaults to "": no prefix.
+
+        Raises:
+            ValueError: if columns are asked that are not available in the layer.
+        """
+        self._columns_in_layer = columns_in_layer
+        self._fid_column = fid_column
+        self._table_prefix = f"{table_alias}." if table_alias != "" else ""
+        self._table_alias = table_alias
+        self._columnname_prefix = column_alias_prefix
+
+        # Now prepare the actual column list to use
+        if columns_asked is not None:
+            # Add special column "fid" to available columns so it can be specified
+            columns_in_layer = list(columns_in_layer) + ["fid"]
+            # Case-insensitive check if input1_columns contains columns not in layer...
+            columns_in_layer_upper = {
+                column.upper(): column for column in columns_in_layer
+            }
+            missing_columns = [
+                col
+                for col in columns_asked
+                if (col.upper() not in columns_in_layer_upper)
+            ]
+            if len(missing_columns) > 0:
+                raise ValueError(
+                    "columns_asked contains columns not in columns_in_layer: "
+                    f"{missing_columns}. Available: {columns_in_layer}"
+                )
+
+            # Create column list to keep in the casing of the original columns
+            columns = [columns_in_layer_upper[col.upper()] for col in columns_asked]
+        else:
+            columns = list(columns_in_layer)
+            columns_asked = columns
+
+        self._columns = columns
+        self._columns_asked = columns_asked
+
+    def _columns_prefixed(self) -> List[str]:
+        columns_prefixed = [
+            f'{self._table_prefix}"{column}"' for column in self._columns
+        ]
+        columns_prefixed = self._fix_fid_columns(columns_prefixed)
+        return columns_prefixed
+
+    def _fix_fid_columns(self, columns: List[str]) -> List[str]:
+        """
+        The "fid" special column needs some extra treatment:
+            - if the fid_column name as reported by gdal is "", this means that the file
+              format doesn't actually save the fid (eg. shapefile) but uses a row number
+              in the file. When using sql in sql_dialect "SQLITE", "rowid" is the
+              equivalent.
+            - if the fid_column name as reported by gdal is "fid", ogr will treat the
+              selected column as "fid" in the destination file as well, even if an alias
+              is specified. To stop ogr from doing this, putting a CAST(... AS INT)
+              around it prevents ogr from recognizing it.
+              Remark: the ogr2ogr -unsetFid switch didn't help.
+            - if the fid_column name as reported by gdal is some other string, "fid"
+              just needs to be replaced by the fid_column value.
+        """
+        columns = list(columns)
+        fid_column_indexes = [
+            idx for idx, col in enumerate(self._columns) if col.upper() == "FID"
+        ]
+        if self._fid_column.lower() == "fid":
+            # Put CAST() around "fid"
+            for fid_column_index in fid_column_indexes:
+                columns[fid_column_index] = f"CAST({columns[fid_column_index]} AS INT)"
+        else:
+            # Replace "fid" by the fid_column or rowid
+            replace_fid_column = self._fid_column if self._fid_column != "" else "rowid"
+            for fid_column_index in fid_column_indexes:
+                columns[fid_column_index] = columns[fid_column_index].replace(
+                    self._columns[fid_column_index], replace_fid_column
+                )
+
+        return columns
+
+    def _aliases(self) -> List[str]:
+        if self._aliases_cache is not None:
+            return self._aliases_cache
+
+        # Use columns_asked to keep asked casing
+        aliases = [
+            f"{self._columnname_prefix}{column}" for column in self._columns_asked
+        ]
+
+        # If no prefix, create a unique alias for fid column(s)
+        if self._columnname_prefix == "":
+            for alias_idx, alias in enumerate(aliases):
+                if alias.lower() == "fid":
+                    # If alias "fid", change it + make sure the alias isn't in use yet
+                    for idx in range(1, 100):
+                        alias_with_id = f"{alias}_{idx}"
+                        if alias_with_id not in aliases:
+                            aliases[alias_idx] = alias_with_id
+                            break
+
+        self._aliases_cache = aliases
+        return self._aliases_cache
+
+    def quoted(self) -> str:
+        if len(self._columns) == 0:
+            return ""
+
+        columns_quoted = [f'"{column}"' for column in self._columns]
+        columns_quoted = self._fix_fid_columns(columns_quoted)
+        return f",{', '.join(columns_quoted)}"
+
+    def prefixed(self) -> str:
+        if len(self._columns) == 0:
+            return ""
+        return f",{', '.join(self._columns_prefixed())}"
+
+    def prefixed_aliased(self):
+        if len(self._columns) == 0:
+            return ""
+
+        columns_prefixed_aliased = [
+            f'{column_prefixed} "{column_alias}"'
+            for column_prefixed, column_alias in zip(
+                self._columns_prefixed(), self._aliases()
+            )
+        ]
+        return f",{', '.join(columns_prefixed_aliased)}"
+
+    def null_aliased(self):
+        if len(self._columns) == 0:
+            return ""
+
+        columns_null_aliased = [f'NULL "{alias}"' for alias in self._aliases()]
+        return f",{', '.join(columns_null_aliased)}"
+
+    def from_subselect(self, subselect_alias: str = "sub"):
+        if len(self._columns) == 0:
+            return ""
+
+        prefix = "" if subselect_alias == "" else f"{subselect_alias}."
+        columns_from_subselect = [f'{prefix}"{alias}"' for alias in self._aliases()]
+        return f",{', '.join(columns_from_subselect)}"
```

### Comparing `geofileops-0.8.0a1/geofileops/util/_ogr_util.py` & `geofileops-0.8.0a2/geofileops/util/_ogr_util.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,486 +1,486 @@
-# -*- coding: utf-8 -*-
-"""
-Module containing utilities regarding the usage of ogr functionalities.
-"""
-
-# -------------------------------------
-# Import/init needed modules
-# -------------------------------------
-import logging
-import os
-from pathlib import Path
-import tempfile
-from threading import Lock
-from typing import List, Literal, Optional, Tuple, Union
-
-from osgeo import gdal
-
-import geofileops as gfo
-from geofileops.util.geofiletype import GeofileType
-from geofileops.util.geometry_util import GeometryType
-
-#####################################################################
-# First define/init some general variables/constants
-#####################################################################
-
-# Make sure only one instance per process is running
-lock = Lock()
-
-# Get a logger...
-logger = logging.getLogger(__name__)
-
-#####################################################################
-# The real work
-#####################################################################
-
-
-class GFOError(Exception):
-    pass
-
-
-def get_drivers() -> dict:
-    drivers = {}
-    for i in range(gdal.GetDriverCount()):
-        driver = gdal.GetDriver(i)
-        drivers[driver.ShortName] = driver.GetDescription()
-    return drivers
-
-
-class VectorTranslateInfo:
-    def __init__(
-        self,
-        input_path: Path,
-        output_path: Path,
-        input_layers: Union[List[str], str, None] = None,
-        output_layer: Optional[str] = None,
-        input_srs: Union[int, str, None] = None,
-        output_srs: Union[int, str, None] = None,
-        reproject: bool = False,
-        spatial_filter: Optional[Tuple[float, float, float, float]] = None,
-        clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
-        sql_stmt: Optional[str] = None,
-        sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
-        transaction_size: int = 65536,
-        append: bool = False,
-        update: bool = False,
-        explodecollections: bool = False,
-        force_output_geometrytype: Union[GeometryType, str, None] = None,
-        options: dict = {},
-        columns: Optional[List[str]] = None,
-        warp: Optional[dict] = None,
-        preserve_fid: Optional[bool] = None,
-    ):
-        self.input_path = input_path
-        self.output_path = output_path
-        self.input_layers = input_layers
-        self.output_layer = output_layer
-        self.input_srs = input_srs
-        self.output_srs = output_srs
-        self.reproject = reproject
-        self.spatial_filter = spatial_filter
-        self.clip_geometry = clip_geometry
-        self.sql_stmt = sql_stmt
-        self.sql_dialect = sql_dialect
-        self.transaction_size = transaction_size
-        self.append = append
-        self.update = update
-        self.explodecollections = explodecollections
-        self.force_output_geometrytype = force_output_geometrytype
-        self.options = options
-        self.columns = columns
-        self.warp = warp
-        self.preserve_fid = preserve_fid
-
-
-def vector_translate_by_info(info: VectorTranslateInfo):
-    return vector_translate(
-        input_path=info.input_path,
-        output_path=info.output_path,
-        input_layers=info.input_layers,
-        output_layer=info.output_layer,
-        input_srs=info.input_srs,
-        output_srs=info.output_srs,
-        reproject=info.reproject,
-        spatial_filter=info.spatial_filter,
-        clip_geometry=info.clip_geometry,
-        sql_stmt=info.sql_stmt,
-        sql_dialect=info.sql_dialect,  # type: ignore
-        transaction_size=info.transaction_size,
-        append=info.append,
-        update=info.update,
-        explodecollections=info.explodecollections,
-        force_output_geometrytype=info.force_output_geometrytype,
-        options=info.options,
-        columns=info.columns,
-        warp=info.warp,
-        preserve_fid=info.preserve_fid,
-    )
-
-
-def vector_translate(
-    input_path: Union[Path, str],
-    output_path: Path,
-    input_layers: Union[List[str], str, None] = None,
-    output_layer: Optional[str] = None,
-    input_srs: Union[int, str, None] = None,
-    output_srs: Union[int, str, None] = None,
-    reproject: bool = False,
-    spatial_filter: Optional[Tuple[float, float, float, float]] = None,
-    clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
-    sql_stmt: Optional[str] = None,
-    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
-    transaction_size: int = 65536,
-    append: bool = False,
-    update: bool = False,
-    explodecollections: bool = False,
-    force_output_geometrytype: Union[GeometryType, str, None] = None,
-    options: dict = {},
-    columns: Optional[List[str]] = None,
-    warp: Optional[dict] = None,
-    preserve_fid: Optional[bool] = None,
-) -> bool:
-    # API Doc of VectorTranslateOptions:
-    #   https://gdal.org/api/python/osgeo.gdal.html#osgeo.gdal.VectorTranslateOptions
-    args = []
-    if isinstance(input_path, str):
-        input_path = Path(input_path)
-    gdal_options = _prepare_gdal_options(options, split_by_option_type=True)
-
-    # Input file parameters
-    # Cleanup the input_layers variable.
-    if input_path.suffix.lower() == ".shp":
-        # For shapefiles, having input_layers not None gives issues
-        input_layers = None
-    elif sql_stmt is not None:
-        # If a sql statement is passed, the input layers are not relevant,
-        # and ogr2ogr will give a warning, so clear it.
-        input_layers = None
-
-    # SRS
-    if input_srs is not None and isinstance(input_srs, int):
-        input_srs = f"EPSG:{input_srs}"
-
-    # Sql'ing, Filtering, clipping
-    if spatial_filter is not None:
-        args.extend(["-spat"])
-        bounds = [str(coord) for coord in spatial_filter]
-        args.extend(bounds)
-    if sql_stmt is not None:
-        # If sql_stmt starts with "\n" or "\t" for gpkg or with " " for a shp,
-        # VectorTranslate outputs no or an invalid file if the statement doesn't return
-        # any rows...
-        sql_stmt = sql_stmt.lstrip("\n\t ")
-    if clip_geometry is not None:
-        args.extend(["-clipsrc"])
-        if isinstance(clip_geometry, str):
-            args.extend([clip_geometry])
-        else:
-            bounds = [str(coord) for coord in clip_geometry]
-            args.extend(bounds)
-    if columns is not None:
-        args.extend(["-select", ",".join(columns)])
-
-    # Warp
-    if warp is not None:
-        gcps = warp.get("gcps", [])
-        for gcp in gcps:
-            args.extend(["-gcp"])
-            args.extend([str(coord) for coord in gcp if coord is not None])
-        algorithm = warp.get("algorithm", "polynomial")
-        if algorithm == "polynomial":
-            order = warp.get("order", None)
-            if order is not None:
-                args.extend(["-order", order])
-        elif algorithm == "tps":
-            args.extend(["-tps"])
-        else:
-            raise ValueError(f"unsupported warp algorithm: {algorithm}")
-
-    # Input dataset open options
-    for option_name, value in gdal_options["INPUT_OPEN"].items():
-        args.extend(["-oo", f"{option_name}={value}"])
-
-    # Output file parameters
-    # Get output format from the filename
-    output_filetype = GeofileType(output_path)
-    input_filetype = GeofileType(input_path)
-
-    # SRS
-    if output_srs is not None and isinstance(output_srs, int):
-        output_srs = f"EPSG:{output_srs}"
-
-    # Output basic options
-    if output_path.exists() is True:
-        if append is True:
-            args.append("-append")
-        if update is True:
-            args.append("-update")
-
-    datasetCreationOptions = []
-    # Output dataset creation options are only applicable if a new output file
-    # will be created
-    if output_path.exists() is False or update is False:
-        dataset_creation_options = gdal_options["DATASET_CREATION"]
-        if output_filetype == GeofileType.SQLite:
-            # If SQLite file, use the spatialite type of sqlite by default
-            if "SPATIALITE" not in dataset_creation_options:
-                dataset_creation_options["SPATIALITE"] = "YES"
-        for option_name, value in dataset_creation_options.items():
-            datasetCreationOptions.extend([f"{option_name}={value}"])
-
-    # Output layer options
-    if explodecollections is True:
-        args.append("-explodecollections")
-    output_geometrytypes = []
-    if force_output_geometrytype is not None:
-        if isinstance(force_output_geometrytype, GeometryType):
-            output_geometrytypes.append(force_output_geometrytype.name)
-        else:
-            output_geometrytypes.append(force_output_geometrytype)
-    output_geometrytypes.append("PROMOTE_TO_MULTI")
-    if transaction_size is not None:
-        args.extend(["-gt", str(transaction_size)])
-    if preserve_fid is not None:
-        if preserve_fid:
-            args.append("-preserve_fid")
-        else:
-            args.append("-unsetFid")
-
-    # Output layer creation options are only applicable if a new layer will be
-    # created
-    layerCreationOptions = []
-    if output_path.exists() is False or (update is True and append is False):
-        for option_name, value in gdal_options["LAYER_CREATION"].items():
-            layerCreationOptions.extend([f"{option_name}={value}"])
-
-    # General configuration options
-    # Remark: they cannot be passed on as parameter, but are set as
-    # environment variables later on (using a context manager).
-    config_options = gdal_options["CONFIG"]
-    if input_filetype.is_spatialite_based or output_filetype.is_spatialite_based:
-        # If spatialite based file, increase SQLITE cache size by default
-        if "OGR_SQLITE_CACHE" not in config_options:
-            config_options["OGR_SQLITE_CACHE"] = "128"
-
-    # Now we can really get to work
-    result_ds = None
-    gdallog_dir = Path(tempfile.gettempdir()) / "geofileops/gdal_log"
-    try:
-        # Consolidate all parameters
-        # First take copy of args, because gdal.VectorTranslateOptions adds all
-        # other parameters to the list passed (by ref)!!!
-        args_copy = list(args)
-        options = gdal.VectorTranslateOptions(
-            options=args_copy,
-            format=output_filetype.ogrdriver,
-            accessMode=None,
-            srcSRS=input_srs,
-            dstSRS=output_srs,
-            reproject=reproject,
-            SQLStatement=sql_stmt,
-            SQLDialect=sql_dialect,
-            where=None,  # "geom IS NOT NULL",
-            selectFields=None,
-            addFields=False,
-            forceNullable=False,
-            spatFilter=spatial_filter,
-            spatSRS=None,
-            datasetCreationOptions=datasetCreationOptions,
-            layerCreationOptions=layerCreationOptions,
-            layers=input_layers,
-            layerName=output_layer,
-            geometryType=output_geometrytypes,
-            dim=None,
-            segmentizeMaxDist=None,
-            zField=None,
-            skipFailures=False,
-            limit=None,
-            callback=None,
-            callback_data=None,
-        )
-
-        # In some cases gdal only raises the last exception instead of the stack in
-        # VectorTranslate, so you lose necessary details!
-        # -> uncomment gdal.DontUseExceptions() when debugging!
-        # gdal.DontUseExceptions()
-        gdal.UseExceptions()
-        enable_debug = True if logger.level == logging.DEBUG else False
-        gdal.ConfigurePythonLogging(logger_name="gdal", enable_debug=enable_debug)
-
-        # Sometimes GDAL doesn't log to standard logging nor throw an exception but just
-        # writes to a seperate logging system. Enable this seperate logging to check it
-        # afterwards.
-        errorlog_path = gdallog_dir / f"gdal_errors_{os.getpid()}.log"
-        config_options["CPL_LOG"] = str(errorlog_path)
-        config_options["CPL_LOG_ERRORS"] = "ON"
-
-        # Go!
-        with set_config_options(config_options):
-            result_ds = gdal.VectorTranslate(
-                destNameOrDestDS=str(output_path),
-                srcDS=str(input_path),
-                options=options,
-            )
-
-        # If there is CPL_LOG logging, write to standard logger as well, extract last
-        # error and clean log file.
-        cpl_error = None
-        if errorlog_path.exists() and errorlog_path.stat().st_size > 0:
-            with open(errorlog_path, "r+") as errorlog_file:
-                lines = errorlog_file.readlines()
-                for line in lines:
-                    line = line.lstrip("\0")
-                    if line.startswith("ERROR"):
-                        logger.error(line)
-                        cpl_error = line
-                    else:
-                        logger.info(line)
-                errorlog_file.truncate(0)  # size '0' when using r+
-
-        # If the resulting datasource is None, something went wrong
-        if result_ds is None:
-            raise GFOError(f"result_ds is None ({cpl_error})")
-
-        # If the output file is an empty shapefile and it was the result of a SQLITE sql
-        # statement, delete the "geom" column if it is present
-        if (
-            sql_stmt is not None
-            and sql_dialect == "SQLITE"
-            and output_path.suffix.lower() == ".shp"
-        ):
-            assert isinstance(result_ds, gdal.Dataset)
-            result_layer = result_ds.GetLayerByIndex(0)
-            if result_layer.GetFeatureCount() == 0:
-                layer_defn = result_layer.GetLayerDefn()
-                for field_idx in range(layer_defn.GetFieldCount()):
-                    field_name = layer_defn.GetFieldDefn(field_idx).GetName()
-                    if field_name.lower() == "geom":
-                        result_layer.DeleteField(field_idx)
-                        break
-
-        # Sometimes an invalid output file is written, so close and try to reopen it.
-        result_ds = None
-        if output_path.exists():
-            try:
-                result_ds = gdal.OpenEx(str(output_path))
-            except Exception as ex:
-                logger.info(
-                    f"Opening output file gave error, probably the input file was "
-                    f"empty, no rows were selected or geom was NULL: {ex}"
-                )
-                gfo.remove(output_path)
-            finally:
-                result_ds = None
-
-    except Exception as ex:
-        result_ds = None
-        message = f"Error {ex} while creating {output_path}"
-        if sql_stmt is not None:
-            message = f"{message} using sql_stmt {sql_stmt}"
-        raise GFOError(message)
-    finally:
-        result_ds = None
-
-    return True
-
-
-def _prepare_gdal_options(options: dict, split_by_option_type: bool = False) -> dict:
-    """
-    Prepares the options so they are ready to pass on to gdal.
-
-        - Uppercase the option key
-        - Check if the option types are on of the supported ones:
-
-            - LAYER_CREATION: layer creation option (lco)
-            - DATASET_CREATION: dataset creation option (dsco)
-            - INPUT_OPEN: input dataset open option (oo)
-            - DESTINATION_OPEN: destination dataset open option (doo)
-            - CONFIG: config option (config)
-        - Prepare the option values
-            - convert bool to YES/NO
-            - convert all values to str
-
-    Args:
-        options (dict): options to pass to gdal.
-        split_by_option_type (optional, bool): True to split the options in a
-            seperate dict per option type. Defaults to False.
-
-    Returns:
-        dict: prepared options. If split_by_option_type: a dict of dicts for each
-            occuring option type.
-    """
-    # Init prepared options with all existing option types
-    option_types = [
-        "LAYER_CREATION",
-        "DATASET_CREATION",
-        "INPUT_OPEN",
-        "DESTINATION_OPEN",
-        "CONFIG",
-    ]
-    prepared_options = {option_type: {} for option_type in option_types}
-
-    # Loop through options specified to add them
-    for option, value in options.items():
-        # Prepare option type and name
-        option_type, option_name = option.split(".")
-        option_type = option_type.strip().upper()
-        option_name = option_name.strip().upper()
-        if option_type not in option_types:
-            raise ValueError(
-                f"Unsupported option type: {option_type}, not one of {option_types}"
-            )
-
-        # Prepare value
-        if isinstance(value, bool):
-            value = "YES" if value is True else "NO"
-
-        # Add to prepared options
-        if option_name in prepared_options[option_type]:
-            raise ValueError(
-                f"option {option_type}.{option_name} specified more than once"
-            )
-        prepared_options[option_type][option_name] = str(value)
-
-    # If no split is asked, convert back to original format
-    if split_by_option_type is True:
-        result = prepared_options
-    else:
-        result = {}
-        for option_type in prepared_options:
-            for option_name, value in prepared_options[option_type].items():
-                result[f"{option_type}.{option_name}"] = value
-
-    return result
-
-
-class set_config_options(object):
-    """
-    Context manager to set config options.
-
-    Args:
-        config_options (dict): dict with config options to set.
-            `Eg. { "OGR_SQLITE_CACHE", 128 }`
-    """
-
-    def __init__(self, config_options: dict):
-        self.config_options = config_options
-
-    def __enter__(self):
-        # TODO: uncomment if GetConfigOptions() is supported
-        # self.config_options_backup = gdal.GetConfigOptions()
-        for name, value in self.config_options.items():
-            # Prepare value
-            if value is None:
-                pass
-            elif isinstance(value, bool):
-                value = "YES" if value is True else "NO"
-            else:
-                value = str(value)
-            gdal.SetConfigOption(str(name), value)
-
-    def __exit__(self, type, value, traceback):
-        # Remove config options that were set
-        # TODO: delete loop + uncomment if SetConfigOptions() is supported
-        for name, value in self.config_options.items():
-            gdal.SetConfigOption(name, None)
-        # gdal.SetConfigOptions(self.config_options_backup)
+# -*- coding: utf-8 -*-
+"""
+Module containing utilities regarding the usage of ogr functionalities.
+"""
+
+# -------------------------------------
+# Import/init needed modules
+# -------------------------------------
+import logging
+import os
+from pathlib import Path
+import tempfile
+from threading import Lock
+from typing import List, Literal, Optional, Tuple, Union
+
+from osgeo import gdal
+
+import geofileops as gfo
+from geofileops.util.geofiletype import GeofileType
+from geofileops.util.geometry_util import GeometryType
+
+#####################################################################
+# First define/init some general variables/constants
+#####################################################################
+
+# Make sure only one instance per process is running
+lock = Lock()
+
+# Get a logger...
+logger = logging.getLogger(__name__)
+
+#####################################################################
+# The real work
+#####################################################################
+
+
+class GFOError(Exception):
+    pass
+
+
+def get_drivers() -> dict:
+    drivers = {}
+    for i in range(gdal.GetDriverCount()):
+        driver = gdal.GetDriver(i)
+        drivers[driver.ShortName] = driver.GetDescription()
+    return drivers
+
+
+class VectorTranslateInfo:
+    def __init__(
+        self,
+        input_path: Path,
+        output_path: Path,
+        input_layers: Union[List[str], str, None] = None,
+        output_layer: Optional[str] = None,
+        input_srs: Union[int, str, None] = None,
+        output_srs: Union[int, str, None] = None,
+        reproject: bool = False,
+        spatial_filter: Optional[Tuple[float, float, float, float]] = None,
+        clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
+        sql_stmt: Optional[str] = None,
+        sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
+        transaction_size: int = 65536,
+        append: bool = False,
+        update: bool = False,
+        explodecollections: bool = False,
+        force_output_geometrytype: Union[GeometryType, str, None] = None,
+        options: dict = {},
+        columns: Optional[List[str]] = None,
+        warp: Optional[dict] = None,
+        preserve_fid: Optional[bool] = None,
+    ):
+        self.input_path = input_path
+        self.output_path = output_path
+        self.input_layers = input_layers
+        self.output_layer = output_layer
+        self.input_srs = input_srs
+        self.output_srs = output_srs
+        self.reproject = reproject
+        self.spatial_filter = spatial_filter
+        self.clip_geometry = clip_geometry
+        self.sql_stmt = sql_stmt
+        self.sql_dialect = sql_dialect
+        self.transaction_size = transaction_size
+        self.append = append
+        self.update = update
+        self.explodecollections = explodecollections
+        self.force_output_geometrytype = force_output_geometrytype
+        self.options = options
+        self.columns = columns
+        self.warp = warp
+        self.preserve_fid = preserve_fid
+
+
+def vector_translate_by_info(info: VectorTranslateInfo):
+    return vector_translate(
+        input_path=info.input_path,
+        output_path=info.output_path,
+        input_layers=info.input_layers,
+        output_layer=info.output_layer,
+        input_srs=info.input_srs,
+        output_srs=info.output_srs,
+        reproject=info.reproject,
+        spatial_filter=info.spatial_filter,
+        clip_geometry=info.clip_geometry,
+        sql_stmt=info.sql_stmt,
+        sql_dialect=info.sql_dialect,  # type: ignore
+        transaction_size=info.transaction_size,
+        append=info.append,
+        update=info.update,
+        explodecollections=info.explodecollections,
+        force_output_geometrytype=info.force_output_geometrytype,
+        options=info.options,
+        columns=info.columns,
+        warp=info.warp,
+        preserve_fid=info.preserve_fid,
+    )
+
+
+def vector_translate(
+    input_path: Union[Path, str],
+    output_path: Path,
+    input_layers: Union[List[str], str, None] = None,
+    output_layer: Optional[str] = None,
+    input_srs: Union[int, str, None] = None,
+    output_srs: Union[int, str, None] = None,
+    reproject: bool = False,
+    spatial_filter: Optional[Tuple[float, float, float, float]] = None,
+    clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
+    sql_stmt: Optional[str] = None,
+    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
+    transaction_size: int = 65536,
+    append: bool = False,
+    update: bool = False,
+    explodecollections: bool = False,
+    force_output_geometrytype: Union[GeometryType, str, None] = None,
+    options: dict = {},
+    columns: Optional[List[str]] = None,
+    warp: Optional[dict] = None,
+    preserve_fid: Optional[bool] = None,
+) -> bool:
+    # API Doc of VectorTranslateOptions:
+    #   https://gdal.org/api/python/osgeo.gdal.html#osgeo.gdal.VectorTranslateOptions
+    args = []
+    if isinstance(input_path, str):
+        input_path = Path(input_path)
+    gdal_options = _prepare_gdal_options(options, split_by_option_type=True)
+
+    # Input file parameters
+    # Cleanup the input_layers variable.
+    if input_path.suffix.lower() == ".shp":
+        # For shapefiles, having input_layers not None gives issues
+        input_layers = None
+    elif sql_stmt is not None:
+        # If a sql statement is passed, the input layers are not relevant,
+        # and ogr2ogr will give a warning, so clear it.
+        input_layers = None
+
+    # SRS
+    if input_srs is not None and isinstance(input_srs, int):
+        input_srs = f"EPSG:{input_srs}"
+
+    # Sql'ing, Filtering, clipping
+    if spatial_filter is not None:
+        args.extend(["-spat"])
+        bounds = [str(coord) for coord in spatial_filter]
+        args.extend(bounds)
+    if sql_stmt is not None:
+        # If sql_stmt starts with "\n" or "\t" for gpkg or with " " for a shp,
+        # VectorTranslate outputs no or an invalid file if the statement doesn't return
+        # any rows...
+        sql_stmt = sql_stmt.lstrip("\n\t ")
+    if clip_geometry is not None:
+        args.extend(["-clipsrc"])
+        if isinstance(clip_geometry, str):
+            args.extend([clip_geometry])
+        else:
+            bounds = [str(coord) for coord in clip_geometry]
+            args.extend(bounds)
+    if columns is not None:
+        args.extend(["-select", ",".join(columns)])
+
+    # Warp
+    if warp is not None:
+        gcps = warp.get("gcps", [])
+        for gcp in gcps:
+            args.extend(["-gcp"])
+            args.extend([str(coord) for coord in gcp if coord is not None])
+        algorithm = warp.get("algorithm", "polynomial")
+        if algorithm == "polynomial":
+            order = warp.get("order", None)
+            if order is not None:
+                args.extend(["-order", order])
+        elif algorithm == "tps":
+            args.extend(["-tps"])
+        else:
+            raise ValueError(f"unsupported warp algorithm: {algorithm}")
+
+    # Input dataset open options
+    for option_name, value in gdal_options["INPUT_OPEN"].items():
+        args.extend(["-oo", f"{option_name}={value}"])
+
+    # Output file parameters
+    # Get output format from the filename
+    output_filetype = GeofileType(output_path)
+    input_filetype = GeofileType(input_path)
+
+    # SRS
+    if output_srs is not None and isinstance(output_srs, int):
+        output_srs = f"EPSG:{output_srs}"
+
+    # Output basic options
+    if output_path.exists() is True:
+        if append is True:
+            args.append("-append")
+        if update is True:
+            args.append("-update")
+
+    datasetCreationOptions = []
+    # Output dataset creation options are only applicable if a new output file
+    # will be created
+    if output_path.exists() is False or update is False:
+        dataset_creation_options = gdal_options["DATASET_CREATION"]
+        if output_filetype == GeofileType.SQLite:
+            # If SQLite file, use the spatialite type of sqlite by default
+            if "SPATIALITE" not in dataset_creation_options:
+                dataset_creation_options["SPATIALITE"] = "YES"
+        for option_name, value in dataset_creation_options.items():
+            datasetCreationOptions.extend([f"{option_name}={value}"])
+
+    # Output layer options
+    if explodecollections is True:
+        args.append("-explodecollections")
+    output_geometrytypes = []
+    if force_output_geometrytype is not None:
+        if isinstance(force_output_geometrytype, GeometryType):
+            output_geometrytypes.append(force_output_geometrytype.name)
+        else:
+            output_geometrytypes.append(force_output_geometrytype)
+    output_geometrytypes.append("PROMOTE_TO_MULTI")
+    if transaction_size is not None:
+        args.extend(["-gt", str(transaction_size)])
+    if preserve_fid is not None:
+        if preserve_fid:
+            args.append("-preserve_fid")
+        else:
+            args.append("-unsetFid")
+
+    # Output layer creation options are only applicable if a new layer will be
+    # created
+    layerCreationOptions = []
+    if output_path.exists() is False or (update is True and append is False):
+        for option_name, value in gdal_options["LAYER_CREATION"].items():
+            layerCreationOptions.extend([f"{option_name}={value}"])
+
+    # General configuration options
+    # Remark: they cannot be passed on as parameter, but are set as
+    # environment variables later on (using a context manager).
+    config_options = gdal_options["CONFIG"]
+    if input_filetype.is_spatialite_based or output_filetype.is_spatialite_based:
+        # If spatialite based file, increase SQLITE cache size by default
+        if "OGR_SQLITE_CACHE" not in config_options:
+            config_options["OGR_SQLITE_CACHE"] = "128"
+
+    # Now we can really get to work
+    result_ds = None
+    gdallog_dir = Path(tempfile.gettempdir()) / "geofileops/gdal_log"
+    try:
+        # Consolidate all parameters
+        # First take copy of args, because gdal.VectorTranslateOptions adds all
+        # other parameters to the list passed (by ref)!!!
+        args_copy = list(args)
+        options = gdal.VectorTranslateOptions(
+            options=args_copy,
+            format=output_filetype.ogrdriver,
+            accessMode=None,
+            srcSRS=input_srs,
+            dstSRS=output_srs,
+            reproject=reproject,
+            SQLStatement=sql_stmt,
+            SQLDialect=sql_dialect,
+            where=None,  # "geom IS NOT NULL",
+            selectFields=None,
+            addFields=False,
+            forceNullable=False,
+            spatFilter=spatial_filter,
+            spatSRS=None,
+            datasetCreationOptions=datasetCreationOptions,
+            layerCreationOptions=layerCreationOptions,
+            layers=input_layers,
+            layerName=output_layer,
+            geometryType=output_geometrytypes,
+            dim=None,
+            segmentizeMaxDist=None,
+            zField=None,
+            skipFailures=False,
+            limit=None,
+            callback=None,
+            callback_data=None,
+        )
+
+        # In some cases gdal only raises the last exception instead of the stack in
+        # VectorTranslate, so you lose necessary details!
+        # -> uncomment gdal.DontUseExceptions() when debugging!
+        # gdal.DontUseExceptions()
+        gdal.UseExceptions()
+        enable_debug = True if logger.level == logging.DEBUG else False
+        gdal.ConfigurePythonLogging(logger_name="gdal", enable_debug=enable_debug)
+
+        # Sometimes GDAL doesn't log to standard logging nor throw an exception but just
+        # writes to a seperate logging system. Enable this seperate logging to check it
+        # afterwards.
+        errorlog_path = gdallog_dir / f"gdal_errors_{os.getpid()}.log"
+        config_options["CPL_LOG"] = str(errorlog_path)
+        config_options["CPL_LOG_ERRORS"] = "ON"
+
+        # Go!
+        with set_config_options(config_options):
+            result_ds = gdal.VectorTranslate(
+                destNameOrDestDS=str(output_path),
+                srcDS=str(input_path),
+                options=options,
+            )
+
+        # If there is CPL_LOG logging, write to standard logger as well, extract last
+        # error and clean log file.
+        cpl_error = None
+        if errorlog_path.exists() and errorlog_path.stat().st_size > 0:
+            with open(errorlog_path, "r+") as errorlog_file:
+                lines = errorlog_file.readlines()
+                for line in lines:
+                    line = line.lstrip("\0")
+                    if line.startswith("ERROR"):
+                        logger.error(line)
+                        cpl_error = line
+                    else:
+                        logger.info(line)
+                errorlog_file.truncate(0)  # size '0' when using r+
+
+        # If the resulting datasource is None, something went wrong
+        if result_ds is None:
+            raise GFOError(f"result_ds is None ({cpl_error})")
+
+        # If the output file is an empty shapefile and it was the result of a SQLITE sql
+        # statement, delete the "geom" column if it is present
+        if (
+            sql_stmt is not None
+            and sql_dialect == "SQLITE"
+            and output_path.suffix.lower() == ".shp"
+        ):
+            assert isinstance(result_ds, gdal.Dataset)
+            result_layer = result_ds.GetLayerByIndex(0)
+            if result_layer.GetFeatureCount() == 0:
+                layer_defn = result_layer.GetLayerDefn()
+                for field_idx in range(layer_defn.GetFieldCount()):
+                    field_name = layer_defn.GetFieldDefn(field_idx).GetName()
+                    if field_name.lower() == "geom":
+                        result_layer.DeleteField(field_idx)
+                        break
+
+        # Sometimes an invalid output file is written, so close and try to reopen it.
+        result_ds = None
+        if output_path.exists():
+            try:
+                result_ds = gdal.OpenEx(str(output_path))
+            except Exception as ex:
+                logger.info(
+                    f"Opening output file gave error, probably the input file was "
+                    f"empty, no rows were selected or geom was NULL: {ex}"
+                )
+                gfo.remove(output_path)
+            finally:
+                result_ds = None
+
+    except Exception as ex:
+        result_ds = None
+        message = f"Error {ex} while creating {output_path}"
+        if sql_stmt is not None:
+            message = f"{message} using sql_stmt {sql_stmt}"
+        raise GFOError(message)
+    finally:
+        result_ds = None
+
+    return True
+
+
+def _prepare_gdal_options(options: dict, split_by_option_type: bool = False) -> dict:
+    """
+    Prepares the options so they are ready to pass on to gdal.
+
+        - Uppercase the option key
+        - Check if the option types are on of the supported ones:
+
+            - LAYER_CREATION: layer creation option (lco)
+            - DATASET_CREATION: dataset creation option (dsco)
+            - INPUT_OPEN: input dataset open option (oo)
+            - DESTINATION_OPEN: destination dataset open option (doo)
+            - CONFIG: config option (config)
+        - Prepare the option values
+            - convert bool to YES/NO
+            - convert all values to str
+
+    Args:
+        options (dict): options to pass to gdal.
+        split_by_option_type (optional, bool): True to split the options in a
+            seperate dict per option type. Defaults to False.
+
+    Returns:
+        dict: prepared options. If split_by_option_type: a dict of dicts for each
+            occuring option type.
+    """
+    # Init prepared options with all existing option types
+    option_types = [
+        "LAYER_CREATION",
+        "DATASET_CREATION",
+        "INPUT_OPEN",
+        "DESTINATION_OPEN",
+        "CONFIG",
+    ]
+    prepared_options = {option_type: {} for option_type in option_types}
+
+    # Loop through options specified to add them
+    for option, value in options.items():
+        # Prepare option type and name
+        option_type, option_name = option.split(".")
+        option_type = option_type.strip().upper()
+        option_name = option_name.strip().upper()
+        if option_type not in option_types:
+            raise ValueError(
+                f"Unsupported option type: {option_type}, not one of {option_types}"
+            )
+
+        # Prepare value
+        if isinstance(value, bool):
+            value = "YES" if value is True else "NO"
+
+        # Add to prepared options
+        if option_name in prepared_options[option_type]:
+            raise ValueError(
+                f"option {option_type}.{option_name} specified more than once"
+            )
+        prepared_options[option_type][option_name] = str(value)
+
+    # If no split is asked, convert back to original format
+    if split_by_option_type is True:
+        result = prepared_options
+    else:
+        result = {}
+        for option_type in prepared_options:
+            for option_name, value in prepared_options[option_type].items():
+                result[f"{option_type}.{option_name}"] = value
+
+    return result
+
+
+class set_config_options(object):
+    """
+    Context manager to set config options.
+
+    Args:
+        config_options (dict): dict with config options to set.
+            `Eg. { "OGR_SQLITE_CACHE", 128 }`
+    """
+
+    def __init__(self, config_options: dict):
+        self.config_options = config_options
+
+    def __enter__(self):
+        # TODO: uncomment if GetConfigOptions() is supported
+        # self.config_options_backup = gdal.GetConfigOptions()
+        for name, value in self.config_options.items():
+            # Prepare value
+            if value is None:
+                pass
+            elif isinstance(value, bool):
+                value = "YES" if value is True else "NO"
+            else:
+                value = str(value)
+            gdal.SetConfigOption(str(name), value)
+
+    def __exit__(self, type, value, traceback):
+        # Remove config options that were set
+        # TODO: delete loop + uncomment if SetConfigOptions() is supported
+        for name, value in self.config_options.items():
+            gdal.SetConfigOption(name, None)
+        # gdal.SetConfigOptions(self.config_options_backup)
```

### Comparing `geofileops-0.8.0a1/geofileops/util/_processing_util.py` & `geofileops-0.8.0a2/geofileops/util/_processing_util.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,145 +1,145 @@
-# -*- coding: utf-8 -*-
-"""
-Module containing utilities regarding processes.
-"""
-from concurrent import futures
-import os
-import psutil
-
-
-class PooledExecutorFactory(object):
-    """
-    Context manager to create an Executor.
-
-    Args:
-        threadpool (bool, optional): True to get a ThreadPoolExecutor,
-            False to get a ProcessPoolExecutor. Defaults to True.
-        max_workers (int, optional): Max number of workers.
-            Defaults to None to get automatic determination.
-        initialisze (function, optional): Function that does initialisations.
-    """
-
-    def __init__(self, threadpool: bool = True, max_workers=None, initializer=None):
-        self.threadpool = threadpool
-        if max_workers is not None and os.name == "nt":
-            self.max_workers = min(max_workers, 61)
-        else:
-            self.max_workers = max_workers
-        self.initializer = initializer
-        self.pool = None
-
-    def __enter__(self) -> futures.Executor:
-        if self.threadpool:
-            self.pool = futures.ThreadPoolExecutor(
-                max_workers=self.max_workers, initializer=self.initializer
-            )
-        else:
-            self.pool = futures.ProcessPoolExecutor(
-                max_workers=self.max_workers, initializer=self.initializer
-            )
-        return self.pool
-
-    def __exit__(self, type, value, traceback):
-        if self.pool is not None:
-            self.pool.shutdown(wait=True)
-
-
-def initialize_worker():
-    # We don't want the workers to block the entire system, so make them nice
-    # if they aren't quite nice already.
-    # Remark: on linux, depending on system settings it is not possible to
-    # decrease niceness, even if it was you who niced before.
-    nice_value = 15
-    if getprocessnice() < nice_value:
-        setprocessnice(nice_value)
-
-
-def getprocessnice() -> int:
-    """
-    Get the niceness of the current process.
-
-    The nice value can (typically) range from 19, which gives all other
-    processes priority, to -20, which means that this process will take
-    maximum priority (which isn't very nice ;-)).
-
-    Remarks for windows:
-        - windows only supports 6 niceness classes. setprocessnice en
-          getprocessnice maps niceness values to these classes.
-        - when setting REALTIME priority (-20 niceness) apparently this
-          results only to HIGH priority.
-    """
-    p = psutil.Process(os.getpid())
-    nice_value = p.nice()
-    if os.name == "nt":
-        return process_priorityclass_to_nice(nice_value)
-    else:
-        return int(nice_value)
-
-
-def setprocessnice(nice_value: int):
-    """
-    Set the niceness of the current process.
-
-    The nice value can (typically) range from 19, which gives all other
-    processes priority, to -20, which means that this process will take
-    maximum priority (which isn't very nice ;-)).
-
-    Remarks for windows:
-        - windows only supports 6 niceness classes. setprocessnice en
-          getprocessnice maps niceness values to these classes.
-        - when setting REALTIME priority (-20 niceness) apparently this
-          results only to HIGH priority.
-
-    Args:
-        nice_value (int): the niceness to be set.
-    """
-    if nice_value < -20 or nice_value > 19:
-        raise ValueError(
-            f"Invalid value for nice_values (min: -20, max: 19): {nice_value}"
-        )
-    if getprocessnice() == nice_value:
-        # If the nice value is already the same... no use setting it
-        return
-
-    try:
-        p = psutil.Process(os.getpid())
-        if os.name == "nt":
-            p.nice(process_nice_to_priorityclass(nice_value))
-        else:
-            p.nice(nice_value)
-    except Exception as ex:
-        raise Exception(
-            f"Error in setprocessnice with nice_value: {nice_value}"
-        ) from ex
-
-
-def process_nice_to_priorityclass(nice_value: int) -> int:  # pragma: no cover
-    if nice_value == -20:
-        return psutil.REALTIME_PRIORITY_CLASS
-    elif nice_value <= -15:
-        return psutil.HIGH_PRIORITY_CLASS
-    elif nice_value <= -10:
-        return psutil.ABOVE_NORMAL_PRIORITY_CLASS
-    elif nice_value <= 0:
-        return psutil.NORMAL_PRIORITY_CLASS
-    elif nice_value <= 10:
-        return psutil.BELOW_NORMAL_PRIORITY_CLASS
-    else:
-        return psutil.IDLE_PRIORITY_CLASS
-
-
-def process_priorityclass_to_nice(priority_class: int) -> int:  # pragma: no cover
-    if priority_class == psutil.REALTIME_PRIORITY_CLASS:
-        return -20
-    elif priority_class == psutil.HIGH_PRIORITY_CLASS:
-        return -15
-    elif priority_class == psutil.ABOVE_NORMAL_PRIORITY_CLASS:
-        return -10
-    elif priority_class == psutil.NORMAL_PRIORITY_CLASS:
-        return 0
-    elif priority_class == psutil.BELOW_NORMAL_PRIORITY_CLASS:
-        return 10
-    elif priority_class == psutil.IDLE_PRIORITY_CLASS:
-        return 19
-    else:
-        return 0
+# -*- coding: utf-8 -*-
+"""
+Module containing utilities regarding processes.
+"""
+from concurrent import futures
+import os
+import psutil
+
+
+class PooledExecutorFactory(object):
+    """
+    Context manager to create an Executor.
+
+    Args:
+        threadpool (bool, optional): True to get a ThreadPoolExecutor,
+            False to get a ProcessPoolExecutor. Defaults to True.
+        max_workers (int, optional): Max number of workers.
+            Defaults to None to get automatic determination.
+        initialisze (function, optional): Function that does initialisations.
+    """
+
+    def __init__(self, threadpool: bool = True, max_workers=None, initializer=None):
+        self.threadpool = threadpool
+        if max_workers is not None and os.name == "nt":
+            self.max_workers = min(max_workers, 61)
+        else:
+            self.max_workers = max_workers
+        self.initializer = initializer
+        self.pool = None
+
+    def __enter__(self) -> futures.Executor:
+        if self.threadpool:
+            self.pool = futures.ThreadPoolExecutor(
+                max_workers=self.max_workers, initializer=self.initializer
+            )
+        else:
+            self.pool = futures.ProcessPoolExecutor(
+                max_workers=self.max_workers, initializer=self.initializer
+            )
+        return self.pool
+
+    def __exit__(self, type, value, traceback):
+        if self.pool is not None:
+            self.pool.shutdown(wait=True)
+
+
+def initialize_worker():
+    # We don't want the workers to block the entire system, so make them nice
+    # if they aren't quite nice already.
+    # Remark: on linux, depending on system settings it is not possible to
+    # decrease niceness, even if it was you who niced before.
+    nice_value = 15
+    if getprocessnice() < nice_value:
+        setprocessnice(nice_value)
+
+
+def getprocessnice() -> int:
+    """
+    Get the niceness of the current process.
+
+    The nice value can (typically) range from 19, which gives all other
+    processes priority, to -20, which means that this process will take
+    maximum priority (which isn't very nice ;-)).
+
+    Remarks for windows:
+        - windows only supports 6 niceness classes. setprocessnice en
+          getprocessnice maps niceness values to these classes.
+        - when setting REALTIME priority (-20 niceness) apparently this
+          results only to HIGH priority.
+    """
+    p = psutil.Process(os.getpid())
+    nice_value = p.nice()
+    if os.name == "nt":
+        return process_priorityclass_to_nice(nice_value)
+    else:
+        return int(nice_value)
+
+
+def setprocessnice(nice_value: int):
+    """
+    Set the niceness of the current process.
+
+    The nice value can (typically) range from 19, which gives all other
+    processes priority, to -20, which means that this process will take
+    maximum priority (which isn't very nice ;-)).
+
+    Remarks for windows:
+        - windows only supports 6 niceness classes. setprocessnice en
+          getprocessnice maps niceness values to these classes.
+        - when setting REALTIME priority (-20 niceness) apparently this
+          results only to HIGH priority.
+
+    Args:
+        nice_value (int): the niceness to be set.
+    """
+    if nice_value < -20 or nice_value > 19:
+        raise ValueError(
+            f"Invalid value for nice_values (min: -20, max: 19): {nice_value}"
+        )
+    if getprocessnice() == nice_value:
+        # If the nice value is already the same... no use setting it
+        return
+
+    try:
+        p = psutil.Process(os.getpid())
+        if os.name == "nt":
+            p.nice(process_nice_to_priorityclass(nice_value))
+        else:
+            p.nice(nice_value)
+    except Exception as ex:
+        raise Exception(
+            f"Error in setprocessnice with nice_value: {nice_value}"
+        ) from ex
+
+
+def process_nice_to_priorityclass(nice_value: int) -> int:  # pragma: no cover
+    if nice_value == -20:
+        return psutil.REALTIME_PRIORITY_CLASS
+    elif nice_value <= -15:
+        return psutil.HIGH_PRIORITY_CLASS
+    elif nice_value <= -10:
+        return psutil.ABOVE_NORMAL_PRIORITY_CLASS
+    elif nice_value <= 0:
+        return psutil.NORMAL_PRIORITY_CLASS
+    elif nice_value <= 10:
+        return psutil.BELOW_NORMAL_PRIORITY_CLASS
+    else:
+        return psutil.IDLE_PRIORITY_CLASS
+
+
+def process_priorityclass_to_nice(priority_class: int) -> int:  # pragma: no cover
+    if priority_class == psutil.REALTIME_PRIORITY_CLASS:
+        return -20
+    elif priority_class == psutil.HIGH_PRIORITY_CLASS:
+        return -15
+    elif priority_class == psutil.ABOVE_NORMAL_PRIORITY_CLASS:
+        return -10
+    elif priority_class == psutil.NORMAL_PRIORITY_CLASS:
+        return 0
+    elif priority_class == psutil.BELOW_NORMAL_PRIORITY_CLASS:
+        return 10
+    elif priority_class == psutil.IDLE_PRIORITY_CLASS:
+        return 19
+    else:
+        return 0
```

### Comparing `geofileops-0.8.0a1/geofileops/util/geofiletype.py` & `geofileops-0.8.0a2/geofileops/util/geofiletype.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,144 +1,144 @@
-# -*- coding: utf-8 -*-
-"""
-Module with information about the supported geofiletypes.
-"""
-
-import ast
-import csv
-from dataclasses import dataclass
-import enum
-from pathlib import Path
-from typing import List, Optional, Union
-
-geofiletypes = {}
-
-
-@dataclass
-class GeofileTypeInfo:
-    """
-    Class with properties of a GeofileType.
-    """
-
-    geofiletype: str
-    ogrdriver: str
-    suffixes: Optional[List[str]]
-    is_fid_zerobased: bool
-    is_spatialite_based: bool
-    suffixes_extrafiles: Optional[List[str]]
-
-
-def init_geofiletypes():
-    geofiletypes_path = Path(__file__).resolve().parent / "geofiletypes.csv"
-    with open(geofiletypes_path, "r") as file:
-        # Set skipinitialspace to True so the csv can be formatted for readability
-        csv.register_dialect("geofiletype_dialect", skipinitialspace=True, strict=True)
-        reader = csv.DictReader(file, dialect="geofiletype_dialect")
-
-        for row in reader:
-            # Prepare optional values that need eval first
-            suffixes = None
-            if row["suffixes"] is not None and row["suffixes"] != "":
-                suffixes = ast.literal_eval(row["suffixes"])
-            suffixes_extrafiles = None
-            if (
-                row["suffixes_extrafiles"] is not None
-                and row["suffixes_extrafiles"] != ""
-            ):
-                suffixes_extrafiles = ast.literal_eval(row["suffixes_extrafiles"])
-
-            # Add geofiletype
-            geofiletypes[row["geofiletype"]] = GeofileTypeInfo(
-                geofiletype=row["geofiletype"],
-                ogrdriver=row["ogrdriver"],
-                suffixes=suffixes,
-                is_fid_zerobased=ast.literal_eval(row["is_fid_zerobased"]),
-                is_spatialite_based=ast.literal_eval(row["is_spatialite_based"]),
-                suffixes_extrafiles=suffixes_extrafiles,
-            )
-
-
-class GeofileType(enum.Enum):
-    """
-    Enumeration of relevant geo file types and their properties.
-    """
-
-    ESRIShapefile = enum.auto()
-    GeoJSON = enum.auto()
-    GPKG = enum.auto()
-    SQLite = enum.auto()
-    FlatGeobuf = enum.auto()
-
-    @classmethod
-    def _missing_(cls, value: Union[str, int, Path]):
-        """
-        Expand options in the GeofileType() constructor.
-
-        Args:
-            value (Union[str, int, Driver]):
-                * string: lookup using case insensitive name
-                * GeofileType: create the same GeometryType as the one passed in
-
-        Returns:
-            [GeofileType]: The corresponding GeometryType.
-        """
-
-        def get_geofiletype_for_suffix(suffix: str):
-            suffix_lower = suffix.lower()
-            for geofiletype in geofiletypes:
-                suffixes = geofiletypes[geofiletype].suffixes
-                if suffixes is not None and suffix_lower in suffixes:
-                    return GeofileType[geofiletype]
-            raise ValueError(f"Unknown extension {suffix}")
-
-        def get_geofiletype_for_ogrdriver(ogrdriver: str):
-            for geofiletype in geofiletypes:
-                driver = geofiletypes[geofiletype].ogrdriver
-                if driver is not None and driver == ogrdriver:
-                    return GeofileType[geofiletype]
-            raise ValueError(f"Unknown ogr driver {ogrdriver}")
-
-        if value is None:
-            return None
-        elif isinstance(value, Path):
-            # If it is a Path, return Driver based on the suffix
-            return get_geofiletype_for_suffix(value.suffix)
-        elif isinstance(value, str):
-            if value.startswith("."):
-                # If it start with a point, it is a suffix
-                return get_geofiletype_for_suffix(value)
-            else:
-                # it's probably an ogr driver
-                return get_geofiletype_for_ogrdriver(value)
-        elif isinstance(value, GeofileType):
-            # If a GeofileType is passed in, return same GeofileType.
-            # TODO: why create a new one?
-            return cls(value.value)
-        # Default behaviour (= lookup based on int value)
-        return super()._missing_(value)
-
-    @property
-    def is_fid_zerobased(self) -> bool:
-        return geofiletypes[self.name].is_fid_zerobased
-
-    @property
-    def is_spatialite_based(self) -> bool:
-        return geofiletypes[self.name].is_spatialite_based
-
-    @property
-    def ogrdriver(self):
-        return geofiletypes[self.name].ogrdriver
-
-    @property
-    def suffixes_extrafiles(self):
-        return geofiletypes[self.name].suffixes_extrafiles
-
-    @property
-    def is_singlelayer(self):
-        if self.is_spatialite_based:
-            return False
-        else:
-            return True
-
-
-# Init!
-init_geofiletypes()
+# -*- coding: utf-8 -*-
+"""
+Module with information about the supported geofiletypes.
+"""
+
+import ast
+import csv
+from dataclasses import dataclass
+import enum
+from pathlib import Path
+from typing import List, Optional, Union
+
+geofiletypes = {}
+
+
+@dataclass
+class GeofileTypeInfo:
+    """
+    Class with properties of a GeofileType.
+    """
+
+    geofiletype: str
+    ogrdriver: str
+    suffixes: Optional[List[str]]
+    is_fid_zerobased: bool
+    is_spatialite_based: bool
+    suffixes_extrafiles: Optional[List[str]]
+
+
+def init_geofiletypes():
+    geofiletypes_path = Path(__file__).resolve().parent / "geofiletypes.csv"
+    with open(geofiletypes_path, "r") as file:
+        # Set skipinitialspace to True so the csv can be formatted for readability
+        csv.register_dialect("geofiletype_dialect", skipinitialspace=True, strict=True)
+        reader = csv.DictReader(file, dialect="geofiletype_dialect")
+
+        for row in reader:
+            # Prepare optional values that need eval first
+            suffixes = None
+            if row["suffixes"] is not None and row["suffixes"] != "":
+                suffixes = ast.literal_eval(row["suffixes"])
+            suffixes_extrafiles = None
+            if (
+                row["suffixes_extrafiles"] is not None
+                and row["suffixes_extrafiles"] != ""
+            ):
+                suffixes_extrafiles = ast.literal_eval(row["suffixes_extrafiles"])
+
+            # Add geofiletype
+            geofiletypes[row["geofiletype"]] = GeofileTypeInfo(
+                geofiletype=row["geofiletype"],
+                ogrdriver=row["ogrdriver"],
+                suffixes=suffixes,
+                is_fid_zerobased=ast.literal_eval(row["is_fid_zerobased"]),
+                is_spatialite_based=ast.literal_eval(row["is_spatialite_based"]),
+                suffixes_extrafiles=suffixes_extrafiles,
+            )
+
+
+class GeofileType(enum.Enum):
+    """
+    Enumeration of relevant geo file types and their properties.
+    """
+
+    ESRIShapefile = enum.auto()
+    GeoJSON = enum.auto()
+    GPKG = enum.auto()
+    SQLite = enum.auto()
+    FlatGeobuf = enum.auto()
+
+    @classmethod
+    def _missing_(cls, value: Union[str, int, Path]):
+        """
+        Expand options in the GeofileType() constructor.
+
+        Args:
+            value (Union[str, int, Driver]):
+                * string: lookup using case insensitive name
+                * GeofileType: create the same GeometryType as the one passed in
+
+        Returns:
+            [GeofileType]: The corresponding GeometryType.
+        """
+
+        def get_geofiletype_for_suffix(suffix: str):
+            suffix_lower = suffix.lower()
+            for geofiletype in geofiletypes:
+                suffixes = geofiletypes[geofiletype].suffixes
+                if suffixes is not None and suffix_lower in suffixes:
+                    return GeofileType[geofiletype]
+            raise ValueError(f"Unknown extension {suffix}")
+
+        def get_geofiletype_for_ogrdriver(ogrdriver: str):
+            for geofiletype in geofiletypes:
+                driver = geofiletypes[geofiletype].ogrdriver
+                if driver is not None and driver == ogrdriver:
+                    return GeofileType[geofiletype]
+            raise ValueError(f"Unknown ogr driver {ogrdriver}")
+
+        if value is None:
+            return None
+        elif isinstance(value, Path):
+            # If it is a Path, return Driver based on the suffix
+            return get_geofiletype_for_suffix(value.suffix)
+        elif isinstance(value, str):
+            if value.startswith("."):
+                # If it start with a point, it is a suffix
+                return get_geofiletype_for_suffix(value)
+            else:
+                # it's probably an ogr driver
+                return get_geofiletype_for_ogrdriver(value)
+        elif isinstance(value, GeofileType):
+            # If a GeofileType is passed in, return same GeofileType.
+            # TODO: why create a new one?
+            return cls(value.value)
+        # Default behaviour (= lookup based on int value)
+        return super()._missing_(value)
+
+    @property
+    def is_fid_zerobased(self) -> bool:
+        return geofiletypes[self.name].is_fid_zerobased
+
+    @property
+    def is_spatialite_based(self) -> bool:
+        return geofiletypes[self.name].is_spatialite_based
+
+    @property
+    def ogrdriver(self):
+        return geofiletypes[self.name].ogrdriver
+
+    @property
+    def suffixes_extrafiles(self):
+        return geofiletypes[self.name].suffixes_extrafiles
+
+    @property
+    def is_singlelayer(self):
+        if self.is_spatialite_based:
+            return False
+        else:
+            return True
+
+
+# Init!
+init_geofiletypes()
```

### Comparing `geofileops-0.8.0a1/geofileops/util/geometry_util.py` & `geofileops-0.8.0a2/geofileops/util/geometry_util.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,836 +1,836 @@
-# -*- coding: utf-8 -*-
-"""
-Module containing utilities regarding low level vector operations.
-"""
-
-import enum
-import logging
-import math
-from typing import List, Optional, Union
-
-import geopandas as gpd
-import numpy as np
-import pygeos
-import pyproj
-import shapely.coords as sh_coords
-import shapely.wkb as sh_wkb
-import shapely.geometry as sh_geom
-import shapely.ops as sh_ops
-
-
-#####################################################################
-# First define/init some general variables/constants
-#####################################################################
-
-
-# Get a logger...
-logger = logging.getLogger(__name__)
-# logger.setLevel(logging.DEBUG)
-
-
-#####################################################################
-# Buffer helpers
-#####################################################################
-
-
-class BufferJoinStyle(enum.Enum):
-    """
-    Enumeration of the available buffer styles for the intermediate points of
-    a line or polygon geometry.
-    """
-
-    ROUND = 1
-    MITRE = 2
-    BEVEL = 3
-
-
-class BufferEndCapStyle(enum.Enum):
-    """
-    Enumeration of the available buffer styles for the end points of
-    a line or point geometry.
-    """
-
-    ROUND = 1
-    FLAT = 2
-    SQUARE = 3
-
-
-#####################################################################
-# Geometry helpers
-#####################################################################
-
-
-class GeometryType(enum.Enum):
-    """
-    Enumeration of the different geometry types.
-    """
-
-    MISSING = -1
-    GEOMETRY = 0
-    POINT = 1
-    LINESTRING = 2
-    POLYGON = 3
-    MULTIPOINT = 4
-    MULTILINESTRING = 5
-    MULTIPOLYGON = 6
-    GEOMETRYCOLLECTION = 7
-
-    @classmethod
-    def _missing_(cls, value: Union[str, int]):
-        """
-        Expand options in the Geometrytype() constructor.
-
-        Args:
-            value (Union[str, int, GeometryType]):
-                * string: lookup using case insensitive name
-                * GeometryType: create the same GeometryType as the one passed in
-
-        Returns:
-            [GeometryType]: The corresponding GeometryType.
-        """
-        if isinstance(value, str):
-            # If a string is passed in, try lookup based on case insensitive
-            # enum name
-            return cls(GeometryType[value.upper()])
-        elif isinstance(value, GeometryType):
-            # If a Geometry type is passed in, return same GeometryType
-            # TODO: why create a new one?
-            return cls(value.value)
-        # Default behaviour (= lookup based on value)
-        return super()._missing_(value)
-
-    @property
-    def name_camelcase(self) -> str:
-        """Get the name in camel case."""
-        if self is GeometryType.POINT:
-            return "Point"
-        elif self is GeometryType.LINESTRING:
-            return "LineString"
-        elif self is GeometryType.POLYGON:
-            return "Polygon"
-        elif self is GeometryType.MULTIPOINT:
-            return "MultiPoint"
-        elif self is GeometryType.MULTILINESTRING:
-            return "MultiLineString"
-        elif self is GeometryType.MULTIPOLYGON:
-            return "MultiPolygon"
-        elif self is GeometryType.GEOMETRYCOLLECTION:
-            return "GeometryCollection"
-        elif self is GeometryType.GEOMETRY:
-            return "Geometry"
-        else:
-            raise ValueError(f"No camelcase name implemented for: {self}")
-
-    @property
-    def is_multitype(self):
-        """Returns if the geometry type is a multi type."""
-        return self in (
-            GeometryType.GEOMETRY,
-            GeometryType.MULTIPOINT,
-            GeometryType.MULTILINESTRING,
-            GeometryType.MULTIPOLYGON,
-            GeometryType.GEOMETRYCOLLECTION,
-        )
-
-    @property
-    def to_multitype(self):
-        """Get the corresponding multitype."""
-        if self in [
-            GeometryType.GEOMETRY,
-            GeometryType.MULTIPOINT,
-            GeometryType.MULTILINESTRING,
-            GeometryType.MULTIPOLYGON,
-            GeometryType.GEOMETRYCOLLECTION,
-        ]:
-            return self
-        elif self is GeometryType.POINT:
-            return GeometryType.MULTIPOINT
-        elif self is GeometryType.LINESTRING:
-            return GeometryType.MULTILINESTRING
-        elif self is GeometryType.POLYGON:
-            return GeometryType.MULTIPOLYGON
-        else:
-            raise Exception(f"No multitype implemented for: {self}")
-
-    @property
-    def to_primitivetype(self):
-        """Get the corresponding primitive type."""
-        if self in [GeometryType.POINT, GeometryType.MULTIPOINT]:
-            return PrimitiveType.POINT
-        elif self in [GeometryType.LINESTRING, GeometryType.MULTILINESTRING]:
-            return PrimitiveType.LINESTRING
-        elif self in [GeometryType.POLYGON, GeometryType.MULTIPOLYGON]:
-            return PrimitiveType.POLYGON
-        elif self is GeometryType.GEOMETRYCOLLECTION:
-            raise Exception("Geometrycollection doesn't have a primitive type")
-        else:
-            raise Exception(f"No primitive type implemented for {self}")
-
-
-class PrimitiveType(enum.Enum):
-    """
-    Enumeration of the different existing primitive types of a geometry.
-    """
-
-    POINT = 1
-    LINESTRING = 2
-    POLYGON = 3
-
-    @classmethod
-    def _missing_(cls, value):
-        if value is None:
-            return None
-        elif isinstance(value, str):
-            return cls(PrimitiveType[value.upper()])
-        elif isinstance(value, PrimitiveType):
-            return cls(value.value)
-        return super()._missing_(value)
-
-    @property
-    def to_multitype(self) -> GeometryType:
-        """Get the corresponding multitype."""
-        if self is PrimitiveType.POINT:
-            return GeometryType.MULTIPOINT
-        elif self is PrimitiveType.LINESTRING:
-            return GeometryType.MULTILINESTRING
-        elif self is PrimitiveType.POLYGON:
-            return GeometryType.MULTIPOLYGON
-        else:
-            raise Exception(f"No multitype implemented for: {self}")
-
-
-def collection_extract(
-    geometry: Optional[sh_geom.base.BaseGeometry], primitivetype: PrimitiveType
-) -> Optional[sh_geom.base.BaseGeometry]:
-    """
-    Extracts the geometries from the input geom that comply with the
-    primitive_type specified and returns them as (Multi)geometry.
-
-    Args:
-        geometry (sh_geom.base.BaseGeometry): geometry to extract the polygons
-            from.
-        primitivetype (GeometryPrimitiveTypes): the primitive type to extract
-            from the input geom.
-
-    Raises:
-        Exception: if in_geom is an unsupported geometry type or the primitive
-            type is invalid.
-
-    Returns:
-        sh_geom.base.BaseGeometry: List of primitive geometries, only
-            containing the primitive type specified.
-    """
-    # Extract the polygons from the multipolygon, but store them as multipolygons anyway
-    if geometry is None:
-        return None
-    elif isinstance(geometry, sh_geom.Point) or isinstance(
-        geometry, sh_geom.MultiPoint
-    ):
-        if primitivetype == PrimitiveType.POINT:
-            return geometry
-    elif isinstance(geometry, sh_geom.LineString) or isinstance(
-        geometry, sh_geom.MultiLineString
-    ):
-        if primitivetype == PrimitiveType.LINESTRING:
-            return geometry
-    elif isinstance(geometry, sh_geom.Polygon) or isinstance(
-        geometry, sh_geom.MultiPolygon
-    ):
-        if primitivetype == PrimitiveType.POLYGON:
-            return geometry
-    elif isinstance(geometry, sh_geom.GeometryCollection):
-        returngeoms = []
-        for geometry in sh_geom.GeometryCollection(geometry).geoms:
-            returngeoms.append(
-                collection_extract(geometry, primitivetype=primitivetype)
-            )
-        if len(returngeoms) > 0:
-            return collect(returngeoms)
-    else:
-        raise Exception(f"Invalid/unsupported geometry(type): {geometry}")
-
-    # Nothing found yet, so return None
-    return None
-
-
-def collect(
-    geometry_list: List[sh_geom.base.BaseGeometry],
-) -> Optional[sh_geom.base.BaseGeometry]:
-    """
-    Collect a list of geometries to one geometry.
-
-    Examples:
-      * if the list contains only Polygon's, returns a MultiPolygon.
-      * if the list contains different types, returns a GeometryCollection.
-
-    Args:
-        geometry_list (List[sh_geom.base.BaseGeometry]): [description]
-
-    Raises:
-        Exception: raises an exception if one of the input geometries is of an
-            unknown type.
-
-    Returns:
-        sh_geom.base.BaseGeometry: the result
-    """
-    # First remove all None geometries in the input list
-    geometry_list = [
-        geometry
-        for geometry in geometry_list
-        if geometry is not None and geometry.is_empty is False
-    ]
-
-    # If the list is empty or contains only 1 element, it is easy...
-    if geometry_list is None or len(geometry_list) == 0:
-        return None
-    elif len(geometry_list) == 1:
-        return geometry_list[0]
-
-    # Loop over all elements in the list, and determine the appropriate geometry
-    # type to create
-    result_collection_type = GeometryType(geometry_list[0].geom_type).to_multitype
-    for geom in geometry_list:
-        # If it is the same as the collection_geom_type, continue checking
-        if GeometryType(geom.geom_type).to_multitype == result_collection_type:
-            continue
-        else:
-            # If multiple types in the list, result becomes a geometrycollection
-            result_collection_type = GeometryType.GEOMETRYCOLLECTION
-            break
-
-    # Now we can create the collection
-    # Explode the multi-geometries to single ones
-    singular_geometry_list = []
-    for geom in geometry_list:
-        if isinstance(geom, sh_geom.base.BaseMultipartGeometry):
-            singular_geometry_list.extend(geom.geoms)
-        else:
-            singular_geometry_list.append(geom)
-
-    if result_collection_type == GeometryType.MULTIPOINT:
-        return sh_geom.MultiPoint(singular_geometry_list)
-    elif result_collection_type == GeometryType.MULTILINESTRING:
-        return sh_geom.MultiLineString(singular_geometry_list)
-    elif result_collection_type == GeometryType.MULTIPOLYGON:
-        return sh_geom.MultiPolygon(singular_geometry_list)
-    elif result_collection_type == GeometryType.GEOMETRYCOLLECTION:
-        return sh_geom.GeometryCollection(geometry_list)
-    else:
-        raise Exception(f"Unsupported geometry type: {result_collection_type}")
-
-
-"""
-def force_geometrytype(
-        geometry: sh_geom.base.BaseGeometry,
-        dest_geometrytype: GeometryType) -> sh_geom.base.BaseGeometry:
-    # Cast to destination geometrytype
-    if dest_geometrytype is GeometryType.MULTIPOLYGON:
-        gdf.geometry = [sh_geom.MultiPolygon([feature])
-                        if type(feature) == sh_geom.Polygon
-                        else feature for feature in gdf.geometry]
-    elif dest_geometrytype is GeometryType.MULTIPOINT:
-        gdf.geometry = [sh_geom.MultiPoint([feature])
-                        if type(feature) == sh_geom.Point
-                        else feature for feature in gdf.geometry]
-    elif dest_geometrytype is GeometryType.MULTILINESTRING:
-        gdf.geometry = [sh_geom.MultiLineString([feature])
-                        if type(feature) == sh_geom.LineString
-                        else feature for feature in gdf.geometry]
-    elif dest_geometrytype in [
-            GeometryType.POLYGON, GeometryType.POINT, GeometryType.LINESTRING]:
-        logger.debug(f"geometrytype is {dest_geometrytype}, so no conversion is done")
-    else:
-        raise Exception(f"Unsupported geometrytype: {dest_geometrytype}")
-"""
-
-
-def make_valid(
-    geometry: Optional[sh_geom.base.BaseGeometry],
-) -> Optional[sh_geom.base.BaseGeometry]:
-    """
-    Make a geometry valid.
-
-    Args:
-        geometry (Optional[sh_geom.base.BaseGeometry]): A (possibly) invalid geometry.
-
-    Returns:
-        Optional[sh_geom.base.BaseGeometry]: The fixed geometry.
-    """
-    if geometry is None:
-        return None
-    else:
-        return sh_wkb.loads(
-            pygeos.io.to_wkb(pygeos.make_valid(pygeos.io.from_shapely(geometry)))
-        )
-
-
-def numberpoints(geometry: Optional[sh_geom.base.BaseGeometry]) -> int:
-    """
-    Calculates the total number of points in a geometry.
-
-    Args:
-        geometry (sh_geom.base.BaseGeometry): the geometry to count the point of.
-
-    Returns:
-        int: the number of points in the geometry.
-    """
-    # If it is a multi-part, recursively call numberpoints for all parts.
-    if geometry is None:
-        return 0
-    elif isinstance(geometry, sh_geom.base.BaseMultipartGeometry):
-        nb_points = 0
-        for geom in geometry.geoms:
-            nb_points += numberpoints(geom)
-        return nb_points
-    elif isinstance(geometry, sh_geom.Polygon):
-        # If it is a polygon, calculate number for exterior and interior rings.
-        assert geometry.exterior is not None
-        nb_points = len(geometry.exterior.coords)
-        for ring in geometry.interiors:
-            nb_points += len(ring.coords)
-        return nb_points
-    else:
-        # For other types, it is just the number of coordinates.
-        return len(geometry.coords)
-
-
-def remove_inner_rings(
-    geometry: Union[sh_geom.Polygon, sh_geom.MultiPolygon, None],
-    min_area_to_keep: float,
-    crs: Optional[pyproj.CRS],
-) -> Union[sh_geom.Polygon, sh_geom.MultiPolygon, None]:
-    """
-    Remove (small) inner rings from a (multi)polygon.
-
-    Args:
-        geometry (Union[sh_geom.Polygon, sh_geom.MultiPolygon, None]): polygon
-        min_area_to_keep (float, optional): keep the inner rings with at least
-            this area in the coordinate units (typically m). If 0.0,
-            no inner rings are kept.
-        crs (pyproj.CRS, optional): the projection of the geometry. Passing
-            None is fine if min_area_to_keep and/or the geometry is in a
-            projected crs (not in degrees). Otherwise the/a crs should be
-            passed.
-
-    Raises:
-        Exception: if the input geometry is no (multi)polygon.
-
-    Returns:
-        Union[sh_geom.Polygon, sh_geom.MultiPolygon, None]: the resulting
-            (multi)polygon.
-    """
-    # If input geom is None, just return.
-    if geometry is None:
-        return None
-
-    # Define function to treat simple polygons
-    def remove_inner_rings_polygon(
-        geom_poly: sh_geom.Polygon,
-        min_area_to_keep: Optional[float] = None,
-        crs: Optional[pyproj.CRS] = None,
-    ) -> sh_geom.Polygon:
-        # If all inner rings need to be removed...
-        if min_area_to_keep is None or min_area_to_keep == 0.0:
-            # If there are no interior rings anyway, just return input
-            if len(geom_poly.interiors) == 0:
-                return geom_poly
-            else:
-                # Else create new polygon with only the exterior ring
-                return sh_ops.Polygon(geom_poly.exterior)
-
-        # If only small rings need to be removed... loop over them
-        ring_coords_to_keep = []
-        small_ring_found = False
-        for ring in geom_poly.interiors:
-            # Calculate area
-            if crs is None:
-                ring_area = sh_ops.Polygon(ring).area
-            elif crs.is_projected is True:
-                ring_area = sh_ops.Polygon(ring).area
-            else:
-                geod = crs.get_geod()
-                assert geod is not None
-                ring_area, ring_perimeter = geod.geometry_area_perimeter(ring)
-
-            # If ring area small, skip it, otherwise keep it
-            if abs(ring_area) <= min_area_to_keep:
-                small_ring_found = True
-            else:
-                ring_coords_to_keep.append(ring.coords)
-
-        # If no small rings were found, just return input
-        if small_ring_found is False:
-            return geom_poly
-        else:
-            assert geom_poly.exterior is not None
-            return sh_ops.Polygon(geom_poly.exterior.coords, ring_coords_to_keep)
-
-    # If the input is a simple Polygon, apply remove on it and return.
-    if isinstance(geometry, sh_geom.Polygon):
-        return remove_inner_rings_polygon(geometry, min_area_to_keep, crs=crs)
-    elif isinstance(geometry, sh_geom.MultiPolygon):
-        # If the input is a MultiPolygon, apply remove on each Polygon in it.
-        polys = []
-        for poly in geometry.geoms:
-            polys.append(remove_inner_rings_polygon(poly, min_area_to_keep, crs=crs))
-        return sh_geom.MultiPolygon(polys)
-    else:
-        raise Exception(
-            f"remove_inner_rings impossible on {geometry.geom_type}: {geometry}"
-        )
-
-
-#####################################################################
-# Simplify helpers
-#####################################################################
-
-
-class SimplifyAlgorithm(enum.Enum):
-    """
-    Enumeration of the supported simplification algorythms.
-    """
-
-    RAMER_DOUGLAS_PEUCKER = "rdp"
-    LANG = "lang"
-    VISVALINGAM_WHYATT = "vw"
-
-
-def simplify_ext(
-    geometry: Optional[sh_geom.base.BaseGeometry],
-    tolerance: float,
-    algorithm: SimplifyAlgorithm = SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
-    lookahead: int = 8,
-    preserve_topology: bool = True,
-    keep_points_on: Optional[sh_geom.base.BaseGeometry] = None,
-) -> Optional[sh_geom.base.BaseGeometry]:
-    """
-    Simplify the geometry, with extended options.
-
-    Args:
-        geometry (shapely geometry): the geometry to simplify
-        tolerance (float): mandatory for the following algorithms:
-            * RAMER_DOUGLAS_PEUCKER: distance to use as tolerance
-            * LANG: distance to use as tolerance
-            * VISVALINGAM_WHYATT: area to use as tolerance
-        algorithm (SimplifyAlgorithm, optional): algorithm to use.
-            Defaults to SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER.
-        lookahead (int, optional): the number of points to consider for removing
-            in a moving window. Used for LANG algorithm. Defaults to 8.
-        preserve_topology (bool, optional): True to (try to) return valid
-            geometries as result. Defaults to True.
-        keep_points_on (BaseGeometry], optional): point of the geometry to
-            that intersect with these geometries are not removed. Defaults to None.
-
-    Raises:
-        Exception: [description]
-        Exception: [description]
-        Exception: [description]
-
-    Returns:
-        sh_geom.base.BaseGeometry: The simplified version of the geometry.
-    """
-    # Init:
-    if geometry is None:
-        return None
-    if algorithm in [
-        SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
-        SimplifyAlgorithm.VISVALINGAM_WHYATT,
-    ]:
-        try:
-            import simplification.cutil as simplification
-        except ImportError as ex:
-            raise ImportError(
-                "To use simplify_ext using rdp or vw, first install "
-                "simplification with 'pip install simplification'"
-            ) from ex
-
-    # Define some inline funtions
-    # Apply the simplification (can result in multipolygons)
-    def simplify_polygon(
-        polygon: sh_geom.Polygon,
-    ) -> Union[sh_geom.Polygon, sh_geom.MultiPolygon, None]:
-        # First simplify exterior ring
-        assert polygon.exterior is not None
-        exterior_simplified = simplify_coords(polygon.exterior.coords)
-
-        # If topology needs to be preserved, keep original ring if simplify results in
-        # None or not enough points
-        if preserve_topology is True and (
-            exterior_simplified is None or len(exterior_simplified) < 3
-        ):
-            exterior_simplified = polygon.exterior.coords
-
-        # Now simplify interior rings
-        interiors_simplified = []
-        for interior in polygon.interiors:
-            interior_simplified = simplify_coords(interior.coords)
-
-            # If simplified version is ring, add it
-            if interior_simplified is not None and len(interior_simplified) >= 3:
-                interiors_simplified.append(interior_simplified)
-            elif preserve_topology is True:
-                # If result is no ring, but topology needs to be preserved,
-                # add original ring
-                interiors_simplified.append(interior.coords)
-
-        result_poly = sh_geom.Polygon(exterior_simplified, interiors_simplified)
-
-        # Extract only polygons as result + try to make valid
-        result_poly = collection_extract(
-            make_valid(result_poly), primitivetype=PrimitiveType.POLYGON
-        )
-
-        # If the result is None and the topology needs to be preserved, return
-        # original polygon
-        if preserve_topology is True and result_poly is None:
-            return polygon
-
-        # evade pyLance warning + return
-        assert (
-            result_poly is None
-            or isinstance(result_poly, sh_geom.Polygon)
-            or isinstance(result_poly, sh_geom.MultiPolygon)
-        )
-        return result_poly
-
-    def simplify_linestring(linestring: sh_geom.LineString) -> sh_geom.LineString:
-        # If the linestring cannot be simplified, return it
-        if linestring is None or len(linestring.coords) <= 2:
-            return linestring
-
-        # Simplify
-        coords_simplified = simplify_coords(linestring.coords)
-
-        # If preserve_topology is True and the result is no line anymore, return
-        # original line
-        if preserve_topology is True and (
-            coords_simplified is None or len(coords_simplified) < 2
-        ):
-            return linestring
-        else:
-            return sh_geom.LineString(coords_simplified)
-
-    def simplify_coords(
-        coords: Union[np.ndarray, sh_coords.CoordinateSequence]
-    ) -> np.ndarray:
-        if isinstance(coords, sh_coords.CoordinateSequence):
-            coords = np.asarray(coords)
-        # Determine the indexes of the coordinates to keep after simplification
-        if algorithm is SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER:
-            coords_simplify_idx = simplification.simplify_coords_idx(coords, tolerance)
-        elif algorithm is SimplifyAlgorithm.VISVALINGAM_WHYATT:
-            coords_simplify_idx = simplification.simplify_coords_vw_idx(
-                coords, tolerance
-            )
-        elif algorithm is SimplifyAlgorithm.LANG:
-            coords_simplify_idx = simplify_coords_lang_idx(
-                coords, tolerance, lookahead=lookahead
-            )
-        else:
-            raise Exception(
-                f"Unsupported algorithm: {algorithm}, supported: {SimplifyAlgorithm}"
-            )
-
-        coords_on_border_idx = []
-        if keep_points_on is not None:
-            coords_gdf = gpd.GeoDataFrame(
-                geometry=list(sh_geom.MultiPoint(coords).geoms)  # type: ignore
-            )
-            coords_on_border_series = coords_gdf.intersects(keep_points_on)
-            coords_on_border_idx = np.array(
-                coords_on_border_series.index[coords_on_border_series]
-            )
-
-        # Extracts coordinates that need to be kept
-        coords_to_keep = coords_simplify_idx
-        if len(coords_on_border_idx) > 0:
-            coords_to_keep = np.concatenate(
-                [coords_to_keep, coords_on_border_idx], dtype=np.int64
-            )
-        return coords[coords_to_keep]
-
-    # Loop over the rings, and simplify them one by one...
-    # If the geometry is None, just return...
-    if geometry is None:
-        raise Exception("geom input paramerter should not be None")
-    elif isinstance(geometry, sh_geom.Point):
-        # Point cannot be simplified
-        return geometry
-    elif isinstance(geometry, sh_geom.MultiPoint):
-        # MultiPoint cannot be simplified
-        return geometry
-    elif isinstance(geometry, sh_geom.LineString):
-        result_geom = simplify_linestring(geometry)
-    elif isinstance(geometry, sh_geom.Polygon):
-        result_geom = simplify_polygon(geometry)
-    elif isinstance(geometry, sh_geom.base.BaseMultipartGeometry):
-        # If it is a multi-part, recursively call simplify for all parts.
-        simplified_geometries = []
-        for geom in geometry.geoms:
-            simplified_geometries.append(
-                simplify_ext(
-                    geom,
-                    tolerance=tolerance,
-                    algorithm=algorithm,
-                    lookahead=lookahead,
-                    preserve_topology=preserve_topology,
-                    keep_points_on=keep_points_on,
-                )
-            )
-        result_geom = collect(simplified_geometries)
-    else:
-        raise Exception(f"Unsupported geom_type: {geometry.geom_type}, {geometry}")
-
-    return make_valid(result_geom)
-
-
-def simplify_coords_lang(
-    coords: Union[np.ndarray, list, sh_coords.CoordinateSequence],
-    tolerance: float,
-    lookahead: int,
-) -> Union[np.ndarray, list]:
-    """
-    Simplify a line using lang algorithm.
-
-    Args:
-        coords (Union[np.ndarray, list]): list of coordinates to be simplified.
-        tolerance (float): distance tolerance to use.
-        lookahead (int, optional): the number of points to consider for removing
-            in a moving window. Defaults to 8.
-
-    Returns:
-        Return the coordinates kept after simplification.
-        If input coords is np.ndarray, returns np.ndarray, otherwise returns a list.
-    """
-
-    # Init variables
-    if isinstance(coords, np.ndarray):
-        coords_arr = coords
-    elif isinstance(coords, sh_coords.CoordinateSequence):
-        coords_arr = np.asarray(coords)
-    else:
-        coords_arr = np.array(list(coords))
-
-    # Determine the coordinates that need to be kept
-    coords_to_keep_idx = simplify_coords_lang_idx(
-        coords=coords_arr, tolerance=tolerance, lookahead=lookahead
-    )
-    coords_simplified_arr = coords_arr[coords_to_keep_idx]
-
-    # If input was np.ndarray, return np.ndarray, otherwise list
-    if isinstance(coords, np.ndarray) or isinstance(
-        coords, sh_coords.CoordinateSequence
-    ):
-        return coords_simplified_arr
-    else:
-        return coords_simplified_arr.tolist()
-
-
-def simplify_coords_lang_idx(
-    coords: Union[np.ndarray, list, sh_coords.CoordinateSequence],
-    tolerance: float,
-    lookahead: int = 8,
-) -> Union[np.ndarray, list]:
-    """
-    Simplify a line using lang algorithm and return the coordinate indexes to
-    be kept.
-
-    Inspiration for the implementation came from:
-        * https://github.com/giscan/Generalizer/blob/master/simplify.py
-        * https://github.com/keszegrobert/polyline-simplification/blob/master/6.%20Lang.ipynb  # noqa: E501
-        * https://web.archive.org/web/20171005193700/http://web.cs.sunyit.edu/~poissad/projects/Curve/about_algorithms/lang.php  # noqa: E501
-
-    Args:
-        coords (Union[np.ndarray, list]): list of coordinates to be simplified.
-        tolerance (float): distance tolerance to use.
-        lookahead (int, optional): the number of points to consider for removing
-            in a moving window. Defaults to 8.
-
-    Returns:
-        Return the indexes of coordinates that need to be kept after
-        simplification.
-        If input coords is np.ndarray, returns np.ndarray, otherwise returns a list.
-    """
-
-    def point_line_distance(
-        point_x, point_y, line_x1, line_y1, line_x2, line_y2
-    ) -> float:
-        denominator = math.sqrt(
-            (line_x2 - line_x1) * (line_x2 - line_x1)
-            + (line_y2 - line_y1) * (line_y2 - line_y1)
-        )
-        if denominator == 0:
-            return float("Inf")
-        else:
-            numerator = abs(
-                (line_x2 - line_x1) * (line_y1 - point_y)
-                - (line_x1 - point_x) * (line_y2 - line_y1)
-            )
-            return numerator / denominator
-
-    # Init variables
-    if isinstance(coords, np.ndarray):
-        line_arr = coords
-    elif isinstance(coords, sh_coords.CoordinateSequence):
-        line_arr = np.asarray(coords)
-    else:
-        line_arr = np.array(list(coords))
-
-    # Prepare lookahead
-    nb_points = len(line_arr)
-    if lookahead == -1:
-        window_size = nb_points - 1
-    else:
-        window_size = min(lookahead, nb_points - 1)
-
-    # mask = np.ones(nb_points), dtype='bool')
-    mask = np.zeros(nb_points, dtype="bool")
-    mask[0] = True
-    window_start = 0
-    window_end = window_size
-
-    # Apply simplification till the window_start arrives at the last point.
-    ready = False
-    while ready is False:
-        # Check if all points between window_start and window_end are within
-        # tolerance distance to the line (window_start, window_end).
-        all_points_in_tolerance = True
-        for i in range(window_start + 1, window_end):
-            distance = point_line_distance(
-                line_arr[i, 0],
-                line_arr[i, 1],
-                line_arr[window_start, 0],
-                line_arr[window_start, 1],
-                line_arr[window_end, 0],
-                line_arr[window_end, 1],
-            )
-            # If distance is nan (= linepoint1 == linepoint2) or > tolerance
-            if distance > tolerance:
-                all_points_in_tolerance = False
-                break
-
-        # If not all the points are within the tolerance distance...
-        if not all_points_in_tolerance:
-            # Move window_end to previous point, and try again
-            window_end -= 1
-        else:
-            # All points are within the tolerance, so they can be masked
-            mask[window_end] = True
-            # mask[window_start+1:window_end-1] = False
-
-            # Move the window forward
-            window_start = window_end
-            if window_start == nb_points - 1:
-                ready = True
-            window_end = window_start + window_size
-            if window_end >= nb_points:
-                window_end = nb_points - 1
-
-    # Prepare result: convert the mask to a list of indices of points to keep.
-    idx_to_keep_arr = mask.nonzero()[0]
-
-    # If input was np.ndarray, return np.ndarray, otherwise list
-    if isinstance(coords, np.ndarray):
-        return idx_to_keep_arr
-    else:
-        return idx_to_keep_arr.tolist()
+# -*- coding: utf-8 -*-
+"""
+Module containing utilities regarding low level vector operations.
+"""
+
+import enum
+import logging
+import math
+from typing import List, Optional, Union
+
+import geopandas as gpd
+import numpy as np
+import pygeos
+import pyproj
+import shapely.coords as sh_coords
+import shapely.wkb as sh_wkb
+import shapely.geometry as sh_geom
+import shapely.ops as sh_ops
+
+
+#####################################################################
+# First define/init some general variables/constants
+#####################################################################
+
+
+# Get a logger...
+logger = logging.getLogger(__name__)
+# logger.setLevel(logging.DEBUG)
+
+
+#####################################################################
+# Buffer helpers
+#####################################################################
+
+
+class BufferJoinStyle(enum.Enum):
+    """
+    Enumeration of the available buffer styles for the intermediate points of
+    a line or polygon geometry.
+    """
+
+    ROUND = 1
+    MITRE = 2
+    BEVEL = 3
+
+
+class BufferEndCapStyle(enum.Enum):
+    """
+    Enumeration of the available buffer styles for the end points of
+    a line or point geometry.
+    """
+
+    ROUND = 1
+    FLAT = 2
+    SQUARE = 3
+
+
+#####################################################################
+# Geometry helpers
+#####################################################################
+
+
+class GeometryType(enum.Enum):
+    """
+    Enumeration of the different geometry types.
+    """
+
+    MISSING = -1
+    GEOMETRY = 0
+    POINT = 1
+    LINESTRING = 2
+    POLYGON = 3
+    MULTIPOINT = 4
+    MULTILINESTRING = 5
+    MULTIPOLYGON = 6
+    GEOMETRYCOLLECTION = 7
+
+    @classmethod
+    def _missing_(cls, value: Union[str, int]):
+        """
+        Expand options in the Geometrytype() constructor.
+
+        Args:
+            value (Union[str, int, GeometryType]):
+                * string: lookup using case insensitive name
+                * GeometryType: create the same GeometryType as the one passed in
+
+        Returns:
+            [GeometryType]: The corresponding GeometryType.
+        """
+        if isinstance(value, str):
+            # If a string is passed in, try lookup based on case insensitive
+            # enum name
+            return cls(GeometryType[value.upper()])
+        elif isinstance(value, GeometryType):
+            # If a Geometry type is passed in, return same GeometryType
+            # TODO: why create a new one?
+            return cls(value.value)
+        # Default behaviour (= lookup based on value)
+        return super()._missing_(value)
+
+    @property
+    def name_camelcase(self) -> str:
+        """Get the name in camel case."""
+        if self is GeometryType.POINT:
+            return "Point"
+        elif self is GeometryType.LINESTRING:
+            return "LineString"
+        elif self is GeometryType.POLYGON:
+            return "Polygon"
+        elif self is GeometryType.MULTIPOINT:
+            return "MultiPoint"
+        elif self is GeometryType.MULTILINESTRING:
+            return "MultiLineString"
+        elif self is GeometryType.MULTIPOLYGON:
+            return "MultiPolygon"
+        elif self is GeometryType.GEOMETRYCOLLECTION:
+            return "GeometryCollection"
+        elif self is GeometryType.GEOMETRY:
+            return "Geometry"
+        else:
+            raise ValueError(f"No camelcase name implemented for: {self}")
+
+    @property
+    def is_multitype(self):
+        """Returns if the geometry type is a multi type."""
+        return self in (
+            GeometryType.GEOMETRY,
+            GeometryType.MULTIPOINT,
+            GeometryType.MULTILINESTRING,
+            GeometryType.MULTIPOLYGON,
+            GeometryType.GEOMETRYCOLLECTION,
+        )
+
+    @property
+    def to_multitype(self):
+        """Get the corresponding multitype."""
+        if self in [
+            GeometryType.GEOMETRY,
+            GeometryType.MULTIPOINT,
+            GeometryType.MULTILINESTRING,
+            GeometryType.MULTIPOLYGON,
+            GeometryType.GEOMETRYCOLLECTION,
+        ]:
+            return self
+        elif self is GeometryType.POINT:
+            return GeometryType.MULTIPOINT
+        elif self is GeometryType.LINESTRING:
+            return GeometryType.MULTILINESTRING
+        elif self is GeometryType.POLYGON:
+            return GeometryType.MULTIPOLYGON
+        else:
+            raise Exception(f"No multitype implemented for: {self}")
+
+    @property
+    def to_primitivetype(self):
+        """Get the corresponding primitive type."""
+        if self in [GeometryType.POINT, GeometryType.MULTIPOINT]:
+            return PrimitiveType.POINT
+        elif self in [GeometryType.LINESTRING, GeometryType.MULTILINESTRING]:
+            return PrimitiveType.LINESTRING
+        elif self in [GeometryType.POLYGON, GeometryType.MULTIPOLYGON]:
+            return PrimitiveType.POLYGON
+        elif self is GeometryType.GEOMETRYCOLLECTION:
+            raise Exception("Geometrycollection doesn't have a primitive type")
+        else:
+            raise Exception(f"No primitive type implemented for {self}")
+
+
+class PrimitiveType(enum.Enum):
+    """
+    Enumeration of the different existing primitive types of a geometry.
+    """
+
+    POINT = 1
+    LINESTRING = 2
+    POLYGON = 3
+
+    @classmethod
+    def _missing_(cls, value):
+        if value is None:
+            return None
+        elif isinstance(value, str):
+            return cls(PrimitiveType[value.upper()])
+        elif isinstance(value, PrimitiveType):
+            return cls(value.value)
+        return super()._missing_(value)
+
+    @property
+    def to_multitype(self) -> GeometryType:
+        """Get the corresponding multitype."""
+        if self is PrimitiveType.POINT:
+            return GeometryType.MULTIPOINT
+        elif self is PrimitiveType.LINESTRING:
+            return GeometryType.MULTILINESTRING
+        elif self is PrimitiveType.POLYGON:
+            return GeometryType.MULTIPOLYGON
+        else:
+            raise Exception(f"No multitype implemented for: {self}")
+
+
+def collection_extract(
+    geometry: Optional[sh_geom.base.BaseGeometry], primitivetype: PrimitiveType
+) -> Optional[sh_geom.base.BaseGeometry]:
+    """
+    Extracts the geometries from the input geom that comply with the
+    primitive_type specified and returns them as (Multi)geometry.
+
+    Args:
+        geometry (sh_geom.base.BaseGeometry): geometry to extract the polygons
+            from.
+        primitivetype (GeometryPrimitiveTypes): the primitive type to extract
+            from the input geom.
+
+    Raises:
+        Exception: if in_geom is an unsupported geometry type or the primitive
+            type is invalid.
+
+    Returns:
+        sh_geom.base.BaseGeometry: List of primitive geometries, only
+            containing the primitive type specified.
+    """
+    # Extract the polygons from the multipolygon, but store them as multipolygons anyway
+    if geometry is None:
+        return None
+    elif isinstance(geometry, sh_geom.Point) or isinstance(
+        geometry, sh_geom.MultiPoint
+    ):
+        if primitivetype == PrimitiveType.POINT:
+            return geometry
+    elif isinstance(geometry, sh_geom.LineString) or isinstance(
+        geometry, sh_geom.MultiLineString
+    ):
+        if primitivetype == PrimitiveType.LINESTRING:
+            return geometry
+    elif isinstance(geometry, sh_geom.Polygon) or isinstance(
+        geometry, sh_geom.MultiPolygon
+    ):
+        if primitivetype == PrimitiveType.POLYGON:
+            return geometry
+    elif isinstance(geometry, sh_geom.GeometryCollection):
+        returngeoms = []
+        for geometry in sh_geom.GeometryCollection(geometry).geoms:
+            returngeoms.append(
+                collection_extract(geometry, primitivetype=primitivetype)
+            )
+        if len(returngeoms) > 0:
+            return collect(returngeoms)
+    else:
+        raise Exception(f"Invalid/unsupported geometry(type): {geometry}")
+
+    # Nothing found yet, so return None
+    return None
+
+
+def collect(
+    geometry_list: List[sh_geom.base.BaseGeometry],
+) -> Optional[sh_geom.base.BaseGeometry]:
+    """
+    Collect a list of geometries to one geometry.
+
+    Examples:
+      * if the list contains only Polygon's, returns a MultiPolygon.
+      * if the list contains different types, returns a GeometryCollection.
+
+    Args:
+        geometry_list (List[sh_geom.base.BaseGeometry]): [description]
+
+    Raises:
+        Exception: raises an exception if one of the input geometries is of an
+            unknown type.
+
+    Returns:
+        sh_geom.base.BaseGeometry: the result
+    """
+    # First remove all None geometries in the input list
+    geometry_list = [
+        geometry
+        for geometry in geometry_list
+        if geometry is not None and geometry.is_empty is False
+    ]
+
+    # If the list is empty or contains only 1 element, it is easy...
+    if geometry_list is None or len(geometry_list) == 0:
+        return None
+    elif len(geometry_list) == 1:
+        return geometry_list[0]
+
+    # Loop over all elements in the list, and determine the appropriate geometry
+    # type to create
+    result_collection_type = GeometryType(geometry_list[0].geom_type).to_multitype
+    for geom in geometry_list:
+        # If it is the same as the collection_geom_type, continue checking
+        if GeometryType(geom.geom_type).to_multitype == result_collection_type:
+            continue
+        else:
+            # If multiple types in the list, result becomes a geometrycollection
+            result_collection_type = GeometryType.GEOMETRYCOLLECTION
+            break
+
+    # Now we can create the collection
+    # Explode the multi-geometries to single ones
+    singular_geometry_list = []
+    for geom in geometry_list:
+        if isinstance(geom, sh_geom.base.BaseMultipartGeometry):
+            singular_geometry_list.extend(geom.geoms)
+        else:
+            singular_geometry_list.append(geom)
+
+    if result_collection_type == GeometryType.MULTIPOINT:
+        return sh_geom.MultiPoint(singular_geometry_list)
+    elif result_collection_type == GeometryType.MULTILINESTRING:
+        return sh_geom.MultiLineString(singular_geometry_list)
+    elif result_collection_type == GeometryType.MULTIPOLYGON:
+        return sh_geom.MultiPolygon(singular_geometry_list)
+    elif result_collection_type == GeometryType.GEOMETRYCOLLECTION:
+        return sh_geom.GeometryCollection(geometry_list)
+    else:
+        raise Exception(f"Unsupported geometry type: {result_collection_type}")
+
+
+"""
+def force_geometrytype(
+        geometry: sh_geom.base.BaseGeometry,
+        dest_geometrytype: GeometryType) -> sh_geom.base.BaseGeometry:
+    # Cast to destination geometrytype
+    if dest_geometrytype is GeometryType.MULTIPOLYGON:
+        gdf.geometry = [sh_geom.MultiPolygon([feature])
+                        if type(feature) == sh_geom.Polygon
+                        else feature for feature in gdf.geometry]
+    elif dest_geometrytype is GeometryType.MULTIPOINT:
+        gdf.geometry = [sh_geom.MultiPoint([feature])
+                        if type(feature) == sh_geom.Point
+                        else feature for feature in gdf.geometry]
+    elif dest_geometrytype is GeometryType.MULTILINESTRING:
+        gdf.geometry = [sh_geom.MultiLineString([feature])
+                        if type(feature) == sh_geom.LineString
+                        else feature for feature in gdf.geometry]
+    elif dest_geometrytype in [
+            GeometryType.POLYGON, GeometryType.POINT, GeometryType.LINESTRING]:
+        logger.debug(f"geometrytype is {dest_geometrytype}, so no conversion is done")
+    else:
+        raise Exception(f"Unsupported geometrytype: {dest_geometrytype}")
+"""
+
+
+def make_valid(
+    geometry: Optional[sh_geom.base.BaseGeometry],
+) -> Optional[sh_geom.base.BaseGeometry]:
+    """
+    Make a geometry valid.
+
+    Args:
+        geometry (Optional[sh_geom.base.BaseGeometry]): A (possibly) invalid geometry.
+
+    Returns:
+        Optional[sh_geom.base.BaseGeometry]: The fixed geometry.
+    """
+    if geometry is None:
+        return None
+    else:
+        return sh_wkb.loads(
+            pygeos.io.to_wkb(pygeos.make_valid(pygeos.io.from_shapely(geometry)))
+        )
+
+
+def numberpoints(geometry: Optional[sh_geom.base.BaseGeometry]) -> int:
+    """
+    Calculates the total number of points in a geometry.
+
+    Args:
+        geometry (sh_geom.base.BaseGeometry): the geometry to count the point of.
+
+    Returns:
+        int: the number of points in the geometry.
+    """
+    # If it is a multi-part, recursively call numberpoints for all parts.
+    if geometry is None:
+        return 0
+    elif isinstance(geometry, sh_geom.base.BaseMultipartGeometry):
+        nb_points = 0
+        for geom in geometry.geoms:
+            nb_points += numberpoints(geom)
+        return nb_points
+    elif isinstance(geometry, sh_geom.Polygon):
+        # If it is a polygon, calculate number for exterior and interior rings.
+        assert geometry.exterior is not None
+        nb_points = len(geometry.exterior.coords)
+        for ring in geometry.interiors:
+            nb_points += len(ring.coords)
+        return nb_points
+    else:
+        # For other types, it is just the number of coordinates.
+        return len(geometry.coords)
+
+
+def remove_inner_rings(
+    geometry: Union[sh_geom.Polygon, sh_geom.MultiPolygon, None],
+    min_area_to_keep: float,
+    crs: Optional[pyproj.CRS],
+) -> Union[sh_geom.Polygon, sh_geom.MultiPolygon, None]:
+    """
+    Remove (small) inner rings from a (multi)polygon.
+
+    Args:
+        geometry (Union[sh_geom.Polygon, sh_geom.MultiPolygon, None]): polygon
+        min_area_to_keep (float, optional): keep the inner rings with at least
+            this area in the coordinate units (typically m). If 0.0,
+            no inner rings are kept.
+        crs (pyproj.CRS, optional): the projection of the geometry. Passing
+            None is fine if min_area_to_keep and/or the geometry is in a
+            projected crs (not in degrees). Otherwise the/a crs should be
+            passed.
+
+    Raises:
+        Exception: if the input geometry is no (multi)polygon.
+
+    Returns:
+        Union[sh_geom.Polygon, sh_geom.MultiPolygon, None]: the resulting
+            (multi)polygon.
+    """
+    # If input geom is None, just return.
+    if geometry is None:
+        return None
+
+    # Define function to treat simple polygons
+    def remove_inner_rings_polygon(
+        geom_poly: sh_geom.Polygon,
+        min_area_to_keep: Optional[float] = None,
+        crs: Optional[pyproj.CRS] = None,
+    ) -> sh_geom.Polygon:
+        # If all inner rings need to be removed...
+        if min_area_to_keep is None or min_area_to_keep == 0.0:
+            # If there are no interior rings anyway, just return input
+            if len(geom_poly.interiors) == 0:
+                return geom_poly
+            else:
+                # Else create new polygon with only the exterior ring
+                return sh_ops.Polygon(geom_poly.exterior)
+
+        # If only small rings need to be removed... loop over them
+        ring_coords_to_keep = []
+        small_ring_found = False
+        for ring in geom_poly.interiors:
+            # Calculate area
+            if crs is None:
+                ring_area = sh_ops.Polygon(ring).area
+            elif crs.is_projected is True:
+                ring_area = sh_ops.Polygon(ring).area
+            else:
+                geod = crs.get_geod()
+                assert geod is not None
+                ring_area, ring_perimeter = geod.geometry_area_perimeter(ring)
+
+            # If ring area small, skip it, otherwise keep it
+            if abs(ring_area) <= min_area_to_keep:
+                small_ring_found = True
+            else:
+                ring_coords_to_keep.append(ring.coords)
+
+        # If no small rings were found, just return input
+        if small_ring_found is False:
+            return geom_poly
+        else:
+            assert geom_poly.exterior is not None
+            return sh_ops.Polygon(geom_poly.exterior.coords, ring_coords_to_keep)
+
+    # If the input is a simple Polygon, apply remove on it and return.
+    if isinstance(geometry, sh_geom.Polygon):
+        return remove_inner_rings_polygon(geometry, min_area_to_keep, crs=crs)
+    elif isinstance(geometry, sh_geom.MultiPolygon):
+        # If the input is a MultiPolygon, apply remove on each Polygon in it.
+        polys = []
+        for poly in geometry.geoms:
+            polys.append(remove_inner_rings_polygon(poly, min_area_to_keep, crs=crs))
+        return sh_geom.MultiPolygon(polys)
+    else:
+        raise Exception(
+            f"remove_inner_rings impossible on {geometry.geom_type}: {geometry}"
+        )
+
+
+#####################################################################
+# Simplify helpers
+#####################################################################
+
+
+class SimplifyAlgorithm(enum.Enum):
+    """
+    Enumeration of the supported simplification algorythms.
+    """
+
+    RAMER_DOUGLAS_PEUCKER = "rdp"
+    LANG = "lang"
+    VISVALINGAM_WHYATT = "vw"
+
+
+def simplify_ext(
+    geometry: Optional[sh_geom.base.BaseGeometry],
+    tolerance: float,
+    algorithm: SimplifyAlgorithm = SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
+    lookahead: int = 8,
+    preserve_topology: bool = True,
+    keep_points_on: Optional[sh_geom.base.BaseGeometry] = None,
+) -> Optional[sh_geom.base.BaseGeometry]:
+    """
+    Simplify the geometry, with extended options.
+
+    Args:
+        geometry (shapely geometry): the geometry to simplify
+        tolerance (float): mandatory for the following algorithms:
+            * RAMER_DOUGLAS_PEUCKER: distance to use as tolerance
+            * LANG: distance to use as tolerance
+            * VISVALINGAM_WHYATT: area to use as tolerance
+        algorithm (SimplifyAlgorithm, optional): algorithm to use.
+            Defaults to SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER.
+        lookahead (int, optional): the number of points to consider for removing
+            in a moving window. Used for LANG algorithm. Defaults to 8.
+        preserve_topology (bool, optional): True to (try to) return valid
+            geometries as result. Defaults to True.
+        keep_points_on (BaseGeometry], optional): point of the geometry to
+            that intersect with these geometries are not removed. Defaults to None.
+
+    Raises:
+        Exception: [description]
+        Exception: [description]
+        Exception: [description]
+
+    Returns:
+        sh_geom.base.BaseGeometry: The simplified version of the geometry.
+    """
+    # Init:
+    if geometry is None:
+        return None
+    if algorithm in [
+        SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
+        SimplifyAlgorithm.VISVALINGAM_WHYATT,
+    ]:
+        try:
+            import simplification.cutil as simplification
+        except ImportError as ex:
+            raise ImportError(
+                "To use simplify_ext using rdp or vw, first install "
+                "simplification with 'pip install simplification'"
+            ) from ex
+
+    # Define some inline funtions
+    # Apply the simplification (can result in multipolygons)
+    def simplify_polygon(
+        polygon: sh_geom.Polygon,
+    ) -> Union[sh_geom.Polygon, sh_geom.MultiPolygon, None]:
+        # First simplify exterior ring
+        assert polygon.exterior is not None
+        exterior_simplified = simplify_coords(polygon.exterior.coords)
+
+        # If topology needs to be preserved, keep original ring if simplify results in
+        # None or not enough points
+        if preserve_topology is True and (
+            exterior_simplified is None or len(exterior_simplified) < 3
+        ):
+            exterior_simplified = polygon.exterior.coords
+
+        # Now simplify interior rings
+        interiors_simplified = []
+        for interior in polygon.interiors:
+            interior_simplified = simplify_coords(interior.coords)
+
+            # If simplified version is ring, add it
+            if interior_simplified is not None and len(interior_simplified) >= 3:
+                interiors_simplified.append(interior_simplified)
+            elif preserve_topology is True:
+                # If result is no ring, but topology needs to be preserved,
+                # add original ring
+                interiors_simplified.append(interior.coords)
+
+        result_poly = sh_geom.Polygon(exterior_simplified, interiors_simplified)
+
+        # Extract only polygons as result + try to make valid
+        result_poly = collection_extract(
+            make_valid(result_poly), primitivetype=PrimitiveType.POLYGON
+        )
+
+        # If the result is None and the topology needs to be preserved, return
+        # original polygon
+        if preserve_topology is True and result_poly is None:
+            return polygon
+
+        # evade pyLance warning + return
+        assert (
+            result_poly is None
+            or isinstance(result_poly, sh_geom.Polygon)
+            or isinstance(result_poly, sh_geom.MultiPolygon)
+        )
+        return result_poly
+
+    def simplify_linestring(linestring: sh_geom.LineString) -> sh_geom.LineString:
+        # If the linestring cannot be simplified, return it
+        if linestring is None or len(linestring.coords) <= 2:
+            return linestring
+
+        # Simplify
+        coords_simplified = simplify_coords(linestring.coords)
+
+        # If preserve_topology is True and the result is no line anymore, return
+        # original line
+        if preserve_topology is True and (
+            coords_simplified is None or len(coords_simplified) < 2
+        ):
+            return linestring
+        else:
+            return sh_geom.LineString(coords_simplified)
+
+    def simplify_coords(
+        coords: Union[np.ndarray, sh_coords.CoordinateSequence]
+    ) -> np.ndarray:
+        if isinstance(coords, sh_coords.CoordinateSequence):
+            coords = np.asarray(coords)
+        # Determine the indexes of the coordinates to keep after simplification
+        if algorithm is SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER:
+            coords_simplify_idx = simplification.simplify_coords_idx(coords, tolerance)
+        elif algorithm is SimplifyAlgorithm.VISVALINGAM_WHYATT:
+            coords_simplify_idx = simplification.simplify_coords_vw_idx(
+                coords, tolerance
+            )
+        elif algorithm is SimplifyAlgorithm.LANG:
+            coords_simplify_idx = simplify_coords_lang_idx(
+                coords, tolerance, lookahead=lookahead
+            )
+        else:
+            raise Exception(
+                f"Unsupported algorithm: {algorithm}, supported: {SimplifyAlgorithm}"
+            )
+
+        coords_on_border_idx = []
+        if keep_points_on is not None:
+            coords_gdf = gpd.GeoDataFrame(
+                geometry=list(sh_geom.MultiPoint(coords).geoms)  # type: ignore
+            )
+            coords_on_border_series = coords_gdf.intersects(keep_points_on)
+            coords_on_border_idx = np.array(
+                coords_on_border_series.index[coords_on_border_series]
+            )
+
+        # Extracts coordinates that need to be kept
+        coords_to_keep = coords_simplify_idx
+        if len(coords_on_border_idx) > 0:
+            coords_to_keep = np.concatenate(
+                [coords_to_keep, coords_on_border_idx], dtype=np.int64
+            )
+        return coords[coords_to_keep]
+
+    # Loop over the rings, and simplify them one by one...
+    # If the geometry is None, just return...
+    if geometry is None:
+        raise Exception("geom input paramerter should not be None")
+    elif isinstance(geometry, sh_geom.Point):
+        # Point cannot be simplified
+        return geometry
+    elif isinstance(geometry, sh_geom.MultiPoint):
+        # MultiPoint cannot be simplified
+        return geometry
+    elif isinstance(geometry, sh_geom.LineString):
+        result_geom = simplify_linestring(geometry)
+    elif isinstance(geometry, sh_geom.Polygon):
+        result_geom = simplify_polygon(geometry)
+    elif isinstance(geometry, sh_geom.base.BaseMultipartGeometry):
+        # If it is a multi-part, recursively call simplify for all parts.
+        simplified_geometries = []
+        for geom in geometry.geoms:
+            simplified_geometries.append(
+                simplify_ext(
+                    geom,
+                    tolerance=tolerance,
+                    algorithm=algorithm,
+                    lookahead=lookahead,
+                    preserve_topology=preserve_topology,
+                    keep_points_on=keep_points_on,
+                )
+            )
+        result_geom = collect(simplified_geometries)
+    else:
+        raise Exception(f"Unsupported geom_type: {geometry.geom_type}, {geometry}")
+
+    return make_valid(result_geom)
+
+
+def simplify_coords_lang(
+    coords: Union[np.ndarray, list, sh_coords.CoordinateSequence],
+    tolerance: float,
+    lookahead: int,
+) -> Union[np.ndarray, list]:
+    """
+    Simplify a line using lang algorithm.
+
+    Args:
+        coords (Union[np.ndarray, list]): list of coordinates to be simplified.
+        tolerance (float): distance tolerance to use.
+        lookahead (int, optional): the number of points to consider for removing
+            in a moving window. Defaults to 8.
+
+    Returns:
+        Return the coordinates kept after simplification.
+        If input coords is np.ndarray, returns np.ndarray, otherwise returns a list.
+    """
+
+    # Init variables
+    if isinstance(coords, np.ndarray):
+        coords_arr = coords
+    elif isinstance(coords, sh_coords.CoordinateSequence):
+        coords_arr = np.asarray(coords)
+    else:
+        coords_arr = np.array(list(coords))
+
+    # Determine the coordinates that need to be kept
+    coords_to_keep_idx = simplify_coords_lang_idx(
+        coords=coords_arr, tolerance=tolerance, lookahead=lookahead
+    )
+    coords_simplified_arr = coords_arr[coords_to_keep_idx]
+
+    # If input was np.ndarray, return np.ndarray, otherwise list
+    if isinstance(coords, np.ndarray) or isinstance(
+        coords, sh_coords.CoordinateSequence
+    ):
+        return coords_simplified_arr
+    else:
+        return coords_simplified_arr.tolist()
+
+
+def simplify_coords_lang_idx(
+    coords: Union[np.ndarray, list, sh_coords.CoordinateSequence],
+    tolerance: float,
+    lookahead: int = 8,
+) -> Union[np.ndarray, list]:
+    """
+    Simplify a line using lang algorithm and return the coordinate indexes to
+    be kept.
+
+    Inspiration for the implementation came from:
+        * https://github.com/giscan/Generalizer/blob/master/simplify.py
+        * https://github.com/keszegrobert/polyline-simplification/blob/master/6.%20Lang.ipynb  # noqa: E501
+        * https://web.archive.org/web/20171005193700/http://web.cs.sunyit.edu/~poissad/projects/Curve/about_algorithms/lang.php  # noqa: E501
+
+    Args:
+        coords (Union[np.ndarray, list]): list of coordinates to be simplified.
+        tolerance (float): distance tolerance to use.
+        lookahead (int, optional): the number of points to consider for removing
+            in a moving window. Defaults to 8.
+
+    Returns:
+        Return the indexes of coordinates that need to be kept after
+        simplification.
+        If input coords is np.ndarray, returns np.ndarray, otherwise returns a list.
+    """
+
+    def point_line_distance(
+        point_x, point_y, line_x1, line_y1, line_x2, line_y2
+    ) -> float:
+        denominator = math.sqrt(
+            (line_x2 - line_x1) * (line_x2 - line_x1)
+            + (line_y2 - line_y1) * (line_y2 - line_y1)
+        )
+        if denominator == 0:
+            return float("Inf")
+        else:
+            numerator = abs(
+                (line_x2 - line_x1) * (line_y1 - point_y)
+                - (line_x1 - point_x) * (line_y2 - line_y1)
+            )
+            return numerator / denominator
+
+    # Init variables
+    if isinstance(coords, np.ndarray):
+        line_arr = coords
+    elif isinstance(coords, sh_coords.CoordinateSequence):
+        line_arr = np.asarray(coords)
+    else:
+        line_arr = np.array(list(coords))
+
+    # Prepare lookahead
+    nb_points = len(line_arr)
+    if lookahead == -1:
+        window_size = nb_points - 1
+    else:
+        window_size = min(lookahead, nb_points - 1)
+
+    # mask = np.ones(nb_points), dtype='bool')
+    mask = np.zeros(nb_points, dtype="bool")
+    mask[0] = True
+    window_start = 0
+    window_end = window_size
+
+    # Apply simplification till the window_start arrives at the last point.
+    ready = False
+    while ready is False:
+        # Check if all points between window_start and window_end are within
+        # tolerance distance to the line (window_start, window_end).
+        all_points_in_tolerance = True
+        for i in range(window_start + 1, window_end):
+            distance = point_line_distance(
+                line_arr[i, 0],
+                line_arr[i, 1],
+                line_arr[window_start, 0],
+                line_arr[window_start, 1],
+                line_arr[window_end, 0],
+                line_arr[window_end, 1],
+            )
+            # If distance is nan (= linepoint1 == linepoint2) or > tolerance
+            if distance > tolerance:
+                all_points_in_tolerance = False
+                break
+
+        # If not all the points are within the tolerance distance...
+        if not all_points_in_tolerance:
+            # Move window_end to previous point, and try again
+            window_end -= 1
+        else:
+            # All points are within the tolerance, so they can be masked
+            mask[window_end] = True
+            # mask[window_start+1:window_end-1] = False
+
+            # Move the window forward
+            window_start = window_end
+            if window_start == nb_points - 1:
+                ready = True
+            window_end = window_start + window_size
+            if window_end >= nb_points:
+                window_end = nb_points - 1
+
+    # Prepare result: convert the mask to a list of indices of points to keep.
+    idx_to_keep_arr = mask.nonzero()[0]
+
+    # If input was np.ndarray, return np.ndarray, otherwise list
+    if isinstance(coords, np.ndarray):
+        return idx_to_keep_arr
+    else:
+        return idx_to_keep_arr.tolist()
```

### Comparing `geofileops-0.8.0a1/geofileops/util/geoseries_util.py` & `geofileops-0.8.0a2/geofileops/util/geoseries_util.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,322 +1,322 @@
-# -*- coding: utf-8 -*-
-"""
-Module containing utilities regarding operations on geoseries.
-"""
-
-import logging
-from typing import List, Optional
-
-import geopandas as gpd
-import numpy as np
-import pandas as pd
-import pygeos
-from shapely import geometry as sh_geom
-
-from . import geometry_util
-from .geometry_util import GeometryType, PrimitiveType, SimplifyAlgorithm
-
-#####################################################################
-# First define/init some general variables/constants
-#####################################################################
-
-# Get a logger...
-logger = logging.getLogger(__name__)
-# logger.setLevel(logging.DEBUG)
-
-#####################################################################
-# GeoDataFrame helpers
-#####################################################################
-
-
-def geometry_collection_extract(
-    geoseries: gpd.GeoSeries, primitivetype: PrimitiveType
-) -> gpd.GeoSeries:
-    """
-    # Apply the collection_extract
-    return gpd.GeoSeries(
-        [geometry_util.collection_extract(geom, primitivetype) for geom in geoseries])
-    """
-    # Apply the collection_extract
-    geoseries_copy = geoseries.copy()
-    for index, geom in geoseries_copy.items():
-        geoseries_copy[index] = geometry_util.collection_extract(geom, primitivetype)
-    assert isinstance(geoseries_copy, gpd.GeoSeries)
-    return geoseries_copy
-
-
-def get_geometrytypes(
-    geoseries: gpd.GeoSeries, ignore_empty_geometries: bool = True
-) -> List[GeometryType]:
-    """
-    Determine the geometry types in the GeoDataFrame.
-
-    Args:
-        geoseries (gpd.GeoSeries): input geoseries.
-        ignore_empty_geometries (bool, optional): True to ignore empty geometries.
-            Defaults to True.
-
-    Returns:
-        List[GeometryType]: [description]
-    """
-    if ignore_empty_geometries is True:
-        input_geoseries = geoseries[~geoseries.is_empty]
-    else:
-        input_geoseries = geoseries
-    geom_types_2D = input_geoseries[~input_geoseries.has_z].geom_type.unique()
-    geom_types_2D = [gtype for gtype in geom_types_2D if gtype is not None]
-    geom_types_3D = input_geoseries[input_geoseries.has_z].geom_type.unique()
-    geom_types_3D = ["3D " + gtype for gtype in geom_types_3D if gtype is not None]
-    geom_types = geom_types_3D + geom_types_2D
-
-    if len(geom_types) == 0:
-        return [GeometryType.GEOMETRY]
-
-    geometrytypes_list = [GeometryType[geom_type.upper()] for geom_type in geom_types]
-    return geometrytypes_list
-
-
-def harmonize_geometrytypes(
-    geoseries: gpd.GeoSeries, force_multitype: bool = False
-) -> gpd.GeoSeries:
-    """
-    Tries to harmonize the geometries in the geoseries to one type.
-
-    Eg. if Polygons and MultiPolygons are present in the geoseries, all
-    geometries are converted to MultiPolygons.
-
-    Empty geometries are changed to None.
-
-    If they cannot be harmonized, the original series is returned...
-
-    Args:
-        geoseries (gpd.GeoSeries): The geoseries to harmonize.
-        force_multitype (bool, optional): True to force all geometries to the
-            corresponding multitype. Defaults to False.
-
-    Returns:
-        gpd.GeoSeries: the harmonized geoseries if possible, otherwise the
-            original one.
-    """
-    # Get unique list of geometrytypes in gdf
-    geometrytypes = get_geometrytypes(geoseries)
-
-    # If already only one geometrytype...
-    if len(geometrytypes) == 1:
-        if force_multitype is True:
-            # If it is already a multitype, return
-            if geometrytypes[0].is_multitype is True:
-                return geoseries
-            else:
-                # Else convert to corresponding multitype
-                return _harmonize_to_multitype(geoseries, geometrytypes[0].to_multitype)
-        else:
-            return geoseries
-    elif (
-        len(geometrytypes) == 2
-        and geometrytypes[0].to_primitivetype == geometrytypes[1].to_primitivetype
-    ):
-        # There are two geometrytypes, but they are of the same primitive type,
-        # so can just be harmonized to the multitype
-        return _harmonize_to_multitype(geoseries, geometrytypes[0].to_multitype)
-    else:
-        # Too difficult to harmonize, so just return
-        return geoseries
-
-
-def is_valid_reason(geoseries: gpd.GeoSeries) -> pd.Series:
-    # Get result and keep geoseries indexes
-    return pd.Series(
-        data=pygeos.is_valid_reason(geoseries.array.data),  # type: ignore
-        index=geoseries.index,
-    )
-
-
-def _harmonize_to_multitype(
-    geoseries: gpd.GeoSeries, dest_geometrytype: GeometryType
-) -> gpd.GeoSeries:
-    # Copy geoseries to pygeos array
-    geometries_arr = geoseries.array.data.copy()  # type: ignore
-
-    # Set empty geometries to None
-    empty_idxs = pygeos.is_empty(geometries_arr)
-    if empty_idxs.sum():
-        geometries_arr[empty_idxs] = None
-
-    # Cast all geometries that are not of the correct multitype yet
-    # Remark: all rows need to be retained, so the same indexers exist in the
-    # returned geoseries
-    if dest_geometrytype is GeometryType.MULTIPOLYGON:
-        # Convert polygons to multipolygons
-        single_idxs = pygeos.get_type_id(geometries_arr) == 3
-        if single_idxs.sum():
-            geometries_arr[single_idxs] = np.apply_along_axis(
-                pygeos.multipolygons,
-                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
-                axis=1,
-            )
-    elif dest_geometrytype is GeometryType.MULTILINESTRING:
-        # Convert linestrings to multilinestrings
-        single_idxs = pygeos.get_type_id(geometries_arr) == 1
-        if single_idxs.sum():
-            geometries_arr[single_idxs] = np.apply_along_axis(
-                pygeos.multilinestrings,
-                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
-                axis=1,
-            )
-    elif dest_geometrytype is GeometryType.MULTIPOINT:
-        single_idxs = pygeos.get_type_id(geometries_arr) == 0
-        if single_idxs.sum():
-            geometries_arr[single_idxs] = np.apply_along_axis(
-                pygeos.multipoints,
-                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
-                axis=1,
-            )
-    else:
-        raise Exception(f"Unsupported destination GeometryType: {dest_geometrytype}")
-
-    # Prepare result to return
-    geoseries_result = geoseries.copy()
-    geoseries_result.array.data = geometries_arr  # type: ignore
-    assert isinstance(geoseries_result, gpd.GeoSeries)
-    return geoseries_result
-
-
-def polygons_to_lines(geoseries: gpd.GeoSeries) -> gpd.GeoSeries:
-    polygons_lines = []
-    for geom in geoseries:
-        if geom is None or geom.is_empty:
-            continue
-        if (
-            isinstance(geom, sh_geom.Polygon) is False
-            and isinstance(geom, sh_geom.MultiPolygon) is False
-        ):
-            raise ValueError(f"Invalid geometry: {geom}")
-        boundary = geom.boundary
-        if boundary.geom_type == "MultiLineString":
-            for line in boundary.geoms:
-                polygons_lines.append(line)
-        else:
-            polygons_lines.append(boundary)
-
-    return gpd.GeoSeries(polygons_lines)
-
-
-def simplify_topo_ext(
-    geoseries: gpd.GeoSeries,
-    tolerance: float,
-    algorithm: SimplifyAlgorithm = SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
-    lookahead: int = 8,
-    keep_points_on: Optional[sh_geom.base.BaseGeometry] = None,
-) -> gpd.GeoSeries:
-    """
-    Applies simplify while retaining common boundaries between geometries in the
-    geoseries.
-
-    Args:
-        geoseries (gpd.GeoSeries): the geoseries to simplify.
-        algorithm (SimplifyAlgorithm): algorithm to use.
-        tolerance (float): tolerance to use for simplify
-        lookahead (int, optional): lookahead value for algorithms that use this.
-            Defaults to 8.
-        keep_points_on (Optional[sh_geom.base.BaseGeometry], optional): points that
-            intersect with this geometry won't be removed by the simplification.
-            Defaults to None.
-
-    Returns:
-        gpd.GeoSeries: the simplified geoseries
-    """
-    try:
-        import topojson
-        import topojson.ops
-    except ImportError as ex:
-        raise ImportError(
-            "simplify_topo_ext needs an optional package. Install with "
-            "'pip install topojson'"
-        ) from ex
-
-    topo = topojson.Topology(geoseries, prequantize=False)
-    topolines = sh_geom.MultiLineString(topo.output["arcs"])
-    topolines_simpl = geometry_util.simplify_ext(
-        geometry=topolines,
-        tolerance=tolerance,
-        algorithm=algorithm,
-        lookahead=lookahead,
-        keep_points_on=keep_points_on,
-        preserve_topology=True,
-    )
-    assert topolines_simpl is not None
-
-    # Copy the results of the simplified lines
-    if algorithm == SimplifyAlgorithm.LANG:
-        # For LANG, a simple copy is OK
-        assert isinstance(topolines_simpl, sh_geom.MultiLineString)
-        topo.output["arcs"] = [list(geom.coords) for geom in topolines_simpl.geoms]
-    else:
-        # For RDP, only overwrite the lines that have a valid result
-        for index in range(len(topo.output["arcs"])):
-            # If the result of the simplify is a point, keep original
-            topoline_simpl = topolines_simpl.geoms[index].coords  # type: ignore
-            if len(topoline_simpl) < 2:
-                continue
-            elif (
-                list(topoline_simpl[0]) != topo.output["arcs"][index][0]
-                or list(topoline_simpl[-1]) != topo.output["arcs"][index][-1]
-            ):
-                # Start or end point of the simplified version is not the same anymore
-                continue
-            else:
-                topo.output["arcs"][index] = list(topoline_simpl)
-
-    topo_simpl_geoseries = topo.to_gdf(crs=geoseries.crs).geometry
-    topo_simpl_geoseries.array.data = pygeos.make_valid(topo_simpl_geoseries.array.data)
-    geometry_types_orig = geoseries.geom_type.unique()
-    geometry_types_simpl = topo_simpl_geoseries.geom_type.unique()
-    if len(geometry_types_orig) == 1 and len(geometry_types_simpl) > 1:
-        topo_simpl_geoseries = geometry_collection_extract(
-            topo_simpl_geoseries,
-            GeometryType(geometry_types_orig[0]).to_primitivetype,
-        )
-    return topo_simpl_geoseries
-
-
-def simplify_ext(
-    geoseries: gpd.GeoSeries,
-    tolerance: float,
-    algorithm: SimplifyAlgorithm = SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
-    lookahead: int = 8,
-    keep_points_on: Optional[sh_geom.base.BaseGeometry] = None,
-) -> gpd.GeoSeries:
-    """
-    Applies simplify on the geometries in the geoseries.
-
-    Args:
-        geoseries (gpd.GeoSeries): the geoseries to simplify.
-        algorithm (SimplifyAlgorithm): algorithm to use.
-        tolerance (float): tolerance to use for simplify
-        lookahead (int, optional): lookahead value for algorithms that use this.
-            Defaults to 8.
-        keep_points_on (Optional[sh_geom.base.BaseGeometry], optional): points that
-            intersect with this geometry won't be removed by the simplification.
-            Defaults to None.
-
-    Returns:
-        gpd.GeoSeries: the simplified geoseries
-    """
-    # If ramer-douglas-peucker and no keep_points_on, use standard geopandas algorithm
-    if algorithm is SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER and keep_points_on is None:
-        return geoseries.simplify(tolerance=tolerance, preserve_topology=True)
-    else:
-        # For other algorithms, use vector_util.simplify_ext()
-        return gpd.GeoSeries(
-            [
-                geometry_util.simplify_ext(
-                    geom,
-                    algorithm=algorithm,
-                    tolerance=tolerance,
-                    lookahead=lookahead,
-                    keep_points_on=keep_points_on,
-                    preserve_topology=True,
-                )
-                for geom in geoseries
-            ]
-        )
+# -*- coding: utf-8 -*-
+"""
+Module containing utilities regarding operations on geoseries.
+"""
+
+import logging
+from typing import List, Optional
+
+import geopandas as gpd
+import numpy as np
+import pandas as pd
+import pygeos
+from shapely import geometry as sh_geom
+
+from . import geometry_util
+from .geometry_util import GeometryType, PrimitiveType, SimplifyAlgorithm
+
+#####################################################################
+# First define/init some general variables/constants
+#####################################################################
+
+# Get a logger...
+logger = logging.getLogger(__name__)
+# logger.setLevel(logging.DEBUG)
+
+#####################################################################
+# GeoDataFrame helpers
+#####################################################################
+
+
+def geometry_collection_extract(
+    geoseries: gpd.GeoSeries, primitivetype: PrimitiveType
+) -> gpd.GeoSeries:
+    """
+    # Apply the collection_extract
+    return gpd.GeoSeries(
+        [geometry_util.collection_extract(geom, primitivetype) for geom in geoseries])
+    """
+    # Apply the collection_extract
+    geoseries_copy = geoseries.copy()
+    for index, geom in geoseries_copy.items():
+        geoseries_copy[index] = geometry_util.collection_extract(geom, primitivetype)
+    assert isinstance(geoseries_copy, gpd.GeoSeries)
+    return geoseries_copy
+
+
+def get_geometrytypes(
+    geoseries: gpd.GeoSeries, ignore_empty_geometries: bool = True
+) -> List[GeometryType]:
+    """
+    Determine the geometry types in the GeoDataFrame.
+
+    Args:
+        geoseries (gpd.GeoSeries): input geoseries.
+        ignore_empty_geometries (bool, optional): True to ignore empty geometries.
+            Defaults to True.
+
+    Returns:
+        List[GeometryType]: [description]
+    """
+    if ignore_empty_geometries is True:
+        input_geoseries = geoseries[~geoseries.is_empty]
+    else:
+        input_geoseries = geoseries
+    geom_types_2D = input_geoseries[~input_geoseries.has_z].geom_type.unique()
+    geom_types_2D = [gtype for gtype in geom_types_2D if gtype is not None]
+    geom_types_3D = input_geoseries[input_geoseries.has_z].geom_type.unique()
+    geom_types_3D = ["3D " + gtype for gtype in geom_types_3D if gtype is not None]
+    geom_types = geom_types_3D + geom_types_2D
+
+    if len(geom_types) == 0:
+        return [GeometryType.GEOMETRY]
+
+    geometrytypes_list = [GeometryType[geom_type.upper()] for geom_type in geom_types]
+    return geometrytypes_list
+
+
+def harmonize_geometrytypes(
+    geoseries: gpd.GeoSeries, force_multitype: bool = False
+) -> gpd.GeoSeries:
+    """
+    Tries to harmonize the geometries in the geoseries to one type.
+
+    Eg. if Polygons and MultiPolygons are present in the geoseries, all
+    geometries are converted to MultiPolygons.
+
+    Empty geometries are changed to None.
+
+    If they cannot be harmonized, the original series is returned...
+
+    Args:
+        geoseries (gpd.GeoSeries): The geoseries to harmonize.
+        force_multitype (bool, optional): True to force all geometries to the
+            corresponding multitype. Defaults to False.
+
+    Returns:
+        gpd.GeoSeries: the harmonized geoseries if possible, otherwise the
+            original one.
+    """
+    # Get unique list of geometrytypes in gdf
+    geometrytypes = get_geometrytypes(geoseries)
+
+    # If already only one geometrytype...
+    if len(geometrytypes) == 1:
+        if force_multitype is True:
+            # If it is already a multitype, return
+            if geometrytypes[0].is_multitype is True:
+                return geoseries
+            else:
+                # Else convert to corresponding multitype
+                return _harmonize_to_multitype(geoseries, geometrytypes[0].to_multitype)
+        else:
+            return geoseries
+    elif (
+        len(geometrytypes) == 2
+        and geometrytypes[0].to_primitivetype == geometrytypes[1].to_primitivetype
+    ):
+        # There are two geometrytypes, but they are of the same primitive type,
+        # so can just be harmonized to the multitype
+        return _harmonize_to_multitype(geoseries, geometrytypes[0].to_multitype)
+    else:
+        # Too difficult to harmonize, so just return
+        return geoseries
+
+
+def is_valid_reason(geoseries: gpd.GeoSeries) -> pd.Series:
+    # Get result and keep geoseries indexes
+    return pd.Series(
+        data=pygeos.is_valid_reason(geoseries.array.data),  # type: ignore
+        index=geoseries.index,
+    )
+
+
+def _harmonize_to_multitype(
+    geoseries: gpd.GeoSeries, dest_geometrytype: GeometryType
+) -> gpd.GeoSeries:
+    # Copy geoseries to pygeos array
+    geometries_arr = geoseries.array.data.copy()  # type: ignore
+
+    # Set empty geometries to None
+    empty_idxs = pygeos.is_empty(geometries_arr)
+    if empty_idxs.sum():
+        geometries_arr[empty_idxs] = None
+
+    # Cast all geometries that are not of the correct multitype yet
+    # Remark: all rows need to be retained, so the same indexers exist in the
+    # returned geoseries
+    if dest_geometrytype is GeometryType.MULTIPOLYGON:
+        # Convert polygons to multipolygons
+        single_idxs = pygeos.get_type_id(geometries_arr) == 3
+        if single_idxs.sum():
+            geometries_arr[single_idxs] = np.apply_along_axis(
+                pygeos.multipolygons,
+                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
+                axis=1,
+            )
+    elif dest_geometrytype is GeometryType.MULTILINESTRING:
+        # Convert linestrings to multilinestrings
+        single_idxs = pygeos.get_type_id(geometries_arr) == 1
+        if single_idxs.sum():
+            geometries_arr[single_idxs] = np.apply_along_axis(
+                pygeos.multilinestrings,
+                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
+                axis=1,
+            )
+    elif dest_geometrytype is GeometryType.MULTIPOINT:
+        single_idxs = pygeos.get_type_id(geometries_arr) == 0
+        if single_idxs.sum():
+            geometries_arr[single_idxs] = np.apply_along_axis(
+                pygeos.multipoints,
+                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
+                axis=1,
+            )
+    else:
+        raise Exception(f"Unsupported destination GeometryType: {dest_geometrytype}")
+
+    # Prepare result to return
+    geoseries_result = geoseries.copy()
+    geoseries_result.array.data = geometries_arr  # type: ignore
+    assert isinstance(geoseries_result, gpd.GeoSeries)
+    return geoseries_result
+
+
+def polygons_to_lines(geoseries: gpd.GeoSeries) -> gpd.GeoSeries:
+    polygons_lines = []
+    for geom in geoseries:
+        if geom is None or geom.is_empty:
+            continue
+        if (
+            isinstance(geom, sh_geom.Polygon) is False
+            and isinstance(geom, sh_geom.MultiPolygon) is False
+        ):
+            raise ValueError(f"Invalid geometry: {geom}")
+        boundary = geom.boundary
+        if boundary.geom_type == "MultiLineString":
+            for line in boundary.geoms:
+                polygons_lines.append(line)
+        else:
+            polygons_lines.append(boundary)
+
+    return gpd.GeoSeries(polygons_lines)
+
+
+def simplify_topo_ext(
+    geoseries: gpd.GeoSeries,
+    tolerance: float,
+    algorithm: SimplifyAlgorithm = SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
+    lookahead: int = 8,
+    keep_points_on: Optional[sh_geom.base.BaseGeometry] = None,
+) -> gpd.GeoSeries:
+    """
+    Applies simplify while retaining common boundaries between geometries in the
+    geoseries.
+
+    Args:
+        geoseries (gpd.GeoSeries): the geoseries to simplify.
+        algorithm (SimplifyAlgorithm): algorithm to use.
+        tolerance (float): tolerance to use for simplify
+        lookahead (int, optional): lookahead value for algorithms that use this.
+            Defaults to 8.
+        keep_points_on (Optional[sh_geom.base.BaseGeometry], optional): points that
+            intersect with this geometry won't be removed by the simplification.
+            Defaults to None.
+
+    Returns:
+        gpd.GeoSeries: the simplified geoseries
+    """
+    try:
+        import topojson
+        import topojson.ops
+    except ImportError as ex:
+        raise ImportError(
+            "simplify_topo_ext needs an optional package. Install with "
+            "'pip install topojson'"
+        ) from ex
+
+    topo = topojson.Topology(geoseries, prequantize=False)
+    topolines = sh_geom.MultiLineString(topo.output["arcs"])
+    topolines_simpl = geometry_util.simplify_ext(
+        geometry=topolines,
+        tolerance=tolerance,
+        algorithm=algorithm,
+        lookahead=lookahead,
+        keep_points_on=keep_points_on,
+        preserve_topology=True,
+    )
+    assert topolines_simpl is not None
+
+    # Copy the results of the simplified lines
+    if algorithm == SimplifyAlgorithm.LANG:
+        # For LANG, a simple copy is OK
+        assert isinstance(topolines_simpl, sh_geom.MultiLineString)
+        topo.output["arcs"] = [list(geom.coords) for geom in topolines_simpl.geoms]
+    else:
+        # For RDP, only overwrite the lines that have a valid result
+        for index in range(len(topo.output["arcs"])):
+            # If the result of the simplify is a point, keep original
+            topoline_simpl = topolines_simpl.geoms[index].coords  # type: ignore
+            if len(topoline_simpl) < 2:
+                continue
+            elif (
+                list(topoline_simpl[0]) != topo.output["arcs"][index][0]
+                or list(topoline_simpl[-1]) != topo.output["arcs"][index][-1]
+            ):
+                # Start or end point of the simplified version is not the same anymore
+                continue
+            else:
+                topo.output["arcs"][index] = list(topoline_simpl)
+
+    topo_simpl_geoseries = topo.to_gdf(crs=geoseries.crs).geometry
+    topo_simpl_geoseries.array.data = pygeos.make_valid(topo_simpl_geoseries.array.data)
+    geometry_types_orig = geoseries.geom_type.unique()
+    geometry_types_simpl = topo_simpl_geoseries.geom_type.unique()
+    if len(geometry_types_orig) == 1 and len(geometry_types_simpl) > 1:
+        topo_simpl_geoseries = geometry_collection_extract(
+            topo_simpl_geoseries,
+            GeometryType(geometry_types_orig[0]).to_primitivetype,
+        )
+    return topo_simpl_geoseries
+
+
+def simplify_ext(
+    geoseries: gpd.GeoSeries,
+    tolerance: float,
+    algorithm: SimplifyAlgorithm = SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
+    lookahead: int = 8,
+    keep_points_on: Optional[sh_geom.base.BaseGeometry] = None,
+) -> gpd.GeoSeries:
+    """
+    Applies simplify on the geometries in the geoseries.
+
+    Args:
+        geoseries (gpd.GeoSeries): the geoseries to simplify.
+        algorithm (SimplifyAlgorithm): algorithm to use.
+        tolerance (float): tolerance to use for simplify
+        lookahead (int, optional): lookahead value for algorithms that use this.
+            Defaults to 8.
+        keep_points_on (Optional[sh_geom.base.BaseGeometry], optional): points that
+            intersect with this geometry won't be removed by the simplification.
+            Defaults to None.
+
+    Returns:
+        gpd.GeoSeries: the simplified geoseries
+    """
+    # If ramer-douglas-peucker and no keep_points_on, use standard geopandas algorithm
+    if algorithm is SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER and keep_points_on is None:
+        return geoseries.simplify(tolerance=tolerance, preserve_topology=True)
+    else:
+        # For other algorithms, use vector_util.simplify_ext()
+        return gpd.GeoSeries(
+            [
+                geometry_util.simplify_ext(
+                    geom,
+                    algorithm=algorithm,
+                    tolerance=tolerance,
+                    lookahead=lookahead,
+                    keep_points_on=keep_points_on,
+                    preserve_topology=True,
+                )
+                for geom in geoseries
+            ]
+        )
```

### Comparing `geofileops-0.8.0a1/geofileops/util/grid_util.py` & `geofileops-0.8.0a2/geofileops/util/grid_util.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,226 +1,226 @@
-# -*- coding: utf-8 -*-
-"""
-Module containing utilities to create/manipulate grids.
-"""
-
-import logging
-import math
-from typing import Optional, Tuple, Union
-
-import geopandas as gpd
-import pyproj
-import shapely.ops as sh_ops
-import shapely.geometry as sh_geom
-
-#####################################################################
-# First define/init some general variables/constants
-#####################################################################
-
-# Get a logger...
-logger = logging.getLogger(__name__)
-# logger.setLevel(logging.DEBUG)
-
-#####################################################################
-# Grid tile helpers
-#####################################################################
-
-
-def create_grid(
-    total_bounds: Tuple[float, float, float, float],
-    nb_columns: int,
-    nb_rows: int,
-    crs: Union[pyproj.CRS, int, str, None],
-) -> gpd.GeoDataFrame:
-    xmin, ymin, xmax, ymax = total_bounds
-    width = (xmax - xmin) / nb_columns
-    height = (ymax - ymin) / nb_rows
-
-    return create_grid3(total_bounds=total_bounds, width=width, height=height, crs=crs)
-
-
-def create_grid3(
-    total_bounds: Tuple[float, float, float, float],
-    width: float,
-    height: float,
-    crs: Union[pyproj.CRS, int, str, None],
-) -> gpd.GeoDataFrame:
-    """
-
-
-    Args:
-        total_bounds (Tuple[float, float, float, float]): [description]
-        width (float): [description]
-        height (float): [description]
-        crs (Union[pyproj.CRS, int, str, None]): [description]
-        number_decimals (int, optional): The number of decimals the coordinates
-            of the grid will have. Defaults to None, so no rounding.
-
-    Returns:
-        gpd.GeoDataFrame: [description]
-    """
-
-    xmin, ymin, xmax, ymax = total_bounds
-    rows = int(math.ceil((ymax - ymin) / height))
-    cols = int(math.ceil((xmax - xmin) / width))
-
-    polygons = []
-    cell_left = xmin
-    cell_right = xmin + width
-    for _ in range(cols):
-        if cell_left > xmax:
-            break
-        cell_top = ymin + height
-        cell_bottom = ymin
-        for _ in range(rows):
-            if cell_bottom > ymax:
-                break
-            polygons.append(
-                sh_ops.Polygon(
-                    [
-                        (cell_left, cell_top),
-                        (cell_right, cell_top),
-                        (cell_right, cell_bottom),
-                        (cell_left, cell_bottom),
-                    ]
-                )
-            )
-            cell_top += height
-            cell_bottom += height
-
-        cell_left += width
-        cell_right += width
-
-    return gpd.GeoDataFrame(geometry=polygons, crs=crs)  # type: ignore
-
-
-def create_grid2(
-    total_bounds: Tuple[float, float, float, float],
-    nb_squarish_tiles: int,
-    crs: Union[pyproj.CRS, int, str, None],
-    nb_squarish_tiles_max: Optional[int] = None,
-) -> gpd.GeoDataFrame:
-    """
-    Creates a grid and tries to approximate the number of cells asked as
-    good as possible with grid cells that as close to square as possible.
-
-    Args:
-        total_bounds (Tuple[float, float, float, float]): bounds of the grid to be
-            created
-        nb_squarish_cells (int): about the number of cells wanted
-        crs (pyproj.CRS, int, str, optional): the projection to create the grid in
-        nb_squarish_tiles_max (int, optional): the maximum number of cells
-
-    Returns:
-        gpd.GeoDataFrame: geodataframe with the grid
-    """
-    # Check input
-    if nb_squarish_tiles_max is not None and nb_squarish_tiles_max < 1:
-        raise Exception("The maximum nb of tiles should be larger than 1")
-
-    # If more cells asked, calculate optimal number
-    xmin, ymin, xmax, ymax = total_bounds
-    total_width = xmax - xmin
-    total_height = ymax - ymin
-
-    columns_vs_rows = total_width / total_height
-    nb_rows = max(round(math.sqrt(nb_squarish_tiles / columns_vs_rows)), 1)
-
-    # Evade having too many cells (if few cells are asked)
-    if nb_rows > nb_squarish_tiles:
-        nb_rows = nb_squarish_tiles
-    nb_columns = max(round(nb_squarish_tiles / nb_rows), 1)
-    # If a maximum number of tiles is specified, check it
-    if nb_squarish_tiles_max is not None:
-        while (nb_rows * nb_columns) > nb_squarish_tiles_max:
-            # If the number of cells became larger than the max number of cells,
-            # increase the number of cells in the direction of the longest side
-            # of the resulting cells
-            if nb_columns > 1 and (
-                nb_rows == 1 or total_width / nb_columns > total_height / nb_rows
-            ):
-                # Cell width is larger than cell height
-                nb_columns -= 1
-            else:
-                nb_rows -= 1
-
-    # Now we know everything to create the grid
-    return create_grid(
-        total_bounds=total_bounds, nb_columns=nb_columns, nb_rows=nb_rows, crs=crs
-    )
-
-
-def split_tiles(
-    input_tiles: gpd.GeoDataFrame, nb_tiles_wanted: int
-) -> gpd.GeoDataFrame:
-    nb_tiles = len(input_tiles)
-    if nb_tiles >= nb_tiles_wanted:
-        return input_tiles
-
-    nb_tiles_ratio_target = nb_tiles_wanted / nb_tiles
-
-    # Loop over all tiles in the grid
-    result_tiles = []
-    for tile in input_tiles.itertuples():
-        # For this tile, as long as the curr_nb_tiles_ratio_todo is not 1, keep
-        # splitting
-        curr_nb_tiles_ratio_todo = nb_tiles_ratio_target
-        curr_tiles_being_split = [tile.geometry]
-        while curr_nb_tiles_ratio_todo > 1:
-            # Check in how many parts the tiles are split in this iteration
-            divisor = 0
-            if round(curr_nb_tiles_ratio_todo) == 3:
-                divisor = 3
-            else:
-                divisor = 2
-            curr_nb_tiles_ratio_todo /= divisor
-
-            # Split all current tiles
-            tmp_tiles_after_split = []
-            for tile_to_split in curr_tiles_being_split:
-                xmin, ymin, xmax, ymax = tile_to_split.bounds
-                width = abs(xmax - xmin)
-                height = abs(ymax - ymin)
-
-                # Split in 2 or 3...
-                if divisor == 3:
-                    if width > height:
-                        split_line = sh_geom.LineString(
-                            [
-                                (xmin + width / 3, ymin - 1),
-                                (xmin + width / 3, ymax + 1),
-                                (xmin + 2 * width / 3, ymax + 1),
-                                (xmin + 2 * width / 3, ymin - 1),
-                            ]
-                        )
-                    else:
-                        split_line = sh_geom.LineString(
-                            [
-                                (xmin - 1, ymin + height / 3),
-                                (xmax + 1, ymin + height / 3),
-                                (xmax + 1, ymin + 2 * height / 3),
-                                (xmin - 1, ymin + 2 * height / 3),
-                            ]
-                        )
-                else:
-                    if width > height:
-                        split_line = sh_geom.LineString(
-                            [(xmin + width / 2, ymin - 1), (xmin + width / 2, ymax + 1)]
-                        )
-                    else:
-                        split_line = sh_geom.LineString(
-                            [
-                                (xmin - 1, ymin + height / 2),
-                                (xmax + 1, ymin + height / 2),
-                            ]
-                        )
-                tmp_tiles_after_split.extend(
-                    sh_ops.split(tile_to_split, split_line).geoms
-                )
-            curr_tiles_being_split = tmp_tiles_after_split
-
-        # Copy the tile parts to the result and retain possible other columns
-        for tile_split_part in curr_tiles_being_split:
-            result_tiles.append(tile._replace(geometry=tile_split_part))
-
-    # We should be ready...
-    return gpd.GeoDataFrame(data=result_tiles, crs=input_tiles.crs)  # type: ignore
+# -*- coding: utf-8 -*-
+"""
+Module containing utilities to create/manipulate grids.
+"""
+
+import logging
+import math
+from typing import Optional, Tuple, Union
+
+import geopandas as gpd
+import pyproj
+import shapely.ops as sh_ops
+import shapely.geometry as sh_geom
+
+#####################################################################
+# First define/init some general variables/constants
+#####################################################################
+
+# Get a logger...
+logger = logging.getLogger(__name__)
+# logger.setLevel(logging.DEBUG)
+
+#####################################################################
+# Grid tile helpers
+#####################################################################
+
+
+def create_grid(
+    total_bounds: Tuple[float, float, float, float],
+    nb_columns: int,
+    nb_rows: int,
+    crs: Union[pyproj.CRS, int, str, None],
+) -> gpd.GeoDataFrame:
+    xmin, ymin, xmax, ymax = total_bounds
+    width = (xmax - xmin) / nb_columns
+    height = (ymax - ymin) / nb_rows
+
+    return create_grid3(total_bounds=total_bounds, width=width, height=height, crs=crs)
+
+
+def create_grid3(
+    total_bounds: Tuple[float, float, float, float],
+    width: float,
+    height: float,
+    crs: Union[pyproj.CRS, int, str, None],
+) -> gpd.GeoDataFrame:
+    """
+
+
+    Args:
+        total_bounds (Tuple[float, float, float, float]): [description]
+        width (float): [description]
+        height (float): [description]
+        crs (Union[pyproj.CRS, int, str, None]): [description]
+        number_decimals (int, optional): The number of decimals the coordinates
+            of the grid will have. Defaults to None, so no rounding.
+
+    Returns:
+        gpd.GeoDataFrame: [description]
+    """
+
+    xmin, ymin, xmax, ymax = total_bounds
+    rows = int(math.ceil((ymax - ymin) / height))
+    cols = int(math.ceil((xmax - xmin) / width))
+
+    polygons = []
+    cell_left = xmin
+    cell_right = xmin + width
+    for _ in range(cols):
+        if cell_left > xmax:
+            break
+        cell_top = ymin + height
+        cell_bottom = ymin
+        for _ in range(rows):
+            if cell_bottom > ymax:
+                break
+            polygons.append(
+                sh_ops.Polygon(
+                    [
+                        (cell_left, cell_top),
+                        (cell_right, cell_top),
+                        (cell_right, cell_bottom),
+                        (cell_left, cell_bottom),
+                    ]
+                )
+            )
+            cell_top += height
+            cell_bottom += height
+
+        cell_left += width
+        cell_right += width
+
+    return gpd.GeoDataFrame(geometry=polygons, crs=crs)  # type: ignore
+
+
+def create_grid2(
+    total_bounds: Tuple[float, float, float, float],
+    nb_squarish_tiles: int,
+    crs: Union[pyproj.CRS, int, str, None],
+    nb_squarish_tiles_max: Optional[int] = None,
+) -> gpd.GeoDataFrame:
+    """
+    Creates a grid and tries to approximate the number of cells asked as
+    good as possible with grid cells that as close to square as possible.
+
+    Args:
+        total_bounds (Tuple[float, float, float, float]): bounds of the grid to be
+            created
+        nb_squarish_cells (int): about the number of cells wanted
+        crs (pyproj.CRS, int, str, optional): the projection to create the grid in
+        nb_squarish_tiles_max (int, optional): the maximum number of cells
+
+    Returns:
+        gpd.GeoDataFrame: geodataframe with the grid
+    """
+    # Check input
+    if nb_squarish_tiles_max is not None and nb_squarish_tiles_max < 1:
+        raise Exception("The maximum nb of tiles should be larger than 1")
+
+    # If more cells asked, calculate optimal number
+    xmin, ymin, xmax, ymax = total_bounds
+    total_width = xmax - xmin
+    total_height = ymax - ymin
+
+    columns_vs_rows = total_width / total_height
+    nb_rows = max(round(math.sqrt(nb_squarish_tiles / columns_vs_rows)), 1)
+
+    # Evade having too many cells (if few cells are asked)
+    if nb_rows > nb_squarish_tiles:
+        nb_rows = nb_squarish_tiles
+    nb_columns = max(round(nb_squarish_tiles / nb_rows), 1)
+    # If a maximum number of tiles is specified, check it
+    if nb_squarish_tiles_max is not None:
+        while (nb_rows * nb_columns) > nb_squarish_tiles_max:
+            # If the number of cells became larger than the max number of cells,
+            # increase the number of cells in the direction of the longest side
+            # of the resulting cells
+            if nb_columns > 1 and (
+                nb_rows == 1 or total_width / nb_columns > total_height / nb_rows
+            ):
+                # Cell width is larger than cell height
+                nb_columns -= 1
+            else:
+                nb_rows -= 1
+
+    # Now we know everything to create the grid
+    return create_grid(
+        total_bounds=total_bounds, nb_columns=nb_columns, nb_rows=nb_rows, crs=crs
+    )
+
+
+def split_tiles(
+    input_tiles: gpd.GeoDataFrame, nb_tiles_wanted: int
+) -> gpd.GeoDataFrame:
+    nb_tiles = len(input_tiles)
+    if nb_tiles >= nb_tiles_wanted:
+        return input_tiles
+
+    nb_tiles_ratio_target = nb_tiles_wanted / nb_tiles
+
+    # Loop over all tiles in the grid
+    result_tiles = []
+    for tile in input_tiles.itertuples():
+        # For this tile, as long as the curr_nb_tiles_ratio_todo is not 1, keep
+        # splitting
+        curr_nb_tiles_ratio_todo = nb_tiles_ratio_target
+        curr_tiles_being_split = [tile.geometry]
+        while curr_nb_tiles_ratio_todo > 1:
+            # Check in how many parts the tiles are split in this iteration
+            divisor = 0
+            if round(curr_nb_tiles_ratio_todo) == 3:
+                divisor = 3
+            else:
+                divisor = 2
+            curr_nb_tiles_ratio_todo /= divisor
+
+            # Split all current tiles
+            tmp_tiles_after_split = []
+            for tile_to_split in curr_tiles_being_split:
+                xmin, ymin, xmax, ymax = tile_to_split.bounds
+                width = abs(xmax - xmin)
+                height = abs(ymax - ymin)
+
+                # Split in 2 or 3...
+                if divisor == 3:
+                    if width > height:
+                        split_line = sh_geom.LineString(
+                            [
+                                (xmin + width / 3, ymin - 1),
+                                (xmin + width / 3, ymax + 1),
+                                (xmin + 2 * width / 3, ymax + 1),
+                                (xmin + 2 * width / 3, ymin - 1),
+                            ]
+                        )
+                    else:
+                        split_line = sh_geom.LineString(
+                            [
+                                (xmin - 1, ymin + height / 3),
+                                (xmax + 1, ymin + height / 3),
+                                (xmax + 1, ymin + 2 * height / 3),
+                                (xmin - 1, ymin + 2 * height / 3),
+                            ]
+                        )
+                else:
+                    if width > height:
+                        split_line = sh_geom.LineString(
+                            [(xmin + width / 2, ymin - 1), (xmin + width / 2, ymax + 1)]
+                        )
+                    else:
+                        split_line = sh_geom.LineString(
+                            [
+                                (xmin - 1, ymin + height / 2),
+                                (xmax + 1, ymin + height / 2),
+                            ]
+                        )
+                tmp_tiles_after_split.extend(
+                    sh_ops.split(tile_to_split, split_line).geoms
+                )
+            curr_tiles_being_split = tmp_tiles_after_split
+
+        # Copy the tile parts to the result and retain possible other columns
+        for tile_split_part in curr_tiles_being_split:
+            result_tiles.append(tile._replace(geometry=tile_split_part))
+
+    # We should be ready...
+    return gpd.GeoDataFrame(data=result_tiles, crs=input_tiles.crs)  # type: ignore
```

### Comparing `geofileops-0.8.0a1/geofileops/util/test.gpkg` & `geofileops-0.8.0a2/geofileops/util/test.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/geofileops.egg-info/PKG-INFO` & `geofileops-0.8.0a2/README.md`

 * *Files 18% similar despite different names*

```diff
@@ -1,42 +1,28 @@
-Metadata-Version: 2.1
-Name: geofileops
-Version: 0.8.0a1
-Summary: Package to do spatial operations on large geo files.
-Home-page: https://github.com/geofileops/geofileops
-Author: Pieter Roggemans
-Author-email: pieter.roggemans@gmail.com
-Classifier: Programming Language :: Python :: 3
-Classifier: Operating System :: OS Independent
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Provides-Extra: full
-License-File: LICENSE.txt
-
-# geofileops 
-
-[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
-[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
-[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
-[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
-
-Library to make spatial operations on large geo files fast(er) and easy.
-
-Remarks: 
-* Most typical operations are available: 
-  [buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer),
-  [simplify](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.simolify),
-  [dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
-  [union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),
-  [erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
-  [intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection),...
-* Any python function can be applied to a geofile in parallel using [apply](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.apply)
-* The speed (improvement) depends on the operation, the number of available cores and the size of the input files.
-  * For CPU bound operations (eg. union,... between large input files) the processing time will depend on the number of available CPU cores. For (very) large files the typical processing time can be divided by the number of available cores.
-  * For dissolve on (very) large files, the speed improvement can be more than the processing time divided by the available cores.
-* Tested on geopackage and shapefile input/output files. However, geopackage is highly recommended as it will offer better performance in geofileops... and also for the reasons listed here: www.switchfromshapefile.org.
-
-Documentation on how to use geofileops can be found [here](https://geofileops.readthedocs.io).
-
-The following chart gives an impression of the speed improvement that can be expected when processing larger files (including I/O!). More information about this benchmark can be found [here](https://github.com/geofileops/geobenchmark).
-
-![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
+# geofileops 
+
+[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
+[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
+[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
+[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
+
+Library to make spatial operations on large geo files fast(er) and easy.
+
+Remarks: 
+* Most typical operations are available: 
+  [buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer),
+  [simplify](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.simolify),
+  [dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
+  [union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),
+  [erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
+  [intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection),...
+* Any python function can be applied to a geofile in parallel using [apply](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.apply)
+* The speed (improvement) depends on the operation, the number of available cores and the size of the input files.
+  * For CPU bound operations (eg. union,... between large input files) the processing time will depend on the number of available CPU cores. For (very) large files the typical processing time can be divided by the number of available cores.
+  * For dissolve on (very) large files, the speed improvement can be more than the processing time divided by the available cores.
+* Tested on geopackage and shapefile input/output files. However, geopackage is highly recommended as it will offer better performance in geofileops... and also for the reasons listed here: www.switchfromshapefile.org.
+
+Documentation on how to use geofileops can be found [here](https://geofileops.readthedocs.io).
+
+The following chart gives an impression of the speed improvement that can be expected when processing larger files (including I/O!). More information about this benchmark can be found [here](https://github.com/geofileops/geobenchmark).
+
+![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
```

### Comparing `geofileops-0.8.0a1/setup.py` & `geofileops-0.8.0a2/setup.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-import setuptools
-
-with open("README.md", "r") as fh:
-    long_description = fh.read()
-
-with open("geofileops/version.txt", mode="r") as file:
-    version = file.readline()
-
-setuptools.setup(
-    name="geofileops",
-    version=version,
-    author="Pieter Roggemans",
-    author_email="pieter.roggemans@gmail.com",
-    description="Package to do spatial operations on large geo files.",
-    long_description=long_description,
-    long_description_content_type="text/markdown",
-    url="https://github.com/geofileops/geofileops",
-    include_package_data=True,
-    packages=setuptools.find_packages(),
-    install_requires=[
-        "cloudpickle",
-        "fiona",
-        "gdal",
-        "geopandas>=0.11,<1.0",
-        "numpy",
-        "pandas",
-        "psutil",
-        "pygeos",
-        "pyogrio",
-        "pyproj",
-        "shapely",
-        "topojson",
-    ],
-    extras_require={"full": ["simplification"]},
-    classifiers=[
-        "Programming Language :: Python :: 3",
-        "Operating System :: OS Independent",
-    ],
-    python_requires=">=3.8",
-)
+import setuptools
+
+with open("README.md", "r") as fh:
+    long_description = fh.read()
+
+with open("geofileops/version.txt", mode="r") as file:
+    version = file.readline()
+
+setuptools.setup(
+    name="geofileops",
+    version=version,
+    author="Pieter Roggemans",
+    author_email="pieter.roggemans@gmail.com",
+    description="Package to do spatial operations on large geo files.",
+    long_description=long_description,
+    long_description_content_type="text/markdown",
+    url="https://github.com/geofileops/geofileops",
+    include_package_data=True,
+    packages=setuptools.find_packages(),
+    install_requires=[
+        "cloudpickle",
+        "fiona",
+        "gdal",
+        "geopandas>=0.11,<1.0",
+        "numpy",
+        "pandas",
+        "psutil",
+        "pygeos",
+        "pyogrio",
+        "pyproj",
+        "shapely",
+        "topojson",
+    ],
+    extras_require={"full": ["simplification"]},
+    classifiers=[
+        "Programming Language :: Python :: 3",
+        "Operating System :: OS Independent",
+    ],
+    python_requires=">=3.8",
+)
```

### Comparing `geofileops-0.8.0a1/tests/data/BEFL-kbl.gpkg` & `geofileops-0.8.0a2/tests/data/BEFL-kbl.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/geofileops_testdata.qgz` & `geofileops-0.8.0a2/tests/data/geofileops_testdata.qgz`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/linestring-row-trees.gpkg` & `geofileops-0.8.0a2/tests/data/linestring-row-trees.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/linestring-watercourse.gpkg` & `geofileops-0.8.0a2/tests/data/linestring-watercourse.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/linestrings_hedges.gpkg` & `geofileops-0.8.0a2/tests/data/linestrings_hedges.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/point.gpkg` & `geofileops-0.8.0a2/tests/data/point.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/polygon-invalid.gpkg` & `geofileops-0.8.0a2/tests/data/polygon-invalid.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/polygon-no-rows.gpkg` & `geofileops-0.8.0a2/tests/data/polygon-no-rows.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/polygon-overlappingcircles-all.gpkg` & `geofileops-0.8.0a2/tests/data/polygon-overlappingcircles-all.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/polygon-overlappingcircles-one.gpkg` & `geofileops-0.8.0a2/tests/data/polygon-overlappingcircles-one.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/polygon-overlappingcircles-two+three.gpkg` & `geofileops-0.8.0a2/tests/data/polygon-overlappingcircles-two+three.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/polygon-parcel.gpkg` & `geofileops-0.8.0a2/tests/data/polygon-parcel.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/polygon-simplify-onborder-testcase.gpkg` & `geofileops-0.8.0a2/tests/data/polygon-simplify-onborder-testcase.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/polygon-twolayers.gpkg` & `geofileops-0.8.0a2/tests/data/polygon-twolayers.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/polygon-zone.gpkg` & `geofileops-0.8.0a2/tests/data/polygon-zone.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.0a1/tests/data/polygonstyle.qml` & `geofileops-0.8.0a2/tests/data/polygonstyle.qml`

 * *Files 19% similar despite different names*

```diff
@@ -1,1240 +1,1215 @@
 00000000: 3c21 444f 4354 5950 4520 7167 6973 2050  <!DOCTYPE qgis P
 00000010: 5542 4c49 4320 2268 7474 703a 2f2f 6d72  UBLIC "http://mr
 00000020: 6363 2e63 6f6d 2f71 6769 732e 6474 6422  cc.com/qgis.dtd"
-00000030: 2022 5359 5354 454d 223e 0d0a 3c71 6769   "SYSTEM">..<qgi
-00000040: 7320 7369 6d70 6c69 6679 4472 6177 696e  s simplifyDrawin
-00000050: 6748 696e 7473 3d22 3122 2072 6561 644f  gHints="1" readO
-00000060: 6e6c 793d 2230 2220 6c61 6265 6c73 456e  nly="0" labelsEn
-00000070: 6162 6c65 643d 2230 2220 7369 6d70 6c69  abled="0" simpli
-00000080: 6679 4c6f 6361 6c3d 2231 2220 6d61 7853  fyLocal="1" maxS
-00000090: 6361 6c65 3d22 3022 206d 696e 5363 616c  cale="0" minScal
-000000a0: 653d 2231 3030 3030 3030 3030 2220 7369  e="100000000" si
-000000b0: 6d70 6c69 6679 4d61 7853 6361 6c65 3d22  mplifyMaxScale="
-000000c0: 3122 2073 696d 706c 6966 7944 7261 7769  1" simplifyDrawi
-000000d0: 6e67 546f 6c3d 2231 2220 7665 7273 696f  ngTol="1" versio
-000000e0: 6e3d 2233 2e32 322e 302d 4269 61c5 826f  n="3.22.0-Bia..o
-000000f0: 7769 65c5 bc61 2220 6861 7353 6361 6c65  wie..a" hasScale
-00000100: 4261 7365 6456 6973 6962 696c 6974 7946  BasedVisibilityF
-00000110: 6c61 673d 2230 2220 7379 6d62 6f6c 6f67  lag="0" symbolog
-00000120: 7952 6566 6572 656e 6365 5363 616c 653d  yReferenceScale=
-00000130: 222d 3122 2073 7479 6c65 4361 7465 676f  "-1" styleCatego
-00000140: 7269 6573 3d22 416c 6c53 7479 6c65 4361  ries="AllStyleCa
-00000150: 7465 676f 7269 6573 2220 7369 6d70 6c69  tegories" simpli
-00000160: 6679 416c 676f 7269 7468 6d3d 2230 223e  fyAlgorithm="0">
-00000170: 0d0a 093c 666c 6167 733e 0d0a 0909 3c49  ...<flags>....<I
-00000180: 6465 6e74 6966 6961 626c 653e 313c 2f49  dentifiable>1</I
-00000190: 6465 6e74 6966 6961 626c 653e 0d0a 0909  dentifiable>....
-000001a0: 3c52 656d 6f76 6162 6c65 3e31 3c2f 5265  <Removable>1</Re
-000001b0: 6d6f 7661 626c 653e 0d0a 0909 3c53 6561  movable>....<Sea
-000001c0: 7263 6861 626c 653e 313c 2f53 6561 7263  rchable>1</Searc
-000001d0: 6861 626c 653e 0d0a 0909 3c50 7269 7661  hable>....<Priva
-000001e0: 7465 3e30 3c2f 5072 6976 6174 653e 0d0a  te>0</Private>..
-000001f0: 093c 2f66 6c61 6773 3e0d 0a09 3c74 656d  .</flags>...<tem
-00000200: 706f 7261 6c20 6c69 6d69 744d 6f64 653d  poral limitMode=
-00000210: 2230 2220 6475 7261 7469 6f6e 4669 656c  "0" durationFiel
-00000220: 643d 2222 2061 6363 756d 756c 6174 653d  d="" accumulate=
-00000230: 2230 2220 656e 6162 6c65 643d 2230 2220  "0" enabled="0" 
-00000240: 7374 6172 7445 7870 7265 7373 696f 6e3d  startExpression=
-00000250: 2222 2065 6e64 4578 7072 6573 7369 6f6e  "" endExpression
-00000260: 3d22 2220 7374 6172 7446 6965 6c64 3d22  ="" startField="
-00000270: 2220 6669 7865 6444 7572 6174 696f 6e3d  " fixedDuration=
-00000280: 2230 2220 6d6f 6465 3d22 3022 2065 6e64  "0" mode="0" end
-00000290: 4669 656c 643d 2222 2064 7572 6174 696f  Field="" duratio
-000002a0: 6e55 6e69 743d 226d 696e 223e 0d0a 0909  nUnit="min">....
-000002b0: 3c66 6978 6564 5261 6e67 653e 0d0a 0909  <fixedRange>....
-000002c0: 093c 7374 6172 743e 3c2f 7374 6172 743e  .<start></start>
-000002d0: 0d0a 0909 093c 656e 643e 3c2f 656e 643e  .....<end></end>
-000002e0: 0d0a 0909 3c2f 6669 7865 6452 616e 6765  ....</fixedRange
-000002f0: 3e0d 0a09 3c2f 7465 6d70 6f72 616c 3e0d  >...</temporal>.
-00000300: 0a09 3c72 656e 6465 7265 722d 7632 2065  ..<renderer-v2 e
-00000310: 6e61 626c 656f 7264 6572 6279 3d22 3022  nableorderby="0"
-00000320: 2072 6566 6572 656e 6365 7363 616c 653d   referencescale=
-00000330: 222d 3122 2073 796d 626f 6c6c 6576 656c  "-1" symbollevel
-00000340: 733d 2230 2220 7479 7065 3d22 7369 6e67  s="0" type="sing
-00000350: 6c65 5379 6d62 6f6c 2220 666f 7263 6572  leSymbol" forcer
-00000360: 6173 7465 723d 2230 223e 0d0a 0909 3c73  aster="0">....<s
-00000370: 796d 626f 6c73 3e0d 0a09 0909 3c73 796d  ymbols>.....<sym
-00000380: 626f 6c20 6e61 6d65 3d22 3022 2063 6c69  bol name="0" cli
-00000390: 705f 746f 5f65 7874 656e 743d 2231 2220  p_to_extent="1" 
-000003a0: 666f 7263 655f 7268 723d 2230 2220 7479  force_rhr="0" ty
-000003b0: 7065 3d22 6669 6c6c 2220 616c 7068 613d  pe="fill" alpha=
-000003c0: 2231 223e 0d0a 0909 0909 3c64 6174 615f  "1">......<data_
-000003d0: 6465 6669 6e65 645f 7072 6f70 6572 7469  defined_properti
-000003e0: 6573 3e0d 0a09 0909 0909 3c4f 7074 696f  es>.......<Optio
-000003f0: 6e20 7479 7065 3d22 4d61 7022 3e0d 0a09  n type="Map">...
-00000400: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
-00000410: 653d 226e 616d 6522 2076 616c 7565 3d22  e="name" value="
-00000420: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
-00000430: 2f3e 0d0a 0909 0909 0909 3c4f 7074 696f  />........<Optio
-00000440: 6e20 6e61 6d65 3d22 7072 6f70 6572 7469  n name="properti
-00000450: 6573 222f 3e0d 0a09 0909 0909 093c 4f70  es"/>........<Op
-00000460: 7469 6f6e 206e 616d 653d 2274 7970 6522  tion name="type"
-00000470: 2076 616c 7565 3d22 636f 6c6c 6563 7469   value="collecti
-00000480: 6f6e 2220 7479 7065 3d22 5153 7472 696e  on" type="QStrin
-00000490: 6722 2f3e 0d0a 0909 0909 093c 2f4f 7074  g"/>.......</Opt
-000004a0: 696f 6e3e 0d0a 0909 0909 3c2f 6461 7461  ion>......</data
-000004b0: 5f64 6566 696e 6564 5f70 726f 7065 7274  _defined_propert
-000004c0: 6965 733e 0d0a 0909 0909 3c6c 6179 6572  ies>......<layer
-000004d0: 2065 6e61 626c 6564 3d22 3122 2063 6c61   enabled="1" cla
-000004e0: 7373 3d22 4c69 6e65 5061 7474 6572 6e46  ss="LinePatternF
-000004f0: 696c 6c22 206c 6f63 6b65 643d 2230 2220  ill" locked="0" 
-00000500: 7061 7373 3d22 3022 3e0d 0a09 0909 0909  pass="0">.......
-00000510: 3c4f 7074 696f 6e20 7479 7065 3d22 4d61  <Option type="Ma
-00000520: 7022 3e0d 0a09 0909 0909 093c 4f70 7469  p">........<Opti
-00000530: 6f6e 206e 616d 653d 2261 6e67 6c65 2220  on name="angle" 
-00000540: 7661 6c75 653d 2234 3522 2074 7970 653d  value="45" type=
-00000550: 2251 5374 7269 6e67 222f 3e0d 0a09 0909  "QString"/>.....
-00000560: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
-00000570: 2263 6f6c 6f72 2220 7661 6c75 653d 2231  "color" value="1
-00000580: 322c 3234 362c 302c 3235 3522 2074 7970  2,246,0,255" typ
-00000590: 653d 2251 5374 7269 6e67 222f 3e0d 0a09  e="QString"/>...
-000005a0: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
-000005b0: 653d 2264 6973 7461 6e63 6522 2076 616c  e="distance" val
-000005c0: 7565 3d22 3222 2074 7970 653d 2251 5374  ue="2" type="QSt
-000005d0: 7269 6e67 222f 3e0d 0a09 0909 0909 093c  ring"/>........<
-000005e0: 4f70 7469 6f6e 206e 616d 653d 2264 6973  Option name="dis
-000005f0: 7461 6e63 655f 6d61 705f 756e 6974 5f73  tance_map_unit_s
-00000600: 6361 6c65 2220 7661 6c75 653d 2233 783a  cale" value="3x:
-00000610: 302c 302c 302c 302c 302c 3022 2074 7970  0,0,0,0,0,0" typ
-00000620: 653d 2251 5374 7269 6e67 222f 3e0d 0a09  e="QString"/>...
-00000630: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
-00000640: 653d 2264 6973 7461 6e63 655f 756e 6974  e="distance_unit
-00000650: 2220 7661 6c75 653d 224d 4d22 2074 7970  " value="MM" typ
-00000660: 653d 2251 5374 7269 6e67 222f 3e0d 0a09  e="QString"/>...
-00000670: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
-00000680: 653d 226c 696e 655f 7769 6474 6822 2076  e="line_width" v
-00000690: 616c 7565 3d22 302e 3236 2220 7479 7065  alue="0.26" type
-000006a0: 3d22 5153 7472 696e 6722 2f3e 0d0a 0909  ="QString"/>....
-000006b0: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
-000006c0: 3d22 6c69 6e65 5f77 6964 7468 5f6d 6170  ="line_width_map
-000006d0: 5f75 6e69 745f 7363 616c 6522 2076 616c  _unit_scale" val
-000006e0: 7565 3d22 3378 3a30 2c30 2c30 2c30 2c30  ue="3x:0,0,0,0,0
-000006f0: 2c30 2220 7479 7065 3d22 5153 7472 696e  ,0" type="QStrin
-00000700: 6722 2f3e 0d0a 0909 0909 0909 3c4f 7074  g"/>........<Opt
-00000710: 696f 6e20 6e61 6d65 3d22 6c69 6e65 5f77  ion name="line_w
-00000720: 6964 7468 5f75 6e69 7422 2076 616c 7565  idth_unit" value
-00000730: 3d22 4d4d 2220 7479 7065 3d22 5153 7472  ="MM" type="QStr
-00000740: 696e 6722 2f3e 0d0a 0909 0909 0909 3c4f  ing"/>........<O
-00000750: 7074 696f 6e20 6e61 6d65 3d22 6f66 6673  ption name="offs
-00000760: 6574 2220 7661 6c75 653d 2230 2220 7479  et" value="0" ty
-00000770: 7065 3d22 5153 7472 696e 6722 2f3e 0d0a  pe="QString"/>..
-00000780: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
-00000790: 6d65 3d22 6f66 6673 6574 5f6d 6170 5f75  me="offset_map_u
-000007a0: 6e69 745f 7363 616c 6522 2076 616c 7565  nit_scale" value
-000007b0: 3d22 3378 3a30 2c30 2c30 2c30 2c30 2c30  ="3x:0,0,0,0,0,0
-000007c0: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
-000007d0: 2f3e 0d0a 0909 0909 0909 3c4f 7074 696f  />........<Optio
-000007e0: 6e20 6e61 6d65 3d22 6f66 6673 6574 5f75  n name="offset_u
-000007f0: 6e69 7422 2076 616c 7565 3d22 4d4d 2220  nit" value="MM" 
-00000800: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-00000810: 0d0a 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
-00000820: 6e61 6d65 3d22 6f75 746c 696e 655f 7769  name="outline_wi
-00000830: 6474 685f 6d61 705f 756e 6974 5f73 6361  dth_map_unit_sca
-00000840: 6c65 2220 7661 6c75 653d 2233 783a 302c  le" value="3x:0,
-00000850: 302c 302c 302c 302c 3022 2074 7970 653d  0,0,0,0,0" type=
-00000860: 2251 5374 7269 6e67 222f 3e0d 0a09 0909  "QString"/>.....
-00000870: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
-00000880: 226f 7574 6c69 6e65 5f77 6964 7468 5f75  "outline_width_u
-00000890: 6e69 7422 2076 616c 7565 3d22 4d4d 2220  nit" value="MM" 
-000008a0: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-000008b0: 0d0a 0909 0909 093c 2f4f 7074 696f 6e3e  .......</Option>
-000008c0: 0d0a 0909 0909 093c 7072 6f70 206b 3d22  .......<prop k="
-000008d0: 616e 676c 6522 2076 3d22 3435 222f 3e0d  angle" v="45"/>.
-000008e0: 0a09 0909 0909 3c70 726f 7020 6b3d 2263  ......<prop k="c
-000008f0: 6f6c 6f72 2220 763d 2231 322c 3234 362c  olor" v="12,246,
-00000900: 302c 3235 3522 2f3e 0d0a 0909 0909 093c  0,255"/>.......<
-00000910: 7072 6f70 206b 3d22 6469 7374 616e 6365  prop k="distance
-00000920: 2220 763d 2232 222f 3e0d 0a09 0909 0909  " v="2"/>.......
-00000930: 3c70 726f 7020 6b3d 2264 6973 7461 6e63  <prop k="distanc
-00000940: 655f 6d61 705f 756e 6974 5f73 6361 6c65  e_map_unit_scale
-00000950: 2220 763d 2233 783a 302c 302c 302c 302c  " v="3x:0,0,0,0,
-00000960: 302c 3022 2f3e 0d0a 0909 0909 093c 7072  0,0"/>.......<pr
-00000970: 6f70 206b 3d22 6469 7374 616e 6365 5f75  op k="distance_u
-00000980: 6e69 7422 2076 3d22 4d4d 222f 3e0d 0a09  nit" v="MM"/>...
-00000990: 0909 0909 3c70 726f 7020 6b3d 226c 696e  ....<prop k="lin
-000009a0: 655f 7769 6474 6822 2076 3d22 302e 3236  e_width" v="0.26
-000009b0: 222f 3e0d 0a09 0909 0909 3c70 726f 7020  "/>.......<prop 
-000009c0: 6b3d 226c 696e 655f 7769 6474 685f 6d61  k="line_width_ma
-000009d0: 705f 756e 6974 5f73 6361 6c65 2220 763d  p_unit_scale" v=
-000009e0: 2233 783a 302c 302c 302c 302c 302c 3022  "3x:0,0,0,0,0,0"
-000009f0: 2f3e 0d0a 0909 0909 093c 7072 6f70 206b  />.......<prop k
-00000a00: 3d22 6c69 6e65 5f77 6964 7468 5f75 6e69  ="line_width_uni
-00000a10: 7422 2076 3d22 4d4d 222f 3e0d 0a09 0909  t" v="MM"/>.....
-00000a20: 0909 3c70 726f 7020 6b3d 226f 6666 7365  ..<prop k="offse
-00000a30: 7422 2076 3d22 3022 2f3e 0d0a 0909 0909  t" v="0"/>......
-00000a40: 093c 7072 6f70 206b 3d22 6f66 6673 6574  .<prop k="offset
-00000a50: 5f6d 6170 5f75 6e69 745f 7363 616c 6522  _map_unit_scale"
-00000a60: 2076 3d22 3378 3a30 2c30 2c30 2c30 2c30   v="3x:0,0,0,0,0
-00000a70: 2c30 222f 3e0d 0a09 0909 0909 3c70 726f  ,0"/>.......<pro
-00000a80: 7020 6b3d 226f 6666 7365 745f 756e 6974  p k="offset_unit
-00000a90: 2220 763d 224d 4d22 2f3e 0d0a 0909 0909  " v="MM"/>......
-00000aa0: 093c 7072 6f70 206b 3d22 6f75 746c 696e  .<prop k="outlin
-00000ab0: 655f 7769 6474 685f 6d61 705f 756e 6974  e_width_map_unit
-00000ac0: 5f73 6361 6c65 2220 763d 2233 783a 302c  _scale" v="3x:0,
-00000ad0: 302c 302c 302c 302c 3022 2f3e 0d0a 0909  0,0,0,0,0"/>....
-00000ae0: 0909 093c 7072 6f70 206b 3d22 6f75 746c  ...<prop k="outl
-00000af0: 696e 655f 7769 6474 685f 756e 6974 2220  ine_width_unit" 
-00000b00: 763d 224d 4d22 2f3e 0d0a 0909 0909 093c  v="MM"/>.......<
-00000b10: 6461 7461 5f64 6566 696e 6564 5f70 726f  data_defined_pro
-00000b20: 7065 7274 6965 733e 0d0a 0909 0909 0909  perties>........
-00000b30: 3c4f 7074 696f 6e20 7479 7065 3d22 4d61  <Option type="Ma
-00000b40: 7022 3e0d 0a09 0909 0909 0909 3c4f 7074  p">.........<Opt
-00000b50: 696f 6e20 6e61 6d65 3d22 6e61 6d65 2220  ion name="name" 
-00000b60: 7661 6c75 653d 2222 2074 7970 653d 2251  value="" type="Q
-00000b70: 5374 7269 6e67 222f 3e0d 0a09 0909 0909  String"/>.......
-00000b80: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
-00000b90: 7072 6f70 6572 7469 6573 222f 3e0d 0a09  properties"/>...
-00000ba0: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
-00000bb0: 6d65 3d22 7479 7065 2220 7661 6c75 653d  me="type" value=
-00000bc0: 2263 6f6c 6c65 6374 696f 6e22 2074 7970  "collection" typ
-00000bd0: 653d 2251 5374 7269 6e67 222f 3e0d 0a09  e="QString"/>...
-00000be0: 0909 0909 093c 2f4f 7074 696f 6e3e 0d0a  .....</Option>..
-00000bf0: 0909 0909 093c 2f64 6174 615f 6465 6669  .....</data_defi
-00000c00: 6e65 645f 7072 6f70 6572 7469 6573 3e0d  ned_properties>.
-00000c10: 0a09 0909 0909 3c73 796d 626f 6c20 6e61  ......<symbol na
-00000c20: 6d65 3d22 4030 4030 2220 636c 6970 5f74  me="@0@0" clip_t
-00000c30: 6f5f 6578 7465 6e74 3d22 3122 2066 6f72  o_extent="1" for
-00000c40: 6365 5f72 6872 3d22 3022 2074 7970 653d  ce_rhr="0" type=
-00000c50: 226c 696e 6522 2061 6c70 6861 3d22 3122  "line" alpha="1"
-00000c60: 3e0d 0a09 0909 0909 093c 6461 7461 5f64  >........<data_d
-00000c70: 6566 696e 6564 5f70 726f 7065 7274 6965  efined_propertie
-00000c80: 733e 0d0a 0909 0909 0909 093c 4f70 7469  s>.........<Opti
-00000c90: 6f6e 2074 7970 653d 224d 6170 223e 0d0a  on type="Map">..
-00000ca0: 0909 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
-00000cb0: 6e61 6d65 3d22 6e61 6d65 2220 7661 6c75  name="name" valu
-00000cc0: 653d 2222 2074 7970 653d 2251 5374 7269  e="" type="QStri
-00000cd0: 6e67 222f 3e0d 0a09 0909 0909 0909 093c  ng"/>..........<
-00000ce0: 4f70 7469 6f6e 206e 616d 653d 2270 726f  Option name="pro
-00000cf0: 7065 7274 6965 7322 2f3e 0d0a 0909 0909  perties"/>......
-00000d00: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
-00000d10: 3d22 7479 7065 2220 7661 6c75 653d 2263  ="type" value="c
-00000d20: 6f6c 6c65 6374 696f 6e22 2074 7970 653d  ollection" type=
-00000d30: 2251 5374 7269 6e67 222f 3e0d 0a09 0909  "QString"/>.....
-00000d40: 0909 0909 3c2f 4f70 7469 6f6e 3e0d 0a09  ....</Option>...
-00000d50: 0909 0909 093c 2f64 6174 615f 6465 6669  .....</data_defi
-00000d60: 6e65 645f 7072 6f70 6572 7469 6573 3e0d  ned_properties>.
-00000d70: 0a09 0909 0909 093c 6c61 7965 7220 656e  .......<layer en
-00000d80: 6162 6c65 643d 2231 2220 636c 6173 733d  abled="1" class=
-00000d90: 2253 696d 706c 654c 696e 6522 206c 6f63  "SimpleLine" loc
-00000da0: 6b65 643d 2230 2220 7061 7373 3d22 3022  ked="0" pass="0"
-00000db0: 3e0d 0a09 0909 0909 0909 3c4f 7074 696f  >.........<Optio
-00000dc0: 6e20 7479 7065 3d22 4d61 7022 3e0d 0a09  n type="Map">...
-00000dd0: 0909 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-00000de0: 616d 653d 2261 6c69 676e 5f64 6173 685f  ame="align_dash_
-00000df0: 7061 7474 6572 6e22 2076 616c 7565 3d22  pattern" value="
-00000e00: 3022 2074 7970 653d 2251 5374 7269 6e67  0" type="QString
-00000e10: 222f 3e0d 0a09 0909 0909 0909 093c 4f70  "/>..........<Op
-00000e20: 7469 6f6e 206e 616d 653d 2263 6170 7374  tion name="capst
-00000e30: 796c 6522 2076 616c 7565 3d22 7371 7561  yle" value="squa
-00000e40: 7265 2220 7479 7065 3d22 5153 7472 696e  re" type="QStrin
-00000e50: 6722 2f3e 0d0a 0909 0909 0909 0909 3c4f  g"/>..........<O
-00000e60: 7074 696f 6e20 6e61 6d65 3d22 6375 7374  ption name="cust
-00000e70: 6f6d 6461 7368 2220 7661 6c75 653d 2235  omdash" value="5
-00000e80: 3b32 2220 7479 7065 3d22 5153 7472 696e  ;2" type="QStrin
-00000e90: 6722 2f3e 0d0a 0909 0909 0909 0909 3c4f  g"/>..........<O
-00000ea0: 7074 696f 6e20 6e61 6d65 3d22 6375 7374  ption name="cust
-00000eb0: 6f6d 6461 7368 5f6d 6170 5f75 6e69 745f  omdash_map_unit_
-00000ec0: 7363 616c 6522 2076 616c 7565 3d22 3378  scale" value="3x
-00000ed0: 3a30 2c30 2c30 2c30 2c30 2c30 2220 7479  :0,0,0,0,0,0" ty
-00000ee0: 7065 3d22 5153 7472 696e 6722 2f3e 0d0a  pe="QString"/>..
-00000ef0: 0909 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
-00000f00: 6e61 6d65 3d22 6375 7374 6f6d 6461 7368  name="customdash
-00000f10: 5f75 6e69 7422 2076 616c 7565 3d22 4d4d  _unit" value="MM
-00000f20: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
-00000f30: 2f3e 0d0a 0909 0909 0909 0909 3c4f 7074  />..........<Opt
-00000f40: 696f 6e20 6e61 6d65 3d22 6461 7368 5f70  ion name="dash_p
-00000f50: 6174 7465 726e 5f6f 6666 7365 7422 2076  attern_offset" v
-00000f60: 616c 7565 3d22 3022 2074 7970 653d 2251  alue="0" type="Q
-00000f70: 5374 7269 6e67 222f 3e0d 0a09 0909 0909  String"/>.......
-00000f80: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
-00000f90: 2264 6173 685f 7061 7474 6572 6e5f 6f66  "dash_pattern_of
-00000fa0: 6673 6574 5f6d 6170 5f75 6e69 745f 7363  fset_map_unit_sc
-00000fb0: 616c 6522 2076 616c 7565 3d22 3378 3a30  ale" value="3x:0
-00000fc0: 2c30 2c30 2c30 2c30 2c30 2220 7479 7065  ,0,0,0,0,0" type
-00000fd0: 3d22 5153 7472 696e 6722 2f3e 0d0a 0909  ="QString"/>....
-00000fe0: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
-00000ff0: 6d65 3d22 6461 7368 5f70 6174 7465 726e  me="dash_pattern
-00001000: 5f6f 6666 7365 745f 756e 6974 2220 7661  _offset_unit" va
-00001010: 6c75 653d 224d 4d22 2074 7970 653d 2251  lue="MM" type="Q
-00001020: 5374 7269 6e67 222f 3e0d 0a09 0909 0909  String"/>.......
-00001030: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
-00001040: 2264 7261 775f 696e 7369 6465 5f70 6f6c  "draw_inside_pol
-00001050: 7967 6f6e 2220 7661 6c75 653d 2230 2220  ygon" value="0" 
-00001060: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-00001070: 0d0a 0909 0909 0909 0909 3c4f 7074 696f  ..........<Optio
-00001080: 6e20 6e61 6d65 3d22 6a6f 696e 7374 796c  n name="joinstyl
-00001090: 6522 2076 616c 7565 3d22 6265 7665 6c22  e" value="bevel"
-000010a0: 2074 7970 653d 2251 5374 7269 6e67 222f   type="QString"/
-000010b0: 3e0d 0a09 0909 0909 0909 093c 4f70 7469  >..........<Opti
-000010c0: 6f6e 206e 616d 653d 226c 696e 655f 636f  on name="line_co
-000010d0: 6c6f 7222 2076 616c 7565 3d22 3132 2c32  lor" value="12,2
-000010e0: 3436 2c30 2c32 3535 2220 7479 7065 3d22  46,0,255" type="
-000010f0: 5153 7472 696e 6722 2f3e 0d0a 0909 0909  QString"/>......
-00001100: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
-00001110: 3d22 6c69 6e65 5f73 7479 6c65 2220 7661  ="line_style" va
-00001120: 6c75 653d 2273 6f6c 6964 2220 7479 7065  lue="solid" type
-00001130: 3d22 5153 7472 696e 6722 2f3e 0d0a 0909  ="QString"/>....
-00001140: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
-00001150: 6d65 3d22 6c69 6e65 5f77 6964 7468 2220  me="line_width" 
-00001160: 7661 6c75 653d 2230 2e33 2220 7479 7065  value="0.3" type
-00001170: 3d22 5153 7472 696e 6722 2f3e 0d0a 0909  ="QString"/>....
-00001180: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
-00001190: 6d65 3d22 6c69 6e65 5f77 6964 7468 5f75  me="line_width_u
-000011a0: 6e69 7422 2076 616c 7565 3d22 4d4d 2220  nit" value="MM" 
-000011b0: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-000011c0: 0d0a 0909 0909 0909 0909 3c4f 7074 696f  ..........<Optio
-000011d0: 6e20 6e61 6d65 3d22 6f66 6673 6574 2220  n name="offset" 
-000011e0: 7661 6c75 653d 2230 2220 7479 7065 3d22  value="0" type="
-000011f0: 5153 7472 696e 6722 2f3e 0d0a 0909 0909  QString"/>......
+00000030: 2022 5359 5354 454d 223e 0a3c 7167 6973   "SYSTEM">.<qgis
+00000040: 2073 696d 706c 6966 7944 7261 7769 6e67   simplifyDrawing
+00000050: 4869 6e74 733d 2231 2220 7265 6164 4f6e  Hints="1" readOn
+00000060: 6c79 3d22 3022 206c 6162 656c 7345 6e61  ly="0" labelsEna
+00000070: 626c 6564 3d22 3022 2073 696d 706c 6966  bled="0" simplif
+00000080: 794c 6f63 616c 3d22 3122 206d 6178 5363  yLocal="1" maxSc
+00000090: 616c 653d 2230 2220 6d69 6e53 6361 6c65  ale="0" minScale
+000000a0: 3d22 3130 3030 3030 3030 3022 2073 696d  ="100000000" sim
+000000b0: 706c 6966 794d 6178 5363 616c 653d 2231  plifyMaxScale="1
+000000c0: 2220 7369 6d70 6c69 6679 4472 6177 696e  " simplifyDrawin
+000000d0: 6754 6f6c 3d22 3122 2076 6572 7369 6f6e  gTol="1" version
+000000e0: 3d22 332e 3232 2e30 2d42 6961 c582 6f77  ="3.22.0-Bia..ow
+000000f0: 6965 c5bc 6122 2068 6173 5363 616c 6542  ie..a" hasScaleB
+00000100: 6173 6564 5669 7369 6269 6c69 7479 466c  asedVisibilityFl
+00000110: 6167 3d22 3022 2073 796d 626f 6c6f 6779  ag="0" symbology
+00000120: 5265 6665 7265 6e63 6553 6361 6c65 3d22  ReferenceScale="
+00000130: 2d31 2220 7374 796c 6543 6174 6567 6f72  -1" styleCategor
+00000140: 6965 733d 2241 6c6c 5374 796c 6543 6174  ies="AllStyleCat
+00000150: 6567 6f72 6965 7322 2073 696d 706c 6966  egories" simplif
+00000160: 7941 6c67 6f72 6974 686d 3d22 3022 3e0a  yAlgorithm="0">.
+00000170: 093c 666c 6167 733e 0a09 093c 4964 656e  .<flags>...<Iden
+00000180: 7469 6669 6162 6c65 3e31 3c2f 4964 656e  tifiable>1</Iden
+00000190: 7469 6669 6162 6c65 3e0a 0909 3c52 656d  tifiable>...<Rem
+000001a0: 6f76 6162 6c65 3e31 3c2f 5265 6d6f 7661  ovable>1</Remova
+000001b0: 626c 653e 0a09 093c 5365 6172 6368 6162  ble>...<Searchab
+000001c0: 6c65 3e31 3c2f 5365 6172 6368 6162 6c65  le>1</Searchable
+000001d0: 3e0a 0909 3c50 7269 7661 7465 3e30 3c2f  >...<Private>0</
+000001e0: 5072 6976 6174 653e 0a09 3c2f 666c 6167  Private>..</flag
+000001f0: 733e 0a09 3c74 656d 706f 7261 6c20 6c69  s>..<temporal li
+00000200: 6d69 744d 6f64 653d 2230 2220 6475 7261  mitMode="0" dura
+00000210: 7469 6f6e 4669 656c 643d 2222 2061 6363  tionField="" acc
+00000220: 756d 756c 6174 653d 2230 2220 656e 6162  umulate="0" enab
+00000230: 6c65 643d 2230 2220 7374 6172 7445 7870  led="0" startExp
+00000240: 7265 7373 696f 6e3d 2222 2065 6e64 4578  ression="" endEx
+00000250: 7072 6573 7369 6f6e 3d22 2220 7374 6172  pression="" star
+00000260: 7446 6965 6c64 3d22 2220 6669 7865 6444  tField="" fixedD
+00000270: 7572 6174 696f 6e3d 2230 2220 6d6f 6465  uration="0" mode
+00000280: 3d22 3022 2065 6e64 4669 656c 643d 2222  ="0" endField=""
+00000290: 2064 7572 6174 696f 6e55 6e69 743d 226d   durationUnit="m
+000002a0: 696e 223e 0a09 093c 6669 7865 6452 616e  in">...<fixedRan
+000002b0: 6765 3e0a 0909 093c 7374 6172 743e 3c2f  ge>....<start></
+000002c0: 7374 6172 743e 0a09 0909 3c65 6e64 3e3c  start>....<end><
+000002d0: 2f65 6e64 3e0a 0909 3c2f 6669 7865 6452  /end>...</fixedR
+000002e0: 616e 6765 3e0a 093c 2f74 656d 706f 7261  ange>..</tempora
+000002f0: 6c3e 0a09 3c72 656e 6465 7265 722d 7632  l>..<renderer-v2
+00000300: 2065 6e61 626c 656f 7264 6572 6279 3d22   enableorderby="
+00000310: 3022 2072 6566 6572 656e 6365 7363 616c  0" referencescal
+00000320: 653d 222d 3122 2073 796d 626f 6c6c 6576  e="-1" symbollev
+00000330: 656c 733d 2230 2220 7479 7065 3d22 7369  els="0" type="si
+00000340: 6e67 6c65 5379 6d62 6f6c 2220 666f 7263  ngleSymbol" forc
+00000350: 6572 6173 7465 723d 2230 223e 0a09 093c  eraster="0">...<
+00000360: 7379 6d62 6f6c 733e 0a09 0909 3c73 796d  symbols>....<sym
+00000370: 626f 6c20 6e61 6d65 3d22 3022 2063 6c69  bol name="0" cli
+00000380: 705f 746f 5f65 7874 656e 743d 2231 2220  p_to_extent="1" 
+00000390: 666f 7263 655f 7268 723d 2230 2220 7479  force_rhr="0" ty
+000003a0: 7065 3d22 6669 6c6c 2220 616c 7068 613d  pe="fill" alpha=
+000003b0: 2231 223e 0a09 0909 093c 6461 7461 5f64  "1">.....<data_d
+000003c0: 6566 696e 6564 5f70 726f 7065 7274 6965  efined_propertie
+000003d0: 733e 0a09 0909 0909 3c4f 7074 696f 6e20  s>......<Option 
+000003e0: 7479 7065 3d22 4d61 7022 3e0a 0909 0909  type="Map">.....
+000003f0: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
+00000400: 6e61 6d65 2220 7661 6c75 653d 2222 2074  name" value="" t
+00000410: 7970 653d 2251 5374 7269 6e67 222f 3e0a  ype="QString"/>.
+00000420: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
+00000430: 6d65 3d22 7072 6f70 6572 7469 6573 222f  me="properties"/
+00000440: 3e0a 0909 0909 0909 3c4f 7074 696f 6e20  >.......<Option 
+00000450: 6e61 6d65 3d22 7479 7065 2220 7661 6c75  name="type" valu
+00000460: 653d 2263 6f6c 6c65 6374 696f 6e22 2074  e="collection" t
+00000470: 7970 653d 2251 5374 7269 6e67 222f 3e0a  ype="QString"/>.
+00000480: 0909 0909 093c 2f4f 7074 696f 6e3e 0a09  .....</Option>..
+00000490: 0909 093c 2f64 6174 615f 6465 6669 6e65  ...</data_define
+000004a0: 645f 7072 6f70 6572 7469 6573 3e0a 0909  d_properties>...
+000004b0: 0909 3c6c 6179 6572 2065 6e61 626c 6564  ..<layer enabled
+000004c0: 3d22 3122 2063 6c61 7373 3d22 4c69 6e65  ="1" class="Line
+000004d0: 5061 7474 6572 6e46 696c 6c22 206c 6f63  PatternFill" loc
+000004e0: 6b65 643d 2230 2220 7061 7373 3d22 3022  ked="0" pass="0"
+000004f0: 3e0a 0909 0909 093c 4f70 7469 6f6e 2074  >......<Option t
+00000500: 7970 653d 224d 6170 223e 0a09 0909 0909  ype="Map">......
+00000510: 093c 4f70 7469 6f6e 206e 616d 653d 2261  .<Option name="a
+00000520: 6e67 6c65 2220 7661 6c75 653d 2234 3522  ngle" value="45"
+00000530: 2074 7970 653d 2251 5374 7269 6e67 222f   type="QString"/
+00000540: 3e0a 0909 0909 0909 3c4f 7074 696f 6e20  >.......<Option 
+00000550: 6e61 6d65 3d22 636f 6c6f 7222 2076 616c  name="color" val
+00000560: 7565 3d22 3132 2c32 3436 2c30 2c32 3535  ue="12,246,0,255
+00000570: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
+00000580: 2f3e 0a09 0909 0909 093c 4f70 7469 6f6e  />.......<Option
+00000590: 206e 616d 653d 2264 6973 7461 6e63 6522   name="distance"
+000005a0: 2076 616c 7565 3d22 3222 2074 7970 653d   value="2" type=
+000005b0: 2251 5374 7269 6e67 222f 3e0a 0909 0909  "QString"/>.....
+000005c0: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
+000005d0: 6469 7374 616e 6365 5f6d 6170 5f75 6e69  distance_map_uni
+000005e0: 745f 7363 616c 6522 2076 616c 7565 3d22  t_scale" value="
+000005f0: 3378 3a30 2c30 2c30 2c30 2c30 2c30 2220  3x:0,0,0,0,0,0" 
+00000600: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
+00000610: 0a09 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
+00000620: 616d 653d 2264 6973 7461 6e63 655f 756e  ame="distance_un
+00000630: 6974 2220 7661 6c75 653d 224d 4d22 2074  it" value="MM" t
+00000640: 7970 653d 2251 5374 7269 6e67 222f 3e0a  ype="QString"/>.
+00000650: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
+00000660: 6d65 3d22 6c69 6e65 5f77 6964 7468 2220  me="line_width" 
+00000670: 7661 6c75 653d 2230 2e32 3622 2074 7970  value="0.26" typ
+00000680: 653d 2251 5374 7269 6e67 222f 3e0a 0909  e="QString"/>...
+00000690: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
+000006a0: 3d22 6c69 6e65 5f77 6964 7468 5f6d 6170  ="line_width_map
+000006b0: 5f75 6e69 745f 7363 616c 6522 2076 616c  _unit_scale" val
+000006c0: 7565 3d22 3378 3a30 2c30 2c30 2c30 2c30  ue="3x:0,0,0,0,0
+000006d0: 2c30 2220 7479 7065 3d22 5153 7472 696e  ,0" type="QStrin
+000006e0: 6722 2f3e 0a09 0909 0909 093c 4f70 7469  g"/>.......<Opti
+000006f0: 6f6e 206e 616d 653d 226c 696e 655f 7769  on name="line_wi
+00000700: 6474 685f 756e 6974 2220 7661 6c75 653d  dth_unit" value=
+00000710: 224d 4d22 2074 7970 653d 2251 5374 7269  "MM" type="QStri
+00000720: 6e67 222f 3e0a 0909 0909 0909 3c4f 7074  ng"/>.......<Opt
+00000730: 696f 6e20 6e61 6d65 3d22 6f66 6673 6574  ion name="offset
+00000740: 2220 7661 6c75 653d 2230 2220 7479 7065  " value="0" type
+00000750: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+00000760: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
+00000770: 226f 6666 7365 745f 6d61 705f 756e 6974  "offset_map_unit
+00000780: 5f73 6361 6c65 2220 7661 6c75 653d 2233  _scale" value="3
+00000790: 783a 302c 302c 302c 302c 302c 3022 2074  x:0,0,0,0,0,0" t
+000007a0: 7970 653d 2251 5374 7269 6e67 222f 3e0a  ype="QString"/>.
+000007b0: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
+000007c0: 6d65 3d22 6f66 6673 6574 5f75 6e69 7422  me="offset_unit"
+000007d0: 2076 616c 7565 3d22 4d4d 2220 7479 7065   value="MM" type
+000007e0: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+000007f0: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
+00000800: 226f 7574 6c69 6e65 5f77 6964 7468 5f6d  "outline_width_m
+00000810: 6170 5f75 6e69 745f 7363 616c 6522 2076  ap_unit_scale" v
+00000820: 616c 7565 3d22 3378 3a30 2c30 2c30 2c30  alue="3x:0,0,0,0
+00000830: 2c30 2c30 2220 7479 7065 3d22 5153 7472  ,0,0" type="QStr
+00000840: 696e 6722 2f3e 0a09 0909 0909 093c 4f70  ing"/>.......<Op
+00000850: 7469 6f6e 206e 616d 653d 226f 7574 6c69  tion name="outli
+00000860: 6e65 5f77 6964 7468 5f75 6e69 7422 2076  ne_width_unit" v
+00000870: 616c 7565 3d22 4d4d 2220 7479 7065 3d22  alue="MM" type="
+00000880: 5153 7472 696e 6722 2f3e 0a09 0909 0909  QString"/>......
+00000890: 3c2f 4f70 7469 6f6e 3e0a 0909 0909 093c  </Option>......<
+000008a0: 7072 6f70 206b 3d22 616e 676c 6522 2076  prop k="angle" v
+000008b0: 3d22 3435 222f 3e0a 0909 0909 093c 7072  ="45"/>......<pr
+000008c0: 6f70 206b 3d22 636f 6c6f 7222 2076 3d22  op k="color" v="
+000008d0: 3132 2c32 3436 2c30 2c32 3535 222f 3e0a  12,246,0,255"/>.
+000008e0: 0909 0909 093c 7072 6f70 206b 3d22 6469  .....<prop k="di
+000008f0: 7374 616e 6365 2220 763d 2232 222f 3e0a  stance" v="2"/>.
+00000900: 0909 0909 093c 7072 6f70 206b 3d22 6469  .....<prop k="di
+00000910: 7374 616e 6365 5f6d 6170 5f75 6e69 745f  stance_map_unit_
+00000920: 7363 616c 6522 2076 3d22 3378 3a30 2c30  scale" v="3x:0,0
+00000930: 2c30 2c30 2c30 2c30 222f 3e0a 0909 0909  ,0,0,0,0"/>.....
+00000940: 093c 7072 6f70 206b 3d22 6469 7374 616e  .<prop k="distan
+00000950: 6365 5f75 6e69 7422 2076 3d22 4d4d 222f  ce_unit" v="MM"/
+00000960: 3e0a 0909 0909 093c 7072 6f70 206b 3d22  >......<prop k="
+00000970: 6c69 6e65 5f77 6964 7468 2220 763d 2230  line_width" v="0
+00000980: 2e32 3622 2f3e 0a09 0909 0909 3c70 726f  .26"/>......<pro
+00000990: 7020 6b3d 226c 696e 655f 7769 6474 685f  p k="line_width_
+000009a0: 6d61 705f 756e 6974 5f73 6361 6c65 2220  map_unit_scale" 
+000009b0: 763d 2233 783a 302c 302c 302c 302c 302c  v="3x:0,0,0,0,0,
+000009c0: 3022 2f3e 0a09 0909 0909 3c70 726f 7020  0"/>......<prop 
+000009d0: 6b3d 226c 696e 655f 7769 6474 685f 756e  k="line_width_un
+000009e0: 6974 2220 763d 224d 4d22 2f3e 0a09 0909  it" v="MM"/>....
+000009f0: 0909 3c70 726f 7020 6b3d 226f 6666 7365  ..<prop k="offse
+00000a00: 7422 2076 3d22 3022 2f3e 0a09 0909 0909  t" v="0"/>......
+00000a10: 3c70 726f 7020 6b3d 226f 6666 7365 745f  <prop k="offset_
+00000a20: 6d61 705f 756e 6974 5f73 6361 6c65 2220  map_unit_scale" 
+00000a30: 763d 2233 783a 302c 302c 302c 302c 302c  v="3x:0,0,0,0,0,
+00000a40: 3022 2f3e 0a09 0909 0909 3c70 726f 7020  0"/>......<prop 
+00000a50: 6b3d 226f 6666 7365 745f 756e 6974 2220  k="offset_unit" 
+00000a60: 763d 224d 4d22 2f3e 0a09 0909 0909 3c70  v="MM"/>......<p
+00000a70: 726f 7020 6b3d 226f 7574 6c69 6e65 5f77  rop k="outline_w
+00000a80: 6964 7468 5f6d 6170 5f75 6e69 745f 7363  idth_map_unit_sc
+00000a90: 616c 6522 2076 3d22 3378 3a30 2c30 2c30  ale" v="3x:0,0,0
+00000aa0: 2c30 2c30 2c30 222f 3e0a 0909 0909 093c  ,0,0,0"/>......<
+00000ab0: 7072 6f70 206b 3d22 6f75 746c 696e 655f  prop k="outline_
+00000ac0: 7769 6474 685f 756e 6974 2220 763d 224d  width_unit" v="M
+00000ad0: 4d22 2f3e 0a09 0909 0909 3c64 6174 615f  M"/>......<data_
+00000ae0: 6465 6669 6e65 645f 7072 6f70 6572 7469  defined_properti
+00000af0: 6573 3e0a 0909 0909 0909 3c4f 7074 696f  es>.......<Optio
+00000b00: 6e20 7479 7065 3d22 4d61 7022 3e0a 0909  n type="Map">...
+00000b10: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
+00000b20: 653d 226e 616d 6522 2076 616c 7565 3d22  e="name" value="
+00000b30: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
+00000b40: 2f3e 0a09 0909 0909 0909 3c4f 7074 696f  />........<Optio
+00000b50: 6e20 6e61 6d65 3d22 7072 6f70 6572 7469  n name="properti
+00000b60: 6573 222f 3e0a 0909 0909 0909 093c 4f70  es"/>........<Op
+00000b70: 7469 6f6e 206e 616d 653d 2274 7970 6522  tion name="type"
+00000b80: 2076 616c 7565 3d22 636f 6c6c 6563 7469   value="collecti
+00000b90: 6f6e 2220 7479 7065 3d22 5153 7472 696e  on" type="QStrin
+00000ba0: 6722 2f3e 0a09 0909 0909 093c 2f4f 7074  g"/>.......</Opt
+00000bb0: 696f 6e3e 0a09 0909 0909 3c2f 6461 7461  ion>......</data
+00000bc0: 5f64 6566 696e 6564 5f70 726f 7065 7274  _defined_propert
+00000bd0: 6965 733e 0a09 0909 0909 3c73 796d 626f  ies>......<symbo
+00000be0: 6c20 6e61 6d65 3d22 4030 4030 2220 636c  l name="@0@0" cl
+00000bf0: 6970 5f74 6f5f 6578 7465 6e74 3d22 3122  ip_to_extent="1"
+00000c00: 2066 6f72 6365 5f72 6872 3d22 3022 2074   force_rhr="0" t
+00000c10: 7970 653d 226c 696e 6522 2061 6c70 6861  ype="line" alpha
+00000c20: 3d22 3122 3e0a 0909 0909 0909 3c64 6174  ="1">.......<dat
+00000c30: 615f 6465 6669 6e65 645f 7072 6f70 6572  a_defined_proper
+00000c40: 7469 6573 3e0a 0909 0909 0909 093c 4f70  ties>........<Op
+00000c50: 7469 6f6e 2074 7970 653d 224d 6170 223e  tion type="Map">
+00000c60: 0a09 0909 0909 0909 093c 4f70 7469 6f6e  .........<Option
+00000c70: 206e 616d 653d 226e 616d 6522 2076 616c   name="name" val
+00000c80: 7565 3d22 2220 7479 7065 3d22 5153 7472  ue="" type="QStr
+00000c90: 696e 6722 2f3e 0a09 0909 0909 0909 093c  ing"/>.........<
+00000ca0: 4f70 7469 6f6e 206e 616d 653d 2270 726f  Option name="pro
+00000cb0: 7065 7274 6965 7322 2f3e 0a09 0909 0909  perties"/>......
+00000cc0: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
+00000cd0: 2274 7970 6522 2076 616c 7565 3d22 636f  "type" value="co
+00000ce0: 6c6c 6563 7469 6f6e 2220 7479 7065 3d22  llection" type="
+00000cf0: 5153 7472 696e 6722 2f3e 0a09 0909 0909  QString"/>......
+00000d00: 0909 3c2f 4f70 7469 6f6e 3e0a 0909 0909  ..</Option>.....
+00000d10: 0909 3c2f 6461 7461 5f64 6566 696e 6564  ..</data_defined
+00000d20: 5f70 726f 7065 7274 6965 733e 0a09 0909  _properties>....
+00000d30: 0909 093c 6c61 7965 7220 656e 6162 6c65  ...<layer enable
+00000d40: 643d 2231 2220 636c 6173 733d 2253 696d  d="1" class="Sim
+00000d50: 706c 654c 696e 6522 206c 6f63 6b65 643d  pleLine" locked=
+00000d60: 2230 2220 7061 7373 3d22 3022 3e0a 0909  "0" pass="0">...
+00000d70: 0909 0909 093c 4f70 7469 6f6e 2074 7970  .....<Option typ
+00000d80: 653d 224d 6170 223e 0a09 0909 0909 0909  e="Map">........
+00000d90: 093c 4f70 7469 6f6e 206e 616d 653d 2261  .<Option name="a
+00000da0: 6c69 676e 5f64 6173 685f 7061 7474 6572  lign_dash_patter
+00000db0: 6e22 2076 616c 7565 3d22 3022 2074 7970  n" value="0" typ
+00000dc0: 653d 2251 5374 7269 6e67 222f 3e0a 0909  e="QString"/>...
+00000dd0: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
+00000de0: 6d65 3d22 6361 7073 7479 6c65 2220 7661  me="capstyle" va
+00000df0: 6c75 653d 2273 7175 6172 6522 2074 7970  lue="square" typ
+00000e00: 653d 2251 5374 7269 6e67 222f 3e0a 0909  e="QString"/>...
+00000e10: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
+00000e20: 6d65 3d22 6375 7374 6f6d 6461 7368 2220  me="customdash" 
+00000e30: 7661 6c75 653d 2235 3b32 2220 7479 7065  value="5;2" type
+00000e40: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+00000e50: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
+00000e60: 653d 2263 7573 746f 6d64 6173 685f 6d61  e="customdash_ma
+00000e70: 705f 756e 6974 5f73 6361 6c65 2220 7661  p_unit_scale" va
+00000e80: 6c75 653d 2233 783a 302c 302c 302c 302c  lue="3x:0,0,0,0,
+00000e90: 302c 3022 2074 7970 653d 2251 5374 7269  0,0" type="QStri
+00000ea0: 6e67 222f 3e0a 0909 0909 0909 0909 3c4f  ng"/>.........<O
+00000eb0: 7074 696f 6e20 6e61 6d65 3d22 6375 7374  ption name="cust
+00000ec0: 6f6d 6461 7368 5f75 6e69 7422 2076 616c  omdash_unit" val
+00000ed0: 7565 3d22 4d4d 2220 7479 7065 3d22 5153  ue="MM" type="QS
+00000ee0: 7472 696e 6722 2f3e 0a09 0909 0909 0909  tring"/>........
+00000ef0: 093c 4f70 7469 6f6e 206e 616d 653d 2264  .<Option name="d
+00000f00: 6173 685f 7061 7474 6572 6e5f 6f66 6673  ash_pattern_offs
+00000f10: 6574 2220 7661 6c75 653d 2230 2220 7479  et" value="0" ty
+00000f20: 7065 3d22 5153 7472 696e 6722 2f3e 0a09  pe="QString"/>..
+00000f30: 0909 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
+00000f40: 616d 653d 2264 6173 685f 7061 7474 6572  ame="dash_patter
+00000f50: 6e5f 6f66 6673 6574 5f6d 6170 5f75 6e69  n_offset_map_uni
+00000f60: 745f 7363 616c 6522 2076 616c 7565 3d22  t_scale" value="
+00000f70: 3378 3a30 2c30 2c30 2c30 2c30 2c30 2220  3x:0,0,0,0,0,0" 
+00000f80: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
+00000f90: 0a09 0909 0909 0909 093c 4f70 7469 6f6e  .........<Option
+00000fa0: 206e 616d 653d 2264 6173 685f 7061 7474   name="dash_patt
+00000fb0: 6572 6e5f 6f66 6673 6574 5f75 6e69 7422  ern_offset_unit"
+00000fc0: 2076 616c 7565 3d22 4d4d 2220 7479 7065   value="MM" type
+00000fd0: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+00000fe0: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
+00000ff0: 653d 2264 7261 775f 696e 7369 6465 5f70  e="draw_inside_p
+00001000: 6f6c 7967 6f6e 2220 7661 6c75 653d 2230  olygon" value="0
+00001010: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
+00001020: 2f3e 0a09 0909 0909 0909 093c 4f70 7469  />.........<Opti
+00001030: 6f6e 206e 616d 653d 226a 6f69 6e73 7479  on name="joinsty
+00001040: 6c65 2220 7661 6c75 653d 2262 6576 656c  le" value="bevel
+00001050: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
+00001060: 2f3e 0a09 0909 0909 0909 093c 4f70 7469  />.........<Opti
+00001070: 6f6e 206e 616d 653d 226c 696e 655f 636f  on name="line_co
+00001080: 6c6f 7222 2076 616c 7565 3d22 3132 2c32  lor" value="12,2
+00001090: 3436 2c30 2c32 3535 2220 7479 7065 3d22  46,0,255" type="
+000010a0: 5153 7472 696e 6722 2f3e 0a09 0909 0909  QString"/>......
+000010b0: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
+000010c0: 226c 696e 655f 7374 796c 6522 2076 616c  "line_style" val
+000010d0: 7565 3d22 736f 6c69 6422 2074 7970 653d  ue="solid" type=
+000010e0: 2251 5374 7269 6e67 222f 3e0a 0909 0909  "QString"/>.....
+000010f0: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
+00001100: 3d22 6c69 6e65 5f77 6964 7468 2220 7661  ="line_width" va
+00001110: 6c75 653d 2230 2e33 2220 7479 7065 3d22  lue="0.3" type="
+00001120: 5153 7472 696e 6722 2f3e 0a09 0909 0909  QString"/>......
+00001130: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
+00001140: 226c 696e 655f 7769 6474 685f 756e 6974  "line_width_unit
+00001150: 2220 7661 6c75 653d 224d 4d22 2074 7970  " value="MM" typ
+00001160: 653d 2251 5374 7269 6e67 222f 3e0a 0909  e="QString"/>...
+00001170: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
+00001180: 6d65 3d22 6f66 6673 6574 2220 7661 6c75  me="offset" valu
+00001190: 653d 2230 2220 7479 7065 3d22 5153 7472  e="0" type="QStr
+000011a0: 696e 6722 2f3e 0a09 0909 0909 0909 093c  ing"/>.........<
+000011b0: 4f70 7469 6f6e 206e 616d 653d 226f 6666  Option name="off
+000011c0: 7365 745f 6d61 705f 756e 6974 5f73 6361  set_map_unit_sca
+000011d0: 6c65 2220 7661 6c75 653d 2233 783a 302c  le" value="3x:0,
+000011e0: 302c 302c 302c 302c 3022 2074 7970 653d  0,0,0,0,0" type=
+000011f0: 2251 5374 7269 6e67 222f 3e0a 0909 0909  "QString"/>.....
 00001200: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
-00001210: 3d22 6f66 6673 6574 5f6d 6170 5f75 6e69  ="offset_map_uni
-00001220: 745f 7363 616c 6522 2076 616c 7565 3d22  t_scale" value="
-00001230: 3378 3a30 2c30 2c30 2c30 2c30 2c30 2220  3x:0,0,0,0,0,0" 
-00001240: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-00001250: 0d0a 0909 0909 0909 0909 3c4f 7074 696f  ..........<Optio
-00001260: 6e20 6e61 6d65 3d22 6f66 6673 6574 5f75  n name="offset_u
-00001270: 6e69 7422 2076 616c 7565 3d22 4d4d 2220  nit" value="MM" 
-00001280: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-00001290: 0d0a 0909 0909 0909 0909 3c4f 7074 696f  ..........<Optio
-000012a0: 6e20 6e61 6d65 3d22 7269 6e67 5f66 696c  n name="ring_fil
-000012b0: 7465 7222 2076 616c 7565 3d22 3022 2074  ter" value="0" t
-000012c0: 7970 653d 2251 5374 7269 6e67 222f 3e0d  ype="QString"/>.
-000012d0: 0a09 0909 0909 0909 093c 4f70 7469 6f6e  .........<Option
-000012e0: 206e 616d 653d 2274 7269 6d5f 6469 7374   name="trim_dist
-000012f0: 616e 6365 5f65 6e64 2220 7661 6c75 653d  ance_end" value=
-00001300: 2230 2220 7479 7065 3d22 5153 7472 696e  "0" type="QStrin
-00001310: 6722 2f3e 0d0a 0909 0909 0909 0909 3c4f  g"/>..........<O
-00001320: 7074 696f 6e20 6e61 6d65 3d22 7472 696d  ption name="trim
-00001330: 5f64 6973 7461 6e63 655f 656e 645f 6d61  _distance_end_ma
-00001340: 705f 756e 6974 5f73 6361 6c65 2220 7661  p_unit_scale" va
-00001350: 6c75 653d 2233 783a 302c 302c 302c 302c  lue="3x:0,0,0,0,
-00001360: 302c 3022 2074 7970 653d 2251 5374 7269  0,0" type="QStri
-00001370: 6e67 222f 3e0d 0a09 0909 0909 0909 093c  ng"/>..........<
-00001380: 4f70 7469 6f6e 206e 616d 653d 2274 7269  Option name="tri
-00001390: 6d5f 6469 7374 616e 6365 5f65 6e64 5f75  m_distance_end_u
-000013a0: 6e69 7422 2076 616c 7565 3d22 4d4d 2220  nit" value="MM" 
-000013b0: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-000013c0: 0d0a 0909 0909 0909 0909 3c4f 7074 696f  ..........<Optio
-000013d0: 6e20 6e61 6d65 3d22 7472 696d 5f64 6973  n name="trim_dis
-000013e0: 7461 6e63 655f 7374 6172 7422 2076 616c  tance_start" val
-000013f0: 7565 3d22 3022 2074 7970 653d 2251 5374  ue="0" type="QSt
-00001400: 7269 6e67 222f 3e0d 0a09 0909 0909 0909  ring"/>.........
-00001410: 093c 4f70 7469 6f6e 206e 616d 653d 2274  .<Option name="t
-00001420: 7269 6d5f 6469 7374 616e 6365 5f73 7461  rim_distance_sta
-00001430: 7274 5f6d 6170 5f75 6e69 745f 7363 616c  rt_map_unit_scal
-00001440: 6522 2076 616c 7565 3d22 3378 3a30 2c30  e" value="3x:0,0
-00001450: 2c30 2c30 2c30 2c30 2220 7479 7065 3d22  ,0,0,0,0" type="
-00001460: 5153 7472 696e 6722 2f3e 0d0a 0909 0909  QString"/>......
-00001470: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
-00001480: 3d22 7472 696d 5f64 6973 7461 6e63 655f  ="trim_distance_
-00001490: 7374 6172 745f 756e 6974 2220 7661 6c75  start_unit" valu
-000014a0: 653d 224d 4d22 2074 7970 653d 2251 5374  e="MM" type="QSt
-000014b0: 7269 6e67 222f 3e0d 0a09 0909 0909 0909  ring"/>.........
-000014c0: 093c 4f70 7469 6f6e 206e 616d 653d 2274  .<Option name="t
-000014d0: 7765 616b 5f64 6173 685f 7061 7474 6572  weak_dash_patter
-000014e0: 6e5f 6f6e 5f63 6f72 6e65 7273 2220 7661  n_on_corners" va
-000014f0: 6c75 653d 2230 2220 7479 7065 3d22 5153  lue="0" type="QS
-00001500: 7472 696e 6722 2f3e 0d0a 0909 0909 0909  tring"/>........
-00001510: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
-00001520: 7573 655f 6375 7374 6f6d 5f64 6173 6822  use_custom_dash"
-00001530: 2076 616c 7565 3d22 3022 2074 7970 653d   value="0" type=
-00001540: 2251 5374 7269 6e67 222f 3e0d 0a09 0909  "QString"/>.....
-00001550: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
-00001560: 653d 2277 6964 7468 5f6d 6170 5f75 6e69  e="width_map_uni
-00001570: 745f 7363 616c 6522 2076 616c 7565 3d22  t_scale" value="
-00001580: 3378 3a30 2c30 2c30 2c30 2c30 2c30 2220  3x:0,0,0,0,0,0" 
-00001590: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-000015a0: 0d0a 0909 0909 0909 093c 2f4f 7074 696f  .........</Optio
-000015b0: 6e3e 0d0a 0909 0909 0909 093c 7072 6f70  n>.........<prop
-000015c0: 206b 3d22 616c 6967 6e5f 6461 7368 5f70   k="align_dash_p
-000015d0: 6174 7465 726e 2220 763d 2230 222f 3e0d  attern" v="0"/>.
-000015e0: 0a09 0909 0909 0909 3c70 726f 7020 6b3d  ........<prop k=
-000015f0: 2263 6170 7374 796c 6522 2076 3d22 7371  "capstyle" v="sq
-00001600: 7561 7265 222f 3e0d 0a09 0909 0909 0909  uare"/>.........
-00001610: 3c70 726f 7020 6b3d 2263 7573 746f 6d64  <prop k="customd
-00001620: 6173 6822 2076 3d22 353b 3222 2f3e 0d0a  ash" v="5;2"/>..
-00001630: 0909 0909 0909 093c 7072 6f70 206b 3d22  .......<prop k="
-00001640: 6375 7374 6f6d 6461 7368 5f6d 6170 5f75  customdash_map_u
-00001650: 6e69 745f 7363 616c 6522 2076 3d22 3378  nit_scale" v="3x
-00001660: 3a30 2c30 2c30 2c30 2c30 2c30 222f 3e0d  :0,0,0,0,0,0"/>.
-00001670: 0a09 0909 0909 0909 3c70 726f 7020 6b3d  ........<prop k=
-00001680: 2263 7573 746f 6d64 6173 685f 756e 6974  "customdash_unit
-00001690: 2220 763d 224d 4d22 2f3e 0d0a 0909 0909  " v="MM"/>......
-000016a0: 0909 093c 7072 6f70 206b 3d22 6461 7368  ...<prop k="dash
-000016b0: 5f70 6174 7465 726e 5f6f 6666 7365 7422  _pattern_offset"
-000016c0: 2076 3d22 3022 2f3e 0d0a 0909 0909 0909   v="0"/>........
-000016d0: 093c 7072 6f70 206b 3d22 6461 7368 5f70  .<prop k="dash_p
-000016e0: 6174 7465 726e 5f6f 6666 7365 745f 6d61  attern_offset_ma
-000016f0: 705f 756e 6974 5f73 6361 6c65 2220 763d  p_unit_scale" v=
-00001700: 2233 783a 302c 302c 302c 302c 302c 3022  "3x:0,0,0,0,0,0"
-00001710: 2f3e 0d0a 0909 0909 0909 093c 7072 6f70  />.........<prop
-00001720: 206b 3d22 6461 7368 5f70 6174 7465 726e   k="dash_pattern
-00001730: 5f6f 6666 7365 745f 756e 6974 2220 763d  _offset_unit" v=
-00001740: 224d 4d22 2f3e 0d0a 0909 0909 0909 093c  "MM"/>.........<
-00001750: 7072 6f70 206b 3d22 6472 6177 5f69 6e73  prop k="draw_ins
-00001760: 6964 655f 706f 6c79 676f 6e22 2076 3d22  ide_polygon" v="
-00001770: 3022 2f3e 0d0a 0909 0909 0909 093c 7072  0"/>.........<pr
-00001780: 6f70 206b 3d22 6a6f 696e 7374 796c 6522  op k="joinstyle"
-00001790: 2076 3d22 6265 7665 6c22 2f3e 0d0a 0909   v="bevel"/>....
-000017a0: 0909 0909 093c 7072 6f70 206b 3d22 6c69  .....<prop k="li
-000017b0: 6e65 5f63 6f6c 6f72 2220 763d 2231 322c  ne_color" v="12,
-000017c0: 3234 362c 302c 3235 3522 2f3e 0d0a 0909  246,0,255"/>....
-000017d0: 0909 0909 093c 7072 6f70 206b 3d22 6c69  .....<prop k="li
-000017e0: 6e65 5f73 7479 6c65 2220 763d 2273 6f6c  ne_style" v="sol
-000017f0: 6964 222f 3e0d 0a09 0909 0909 0909 3c70  id"/>.........<p
-00001800: 726f 7020 6b3d 226c 696e 655f 7769 6474  rop k="line_widt
-00001810: 6822 2076 3d22 302e 3322 2f3e 0d0a 0909  h" v="0.3"/>....
-00001820: 0909 0909 093c 7072 6f70 206b 3d22 6c69  .....<prop k="li
-00001830: 6e65 5f77 6964 7468 5f75 6e69 7422 2076  ne_width_unit" v
-00001840: 3d22 4d4d 222f 3e0d 0a09 0909 0909 0909  ="MM"/>.........
-00001850: 3c70 726f 7020 6b3d 226f 6666 7365 7422  <prop k="offset"
-00001860: 2076 3d22 3022 2f3e 0d0a 0909 0909 0909   v="0"/>........
-00001870: 093c 7072 6f70 206b 3d22 6f66 6673 6574  .<prop k="offset
-00001880: 5f6d 6170 5f75 6e69 745f 7363 616c 6522  _map_unit_scale"
-00001890: 2076 3d22 3378 3a30 2c30 2c30 2c30 2c30   v="3x:0,0,0,0,0
-000018a0: 2c30 222f 3e0d 0a09 0909 0909 0909 3c70  ,0"/>.........<p
-000018b0: 726f 7020 6b3d 226f 6666 7365 745f 756e  rop k="offset_un
-000018c0: 6974 2220 763d 224d 4d22 2f3e 0d0a 0909  it" v="MM"/>....
-000018d0: 0909 0909 093c 7072 6f70 206b 3d22 7269  .....<prop k="ri
-000018e0: 6e67 5f66 696c 7465 7222 2076 3d22 3022  ng_filter" v="0"
-000018f0: 2f3e 0d0a 0909 0909 0909 093c 7072 6f70  />.........<prop
-00001900: 206b 3d22 7472 696d 5f64 6973 7461 6e63   k="trim_distanc
-00001910: 655f 656e 6422 2076 3d22 3022 2f3e 0d0a  e_end" v="0"/>..
-00001920: 0909 0909 0909 093c 7072 6f70 206b 3d22  .......<prop k="
-00001930: 7472 696d 5f64 6973 7461 6e63 655f 656e  trim_distance_en
-00001940: 645f 6d61 705f 756e 6974 5f73 6361 6c65  d_map_unit_scale
-00001950: 2220 763d 2233 783a 302c 302c 302c 302c  " v="3x:0,0,0,0,
-00001960: 302c 3022 2f3e 0d0a 0909 0909 0909 093c  0,0"/>.........<
-00001970: 7072 6f70 206b 3d22 7472 696d 5f64 6973  prop k="trim_dis
-00001980: 7461 6e63 655f 656e 645f 756e 6974 2220  tance_end_unit" 
-00001990: 763d 224d 4d22 2f3e 0d0a 0909 0909 0909  v="MM"/>........
-000019a0: 093c 7072 6f70 206b 3d22 7472 696d 5f64  .<prop k="trim_d
-000019b0: 6973 7461 6e63 655f 7374 6172 7422 2076  istance_start" v
-000019c0: 3d22 3022 2f3e 0d0a 0909 0909 0909 093c  ="0"/>.........<
-000019d0: 7072 6f70 206b 3d22 7472 696d 5f64 6973  prop k="trim_dis
-000019e0: 7461 6e63 655f 7374 6172 745f 6d61 705f  tance_start_map_
-000019f0: 756e 6974 5f73 6361 6c65 2220 763d 2233  unit_scale" v="3
-00001a00: 783a 302c 302c 302c 302c 302c 3022 2f3e  x:0,0,0,0,0,0"/>
-00001a10: 0d0a 0909 0909 0909 093c 7072 6f70 206b  .........<prop k
-00001a20: 3d22 7472 696d 5f64 6973 7461 6e63 655f  ="trim_distance_
-00001a30: 7374 6172 745f 756e 6974 2220 763d 224d  start_unit" v="M
-00001a40: 4d22 2f3e 0d0a 0909 0909 0909 093c 7072  M"/>.........<pr
-00001a50: 6f70 206b 3d22 7477 6561 6b5f 6461 7368  op k="tweak_dash
-00001a60: 5f70 6174 7465 726e 5f6f 6e5f 636f 726e  _pattern_on_corn
-00001a70: 6572 7322 2076 3d22 3022 2f3e 0d0a 0909  ers" v="0"/>....
-00001a80: 0909 0909 093c 7072 6f70 206b 3d22 7573  .....<prop k="us
-00001a90: 655f 6375 7374 6f6d 5f64 6173 6822 2076  e_custom_dash" v
-00001aa0: 3d22 3022 2f3e 0d0a 0909 0909 0909 093c  ="0"/>.........<
-00001ab0: 7072 6f70 206b 3d22 7769 6474 685f 6d61  prop k="width_ma
-00001ac0: 705f 756e 6974 5f73 6361 6c65 2220 763d  p_unit_scale" v=
-00001ad0: 2233 783a 302c 302c 302c 302c 302c 3022  "3x:0,0,0,0,0,0"
-00001ae0: 2f3e 0d0a 0909 0909 0909 093c 6461 7461  />.........<data
-00001af0: 5f64 6566 696e 6564 5f70 726f 7065 7274  _defined_propert
-00001b00: 6965 733e 0d0a 0909 0909 0909 0909 3c4f  ies>..........<O
-00001b10: 7074 696f 6e20 7479 7065 3d22 4d61 7022  ption type="Map"
-00001b20: 3e0d 0a09 0909 0909 0909 0909 3c4f 7074  >...........<Opt
-00001b30: 696f 6e20 6e61 6d65 3d22 6e61 6d65 2220  ion name="name" 
-00001b40: 7661 6c75 653d 2222 2074 7970 653d 2251  value="" type="Q
-00001b50: 5374 7269 6e67 222f 3e0d 0a09 0909 0909  String"/>.......
-00001b60: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
-00001b70: 3d22 7072 6f70 6572 7469 6573 222f 3e0d  ="properties"/>.
-00001b80: 0a09 0909 0909 0909 0909 3c4f 7074 696f  ..........<Optio
-00001b90: 6e20 6e61 6d65 3d22 7479 7065 2220 7661  n name="type" va
-00001ba0: 6c75 653d 2263 6f6c 6c65 6374 696f 6e22  lue="collection"
-00001bb0: 2074 7970 653d 2251 5374 7269 6e67 222f   type="QString"/
-00001bc0: 3e0d 0a09 0909 0909 0909 093c 2f4f 7074  >..........</Opt
-00001bd0: 696f 6e3e 0d0a 0909 0909 0909 093c 2f64  ion>.........</d
-00001be0: 6174 615f 6465 6669 6e65 645f 7072 6f70  ata_defined_prop
-00001bf0: 6572 7469 6573 3e0d 0a09 0909 0909 093c  erties>........<
-00001c00: 2f6c 6179 6572 3e0d 0a09 0909 0909 3c2f  /layer>.......</
-00001c10: 7379 6d62 6f6c 3e0d 0a09 0909 093c 2f6c  symbol>......</l
-00001c20: 6179 6572 3e0d 0a09 0909 093c 6c61 7965  ayer>......<laye
-00001c30: 7220 656e 6162 6c65 643d 2231 2220 636c  r enabled="1" cl
-00001c40: 6173 733d 2253 696d 706c 654c 696e 6522  ass="SimpleLine"
-00001c50: 206c 6f63 6b65 643d 2230 2220 7061 7373   locked="0" pass
-00001c60: 3d22 3022 3e0d 0a09 0909 0909 3c4f 7074  ="0">.......<Opt
-00001c70: 696f 6e20 7479 7065 3d22 4d61 7022 3e0d  ion type="Map">.
-00001c80: 0a09 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-00001c90: 616d 653d 2261 6c69 676e 5f64 6173 685f  ame="align_dash_
-00001ca0: 7061 7474 6572 6e22 2076 616c 7565 3d22  pattern" value="
-00001cb0: 3022 2074 7970 653d 2251 5374 7269 6e67  0" type="QString
-00001cc0: 222f 3e0d 0a09 0909 0909 093c 4f70 7469  "/>........<Opti
-00001cd0: 6f6e 206e 616d 653d 2263 6170 7374 796c  on name="capstyl
-00001ce0: 6522 2076 616c 7565 3d22 7371 7561 7265  e" value="square
-00001cf0: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
-00001d00: 2f3e 0d0a 0909 0909 0909 3c4f 7074 696f  />........<Optio
-00001d10: 6e20 6e61 6d65 3d22 6375 7374 6f6d 6461  n name="customda
-00001d20: 7368 2220 7661 6c75 653d 2235 3b32 2220  sh" value="5;2" 
-00001d30: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-00001d40: 0d0a 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
-00001d50: 6e61 6d65 3d22 6375 7374 6f6d 6461 7368  name="customdash
-00001d60: 5f6d 6170 5f75 6e69 745f 7363 616c 6522  _map_unit_scale"
-00001d70: 2076 616c 7565 3d22 3378 3a30 2c30 2c30   value="3x:0,0,0
-00001d80: 2c30 2c30 2c30 2220 7479 7065 3d22 5153  ,0,0,0" type="QS
-00001d90: 7472 696e 6722 2f3e 0d0a 0909 0909 0909  tring"/>........
-00001da0: 3c4f 7074 696f 6e20 6e61 6d65 3d22 6375  <Option name="cu
-00001db0: 7374 6f6d 6461 7368 5f75 6e69 7422 2076  stomdash_unit" v
-00001dc0: 616c 7565 3d22 4d4d 2220 7479 7065 3d22  alue="MM" type="
-00001dd0: 5153 7472 696e 6722 2f3e 0d0a 0909 0909  QString"/>......
-00001de0: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
-00001df0: 6461 7368 5f70 6174 7465 726e 5f6f 6666  dash_pattern_off
-00001e00: 7365 7422 2076 616c 7565 3d22 3022 2074  set" value="0" t
-00001e10: 7970 653d 2251 5374 7269 6e67 222f 3e0d  ype="QString"/>.
-00001e20: 0a09 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-00001e30: 616d 653d 2264 6173 685f 7061 7474 6572  ame="dash_patter
-00001e40: 6e5f 6f66 6673 6574 5f6d 6170 5f75 6e69  n_offset_map_uni
-00001e50: 745f 7363 616c 6522 2076 616c 7565 3d22  t_scale" value="
-00001e60: 3378 3a30 2c30 2c30 2c30 2c30 2c30 2220  3x:0,0,0,0,0,0" 
-00001e70: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-00001e80: 0d0a 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
-00001e90: 6e61 6d65 3d22 6461 7368 5f70 6174 7465  name="dash_patte
-00001ea0: 726e 5f6f 6666 7365 745f 756e 6974 2220  rn_offset_unit" 
-00001eb0: 7661 6c75 653d 224d 4d22 2074 7970 653d  value="MM" type=
-00001ec0: 2251 5374 7269 6e67 222f 3e0d 0a09 0909  "QString"/>.....
-00001ed0: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
-00001ee0: 2264 7261 775f 696e 7369 6465 5f70 6f6c  "draw_inside_pol
-00001ef0: 7967 6f6e 2220 7661 6c75 653d 2230 2220  ygon" value="0" 
-00001f00: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-00001f10: 0d0a 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
-00001f20: 6e61 6d65 3d22 6a6f 696e 7374 796c 6522  name="joinstyle"
-00001f30: 2076 616c 7565 3d22 6265 7665 6c22 2074   value="bevel" t
-00001f40: 7970 653d 2251 5374 7269 6e67 222f 3e0d  ype="QString"/>.
-00001f50: 0a09 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-00001f60: 616d 653d 226c 696e 655f 636f 6c6f 7222  ame="line_color"
-00001f70: 2076 616c 7565 3d22 3132 2c32 3436 2c30   value="12,246,0
-00001f80: 2c32 3535 2220 7479 7065 3d22 5153 7472  ,255" type="QStr
-00001f90: 696e 6722 2f3e 0d0a 0909 0909 0909 3c4f  ing"/>........<O
-00001fa0: 7074 696f 6e20 6e61 6d65 3d22 6c69 6e65  ption name="line
-00001fb0: 5f73 7479 6c65 2220 7661 6c75 653d 2273  _style" value="s
-00001fc0: 6f6c 6964 2220 7479 7065 3d22 5153 7472  olid" type="QStr
-00001fd0: 696e 6722 2f3e 0d0a 0909 0909 0909 3c4f  ing"/>........<O
-00001fe0: 7074 696f 6e20 6e61 6d65 3d22 6c69 6e65  ption name="line
-00001ff0: 5f77 6964 7468 2220 7661 6c75 653d 2230  _width" value="0
-00002000: 2e34 3622 2074 7970 653d 2251 5374 7269  .46" type="QStri
-00002010: 6e67 222f 3e0d 0a09 0909 0909 093c 4f70  ng"/>........<Op
-00002020: 7469 6f6e 206e 616d 653d 226c 696e 655f  tion name="line_
-00002030: 7769 6474 685f 756e 6974 2220 7661 6c75  width_unit" valu
-00002040: 653d 224d 4d22 2074 7970 653d 2251 5374  e="MM" type="QSt
-00002050: 7269 6e67 222f 3e0d 0a09 0909 0909 093c  ring"/>........<
-00002060: 4f70 7469 6f6e 206e 616d 653d 226f 6666  Option name="off
-00002070: 7365 7422 2076 616c 7565 3d22 3022 2074  set" value="0" t
-00002080: 7970 653d 2251 5374 7269 6e67 222f 3e0d  ype="QString"/>.
-00002090: 0a09 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-000020a0: 616d 653d 226f 6666 7365 745f 6d61 705f  ame="offset_map_
-000020b0: 756e 6974 5f73 6361 6c65 2220 7661 6c75  unit_scale" valu
-000020c0: 653d 2233 783a 302c 302c 302c 302c 302c  e="3x:0,0,0,0,0,
-000020d0: 3022 2074 7970 653d 2251 5374 7269 6e67  0" type="QString
-000020e0: 222f 3e0d 0a09 0909 0909 093c 4f70 7469  "/>........<Opti
-000020f0: 6f6e 206e 616d 653d 226f 6666 7365 745f  on name="offset_
-00002100: 756e 6974 2220 7661 6c75 653d 224d 4d22  unit" value="MM"
-00002110: 2074 7970 653d 2251 5374 7269 6e67 222f   type="QString"/
-00002120: 3e0d 0a09 0909 0909 093c 4f70 7469 6f6e  >........<Option
-00002130: 206e 616d 653d 2272 696e 675f 6669 6c74   name="ring_filt
-00002140: 6572 2220 7661 6c75 653d 2230 2220 7479  er" value="0" ty
-00002150: 7065 3d22 5153 7472 696e 6722 2f3e 0d0a  pe="QString"/>..
-00002160: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
-00002170: 6d65 3d22 7472 696d 5f64 6973 7461 6e63  me="trim_distanc
-00002180: 655f 656e 6422 2076 616c 7565 3d22 3022  e_end" value="0"
-00002190: 2074 7970 653d 2251 5374 7269 6e67 222f   type="QString"/
-000021a0: 3e0d 0a09 0909 0909 093c 4f70 7469 6f6e  >........<Option
-000021b0: 206e 616d 653d 2274 7269 6d5f 6469 7374   name="trim_dist
-000021c0: 616e 6365 5f65 6e64 5f6d 6170 5f75 6e69  ance_end_map_uni
-000021d0: 745f 7363 616c 6522 2076 616c 7565 3d22  t_scale" value="
-000021e0: 3378 3a30 2c30 2c30 2c30 2c30 2c30 2220  3x:0,0,0,0,0,0" 
-000021f0: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-00002200: 0d0a 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
-00002210: 6e61 6d65 3d22 7472 696d 5f64 6973 7461  name="trim_dista
-00002220: 6e63 655f 656e 645f 756e 6974 2220 7661  nce_end_unit" va
-00002230: 6c75 653d 224d 4d22 2074 7970 653d 2251  lue="MM" type="Q
-00002240: 5374 7269 6e67 222f 3e0d 0a09 0909 0909  String"/>.......
-00002250: 093c 4f70 7469 6f6e 206e 616d 653d 2274  .<Option name="t
-00002260: 7269 6d5f 6469 7374 616e 6365 5f73 7461  rim_distance_sta
-00002270: 7274 2220 7661 6c75 653d 2230 2220 7479  rt" value="0" ty
-00002280: 7065 3d22 5153 7472 696e 6722 2f3e 0d0a  pe="QString"/>..
-00002290: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
-000022a0: 6d65 3d22 7472 696d 5f64 6973 7461 6e63  me="trim_distanc
-000022b0: 655f 7374 6172 745f 6d61 705f 756e 6974  e_start_map_unit
-000022c0: 5f73 6361 6c65 2220 7661 6c75 653d 2233  _scale" value="3
-000022d0: 783a 302c 302c 302c 302c 302c 3022 2074  x:0,0,0,0,0,0" t
-000022e0: 7970 653d 2251 5374 7269 6e67 222f 3e0d  ype="QString"/>.
-000022f0: 0a09 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-00002300: 616d 653d 2274 7269 6d5f 6469 7374 616e  ame="trim_distan
-00002310: 6365 5f73 7461 7274 5f75 6e69 7422 2076  ce_start_unit" v
-00002320: 616c 7565 3d22 4d4d 2220 7479 7065 3d22  alue="MM" type="
-00002330: 5153 7472 696e 6722 2f3e 0d0a 0909 0909  QString"/>......
-00002340: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
-00002350: 7477 6561 6b5f 6461 7368 5f70 6174 7465  tweak_dash_patte
-00002360: 726e 5f6f 6e5f 636f 726e 6572 7322 2076  rn_on_corners" v
-00002370: 616c 7565 3d22 3022 2074 7970 653d 2251  alue="0" type="Q
-00002380: 5374 7269 6e67 222f 3e0d 0a09 0909 0909  String"/>.......
-00002390: 093c 4f70 7469 6f6e 206e 616d 653d 2275  .<Option name="u
-000023a0: 7365 5f63 7573 746f 6d5f 6461 7368 2220  se_custom_dash" 
-000023b0: 7661 6c75 653d 2230 2220 7479 7065 3d22  value="0" type="
-000023c0: 5153 7472 696e 6722 2f3e 0d0a 0909 0909  QString"/>......
-000023d0: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
-000023e0: 7769 6474 685f 6d61 705f 756e 6974 5f73  width_map_unit_s
-000023f0: 6361 6c65 2220 7661 6c75 653d 2233 783a  cale" value="3x:
-00002400: 302c 302c 302c 302c 302c 3022 2074 7970  0,0,0,0,0,0" typ
-00002410: 653d 2251 5374 7269 6e67 222f 3e0d 0a09  e="QString"/>...
-00002420: 0909 0909 3c2f 4f70 7469 6f6e 3e0d 0a09  ....</Option>...
-00002430: 0909 0909 3c70 726f 7020 6b3d 2261 6c69  ....<prop k="ali
-00002440: 676e 5f64 6173 685f 7061 7474 6572 6e22  gn_dash_pattern"
-00002450: 2076 3d22 3022 2f3e 0d0a 0909 0909 093c   v="0"/>.......<
-00002460: 7072 6f70 206b 3d22 6361 7073 7479 6c65  prop k="capstyle
-00002470: 2220 763d 2273 7175 6172 6522 2f3e 0d0a  " v="square"/>..
-00002480: 0909 0909 093c 7072 6f70 206b 3d22 6375  .....<prop k="cu
-00002490: 7374 6f6d 6461 7368 2220 763d 2235 3b32  stomdash" v="5;2
-000024a0: 222f 3e0d 0a09 0909 0909 3c70 726f 7020  "/>.......<prop 
-000024b0: 6b3d 2263 7573 746f 6d64 6173 685f 6d61  k="customdash_ma
-000024c0: 705f 756e 6974 5f73 6361 6c65 2220 763d  p_unit_scale" v=
-000024d0: 2233 783a 302c 302c 302c 302c 302c 3022  "3x:0,0,0,0,0,0"
-000024e0: 2f3e 0d0a 0909 0909 093c 7072 6f70 206b  />.......<prop k
-000024f0: 3d22 6375 7374 6f6d 6461 7368 5f75 6e69  ="customdash_uni
-00002500: 7422 2076 3d22 4d4d 222f 3e0d 0a09 0909  t" v="MM"/>.....
-00002510: 0909 3c70 726f 7020 6b3d 2264 6173 685f  ..<prop k="dash_
-00002520: 7061 7474 6572 6e5f 6f66 6673 6574 2220  pattern_offset" 
-00002530: 763d 2230 222f 3e0d 0a09 0909 0909 3c70  v="0"/>.......<p
-00002540: 726f 7020 6b3d 2264 6173 685f 7061 7474  rop k="dash_patt
-00002550: 6572 6e5f 6f66 6673 6574 5f6d 6170 5f75  ern_offset_map_u
-00002560: 6e69 745f 7363 616c 6522 2076 3d22 3378  nit_scale" v="3x
-00002570: 3a30 2c30 2c30 2c30 2c30 2c30 222f 3e0d  :0,0,0,0,0,0"/>.
-00002580: 0a09 0909 0909 3c70 726f 7020 6b3d 2264  ......<prop k="d
-00002590: 6173 685f 7061 7474 6572 6e5f 6f66 6673  ash_pattern_offs
-000025a0: 6574 5f75 6e69 7422 2076 3d22 4d4d 222f  et_unit" v="MM"/
-000025b0: 3e0d 0a09 0909 0909 3c70 726f 7020 6b3d  >.......<prop k=
-000025c0: 2264 7261 775f 696e 7369 6465 5f70 6f6c  "draw_inside_pol
-000025d0: 7967 6f6e 2220 763d 2230 222f 3e0d 0a09  ygon" v="0"/>...
-000025e0: 0909 0909 3c70 726f 7020 6b3d 226a 6f69  ....<prop k="joi
-000025f0: 6e73 7479 6c65 2220 763d 2262 6576 656c  nstyle" v="bevel
-00002600: 222f 3e0d 0a09 0909 0909 3c70 726f 7020  "/>.......<prop 
-00002610: 6b3d 226c 696e 655f 636f 6c6f 7222 2076  k="line_color" v
-00002620: 3d22 3132 2c32 3436 2c30 2c32 3535 222f  ="12,246,0,255"/
-00002630: 3e0d 0a09 0909 0909 3c70 726f 7020 6b3d  >.......<prop k=
-00002640: 226c 696e 655f 7374 796c 6522 2076 3d22  "line_style" v="
-00002650: 736f 6c69 6422 2f3e 0d0a 0909 0909 093c  solid"/>.......<
-00002660: 7072 6f70 206b 3d22 6c69 6e65 5f77 6964  prop k="line_wid
-00002670: 7468 2220 763d 2230 2e34 3622 2f3e 0d0a  th" v="0.46"/>..
-00002680: 0909 0909 093c 7072 6f70 206b 3d22 6c69  .....<prop k="li
-00002690: 6e65 5f77 6964 7468 5f75 6e69 7422 2076  ne_width_unit" v
-000026a0: 3d22 4d4d 222f 3e0d 0a09 0909 0909 3c70  ="MM"/>.......<p
-000026b0: 726f 7020 6b3d 226f 6666 7365 7422 2076  rop k="offset" v
-000026c0: 3d22 3022 2f3e 0d0a 0909 0909 093c 7072  ="0"/>.......<pr
-000026d0: 6f70 206b 3d22 6f66 6673 6574 5f6d 6170  op k="offset_map
-000026e0: 5f75 6e69 745f 7363 616c 6522 2076 3d22  _unit_scale" v="
-000026f0: 3378 3a30 2c30 2c30 2c30 2c30 2c30 222f  3x:0,0,0,0,0,0"/
-00002700: 3e0d 0a09 0909 0909 3c70 726f 7020 6b3d  >.......<prop k=
-00002710: 226f 6666 7365 745f 756e 6974 2220 763d  "offset_unit" v=
-00002720: 224d 4d22 2f3e 0d0a 0909 0909 093c 7072  "MM"/>.......<pr
-00002730: 6f70 206b 3d22 7269 6e67 5f66 696c 7465  op k="ring_filte
-00002740: 7222 2076 3d22 3022 2f3e 0d0a 0909 0909  r" v="0"/>......
-00002750: 093c 7072 6f70 206b 3d22 7472 696d 5f64  .<prop k="trim_d
-00002760: 6973 7461 6e63 655f 656e 6422 2076 3d22  istance_end" v="
-00002770: 3022 2f3e 0d0a 0909 0909 093c 7072 6f70  0"/>.......<prop
-00002780: 206b 3d22 7472 696d 5f64 6973 7461 6e63   k="trim_distanc
-00002790: 655f 656e 645f 6d61 705f 756e 6974 5f73  e_end_map_unit_s
-000027a0: 6361 6c65 2220 763d 2233 783a 302c 302c  cale" v="3x:0,0,
-000027b0: 302c 302c 302c 3022 2f3e 0d0a 0909 0909  0,0,0,0"/>......
-000027c0: 093c 7072 6f70 206b 3d22 7472 696d 5f64  .<prop k="trim_d
-000027d0: 6973 7461 6e63 655f 656e 645f 756e 6974  istance_end_unit
-000027e0: 2220 763d 224d 4d22 2f3e 0d0a 0909 0909  " v="MM"/>......
-000027f0: 093c 7072 6f70 206b 3d22 7472 696d 5f64  .<prop k="trim_d
-00002800: 6973 7461 6e63 655f 7374 6172 7422 2076  istance_start" v
-00002810: 3d22 3022 2f3e 0d0a 0909 0909 093c 7072  ="0"/>.......<pr
-00002820: 6f70 206b 3d22 7472 696d 5f64 6973 7461  op k="trim_dista
-00002830: 6e63 655f 7374 6172 745f 6d61 705f 756e  nce_start_map_un
-00002840: 6974 5f73 6361 6c65 2220 763d 2233 783a  it_scale" v="3x:
-00002850: 302c 302c 302c 302c 302c 3022 2f3e 0d0a  0,0,0,0,0,0"/>..
-00002860: 0909 0909 093c 7072 6f70 206b 3d22 7472  .....<prop k="tr
-00002870: 696d 5f64 6973 7461 6e63 655f 7374 6172  im_distance_star
-00002880: 745f 756e 6974 2220 763d 224d 4d22 2f3e  t_unit" v="MM"/>
-00002890: 0d0a 0909 0909 093c 7072 6f70 206b 3d22  .......<prop k="
-000028a0: 7477 6561 6b5f 6461 7368 5f70 6174 7465  tweak_dash_patte
-000028b0: 726e 5f6f 6e5f 636f 726e 6572 7322 2076  rn_on_corners" v
-000028c0: 3d22 3022 2f3e 0d0a 0909 0909 093c 7072  ="0"/>.......<pr
-000028d0: 6f70 206b 3d22 7573 655f 6375 7374 6f6d  op k="use_custom
-000028e0: 5f64 6173 6822 2076 3d22 3022 2f3e 0d0a  _dash" v="0"/>..
-000028f0: 0909 0909 093c 7072 6f70 206b 3d22 7769  .....<prop k="wi
-00002900: 6474 685f 6d61 705f 756e 6974 5f73 6361  dth_map_unit_sca
-00002910: 6c65 2220 763d 2233 783a 302c 302c 302c  le" v="3x:0,0,0,
-00002920: 302c 302c 3022 2f3e 0d0a 0909 0909 093c  0,0,0"/>.......<
-00002930: 6461 7461 5f64 6566 696e 6564 5f70 726f  data_defined_pro
-00002940: 7065 7274 6965 733e 0d0a 0909 0909 0909  perties>........
-00002950: 3c4f 7074 696f 6e20 7479 7065 3d22 4d61  <Option type="Ma
-00002960: 7022 3e0d 0a09 0909 0909 0909 3c4f 7074  p">.........<Opt
-00002970: 696f 6e20 6e61 6d65 3d22 6e61 6d65 2220  ion name="name" 
-00002980: 7661 6c75 653d 2222 2074 7970 653d 2251  value="" type="Q
-00002990: 5374 7269 6e67 222f 3e0d 0a09 0909 0909  String"/>.......
-000029a0: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
-000029b0: 7072 6f70 6572 7469 6573 222f 3e0d 0a09  properties"/>...
-000029c0: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
-000029d0: 6d65 3d22 7479 7065 2220 7661 6c75 653d  me="type" value=
-000029e0: 2263 6f6c 6c65 6374 696f 6e22 2074 7970  "collection" typ
-000029f0: 653d 2251 5374 7269 6e67 222f 3e0d 0a09  e="QString"/>...
-00002a00: 0909 0909 093c 2f4f 7074 696f 6e3e 0d0a  .....</Option>..
-00002a10: 0909 0909 093c 2f64 6174 615f 6465 6669  .....</data_defi
-00002a20: 6e65 645f 7072 6f70 6572 7469 6573 3e0d  ned_properties>.
-00002a30: 0a09 0909 093c 2f6c 6179 6572 3e0d 0a09  .....</layer>...
-00002a40: 0909 3c2f 7379 6d62 6f6c 3e0d 0a09 093c  ..</symbol>....<
-00002a50: 2f73 796d 626f 6c73 3e0d 0a09 093c 726f  /symbols>....<ro
-00002a60: 7461 7469 6f6e 2f3e 0d0a 0909 3c73 697a  tation/>....<siz
-00002a70: 6573 6361 6c65 2f3e 0d0a 093c 2f72 656e  escale/>...</ren
-00002a80: 6465 7265 722d 7632 3e0d 0a09 3c63 7573  derer-v2>...<cus
-00002a90: 746f 6d70 726f 7065 7274 6965 733e 0d0a  tomproperties>..
-00002aa0: 0909 3c4f 7074 696f 6e20 7479 7065 3d22  ..<Option type="
-00002ab0: 4d61 7022 3e0d 0a09 0909 3c4f 7074 696f  Map">.....<Optio
-00002ac0: 6e20 6e61 6d65 3d22 656d 6265 6464 6564  n name="embedded
-00002ad0: 5769 6467 6574 732f 636f 756e 7422 2076  Widgets/count" v
-00002ae0: 616c 7565 3d22 3022 2074 7970 653d 2269  alue="0" type="i
-00002af0: 6e74 222f 3e0d 0a09 0909 3c4f 7074 696f  nt"/>.....<Optio
-00002b00: 6e20 6e61 6d65 3d22 7661 7269 6162 6c65  n name="variable
-00002b10: 4e61 6d65 7322 2f3e 0d0a 0909 093c 4f70  Names"/>.....<Op
-00002b20: 7469 6f6e 206e 616d 653d 2276 6172 6961  tion name="varia
-00002b30: 626c 6556 616c 7565 7322 2f3e 0d0a 0909  bleValues"/>....
-00002b40: 3c2f 4f70 7469 6f6e 3e0d 0a09 3c2f 6375  </Option>...</cu
-00002b50: 7374 6f6d 7072 6f70 6572 7469 6573 3e0d  stomproperties>.
-00002b60: 0a09 3c62 6c65 6e64 4d6f 6465 3e30 3c2f  ..<blendMode>0</
-00002b70: 626c 656e 644d 6f64 653e 0d0a 093c 6665  blendMode>...<fe
-00002b80: 6174 7572 6542 6c65 6e64 4d6f 6465 3e30  atureBlendMode>0
-00002b90: 3c2f 6665 6174 7572 6542 6c65 6e64 4d6f  </featureBlendMo
-00002ba0: 6465 3e0d 0a09 3c6c 6179 6572 4f70 6163  de>...<layerOpac
-00002bb0: 6974 793e 313c 2f6c 6179 6572 4f70 6163  ity>1</layerOpac
-00002bc0: 6974 793e 0d0a 093c 5369 6e67 6c65 4361  ity>...<SingleCa
-00002bd0: 7465 676f 7279 4469 6167 7261 6d52 656e  tegoryDiagramRen
-00002be0: 6465 7265 7220 6174 7472 6962 7574 654c  derer attributeL
-00002bf0: 6567 656e 643d 2231 2220 6469 6167 7261  egend="1" diagra
-00002c00: 6d54 7970 653d 2248 6973 746f 6772 616d  mType="Histogram
-00002c10: 223e 0d0a 0909 3c44 6961 6772 616d 4361  ">....<DiagramCa
-00002c20: 7465 676f 7279 2077 6964 7468 3d22 3135  tegory width="15
-00002c30: 2220 656e 6162 6c65 643d 2230 2220 7065  " enabled="0" pe
-00002c40: 6e41 6c70 6861 3d22 3235 3522 2062 6163  nAlpha="255" bac
-00002c50: 6b67 726f 756e 6443 6f6c 6f72 3d22 2366  kgroundColor="#f
-00002c60: 6666 6666 6622 206c 696e 6553 697a 6553  fffff" lineSizeS
-00002c70: 6361 6c65 3d22 3378 3a30 2c30 2c30 2c30  cale="3x:0,0,0,0
-00002c80: 2c30 2c30 2220 7370 6163 696e 673d 2235  ,0,0" spacing="5
-00002c90: 2220 6d69 6e69 6d75 6d53 697a 653d 2230  " minimumSize="0
-00002ca0: 2220 7065 6e57 6964 7468 3d22 3022 2073  " penWidth="0" s
-00002cb0: 6361 6c65 4261 7365 6456 6973 6962 696c  caleBasedVisibil
-00002cc0: 6974 793d 2230 2220 6261 7257 6964 7468  ity="0" barWidth
-00002cd0: 3d22 3522 206c 6162 656c 506c 6163 656d  ="5" labelPlacem
-00002ce0: 656e 744d 6574 686f 643d 2258 4865 6967  entMethod="XHeig
-00002cf0: 6874 2220 6469 7265 6374 696f 6e3d 2230  ht" direction="0
-00002d00: 2220 6261 636b 6772 6f75 6e64 416c 7068  " backgroundAlph
-00002d10: 613d 2232 3535 2220 6865 6967 6874 3d22  a="255" height="
-00002d20: 3135 2220 7369 7a65 5363 616c 653d 2233  15" sizeScale="3
-00002d30: 783a 302c 302c 302c 302c 302c 3022 2073  x:0,0,0,0,0,0" s
-00002d40: 686f 7741 7869 733d 2231 2220 7370 6163  howAxis="1" spac
-00002d50: 696e 6755 6e69 7453 6361 6c65 3d22 3378  ingUnitScale="3x
-00002d60: 3a30 2c30 2c30 2c30 2c30 2c30 2220 6469  :0,0,0,0,0,0" di
-00002d70: 6167 7261 6d4f 7269 656e 7461 7469 6f6e  agramOrientation
-00002d80: 3d22 5570 2220 7065 6e43 6f6c 6f72 3d22  ="Up" penColor="
-00002d90: 2330 3030 3030 3022 206f 7061 6369 7479  #000000" opacity
-00002da0: 3d22 3122 206d 696e 5363 616c 6544 656e  ="1" minScaleDen
-00002db0: 6f6d 696e 6174 6f72 3d22 3022 2073 7061  ominator="0" spa
-00002dc0: 6369 6e67 556e 6974 3d22 4d4d 2220 7363  cingUnit="MM" sc
-00002dd0: 616c 6544 6570 656e 6465 6e63 793d 2241  aleDependency="A
-00002de0: 7265 6122 2072 6f74 6174 696f 6e4f 6666  rea" rotationOff
-00002df0: 7365 743d 2232 3730 2220 6c69 6e65 5369  set="270" lineSi
-00002e00: 7a65 5479 7065 3d22 4d4d 2220 7369 7a65  zeType="MM" size
-00002e10: 5479 7065 3d22 4d4d 2220 6d61 7853 6361  Type="MM" maxSca
-00002e20: 6c65 4465 6e6f 6d69 6e61 746f 723d 2231  leDenominator="1
-00002e30: 652b 3038 223e 0d0a 0909 093c 666f 6e74  e+08">.....<font
-00002e40: 5072 6f70 6572 7469 6573 2064 6573 6372  Properties descr
-00002e50: 6970 7469 6f6e 3d22 4d53 2053 6865 6c6c  iption="MS Shell
-00002e60: 2044 6c67 2032 2c36 2e36 2c2d 312c 352c   Dlg 2,6.6,-1,5,
-00002e70: 3530 2c30 2c30 2c30 2c30 2c30 2220 7374  50,0,0,0,0,0" st
-00002e80: 796c 653d 2222 2f3e 0d0a 0909 093c 6178  yle=""/>.....<ax
-00002e90: 6973 5379 6d62 6f6c 3e0d 0a09 0909 093c  isSymbol>......<
-00002ea0: 7379 6d62 6f6c 206e 616d 653d 2222 2063  symbol name="" c
-00002eb0: 6c69 705f 746f 5f65 7874 656e 743d 2231  lip_to_extent="1
-00002ec0: 2220 666f 7263 655f 7268 723d 2230 2220  " force_rhr="0" 
-00002ed0: 7479 7065 3d22 6c69 6e65 2220 616c 7068  type="line" alph
-00002ee0: 613d 2231 223e 0d0a 0909 0909 093c 6461  a="1">.......<da
-00002ef0: 7461 5f64 6566 696e 6564 5f70 726f 7065  ta_defined_prope
-00002f00: 7274 6965 733e 0d0a 0909 0909 0909 3c4f  rties>........<O
-00002f10: 7074 696f 6e20 7479 7065 3d22 4d61 7022  ption type="Map"
-00002f20: 3e0d 0a09 0909 0909 0909 3c4f 7074 696f  >.........<Optio
-00002f30: 6e20 6e61 6d65 3d22 6e61 6d65 2220 7661  n name="name" va
-00002f40: 6c75 653d 2222 2074 7970 653d 2251 5374  lue="" type="QSt
-00002f50: 7269 6e67 222f 3e0d 0a09 0909 0909 0909  ring"/>.........
-00002f60: 3c4f 7074 696f 6e20 6e61 6d65 3d22 7072  <Option name="pr
-00002f70: 6f70 6572 7469 6573 222f 3e0d 0a09 0909  operties"/>.....
-00002f80: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
-00002f90: 3d22 7479 7065 2220 7661 6c75 653d 2263  ="type" value="c
-00002fa0: 6f6c 6c65 6374 696f 6e22 2074 7970 653d  ollection" type=
-00002fb0: 2251 5374 7269 6e67 222f 3e0d 0a09 0909  "QString"/>.....
-00002fc0: 0909 093c 2f4f 7074 696f 6e3e 0d0a 0909  ...</Option>....
-00002fd0: 0909 093c 2f64 6174 615f 6465 6669 6e65  ...</data_define
-00002fe0: 645f 7072 6f70 6572 7469 6573 3e0d 0a09  d_properties>...
-00002ff0: 0909 0909 3c6c 6179 6572 2065 6e61 626c  ....<layer enabl
-00003000: 6564 3d22 3122 2063 6c61 7373 3d22 5369  ed="1" class="Si
-00003010: 6d70 6c65 4c69 6e65 2220 6c6f 636b 6564  mpleLine" locked
-00003020: 3d22 3022 2070 6173 733d 2230 223e 0d0a  ="0" pass="0">..
-00003030: 0909 0909 0909 3c4f 7074 696f 6e20 7479  ......<Option ty
-00003040: 7065 3d22 4d61 7022 3e0d 0a09 0909 0909  pe="Map">.......
-00003050: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
-00003060: 616c 6967 6e5f 6461 7368 5f70 6174 7465  align_dash_patte
-00003070: 726e 2220 7661 6c75 653d 2230 2220 7479  rn" value="0" ty
-00003080: 7065 3d22 5153 7472 696e 6722 2f3e 0d0a  pe="QString"/>..
-00003090: 0909 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-000030a0: 616d 653d 2263 6170 7374 796c 6522 2076  ame="capstyle" v
-000030b0: 616c 7565 3d22 7371 7561 7265 2220 7479  alue="square" ty
-000030c0: 7065 3d22 5153 7472 696e 6722 2f3e 0d0a  pe="QString"/>..
-000030d0: 0909 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-000030e0: 616d 653d 2263 7573 746f 6d64 6173 6822  ame="customdash"
-000030f0: 2076 616c 7565 3d22 353b 3222 2074 7970   value="5;2" typ
-00003100: 653d 2251 5374 7269 6e67 222f 3e0d 0a09  e="QString"/>...
-00003110: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
-00003120: 6d65 3d22 6375 7374 6f6d 6461 7368 5f6d  me="customdash_m
+00001210: 3d22 6f66 6673 6574 5f75 6e69 7422 2076  ="offset_unit" v
+00001220: 616c 7565 3d22 4d4d 2220 7479 7065 3d22  alue="MM" type="
+00001230: 5153 7472 696e 6722 2f3e 0a09 0909 0909  QString"/>......
+00001240: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
+00001250: 2272 696e 675f 6669 6c74 6572 2220 7661  "ring_filter" va
+00001260: 6c75 653d 2230 2220 7479 7065 3d22 5153  lue="0" type="QS
+00001270: 7472 696e 6722 2f3e 0a09 0909 0909 0909  tring"/>........
+00001280: 093c 4f70 7469 6f6e 206e 616d 653d 2274  .<Option name="t
+00001290: 7269 6d5f 6469 7374 616e 6365 5f65 6e64  rim_distance_end
+000012a0: 2220 7661 6c75 653d 2230 2220 7479 7065  " value="0" type
+000012b0: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+000012c0: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
+000012d0: 653d 2274 7269 6d5f 6469 7374 616e 6365  e="trim_distance
+000012e0: 5f65 6e64 5f6d 6170 5f75 6e69 745f 7363  _end_map_unit_sc
+000012f0: 616c 6522 2076 616c 7565 3d22 3378 3a30  ale" value="3x:0
+00001300: 2c30 2c30 2c30 2c30 2c30 2220 7479 7065  ,0,0,0,0,0" type
+00001310: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+00001320: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
+00001330: 653d 2274 7269 6d5f 6469 7374 616e 6365  e="trim_distance
+00001340: 5f65 6e64 5f75 6e69 7422 2076 616c 7565  _end_unit" value
+00001350: 3d22 4d4d 2220 7479 7065 3d22 5153 7472  ="MM" type="QStr
+00001360: 696e 6722 2f3e 0a09 0909 0909 0909 093c  ing"/>.........<
+00001370: 4f70 7469 6f6e 206e 616d 653d 2274 7269  Option name="tri
+00001380: 6d5f 6469 7374 616e 6365 5f73 7461 7274  m_distance_start
+00001390: 2220 7661 6c75 653d 2230 2220 7479 7065  " value="0" type
+000013a0: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+000013b0: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
+000013c0: 653d 2274 7269 6d5f 6469 7374 616e 6365  e="trim_distance
+000013d0: 5f73 7461 7274 5f6d 6170 5f75 6e69 745f  _start_map_unit_
+000013e0: 7363 616c 6522 2076 616c 7565 3d22 3378  scale" value="3x
+000013f0: 3a30 2c30 2c30 2c30 2c30 2c30 2220 7479  :0,0,0,0,0,0" ty
+00001400: 7065 3d22 5153 7472 696e 6722 2f3e 0a09  pe="QString"/>..
+00001410: 0909 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
+00001420: 616d 653d 2274 7269 6d5f 6469 7374 616e  ame="trim_distan
+00001430: 6365 5f73 7461 7274 5f75 6e69 7422 2076  ce_start_unit" v
+00001440: 616c 7565 3d22 4d4d 2220 7479 7065 3d22  alue="MM" type="
+00001450: 5153 7472 696e 6722 2f3e 0a09 0909 0909  QString"/>......
+00001460: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
+00001470: 2274 7765 616b 5f64 6173 685f 7061 7474  "tweak_dash_patt
+00001480: 6572 6e5f 6f6e 5f63 6f72 6e65 7273 2220  ern_on_corners" 
+00001490: 7661 6c75 653d 2230 2220 7479 7065 3d22  value="0" type="
+000014a0: 5153 7472 696e 6722 2f3e 0a09 0909 0909  QString"/>......
+000014b0: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
+000014c0: 2275 7365 5f63 7573 746f 6d5f 6461 7368  "use_custom_dash
+000014d0: 2220 7661 6c75 653d 2230 2220 7479 7065  " value="0" type
+000014e0: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+000014f0: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
+00001500: 653d 2277 6964 7468 5f6d 6170 5f75 6e69  e="width_map_uni
+00001510: 745f 7363 616c 6522 2076 616c 7565 3d22  t_scale" value="
+00001520: 3378 3a30 2c30 2c30 2c30 2c30 2c30 2220  3x:0,0,0,0,0,0" 
+00001530: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
+00001540: 0a09 0909 0909 0909 3c2f 4f70 7469 6f6e  ........</Option
+00001550: 3e0a 0909 0909 0909 093c 7072 6f70 206b  >........<prop k
+00001560: 3d22 616c 6967 6e5f 6461 7368 5f70 6174  ="align_dash_pat
+00001570: 7465 726e 2220 763d 2230 222f 3e0a 0909  tern" v="0"/>...
+00001580: 0909 0909 093c 7072 6f70 206b 3d22 6361  .....<prop k="ca
+00001590: 7073 7479 6c65 2220 763d 2273 7175 6172  pstyle" v="squar
+000015a0: 6522 2f3e 0a09 0909 0909 0909 3c70 726f  e"/>........<pro
+000015b0: 7020 6b3d 2263 7573 746f 6d64 6173 6822  p k="customdash"
+000015c0: 2076 3d22 353b 3222 2f3e 0a09 0909 0909   v="5;2"/>......
+000015d0: 0909 3c70 726f 7020 6b3d 2263 7573 746f  ..<prop k="custo
+000015e0: 6d64 6173 685f 6d61 705f 756e 6974 5f73  mdash_map_unit_s
+000015f0: 6361 6c65 2220 763d 2233 783a 302c 302c  cale" v="3x:0,0,
+00001600: 302c 302c 302c 3022 2f3e 0a09 0909 0909  0,0,0,0"/>......
+00001610: 0909 3c70 726f 7020 6b3d 2263 7573 746f  ..<prop k="custo
+00001620: 6d64 6173 685f 756e 6974 2220 763d 224d  mdash_unit" v="M
+00001630: 4d22 2f3e 0a09 0909 0909 0909 3c70 726f  M"/>........<pro
+00001640: 7020 6b3d 2264 6173 685f 7061 7474 6572  p k="dash_patter
+00001650: 6e5f 6f66 6673 6574 2220 763d 2230 222f  n_offset" v="0"/
+00001660: 3e0a 0909 0909 0909 093c 7072 6f70 206b  >........<prop k
+00001670: 3d22 6461 7368 5f70 6174 7465 726e 5f6f  ="dash_pattern_o
+00001680: 6666 7365 745f 6d61 705f 756e 6974 5f73  ffset_map_unit_s
+00001690: 6361 6c65 2220 763d 2233 783a 302c 302c  cale" v="3x:0,0,
+000016a0: 302c 302c 302c 3022 2f3e 0a09 0909 0909  0,0,0,0"/>......
+000016b0: 0909 3c70 726f 7020 6b3d 2264 6173 685f  ..<prop k="dash_
+000016c0: 7061 7474 6572 6e5f 6f66 6673 6574 5f75  pattern_offset_u
+000016d0: 6e69 7422 2076 3d22 4d4d 222f 3e0a 0909  nit" v="MM"/>...
+000016e0: 0909 0909 093c 7072 6f70 206b 3d22 6472  .....<prop k="dr
+000016f0: 6177 5f69 6e73 6964 655f 706f 6c79 676f  aw_inside_polygo
+00001700: 6e22 2076 3d22 3022 2f3e 0a09 0909 0909  n" v="0"/>......
+00001710: 0909 3c70 726f 7020 6b3d 226a 6f69 6e73  ..<prop k="joins
+00001720: 7479 6c65 2220 763d 2262 6576 656c 222f  tyle" v="bevel"/
+00001730: 3e0a 0909 0909 0909 093c 7072 6f70 206b  >........<prop k
+00001740: 3d22 6c69 6e65 5f63 6f6c 6f72 2220 763d  ="line_color" v=
+00001750: 2231 322c 3234 362c 302c 3235 3522 2f3e  "12,246,0,255"/>
+00001760: 0a09 0909 0909 0909 3c70 726f 7020 6b3d  ........<prop k=
+00001770: 226c 696e 655f 7374 796c 6522 2076 3d22  "line_style" v="
+00001780: 736f 6c69 6422 2f3e 0a09 0909 0909 0909  solid"/>........
+00001790: 3c70 726f 7020 6b3d 226c 696e 655f 7769  <prop k="line_wi
+000017a0: 6474 6822 2076 3d22 302e 3322 2f3e 0a09  dth" v="0.3"/>..
+000017b0: 0909 0909 0909 3c70 726f 7020 6b3d 226c  ......<prop k="l
+000017c0: 696e 655f 7769 6474 685f 756e 6974 2220  ine_width_unit" 
+000017d0: 763d 224d 4d22 2f3e 0a09 0909 0909 0909  v="MM"/>........
+000017e0: 3c70 726f 7020 6b3d 226f 6666 7365 7422  <prop k="offset"
+000017f0: 2076 3d22 3022 2f3e 0a09 0909 0909 0909   v="0"/>........
+00001800: 3c70 726f 7020 6b3d 226f 6666 7365 745f  <prop k="offset_
+00001810: 6d61 705f 756e 6974 5f73 6361 6c65 2220  map_unit_scale" 
+00001820: 763d 2233 783a 302c 302c 302c 302c 302c  v="3x:0,0,0,0,0,
+00001830: 3022 2f3e 0a09 0909 0909 0909 3c70 726f  0"/>........<pro
+00001840: 7020 6b3d 226f 6666 7365 745f 756e 6974  p k="offset_unit
+00001850: 2220 763d 224d 4d22 2f3e 0a09 0909 0909  " v="MM"/>......
+00001860: 0909 3c70 726f 7020 6b3d 2272 696e 675f  ..<prop k="ring_
+00001870: 6669 6c74 6572 2220 763d 2230 222f 3e0a  filter" v="0"/>.
+00001880: 0909 0909 0909 093c 7072 6f70 206b 3d22  .......<prop k="
+00001890: 7472 696d 5f64 6973 7461 6e63 655f 656e  trim_distance_en
+000018a0: 6422 2076 3d22 3022 2f3e 0a09 0909 0909  d" v="0"/>......
+000018b0: 0909 3c70 726f 7020 6b3d 2274 7269 6d5f  ..<prop k="trim_
+000018c0: 6469 7374 616e 6365 5f65 6e64 5f6d 6170  distance_end_map
+000018d0: 5f75 6e69 745f 7363 616c 6522 2076 3d22  _unit_scale" v="
+000018e0: 3378 3a30 2c30 2c30 2c30 2c30 2c30 222f  3x:0,0,0,0,0,0"/
+000018f0: 3e0a 0909 0909 0909 093c 7072 6f70 206b  >........<prop k
+00001900: 3d22 7472 696d 5f64 6973 7461 6e63 655f  ="trim_distance_
+00001910: 656e 645f 756e 6974 2220 763d 224d 4d22  end_unit" v="MM"
+00001920: 2f3e 0a09 0909 0909 0909 3c70 726f 7020  />........<prop 
+00001930: 6b3d 2274 7269 6d5f 6469 7374 616e 6365  k="trim_distance
+00001940: 5f73 7461 7274 2220 763d 2230 222f 3e0a  _start" v="0"/>.
+00001950: 0909 0909 0909 093c 7072 6f70 206b 3d22  .......<prop k="
+00001960: 7472 696d 5f64 6973 7461 6e63 655f 7374  trim_distance_st
+00001970: 6172 745f 6d61 705f 756e 6974 5f73 6361  art_map_unit_sca
+00001980: 6c65 2220 763d 2233 783a 302c 302c 302c  le" v="3x:0,0,0,
+00001990: 302c 302c 3022 2f3e 0a09 0909 0909 0909  0,0,0"/>........
+000019a0: 3c70 726f 7020 6b3d 2274 7269 6d5f 6469  <prop k="trim_di
+000019b0: 7374 616e 6365 5f73 7461 7274 5f75 6e69  stance_start_uni
+000019c0: 7422 2076 3d22 4d4d 222f 3e0a 0909 0909  t" v="MM"/>.....
+000019d0: 0909 093c 7072 6f70 206b 3d22 7477 6561  ...<prop k="twea
+000019e0: 6b5f 6461 7368 5f70 6174 7465 726e 5f6f  k_dash_pattern_o
+000019f0: 6e5f 636f 726e 6572 7322 2076 3d22 3022  n_corners" v="0"
+00001a00: 2f3e 0a09 0909 0909 0909 3c70 726f 7020  />........<prop 
+00001a10: 6b3d 2275 7365 5f63 7573 746f 6d5f 6461  k="use_custom_da
+00001a20: 7368 2220 763d 2230 222f 3e0a 0909 0909  sh" v="0"/>.....
+00001a30: 0909 093c 7072 6f70 206b 3d22 7769 6474  ...<prop k="widt
+00001a40: 685f 6d61 705f 756e 6974 5f73 6361 6c65  h_map_unit_scale
+00001a50: 2220 763d 2233 783a 302c 302c 302c 302c  " v="3x:0,0,0,0,
+00001a60: 302c 3022 2f3e 0a09 0909 0909 0909 3c64  0,0"/>........<d
+00001a70: 6174 615f 6465 6669 6e65 645f 7072 6f70  ata_defined_prop
+00001a80: 6572 7469 6573 3e0a 0909 0909 0909 0909  erties>.........
+00001a90: 3c4f 7074 696f 6e20 7479 7065 3d22 4d61  <Option type="Ma
+00001aa0: 7022 3e0a 0909 0909 0909 0909 093c 4f70  p">..........<Op
+00001ab0: 7469 6f6e 206e 616d 653d 226e 616d 6522  tion name="name"
+00001ac0: 2076 616c 7565 3d22 2220 7479 7065 3d22   value="" type="
+00001ad0: 5153 7472 696e 6722 2f3e 0a09 0909 0909  QString"/>......
+00001ae0: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
+00001af0: 3d22 7072 6f70 6572 7469 6573 222f 3e0a  ="properties"/>.
+00001b00: 0909 0909 0909 0909 093c 4f70 7469 6f6e  .........<Option
+00001b10: 206e 616d 653d 2274 7970 6522 2076 616c   name="type" val
+00001b20: 7565 3d22 636f 6c6c 6563 7469 6f6e 2220  ue="collection" 
+00001b30: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
+00001b40: 0a09 0909 0909 0909 093c 2f4f 7074 696f  .........</Optio
+00001b50: 6e3e 0a09 0909 0909 0909 3c2f 6461 7461  n>........</data
+00001b60: 5f64 6566 696e 6564 5f70 726f 7065 7274  _defined_propert
+00001b70: 6965 733e 0a09 0909 0909 093c 2f6c 6179  ies>.......</lay
+00001b80: 6572 3e0a 0909 0909 093c 2f73 796d 626f  er>......</symbo
+00001b90: 6c3e 0a09 0909 093c 2f6c 6179 6572 3e0a  l>.....</layer>.
+00001ba0: 0909 0909 3c6c 6179 6572 2065 6e61 626c  ....<layer enabl
+00001bb0: 6564 3d22 3122 2063 6c61 7373 3d22 5369  ed="1" class="Si
+00001bc0: 6d70 6c65 4c69 6e65 2220 6c6f 636b 6564  mpleLine" locked
+00001bd0: 3d22 3022 2070 6173 733d 2230 223e 0a09  ="0" pass="0">..
+00001be0: 0909 0909 3c4f 7074 696f 6e20 7479 7065  ....<Option type
+00001bf0: 3d22 4d61 7022 3e0a 0909 0909 0909 3c4f  ="Map">.......<O
+00001c00: 7074 696f 6e20 6e61 6d65 3d22 616c 6967  ption name="alig
+00001c10: 6e5f 6461 7368 5f70 6174 7465 726e 2220  n_dash_pattern" 
+00001c20: 7661 6c75 653d 2230 2220 7479 7065 3d22  value="0" type="
+00001c30: 5153 7472 696e 6722 2f3e 0a09 0909 0909  QString"/>......
+00001c40: 093c 4f70 7469 6f6e 206e 616d 653d 2263  .<Option name="c
+00001c50: 6170 7374 796c 6522 2076 616c 7565 3d22  apstyle" value="
+00001c60: 7371 7561 7265 2220 7479 7065 3d22 5153  square" type="QS
+00001c70: 7472 696e 6722 2f3e 0a09 0909 0909 093c  tring"/>.......<
+00001c80: 4f70 7469 6f6e 206e 616d 653d 2263 7573  Option name="cus
+00001c90: 746f 6d64 6173 6822 2076 616c 7565 3d22  tomdash" value="
+00001ca0: 353b 3222 2074 7970 653d 2251 5374 7269  5;2" type="QStri
+00001cb0: 6e67 222f 3e0a 0909 0909 0909 3c4f 7074  ng"/>.......<Opt
+00001cc0: 696f 6e20 6e61 6d65 3d22 6375 7374 6f6d  ion name="custom
+00001cd0: 6461 7368 5f6d 6170 5f75 6e69 745f 7363  dash_map_unit_sc
+00001ce0: 616c 6522 2076 616c 7565 3d22 3378 3a30  ale" value="3x:0
+00001cf0: 2c30 2c30 2c30 2c30 2c30 2220 7479 7065  ,0,0,0,0,0" type
+00001d00: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+00001d10: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
+00001d20: 2263 7573 746f 6d64 6173 685f 756e 6974  "customdash_unit
+00001d30: 2220 7661 6c75 653d 224d 4d22 2074 7970  " value="MM" typ
+00001d40: 653d 2251 5374 7269 6e67 222f 3e0a 0909  e="QString"/>...
+00001d50: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
+00001d60: 3d22 6461 7368 5f70 6174 7465 726e 5f6f  ="dash_pattern_o
+00001d70: 6666 7365 7422 2076 616c 7565 3d22 3022  ffset" value="0"
+00001d80: 2074 7970 653d 2251 5374 7269 6e67 222f   type="QString"/
+00001d90: 3e0a 0909 0909 0909 3c4f 7074 696f 6e20  >.......<Option 
+00001da0: 6e61 6d65 3d22 6461 7368 5f70 6174 7465  name="dash_patte
+00001db0: 726e 5f6f 6666 7365 745f 6d61 705f 756e  rn_offset_map_un
+00001dc0: 6974 5f73 6361 6c65 2220 7661 6c75 653d  it_scale" value=
+00001dd0: 2233 783a 302c 302c 302c 302c 302c 3022  "3x:0,0,0,0,0,0"
+00001de0: 2074 7970 653d 2251 5374 7269 6e67 222f   type="QString"/
+00001df0: 3e0a 0909 0909 0909 3c4f 7074 696f 6e20  >.......<Option 
+00001e00: 6e61 6d65 3d22 6461 7368 5f70 6174 7465  name="dash_patte
+00001e10: 726e 5f6f 6666 7365 745f 756e 6974 2220  rn_offset_unit" 
+00001e20: 7661 6c75 653d 224d 4d22 2074 7970 653d  value="MM" type=
+00001e30: 2251 5374 7269 6e67 222f 3e0a 0909 0909  "QString"/>.....
+00001e40: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
+00001e50: 6472 6177 5f69 6e73 6964 655f 706f 6c79  draw_inside_poly
+00001e60: 676f 6e22 2076 616c 7565 3d22 3022 2074  gon" value="0" t
+00001e70: 7970 653d 2251 5374 7269 6e67 222f 3e0a  ype="QString"/>.
+00001e80: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
+00001e90: 6d65 3d22 6a6f 696e 7374 796c 6522 2076  me="joinstyle" v
+00001ea0: 616c 7565 3d22 6265 7665 6c22 2074 7970  alue="bevel" typ
+00001eb0: 653d 2251 5374 7269 6e67 222f 3e0a 0909  e="QString"/>...
+00001ec0: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
+00001ed0: 3d22 6c69 6e65 5f63 6f6c 6f72 2220 7661  ="line_color" va
+00001ee0: 6c75 653d 2231 322c 3234 362c 302c 3235  lue="12,246,0,25
+00001ef0: 3522 2074 7970 653d 2251 5374 7269 6e67  5" type="QString
+00001f00: 222f 3e0a 0909 0909 0909 3c4f 7074 696f  "/>.......<Optio
+00001f10: 6e20 6e61 6d65 3d22 6c69 6e65 5f73 7479  n name="line_sty
+00001f20: 6c65 2220 7661 6c75 653d 2273 6f6c 6964  le" value="solid
+00001f30: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
+00001f40: 2f3e 0a09 0909 0909 093c 4f70 7469 6f6e  />.......<Option
+00001f50: 206e 616d 653d 226c 696e 655f 7769 6474   name="line_widt
+00001f60: 6822 2076 616c 7565 3d22 302e 3436 2220  h" value="0.46" 
+00001f70: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
+00001f80: 0a09 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
+00001f90: 616d 653d 226c 696e 655f 7769 6474 685f  ame="line_width_
+00001fa0: 756e 6974 2220 7661 6c75 653d 224d 4d22  unit" value="MM"
+00001fb0: 2074 7970 653d 2251 5374 7269 6e67 222f   type="QString"/
+00001fc0: 3e0a 0909 0909 0909 3c4f 7074 696f 6e20  >.......<Option 
+00001fd0: 6e61 6d65 3d22 6f66 6673 6574 2220 7661  name="offset" va
+00001fe0: 6c75 653d 2230 2220 7479 7065 3d22 5153  lue="0" type="QS
+00001ff0: 7472 696e 6722 2f3e 0a09 0909 0909 093c  tring"/>.......<
+00002000: 4f70 7469 6f6e 206e 616d 653d 226f 6666  Option name="off
+00002010: 7365 745f 6d61 705f 756e 6974 5f73 6361  set_map_unit_sca
+00002020: 6c65 2220 7661 6c75 653d 2233 783a 302c  le" value="3x:0,
+00002030: 302c 302c 302c 302c 3022 2074 7970 653d  0,0,0,0,0" type=
+00002040: 2251 5374 7269 6e67 222f 3e0a 0909 0909  "QString"/>.....
+00002050: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
+00002060: 6f66 6673 6574 5f75 6e69 7422 2076 616c  offset_unit" val
+00002070: 7565 3d22 4d4d 2220 7479 7065 3d22 5153  ue="MM" type="QS
+00002080: 7472 696e 6722 2f3e 0a09 0909 0909 093c  tring"/>.......<
+00002090: 4f70 7469 6f6e 206e 616d 653d 2272 696e  Option name="rin
+000020a0: 675f 6669 6c74 6572 2220 7661 6c75 653d  g_filter" value=
+000020b0: 2230 2220 7479 7065 3d22 5153 7472 696e  "0" type="QStrin
+000020c0: 6722 2f3e 0a09 0909 0909 093c 4f70 7469  g"/>.......<Opti
+000020d0: 6f6e 206e 616d 653d 2274 7269 6d5f 6469  on name="trim_di
+000020e0: 7374 616e 6365 5f65 6e64 2220 7661 6c75  stance_end" valu
+000020f0: 653d 2230 2220 7479 7065 3d22 5153 7472  e="0" type="QStr
+00002100: 696e 6722 2f3e 0a09 0909 0909 093c 4f70  ing"/>.......<Op
+00002110: 7469 6f6e 206e 616d 653d 2274 7269 6d5f  tion name="trim_
+00002120: 6469 7374 616e 6365 5f65 6e64 5f6d 6170  distance_end_map
+00002130: 5f75 6e69 745f 7363 616c 6522 2076 616c  _unit_scale" val
+00002140: 7565 3d22 3378 3a30 2c30 2c30 2c30 2c30  ue="3x:0,0,0,0,0
+00002150: 2c30 2220 7479 7065 3d22 5153 7472 696e  ,0" type="QStrin
+00002160: 6722 2f3e 0a09 0909 0909 093c 4f70 7469  g"/>.......<Opti
+00002170: 6f6e 206e 616d 653d 2274 7269 6d5f 6469  on name="trim_di
+00002180: 7374 616e 6365 5f65 6e64 5f75 6e69 7422  stance_end_unit"
+00002190: 2076 616c 7565 3d22 4d4d 2220 7479 7065   value="MM" type
+000021a0: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+000021b0: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
+000021c0: 2274 7269 6d5f 6469 7374 616e 6365 5f73  "trim_distance_s
+000021d0: 7461 7274 2220 7661 6c75 653d 2230 2220  tart" value="0" 
+000021e0: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
+000021f0: 0a09 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
+00002200: 616d 653d 2274 7269 6d5f 6469 7374 616e  ame="trim_distan
+00002210: 6365 5f73 7461 7274 5f6d 6170 5f75 6e69  ce_start_map_uni
+00002220: 745f 7363 616c 6522 2076 616c 7565 3d22  t_scale" value="
+00002230: 3378 3a30 2c30 2c30 2c30 2c30 2c30 2220  3x:0,0,0,0,0,0" 
+00002240: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
+00002250: 0a09 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
+00002260: 616d 653d 2274 7269 6d5f 6469 7374 616e  ame="trim_distan
+00002270: 6365 5f73 7461 7274 5f75 6e69 7422 2076  ce_start_unit" v
+00002280: 616c 7565 3d22 4d4d 2220 7479 7065 3d22  alue="MM" type="
+00002290: 5153 7472 696e 6722 2f3e 0a09 0909 0909  QString"/>......
+000022a0: 093c 4f70 7469 6f6e 206e 616d 653d 2274  .<Option name="t
+000022b0: 7765 616b 5f64 6173 685f 7061 7474 6572  weak_dash_patter
+000022c0: 6e5f 6f6e 5f63 6f72 6e65 7273 2220 7661  n_on_corners" va
+000022d0: 6c75 653d 2230 2220 7479 7065 3d22 5153  lue="0" type="QS
+000022e0: 7472 696e 6722 2f3e 0a09 0909 0909 093c  tring"/>.......<
+000022f0: 4f70 7469 6f6e 206e 616d 653d 2275 7365  Option name="use
+00002300: 5f63 7573 746f 6d5f 6461 7368 2220 7661  _custom_dash" va
+00002310: 6c75 653d 2230 2220 7479 7065 3d22 5153  lue="0" type="QS
+00002320: 7472 696e 6722 2f3e 0a09 0909 0909 093c  tring"/>.......<
+00002330: 4f70 7469 6f6e 206e 616d 653d 2277 6964  Option name="wid
+00002340: 7468 5f6d 6170 5f75 6e69 745f 7363 616c  th_map_unit_scal
+00002350: 6522 2076 616c 7565 3d22 3378 3a30 2c30  e" value="3x:0,0
+00002360: 2c30 2c30 2c30 2c30 2220 7479 7065 3d22  ,0,0,0,0" type="
+00002370: 5153 7472 696e 6722 2f3e 0a09 0909 0909  QString"/>......
+00002380: 3c2f 4f70 7469 6f6e 3e0a 0909 0909 093c  </Option>......<
+00002390: 7072 6f70 206b 3d22 616c 6967 6e5f 6461  prop k="align_da
+000023a0: 7368 5f70 6174 7465 726e 2220 763d 2230  sh_pattern" v="0
+000023b0: 222f 3e0a 0909 0909 093c 7072 6f70 206b  "/>......<prop k
+000023c0: 3d22 6361 7073 7479 6c65 2220 763d 2273  ="capstyle" v="s
+000023d0: 7175 6172 6522 2f3e 0a09 0909 0909 3c70  quare"/>......<p
+000023e0: 726f 7020 6b3d 2263 7573 746f 6d64 6173  rop k="customdas
+000023f0: 6822 2076 3d22 353b 3222 2f3e 0a09 0909  h" v="5;2"/>....
+00002400: 0909 3c70 726f 7020 6b3d 2263 7573 746f  ..<prop k="custo
+00002410: 6d64 6173 685f 6d61 705f 756e 6974 5f73  mdash_map_unit_s
+00002420: 6361 6c65 2220 763d 2233 783a 302c 302c  cale" v="3x:0,0,
+00002430: 302c 302c 302c 3022 2f3e 0a09 0909 0909  0,0,0,0"/>......
+00002440: 3c70 726f 7020 6b3d 2263 7573 746f 6d64  <prop k="customd
+00002450: 6173 685f 756e 6974 2220 763d 224d 4d22  ash_unit" v="MM"
+00002460: 2f3e 0a09 0909 0909 3c70 726f 7020 6b3d  />......<prop k=
+00002470: 2264 6173 685f 7061 7474 6572 6e5f 6f66  "dash_pattern_of
+00002480: 6673 6574 2220 763d 2230 222f 3e0a 0909  fset" v="0"/>...
+00002490: 0909 093c 7072 6f70 206b 3d22 6461 7368  ...<prop k="dash
+000024a0: 5f70 6174 7465 726e 5f6f 6666 7365 745f  _pattern_offset_
+000024b0: 6d61 705f 756e 6974 5f73 6361 6c65 2220  map_unit_scale" 
+000024c0: 763d 2233 783a 302c 302c 302c 302c 302c  v="3x:0,0,0,0,0,
+000024d0: 3022 2f3e 0a09 0909 0909 3c70 726f 7020  0"/>......<prop 
+000024e0: 6b3d 2264 6173 685f 7061 7474 6572 6e5f  k="dash_pattern_
+000024f0: 6f66 6673 6574 5f75 6e69 7422 2076 3d22  offset_unit" v="
+00002500: 4d4d 222f 3e0a 0909 0909 093c 7072 6f70  MM"/>......<prop
+00002510: 206b 3d22 6472 6177 5f69 6e73 6964 655f   k="draw_inside_
+00002520: 706f 6c79 676f 6e22 2076 3d22 3022 2f3e  polygon" v="0"/>
+00002530: 0a09 0909 0909 3c70 726f 7020 6b3d 226a  ......<prop k="j
+00002540: 6f69 6e73 7479 6c65 2220 763d 2262 6576  oinstyle" v="bev
+00002550: 656c 222f 3e0a 0909 0909 093c 7072 6f70  el"/>......<prop
+00002560: 206b 3d22 6c69 6e65 5f63 6f6c 6f72 2220   k="line_color" 
+00002570: 763d 2231 322c 3234 362c 302c 3235 3522  v="12,246,0,255"
+00002580: 2f3e 0a09 0909 0909 3c70 726f 7020 6b3d  />......<prop k=
+00002590: 226c 696e 655f 7374 796c 6522 2076 3d22  "line_style" v="
+000025a0: 736f 6c69 6422 2f3e 0a09 0909 0909 3c70  solid"/>......<p
+000025b0: 726f 7020 6b3d 226c 696e 655f 7769 6474  rop k="line_widt
+000025c0: 6822 2076 3d22 302e 3436 222f 3e0a 0909  h" v="0.46"/>...
+000025d0: 0909 093c 7072 6f70 206b 3d22 6c69 6e65  ...<prop k="line
+000025e0: 5f77 6964 7468 5f75 6e69 7422 2076 3d22  _width_unit" v="
+000025f0: 4d4d 222f 3e0a 0909 0909 093c 7072 6f70  MM"/>......<prop
+00002600: 206b 3d22 6f66 6673 6574 2220 763d 2230   k="offset" v="0
+00002610: 222f 3e0a 0909 0909 093c 7072 6f70 206b  "/>......<prop k
+00002620: 3d22 6f66 6673 6574 5f6d 6170 5f75 6e69  ="offset_map_uni
+00002630: 745f 7363 616c 6522 2076 3d22 3378 3a30  t_scale" v="3x:0
+00002640: 2c30 2c30 2c30 2c30 2c30 222f 3e0a 0909  ,0,0,0,0,0"/>...
+00002650: 0909 093c 7072 6f70 206b 3d22 6f66 6673  ...<prop k="offs
+00002660: 6574 5f75 6e69 7422 2076 3d22 4d4d 222f  et_unit" v="MM"/
+00002670: 3e0a 0909 0909 093c 7072 6f70 206b 3d22  >......<prop k="
+00002680: 7269 6e67 5f66 696c 7465 7222 2076 3d22  ring_filter" v="
+00002690: 3022 2f3e 0a09 0909 0909 3c70 726f 7020  0"/>......<prop 
+000026a0: 6b3d 2274 7269 6d5f 6469 7374 616e 6365  k="trim_distance
+000026b0: 5f65 6e64 2220 763d 2230 222f 3e0a 0909  _end" v="0"/>...
+000026c0: 0909 093c 7072 6f70 206b 3d22 7472 696d  ...<prop k="trim
+000026d0: 5f64 6973 7461 6e63 655f 656e 645f 6d61  _distance_end_ma
+000026e0: 705f 756e 6974 5f73 6361 6c65 2220 763d  p_unit_scale" v=
+000026f0: 2233 783a 302c 302c 302c 302c 302c 3022  "3x:0,0,0,0,0,0"
+00002700: 2f3e 0a09 0909 0909 3c70 726f 7020 6b3d  />......<prop k=
+00002710: 2274 7269 6d5f 6469 7374 616e 6365 5f65  "trim_distance_e
+00002720: 6e64 5f75 6e69 7422 2076 3d22 4d4d 222f  nd_unit" v="MM"/
+00002730: 3e0a 0909 0909 093c 7072 6f70 206b 3d22  >......<prop k="
+00002740: 7472 696d 5f64 6973 7461 6e63 655f 7374  trim_distance_st
+00002750: 6172 7422 2076 3d22 3022 2f3e 0a09 0909  art" v="0"/>....
+00002760: 0909 3c70 726f 7020 6b3d 2274 7269 6d5f  ..<prop k="trim_
+00002770: 6469 7374 616e 6365 5f73 7461 7274 5f6d  distance_start_m
+00002780: 6170 5f75 6e69 745f 7363 616c 6522 2076  ap_unit_scale" v
+00002790: 3d22 3378 3a30 2c30 2c30 2c30 2c30 2c30  ="3x:0,0,0,0,0,0
+000027a0: 222f 3e0a 0909 0909 093c 7072 6f70 206b  "/>......<prop k
+000027b0: 3d22 7472 696d 5f64 6973 7461 6e63 655f  ="trim_distance_
+000027c0: 7374 6172 745f 756e 6974 2220 763d 224d  start_unit" v="M
+000027d0: 4d22 2f3e 0a09 0909 0909 3c70 726f 7020  M"/>......<prop 
+000027e0: 6b3d 2274 7765 616b 5f64 6173 685f 7061  k="tweak_dash_pa
+000027f0: 7474 6572 6e5f 6f6e 5f63 6f72 6e65 7273  ttern_on_corners
+00002800: 2220 763d 2230 222f 3e0a 0909 0909 093c  " v="0"/>......<
+00002810: 7072 6f70 206b 3d22 7573 655f 6375 7374  prop k="use_cust
+00002820: 6f6d 5f64 6173 6822 2076 3d22 3022 2f3e  om_dash" v="0"/>
+00002830: 0a09 0909 0909 3c70 726f 7020 6b3d 2277  ......<prop k="w
+00002840: 6964 7468 5f6d 6170 5f75 6e69 745f 7363  idth_map_unit_sc
+00002850: 616c 6522 2076 3d22 3378 3a30 2c30 2c30  ale" v="3x:0,0,0
+00002860: 2c30 2c30 2c30 222f 3e0a 0909 0909 093c  ,0,0,0"/>......<
+00002870: 6461 7461 5f64 6566 696e 6564 5f70 726f  data_defined_pro
+00002880: 7065 7274 6965 733e 0a09 0909 0909 093c  perties>.......<
+00002890: 4f70 7469 6f6e 2074 7970 653d 224d 6170  Option type="Map
+000028a0: 223e 0a09 0909 0909 0909 3c4f 7074 696f  ">........<Optio
+000028b0: 6e20 6e61 6d65 3d22 6e61 6d65 2220 7661  n name="name" va
+000028c0: 6c75 653d 2222 2074 7970 653d 2251 5374  lue="" type="QSt
+000028d0: 7269 6e67 222f 3e0a 0909 0909 0909 093c  ring"/>........<
+000028e0: 4f70 7469 6f6e 206e 616d 653d 2270 726f  Option name="pro
+000028f0: 7065 7274 6965 7322 2f3e 0a09 0909 0909  perties"/>......
+00002900: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
+00002910: 7479 7065 2220 7661 6c75 653d 2263 6f6c  type" value="col
+00002920: 6c65 6374 696f 6e22 2074 7970 653d 2251  lection" type="Q
+00002930: 5374 7269 6e67 222f 3e0a 0909 0909 0909  String"/>.......
+00002940: 3c2f 4f70 7469 6f6e 3e0a 0909 0909 093c  </Option>......<
+00002950: 2f64 6174 615f 6465 6669 6e65 645f 7072  /data_defined_pr
+00002960: 6f70 6572 7469 6573 3e0a 0909 0909 3c2f  operties>.....</
+00002970: 6c61 7965 723e 0a09 0909 3c2f 7379 6d62  layer>....</symb
+00002980: 6f6c 3e0a 0909 3c2f 7379 6d62 6f6c 733e  ol>...</symbols>
+00002990: 0a09 093c 726f 7461 7469 6f6e 2f3e 0a09  ...<rotation/>..
+000029a0: 093c 7369 7a65 7363 616c 652f 3e0a 093c  .<sizescale/>..<
+000029b0: 2f72 656e 6465 7265 722d 7632 3e0a 093c  /renderer-v2>..<
+000029c0: 6375 7374 6f6d 7072 6f70 6572 7469 6573  customproperties
+000029d0: 3e0a 0909 3c4f 7074 696f 6e20 7479 7065  >...<Option type
+000029e0: 3d22 4d61 7022 3e0a 0909 093c 4f70 7469  ="Map">....<Opti
+000029f0: 6f6e 206e 616d 653d 2265 6d62 6564 6465  on name="embedde
+00002a00: 6457 6964 6765 7473 2f63 6f75 6e74 2220  dWidgets/count" 
+00002a10: 7661 6c75 653d 2230 2220 7479 7065 3d22  value="0" type="
+00002a20: 696e 7422 2f3e 0a09 0909 3c4f 7074 696f  int"/>....<Optio
+00002a30: 6e20 6e61 6d65 3d22 7661 7269 6162 6c65  n name="variable
+00002a40: 4e61 6d65 7322 2f3e 0a09 0909 3c4f 7074  Names"/>....<Opt
+00002a50: 696f 6e20 6e61 6d65 3d22 7661 7269 6162  ion name="variab
+00002a60: 6c65 5661 6c75 6573 222f 3e0a 0909 3c2f  leValues"/>...</
+00002a70: 4f70 7469 6f6e 3e0a 093c 2f63 7573 746f  Option>..</custo
+00002a80: 6d70 726f 7065 7274 6965 733e 0a09 3c62  mproperties>..<b
+00002a90: 6c65 6e64 4d6f 6465 3e30 3c2f 626c 656e  lendMode>0</blen
+00002aa0: 644d 6f64 653e 0a09 3c66 6561 7475 7265  dMode>..<feature
+00002ab0: 426c 656e 644d 6f64 653e 303c 2f66 6561  BlendMode>0</fea
+00002ac0: 7475 7265 426c 656e 644d 6f64 653e 0a09  tureBlendMode>..
+00002ad0: 3c6c 6179 6572 4f70 6163 6974 793e 313c  <layerOpacity>1<
+00002ae0: 2f6c 6179 6572 4f70 6163 6974 793e 0a09  /layerOpacity>..
+00002af0: 3c53 696e 676c 6543 6174 6567 6f72 7944  <SingleCategoryD
+00002b00: 6961 6772 616d 5265 6e64 6572 6572 2061  iagramRenderer a
+00002b10: 7474 7269 6275 7465 4c65 6765 6e64 3d22  ttributeLegend="
+00002b20: 3122 2064 6961 6772 616d 5479 7065 3d22  1" diagramType="
+00002b30: 4869 7374 6f67 7261 6d22 3e0a 0909 3c44  Histogram">...<D
+00002b40: 6961 6772 616d 4361 7465 676f 7279 2077  iagramCategory w
+00002b50: 6964 7468 3d22 3135 2220 656e 6162 6c65  idth="15" enable
+00002b60: 643d 2230 2220 7065 6e41 6c70 6861 3d22  d="0" penAlpha="
+00002b70: 3235 3522 2062 6163 6b67 726f 756e 6443  255" backgroundC
+00002b80: 6f6c 6f72 3d22 2366 6666 6666 6622 206c  olor="#ffffff" l
+00002b90: 696e 6553 697a 6553 6361 6c65 3d22 3378  ineSizeScale="3x
+00002ba0: 3a30 2c30 2c30 2c30 2c30 2c30 2220 7370  :0,0,0,0,0,0" sp
+00002bb0: 6163 696e 673d 2235 2220 6d69 6e69 6d75  acing="5" minimu
+00002bc0: 6d53 697a 653d 2230 2220 7065 6e57 6964  mSize="0" penWid
+00002bd0: 7468 3d22 3022 2073 6361 6c65 4261 7365  th="0" scaleBase
+00002be0: 6456 6973 6962 696c 6974 793d 2230 2220  dVisibility="0" 
+00002bf0: 6261 7257 6964 7468 3d22 3522 206c 6162  barWidth="5" lab
+00002c00: 656c 506c 6163 656d 656e 744d 6574 686f  elPlacementMetho
+00002c10: 643d 2258 4865 6967 6874 2220 6469 7265  d="XHeight" dire
+00002c20: 6374 696f 6e3d 2230 2220 6261 636b 6772  ction="0" backgr
+00002c30: 6f75 6e64 416c 7068 613d 2232 3535 2220  oundAlpha="255" 
+00002c40: 6865 6967 6874 3d22 3135 2220 7369 7a65  height="15" size
+00002c50: 5363 616c 653d 2233 783a 302c 302c 302c  Scale="3x:0,0,0,
+00002c60: 302c 302c 3022 2073 686f 7741 7869 733d  0,0,0" showAxis=
+00002c70: 2231 2220 7370 6163 696e 6755 6e69 7453  "1" spacingUnitS
+00002c80: 6361 6c65 3d22 3378 3a30 2c30 2c30 2c30  cale="3x:0,0,0,0
+00002c90: 2c30 2c30 2220 6469 6167 7261 6d4f 7269  ,0,0" diagramOri
+00002ca0: 656e 7461 7469 6f6e 3d22 5570 2220 7065  entation="Up" pe
+00002cb0: 6e43 6f6c 6f72 3d22 2330 3030 3030 3022  nColor="#000000"
+00002cc0: 206f 7061 6369 7479 3d22 3122 206d 696e   opacity="1" min
+00002cd0: 5363 616c 6544 656e 6f6d 696e 6174 6f72  ScaleDenominator
+00002ce0: 3d22 3022 2073 7061 6369 6e67 556e 6974  ="0" spacingUnit
+00002cf0: 3d22 4d4d 2220 7363 616c 6544 6570 656e  ="MM" scaleDepen
+00002d00: 6465 6e63 793d 2241 7265 6122 2072 6f74  dency="Area" rot
+00002d10: 6174 696f 6e4f 6666 7365 743d 2232 3730  ationOffset="270
+00002d20: 2220 6c69 6e65 5369 7a65 5479 7065 3d22  " lineSizeType="
+00002d30: 4d4d 2220 7369 7a65 5479 7065 3d22 4d4d  MM" sizeType="MM
+00002d40: 2220 6d61 7853 6361 6c65 4465 6e6f 6d69  " maxScaleDenomi
+00002d50: 6e61 746f 723d 2231 652b 3038 223e 0a09  nator="1e+08">..
+00002d60: 0909 3c66 6f6e 7450 726f 7065 7274 6965  ..<fontPropertie
+00002d70: 7320 6465 7363 7269 7074 696f 6e3d 224d  s description="M
+00002d80: 5320 5368 656c 6c20 446c 6720 322c 362e  S Shell Dlg 2,6.
+00002d90: 362c 2d31 2c35 2c35 302c 302c 302c 302c  6,-1,5,50,0,0,0,
+00002da0: 302c 3022 2073 7479 6c65 3d22 222f 3e0a  0,0" style=""/>.
+00002db0: 0909 093c 6178 6973 5379 6d62 6f6c 3e0a  ...<axisSymbol>.
+00002dc0: 0909 0909 3c73 796d 626f 6c20 6e61 6d65  ....<symbol name
+00002dd0: 3d22 2220 636c 6970 5f74 6f5f 6578 7465  ="" clip_to_exte
+00002de0: 6e74 3d22 3122 2066 6f72 6365 5f72 6872  nt="1" force_rhr
+00002df0: 3d22 3022 2074 7970 653d 226c 696e 6522  ="0" type="line"
+00002e00: 2061 6c70 6861 3d22 3122 3e0a 0909 0909   alpha="1">.....
+00002e10: 093c 6461 7461 5f64 6566 696e 6564 5f70  .<data_defined_p
+00002e20: 726f 7065 7274 6965 733e 0a09 0909 0909  roperties>......
+00002e30: 093c 4f70 7469 6f6e 2074 7970 653d 224d  .<Option type="M
+00002e40: 6170 223e 0a09 0909 0909 0909 3c4f 7074  ap">........<Opt
+00002e50: 696f 6e20 6e61 6d65 3d22 6e61 6d65 2220  ion name="name" 
+00002e60: 7661 6c75 653d 2222 2074 7970 653d 2251  value="" type="Q
+00002e70: 5374 7269 6e67 222f 3e0a 0909 0909 0909  String"/>.......
+00002e80: 093c 4f70 7469 6f6e 206e 616d 653d 2270  .<Option name="p
+00002e90: 726f 7065 7274 6965 7322 2f3e 0a09 0909  roperties"/>....
+00002ea0: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
+00002eb0: 3d22 7479 7065 2220 7661 6c75 653d 2263  ="type" value="c
+00002ec0: 6f6c 6c65 6374 696f 6e22 2074 7970 653d  ollection" type=
+00002ed0: 2251 5374 7269 6e67 222f 3e0a 0909 0909  "QString"/>.....
+00002ee0: 0909 3c2f 4f70 7469 6f6e 3e0a 0909 0909  ..</Option>.....
+00002ef0: 093c 2f64 6174 615f 6465 6669 6e65 645f  .</data_defined_
+00002f00: 7072 6f70 6572 7469 6573 3e0a 0909 0909  properties>.....
+00002f10: 093c 6c61 7965 7220 656e 6162 6c65 643d  .<layer enabled=
+00002f20: 2231 2220 636c 6173 733d 2253 696d 706c  "1" class="Simpl
+00002f30: 654c 696e 6522 206c 6f63 6b65 643d 2230  eLine" locked="0
+00002f40: 2220 7061 7373 3d22 3022 3e0a 0909 0909  " pass="0">.....
+00002f50: 0909 3c4f 7074 696f 6e20 7479 7065 3d22  ..<Option type="
+00002f60: 4d61 7022 3e0a 0909 0909 0909 093c 4f70  Map">........<Op
+00002f70: 7469 6f6e 206e 616d 653d 2261 6c69 676e  tion name="align
+00002f80: 5f64 6173 685f 7061 7474 6572 6e22 2076  _dash_pattern" v
+00002f90: 616c 7565 3d22 3022 2074 7970 653d 2251  alue="0" type="Q
+00002fa0: 5374 7269 6e67 222f 3e0a 0909 0909 0909  String"/>.......
+00002fb0: 093c 4f70 7469 6f6e 206e 616d 653d 2263  .<Option name="c
+00002fc0: 6170 7374 796c 6522 2076 616c 7565 3d22  apstyle" value="
+00002fd0: 7371 7561 7265 2220 7479 7065 3d22 5153  square" type="QS
+00002fe0: 7472 696e 6722 2f3e 0a09 0909 0909 0909  tring"/>........
+00002ff0: 3c4f 7074 696f 6e20 6e61 6d65 3d22 6375  <Option name="cu
+00003000: 7374 6f6d 6461 7368 2220 7661 6c75 653d  stomdash" value=
+00003010: 2235 3b32 2220 7479 7065 3d22 5153 7472  "5;2" type="QStr
+00003020: 696e 6722 2f3e 0a09 0909 0909 0909 3c4f  ing"/>........<O
+00003030: 7074 696f 6e20 6e61 6d65 3d22 6375 7374  ption name="cust
+00003040: 6f6d 6461 7368 5f6d 6170 5f75 6e69 745f  omdash_map_unit_
+00003050: 7363 616c 6522 2076 616c 7565 3d22 3378  scale" value="3x
+00003060: 3a30 2c30 2c30 2c30 2c30 2c30 2220 7479  :0,0,0,0,0,0" ty
+00003070: 7065 3d22 5153 7472 696e 6722 2f3e 0a09  pe="QString"/>..
+00003080: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
+00003090: 6d65 3d22 6375 7374 6f6d 6461 7368 5f75  me="customdash_u
+000030a0: 6e69 7422 2076 616c 7565 3d22 4d4d 2220  nit" value="MM" 
+000030b0: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
+000030c0: 0a09 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
+000030d0: 6e61 6d65 3d22 6461 7368 5f70 6174 7465  name="dash_patte
+000030e0: 726e 5f6f 6666 7365 7422 2076 616c 7565  rn_offset" value
+000030f0: 3d22 3022 2074 7970 653d 2251 5374 7269  ="0" type="QStri
+00003100: 6e67 222f 3e0a 0909 0909 0909 093c 4f70  ng"/>........<Op
+00003110: 7469 6f6e 206e 616d 653d 2264 6173 685f  tion name="dash_
+00003120: 7061 7474 6572 6e5f 6f66 6673 6574 5f6d  pattern_offset_m
 00003130: 6170 5f75 6e69 745f 7363 616c 6522 2076  ap_unit_scale" v
 00003140: 616c 7565 3d22 3378 3a30 2c30 2c30 2c30  alue="3x:0,0,0,0
 00003150: 2c30 2c30 2220 7479 7065 3d22 5153 7472  ,0,0" type="QStr
-00003160: 696e 6722 2f3e 0d0a 0909 0909 0909 093c  ing"/>.........<
-00003170: 4f70 7469 6f6e 206e 616d 653d 2263 7573  Option name="cus
-00003180: 746f 6d64 6173 685f 756e 6974 2220 7661  tomdash_unit" va
-00003190: 6c75 653d 224d 4d22 2074 7970 653d 2251  lue="MM" type="Q
-000031a0: 5374 7269 6e67 222f 3e0d 0a09 0909 0909  String"/>.......
-000031b0: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
-000031c0: 6461 7368 5f70 6174 7465 726e 5f6f 6666  dash_pattern_off
-000031d0: 7365 7422 2076 616c 7565 3d22 3022 2074  set" value="0" t
-000031e0: 7970 653d 2251 5374 7269 6e67 222f 3e0d  ype="QString"/>.
-000031f0: 0a09 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
-00003200: 6e61 6d65 3d22 6461 7368 5f70 6174 7465  name="dash_patte
-00003210: 726e 5f6f 6666 7365 745f 6d61 705f 756e  rn_offset_map_un
-00003220: 6974 5f73 6361 6c65 2220 7661 6c75 653d  it_scale" value=
-00003230: 2233 783a 302c 302c 302c 302c 302c 3022  "3x:0,0,0,0,0,0"
-00003240: 2074 7970 653d 2251 5374 7269 6e67 222f   type="QString"/
-00003250: 3e0d 0a09 0909 0909 0909 3c4f 7074 696f  >.........<Optio
-00003260: 6e20 6e61 6d65 3d22 6461 7368 5f70 6174  n name="dash_pat
-00003270: 7465 726e 5f6f 6666 7365 745f 756e 6974  tern_offset_unit
-00003280: 2220 7661 6c75 653d 224d 4d22 2074 7970  " value="MM" typ
-00003290: 653d 2251 5374 7269 6e67 222f 3e0d 0a09  e="QString"/>...
-000032a0: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
-000032b0: 6d65 3d22 6472 6177 5f69 6e73 6964 655f  me="draw_inside_
-000032c0: 706f 6c79 676f 6e22 2076 616c 7565 3d22  polygon" value="
-000032d0: 3022 2074 7970 653d 2251 5374 7269 6e67  0" type="QString
-000032e0: 222f 3e0d 0a09 0909 0909 0909 3c4f 7074  "/>.........<Opt
-000032f0: 696f 6e20 6e61 6d65 3d22 6a6f 696e 7374  ion name="joinst
-00003300: 796c 6522 2076 616c 7565 3d22 6265 7665  yle" value="beve
-00003310: 6c22 2074 7970 653d 2251 5374 7269 6e67  l" type="QString
-00003320: 222f 3e0d 0a09 0909 0909 0909 3c4f 7074  "/>.........<Opt
-00003330: 696f 6e20 6e61 6d65 3d22 6c69 6e65 5f63  ion name="line_c
-00003340: 6f6c 6f72 2220 7661 6c75 653d 2233 352c  olor" value="35,
-00003350: 3335 2c33 352c 3235 3522 2074 7970 653d  35,35,255" type=
-00003360: 2251 5374 7269 6e67 222f 3e0d 0a09 0909  "QString"/>.....
-00003370: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
-00003380: 3d22 6c69 6e65 5f73 7479 6c65 2220 7661  ="line_style" va
-00003390: 6c75 653d 2273 6f6c 6964 2220 7479 7065  lue="solid" type
-000033a0: 3d22 5153 7472 696e 6722 2f3e 0d0a 0909  ="QString"/>....
-000033b0: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
-000033c0: 653d 226c 696e 655f 7769 6474 6822 2076  e="line_width" v
-000033d0: 616c 7565 3d22 302e 3236 2220 7479 7065  alue="0.26" type
-000033e0: 3d22 5153 7472 696e 6722 2f3e 0d0a 0909  ="QString"/>....
-000033f0: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
-00003400: 653d 226c 696e 655f 7769 6474 685f 756e  e="line_width_un
-00003410: 6974 2220 7661 6c75 653d 224d 4d22 2074  it" value="MM" t
-00003420: 7970 653d 2251 5374 7269 6e67 222f 3e0d  ype="QString"/>.
-00003430: 0a09 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
-00003440: 6e61 6d65 3d22 6f66 6673 6574 2220 7661  name="offset" va
-00003450: 6c75 653d 2230 2220 7479 7065 3d22 5153  lue="0" type="QS
-00003460: 7472 696e 6722 2f3e 0d0a 0909 0909 0909  tring"/>........
-00003470: 093c 4f70 7469 6f6e 206e 616d 653d 226f  .<Option name="o
-00003480: 6666 7365 745f 6d61 705f 756e 6974 5f73  ffset_map_unit_s
-00003490: 6361 6c65 2220 7661 6c75 653d 2233 783a  cale" value="3x:
-000034a0: 302c 302c 302c 302c 302c 3022 2074 7970  0,0,0,0,0,0" typ
-000034b0: 653d 2251 5374 7269 6e67 222f 3e0d 0a09  e="QString"/>...
-000034c0: 0909 0909 0909 3c4f 7074 696f 6e20 6e61  ......<Option na
-000034d0: 6d65 3d22 6f66 6673 6574 5f75 6e69 7422  me="offset_unit"
-000034e0: 2076 616c 7565 3d22 4d4d 2220 7479 7065   value="MM" type
-000034f0: 3d22 5153 7472 696e 6722 2f3e 0d0a 0909  ="QString"/>....
-00003500: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
-00003510: 653d 2272 696e 675f 6669 6c74 6572 2220  e="ring_filter" 
-00003520: 7661 6c75 653d 2230 2220 7479 7065 3d22  value="0" type="
-00003530: 5153 7472 696e 6722 2f3e 0d0a 0909 0909  QString"/>......
-00003540: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
-00003550: 2274 7269 6d5f 6469 7374 616e 6365 5f65  "trim_distance_e
-00003560: 6e64 2220 7661 6c75 653d 2230 2220 7479  nd" value="0" ty
-00003570: 7065 3d22 5153 7472 696e 6722 2f3e 0d0a  pe="QString"/>..
-00003580: 0909 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-00003590: 616d 653d 2274 7269 6d5f 6469 7374 616e  ame="trim_distan
-000035a0: 6365 5f65 6e64 5f6d 6170 5f75 6e69 745f  ce_end_map_unit_
-000035b0: 7363 616c 6522 2076 616c 7565 3d22 3378  scale" value="3x
-000035c0: 3a30 2c30 2c30 2c30 2c30 2c30 2220 7479  :0,0,0,0,0,0" ty
-000035d0: 7065 3d22 5153 7472 696e 6722 2f3e 0d0a  pe="QString"/>..
-000035e0: 0909 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-000035f0: 616d 653d 2274 7269 6d5f 6469 7374 616e  ame="trim_distan
-00003600: 6365 5f65 6e64 5f75 6e69 7422 2076 616c  ce_end_unit" val
-00003610: 7565 3d22 4d4d 2220 7479 7065 3d22 5153  ue="MM" type="QS
-00003620: 7472 696e 6722 2f3e 0d0a 0909 0909 0909  tring"/>........
-00003630: 093c 4f70 7469 6f6e 206e 616d 653d 2274  .<Option name="t
-00003640: 7269 6d5f 6469 7374 616e 6365 5f73 7461  rim_distance_sta
-00003650: 7274 2220 7661 6c75 653d 2230 2220 7479  rt" value="0" ty
-00003660: 7065 3d22 5153 7472 696e 6722 2f3e 0d0a  pe="QString"/>..
+00003160: 696e 6722 2f3e 0a09 0909 0909 0909 3c4f  ing"/>........<O
+00003170: 7074 696f 6e20 6e61 6d65 3d22 6461 7368  ption name="dash
+00003180: 5f70 6174 7465 726e 5f6f 6666 7365 745f  _pattern_offset_
+00003190: 756e 6974 2220 7661 6c75 653d 224d 4d22  unit" value="MM"
+000031a0: 2074 7970 653d 2251 5374 7269 6e67 222f   type="QString"/
+000031b0: 3e0a 0909 0909 0909 093c 4f70 7469 6f6e  >........<Option
+000031c0: 206e 616d 653d 2264 7261 775f 696e 7369   name="draw_insi
+000031d0: 6465 5f70 6f6c 7967 6f6e 2220 7661 6c75  de_polygon" valu
+000031e0: 653d 2230 2220 7479 7065 3d22 5153 7472  e="0" type="QStr
+000031f0: 696e 6722 2f3e 0a09 0909 0909 0909 3c4f  ing"/>........<O
+00003200: 7074 696f 6e20 6e61 6d65 3d22 6a6f 696e  ption name="join
+00003210: 7374 796c 6522 2076 616c 7565 3d22 6265  style" value="be
+00003220: 7665 6c22 2074 7970 653d 2251 5374 7269  vel" type="QStri
+00003230: 6e67 222f 3e0a 0909 0909 0909 093c 4f70  ng"/>........<Op
+00003240: 7469 6f6e 206e 616d 653d 226c 696e 655f  tion name="line_
+00003250: 636f 6c6f 7222 2076 616c 7565 3d22 3335  color" value="35
+00003260: 2c33 352c 3335 2c32 3535 2220 7479 7065  ,35,35,255" type
+00003270: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+00003280: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
+00003290: 3d22 6c69 6e65 5f73 7479 6c65 2220 7661  ="line_style" va
+000032a0: 6c75 653d 2273 6f6c 6964 2220 7479 7065  lue="solid" type
+000032b0: 3d22 5153 7472 696e 6722 2f3e 0a09 0909  ="QString"/>....
+000032c0: 0909 0909 3c4f 7074 696f 6e20 6e61 6d65  ....<Option name
+000032d0: 3d22 6c69 6e65 5f77 6964 7468 2220 7661  ="line_width" va
+000032e0: 6c75 653d 2230 2e32 3622 2074 7970 653d  lue="0.26" type=
+000032f0: 2251 5374 7269 6e67 222f 3e0a 0909 0909  "QString"/>.....
+00003300: 0909 093c 4f70 7469 6f6e 206e 616d 653d  ...<Option name=
+00003310: 226c 696e 655f 7769 6474 685f 756e 6974  "line_width_unit
+00003320: 2220 7661 6c75 653d 224d 4d22 2074 7970  " value="MM" typ
+00003330: 653d 2251 5374 7269 6e67 222f 3e0a 0909  e="QString"/>...
+00003340: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
+00003350: 653d 226f 6666 7365 7422 2076 616c 7565  e="offset" value
+00003360: 3d22 3022 2074 7970 653d 2251 5374 7269  ="0" type="QStri
+00003370: 6e67 222f 3e0a 0909 0909 0909 093c 4f70  ng"/>........<Op
+00003380: 7469 6f6e 206e 616d 653d 226f 6666 7365  tion name="offse
+00003390: 745f 6d61 705f 756e 6974 5f73 6361 6c65  t_map_unit_scale
+000033a0: 2220 7661 6c75 653d 2233 783a 302c 302c  " value="3x:0,0,
+000033b0: 302c 302c 302c 3022 2074 7970 653d 2251  0,0,0,0" type="Q
+000033c0: 5374 7269 6e67 222f 3e0a 0909 0909 0909  String"/>.......
+000033d0: 093c 4f70 7469 6f6e 206e 616d 653d 226f  .<Option name="o
+000033e0: 6666 7365 745f 756e 6974 2220 7661 6c75  ffset_unit" valu
+000033f0: 653d 224d 4d22 2074 7970 653d 2251 5374  e="MM" type="QSt
+00003400: 7269 6e67 222f 3e0a 0909 0909 0909 093c  ring"/>........<
+00003410: 4f70 7469 6f6e 206e 616d 653d 2272 696e  Option name="rin
+00003420: 675f 6669 6c74 6572 2220 7661 6c75 653d  g_filter" value=
+00003430: 2230 2220 7479 7065 3d22 5153 7472 696e  "0" type="QStrin
+00003440: 6722 2f3e 0a09 0909 0909 0909 3c4f 7074  g"/>........<Opt
+00003450: 696f 6e20 6e61 6d65 3d22 7472 696d 5f64  ion name="trim_d
+00003460: 6973 7461 6e63 655f 656e 6422 2076 616c  istance_end" val
+00003470: 7565 3d22 3022 2074 7970 653d 2251 5374  ue="0" type="QSt
+00003480: 7269 6e67 222f 3e0a 0909 0909 0909 093c  ring"/>........<
+00003490: 4f70 7469 6f6e 206e 616d 653d 2274 7269  Option name="tri
+000034a0: 6d5f 6469 7374 616e 6365 5f65 6e64 5f6d  m_distance_end_m
+000034b0: 6170 5f75 6e69 745f 7363 616c 6522 2076  ap_unit_scale" v
+000034c0: 616c 7565 3d22 3378 3a30 2c30 2c30 2c30  alue="3x:0,0,0,0
+000034d0: 2c30 2c30 2220 7479 7065 3d22 5153 7472  ,0,0" type="QStr
+000034e0: 696e 6722 2f3e 0a09 0909 0909 0909 3c4f  ing"/>........<O
+000034f0: 7074 696f 6e20 6e61 6d65 3d22 7472 696d  ption name="trim
+00003500: 5f64 6973 7461 6e63 655f 656e 645f 756e  _distance_end_un
+00003510: 6974 2220 7661 6c75 653d 224d 4d22 2074  it" value="MM" t
+00003520: 7970 653d 2251 5374 7269 6e67 222f 3e0a  ype="QString"/>.
+00003530: 0909 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
+00003540: 616d 653d 2274 7269 6d5f 6469 7374 616e  ame="trim_distan
+00003550: 6365 5f73 7461 7274 2220 7661 6c75 653d  ce_start" value=
+00003560: 2230 2220 7479 7065 3d22 5153 7472 696e  "0" type="QStrin
+00003570: 6722 2f3e 0a09 0909 0909 0909 3c4f 7074  g"/>........<Opt
+00003580: 696f 6e20 6e61 6d65 3d22 7472 696d 5f64  ion name="trim_d
+00003590: 6973 7461 6e63 655f 7374 6172 745f 6d61  istance_start_ma
+000035a0: 705f 756e 6974 5f73 6361 6c65 2220 7661  p_unit_scale" va
+000035b0: 6c75 653d 2233 783a 302c 302c 302c 302c  lue="3x:0,0,0,0,
+000035c0: 302c 3022 2074 7970 653d 2251 5374 7269  0,0" type="QStri
+000035d0: 6e67 222f 3e0a 0909 0909 0909 093c 4f70  ng"/>........<Op
+000035e0: 7469 6f6e 206e 616d 653d 2274 7269 6d5f  tion name="trim_
+000035f0: 6469 7374 616e 6365 5f73 7461 7274 5f75  distance_start_u
+00003600: 6e69 7422 2076 616c 7565 3d22 4d4d 2220  nit" value="MM" 
+00003610: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
+00003620: 0a09 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
+00003630: 6e61 6d65 3d22 7477 6561 6b5f 6461 7368  name="tweak_dash
+00003640: 5f70 6174 7465 726e 5f6f 6e5f 636f 726e  _pattern_on_corn
+00003650: 6572 7322 2076 616c 7565 3d22 3022 2074  ers" value="0" t
+00003660: 7970 653d 2251 5374 7269 6e67 222f 3e0a  ype="QString"/>.
 00003670: 0909 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-00003680: 616d 653d 2274 7269 6d5f 6469 7374 616e  ame="trim_distan
-00003690: 6365 5f73 7461 7274 5f6d 6170 5f75 6e69  ce_start_map_uni
-000036a0: 745f 7363 616c 6522 2076 616c 7565 3d22  t_scale" value="
-000036b0: 3378 3a30 2c30 2c30 2c30 2c30 2c30 2220  3x:0,0,0,0,0,0" 
-000036c0: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
-000036d0: 0d0a 0909 0909 0909 093c 4f70 7469 6f6e  .........<Option
-000036e0: 206e 616d 653d 2274 7269 6d5f 6469 7374   name="trim_dist
-000036f0: 616e 6365 5f73 7461 7274 5f75 6e69 7422  ance_start_unit"
-00003700: 2076 616c 7565 3d22 4d4d 2220 7479 7065   value="MM" type
-00003710: 3d22 5153 7472 696e 6722 2f3e 0d0a 0909  ="QString"/>....
-00003720: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
-00003730: 653d 2274 7765 616b 5f64 6173 685f 7061  e="tweak_dash_pa
-00003740: 7474 6572 6e5f 6f6e 5f63 6f72 6e65 7273  ttern_on_corners
-00003750: 2220 7661 6c75 653d 2230 2220 7479 7065  " value="0" type
-00003760: 3d22 5153 7472 696e 6722 2f3e 0d0a 0909  ="QString"/>....
-00003770: 0909 0909 093c 4f70 7469 6f6e 206e 616d  .....<Option nam
-00003780: 653d 2275 7365 5f63 7573 746f 6d5f 6461  e="use_custom_da
-00003790: 7368 2220 7661 6c75 653d 2230 2220 7479  sh" value="0" ty
-000037a0: 7065 3d22 5153 7472 696e 6722 2f3e 0d0a  pe="QString"/>..
-000037b0: 0909 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-000037c0: 616d 653d 2277 6964 7468 5f6d 6170 5f75  ame="width_map_u
-000037d0: 6e69 745f 7363 616c 6522 2076 616c 7565  nit_scale" value
-000037e0: 3d22 3378 3a30 2c30 2c30 2c30 2c30 2c30  ="3x:0,0,0,0,0,0
-000037f0: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
-00003800: 2f3e 0d0a 0909 0909 0909 3c2f 4f70 7469  />........</Opti
-00003810: 6f6e 3e0d 0a09 0909 0909 093c 7072 6f70  on>........<prop
-00003820: 206b 3d22 616c 6967 6e5f 6461 7368 5f70   k="align_dash_p
-00003830: 6174 7465 726e 2220 763d 2230 222f 3e0d  attern" v="0"/>.
-00003840: 0a09 0909 0909 093c 7072 6f70 206b 3d22  .......<prop k="
-00003850: 6361 7073 7479 6c65 2220 763d 2273 7175  capstyle" v="squ
-00003860: 6172 6522 2f3e 0d0a 0909 0909 0909 3c70  are"/>........<p
-00003870: 726f 7020 6b3d 2263 7573 746f 6d64 6173  rop k="customdas
-00003880: 6822 2076 3d22 353b 3222 2f3e 0d0a 0909  h" v="5;2"/>....
-00003890: 0909 0909 3c70 726f 7020 6b3d 2263 7573  ....<prop k="cus
-000038a0: 746f 6d64 6173 685f 6d61 705f 756e 6974  tomdash_map_unit
-000038b0: 5f73 6361 6c65 2220 763d 2233 783a 302c  _scale" v="3x:0,
-000038c0: 302c 302c 302c 302c 3022 2f3e 0d0a 0909  0,0,0,0,0"/>....
-000038d0: 0909 0909 3c70 726f 7020 6b3d 2263 7573  ....<prop k="cus
-000038e0: 746f 6d64 6173 685f 756e 6974 2220 763d  tomdash_unit" v=
-000038f0: 224d 4d22 2f3e 0d0a 0909 0909 0909 3c70  "MM"/>........<p
-00003900: 726f 7020 6b3d 2264 6173 685f 7061 7474  rop k="dash_patt
-00003910: 6572 6e5f 6f66 6673 6574 2220 763d 2230  ern_offset" v="0
-00003920: 222f 3e0d 0a09 0909 0909 093c 7072 6f70  "/>........<prop
-00003930: 206b 3d22 6461 7368 5f70 6174 7465 726e   k="dash_pattern
-00003940: 5f6f 6666 7365 745f 6d61 705f 756e 6974  _offset_map_unit
-00003950: 5f73 6361 6c65 2220 763d 2233 783a 302c  _scale" v="3x:0,
-00003960: 302c 302c 302c 302c 3022 2f3e 0d0a 0909  0,0,0,0,0"/>....
-00003970: 0909 0909 3c70 726f 7020 6b3d 2264 6173  ....<prop k="das
-00003980: 685f 7061 7474 6572 6e5f 6f66 6673 6574  h_pattern_offset
-00003990: 5f75 6e69 7422 2076 3d22 4d4d 222f 3e0d  _unit" v="MM"/>.
-000039a0: 0a09 0909 0909 093c 7072 6f70 206b 3d22  .......<prop k="
-000039b0: 6472 6177 5f69 6e73 6964 655f 706f 6c79  draw_inside_poly
-000039c0: 676f 6e22 2076 3d22 3022 2f3e 0d0a 0909  gon" v="0"/>....
-000039d0: 0909 0909 3c70 726f 7020 6b3d 226a 6f69  ....<prop k="joi
-000039e0: 6e73 7479 6c65 2220 763d 2262 6576 656c  nstyle" v="bevel
-000039f0: 222f 3e0d 0a09 0909 0909 093c 7072 6f70  "/>........<prop
-00003a00: 206b 3d22 6c69 6e65 5f63 6f6c 6f72 2220   k="line_color" 
-00003a10: 763d 2233 352c 3335 2c33 352c 3235 3522  v="35,35,35,255"
-00003a20: 2f3e 0d0a 0909 0909 0909 3c70 726f 7020  />........<prop 
-00003a30: 6b3d 226c 696e 655f 7374 796c 6522 2076  k="line_style" v
-00003a40: 3d22 736f 6c69 6422 2f3e 0d0a 0909 0909  ="solid"/>......
-00003a50: 0909 3c70 726f 7020 6b3d 226c 696e 655f  ..<prop k="line_
-00003a60: 7769 6474 6822 2076 3d22 302e 3236 222f  width" v="0.26"/
-00003a70: 3e0d 0a09 0909 0909 093c 7072 6f70 206b  >........<prop k
-00003a80: 3d22 6c69 6e65 5f77 6964 7468 5f75 6e69  ="line_width_uni
-00003a90: 7422 2076 3d22 4d4d 222f 3e0d 0a09 0909  t" v="MM"/>.....
-00003aa0: 0909 093c 7072 6f70 206b 3d22 6f66 6673  ...<prop k="offs
-00003ab0: 6574 2220 763d 2230 222f 3e0d 0a09 0909  et" v="0"/>.....
-00003ac0: 0909 093c 7072 6f70 206b 3d22 6f66 6673  ...<prop k="offs
-00003ad0: 6574 5f6d 6170 5f75 6e69 745f 7363 616c  et_map_unit_scal
-00003ae0: 6522 2076 3d22 3378 3a30 2c30 2c30 2c30  e" v="3x:0,0,0,0
-00003af0: 2c30 2c30 222f 3e0d 0a09 0909 0909 093c  ,0,0"/>........<
-00003b00: 7072 6f70 206b 3d22 6f66 6673 6574 5f75  prop k="offset_u
-00003b10: 6e69 7422 2076 3d22 4d4d 222f 3e0d 0a09  nit" v="MM"/>...
-00003b20: 0909 0909 093c 7072 6f70 206b 3d22 7269  .....<prop k="ri
-00003b30: 6e67 5f66 696c 7465 7222 2076 3d22 3022  ng_filter" v="0"
-00003b40: 2f3e 0d0a 0909 0909 0909 3c70 726f 7020  />........<prop 
-00003b50: 6b3d 2274 7269 6d5f 6469 7374 616e 6365  k="trim_distance
-00003b60: 5f65 6e64 2220 763d 2230 222f 3e0d 0a09  _end" v="0"/>...
-00003b70: 0909 0909 093c 7072 6f70 206b 3d22 7472  .....<prop k="tr
-00003b80: 696d 5f64 6973 7461 6e63 655f 656e 645f  im_distance_end_
-00003b90: 6d61 705f 756e 6974 5f73 6361 6c65 2220  map_unit_scale" 
-00003ba0: 763d 2233 783a 302c 302c 302c 302c 302c  v="3x:0,0,0,0,0,
-00003bb0: 3022 2f3e 0d0a 0909 0909 0909 3c70 726f  0"/>........<pro
-00003bc0: 7020 6b3d 2274 7269 6d5f 6469 7374 616e  p k="trim_distan
-00003bd0: 6365 5f65 6e64 5f75 6e69 7422 2076 3d22  ce_end_unit" v="
-00003be0: 4d4d 222f 3e0d 0a09 0909 0909 093c 7072  MM"/>........<pr
-00003bf0: 6f70 206b 3d22 7472 696d 5f64 6973 7461  op k="trim_dista
-00003c00: 6e63 655f 7374 6172 7422 2076 3d22 3022  nce_start" v="0"
-00003c10: 2f3e 0d0a 0909 0909 0909 3c70 726f 7020  />........<prop 
-00003c20: 6b3d 2274 7269 6d5f 6469 7374 616e 6365  k="trim_distance
-00003c30: 5f73 7461 7274 5f6d 6170 5f75 6e69 745f  _start_map_unit_
-00003c40: 7363 616c 6522 2076 3d22 3378 3a30 2c30  scale" v="3x:0,0
-00003c50: 2c30 2c30 2c30 2c30 222f 3e0d 0a09 0909  ,0,0,0,0"/>.....
-00003c60: 0909 093c 7072 6f70 206b 3d22 7472 696d  ...<prop k="trim
-00003c70: 5f64 6973 7461 6e63 655f 7374 6172 745f  _distance_start_
-00003c80: 756e 6974 2220 763d 224d 4d22 2f3e 0d0a  unit" v="MM"/>..
-00003c90: 0909 0909 0909 3c70 726f 7020 6b3d 2274  ......<prop k="t
-00003ca0: 7765 616b 5f64 6173 685f 7061 7474 6572  weak_dash_patter
-00003cb0: 6e5f 6f6e 5f63 6f72 6e65 7273 2220 763d  n_on_corners" v=
-00003cc0: 2230 222f 3e0d 0a09 0909 0909 093c 7072  "0"/>........<pr
-00003cd0: 6f70 206b 3d22 7573 655f 6375 7374 6f6d  op k="use_custom
-00003ce0: 5f64 6173 6822 2076 3d22 3022 2f3e 0d0a  _dash" v="0"/>..
-00003cf0: 0909 0909 0909 3c70 726f 7020 6b3d 2277  ......<prop k="w
-00003d00: 6964 7468 5f6d 6170 5f75 6e69 745f 7363  idth_map_unit_sc
-00003d10: 616c 6522 2076 3d22 3378 3a30 2c30 2c30  ale" v="3x:0,0,0
-00003d20: 2c30 2c30 2c30 222f 3e0d 0a09 0909 0909  ,0,0,0"/>.......
-00003d30: 093c 6461 7461 5f64 6566 696e 6564 5f70  .<data_defined_p
-00003d40: 726f 7065 7274 6965 733e 0d0a 0909 0909  roperties>......
-00003d50: 0909 093c 4f70 7469 6f6e 2074 7970 653d  ...<Option type=
-00003d60: 224d 6170 223e 0d0a 0909 0909 0909 0909  "Map">..........
-00003d70: 3c4f 7074 696f 6e20 6e61 6d65 3d22 6e61  <Option name="na
-00003d80: 6d65 2220 7661 6c75 653d 2222 2074 7970  me" value="" typ
-00003d90: 653d 2251 5374 7269 6e67 222f 3e0d 0a09  e="QString"/>...
-00003da0: 0909 0909 0909 093c 4f70 7469 6f6e 206e  .......<Option n
-00003db0: 616d 653d 2270 726f 7065 7274 6965 7322  ame="properties"
-00003dc0: 2f3e 0d0a 0909 0909 0909 0909 3c4f 7074  />..........<Opt
-00003dd0: 696f 6e20 6e61 6d65 3d22 7479 7065 2220  ion name="type" 
-00003de0: 7661 6c75 653d 2263 6f6c 6c65 6374 696f  value="collectio
-00003df0: 6e22 2074 7970 653d 2251 5374 7269 6e67  n" type="QString
-00003e00: 222f 3e0d 0a09 0909 0909 0909 3c2f 4f70  "/>.........</Op
-00003e10: 7469 6f6e 3e0d 0a09 0909 0909 093c 2f64  tion>........</d
-00003e20: 6174 615f 6465 6669 6e65 645f 7072 6f70  ata_defined_prop
-00003e30: 6572 7469 6573 3e0d 0a09 0909 0909 3c2f  erties>.......</
-00003e40: 6c61 7965 723e 0d0a 0909 0909 3c2f 7379  layer>......</sy
-00003e50: 6d62 6f6c 3e0d 0a09 0909 3c2f 6178 6973  mbol>.....</axis
-00003e60: 5379 6d62 6f6c 3e0d 0a09 093c 2f44 6961  Symbol>....</Dia
-00003e70: 6772 616d 4361 7465 676f 7279 3e0d 0a09  gramCategory>...
-00003e80: 3c2f 5369 6e67 6c65 4361 7465 676f 7279  </SingleCategory
-00003e90: 4469 6167 7261 6d52 656e 6465 7265 723e  DiagramRenderer>
-00003ea0: 0d0a 093c 4469 6167 7261 6d4c 6179 6572  ...<DiagramLayer
-00003eb0: 5365 7474 696e 6773 2070 6c61 6365 6d65  Settings placeme
-00003ec0: 6e74 3d22 3122 2070 7269 6f72 6974 793d  nt="1" priority=
-00003ed0: 2230 2220 6f62 7374 6163 6c65 3d22 3022  "0" obstacle="0"
-00003ee0: 2073 686f 7741 6c6c 3d22 3122 206c 696e   showAll="1" lin
-00003ef0: 6550 6c61 6365 6d65 6e74 466c 6167 733d  ePlacementFlags=
-00003f00: 2231 3822 207a 496e 6465 783d 2230 2220  "18" zIndex="0" 
-00003f10: 6469 7374 3d22 3022 3e0d 0a09 093c 7072  dist="0">....<pr
-00003f20: 6f70 6572 7469 6573 3e0d 0a09 0909 3c4f  operties>.....<O
-00003f30: 7074 696f 6e20 7479 7065 3d22 4d61 7022  ption type="Map"
-00003f40: 3e0d 0a09 0909 093c 4f70 7469 6f6e 206e  >......<Option n
-00003f50: 616d 653d 226e 616d 6522 2076 616c 7565  ame="name" value
-00003f60: 3d22 2220 7479 7065 3d22 5153 7472 696e  ="" type="QStrin
-00003f70: 6722 2f3e 0d0a 0909 0909 3c4f 7074 696f  g"/>......<Optio
-00003f80: 6e20 6e61 6d65 3d22 7072 6f70 6572 7469  n name="properti
-00003f90: 6573 222f 3e0d 0a09 0909 093c 4f70 7469  es"/>......<Opti
-00003fa0: 6f6e 206e 616d 653d 2274 7970 6522 2076  on name="type" v
-00003fb0: 616c 7565 3d22 636f 6c6c 6563 7469 6f6e  alue="collection
-00003fc0: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
-00003fd0: 2f3e 0d0a 0909 093c 2f4f 7074 696f 6e3e  />.....</Option>
-00003fe0: 0d0a 0909 3c2f 7072 6f70 6572 7469 6573  ....</properties
-00003ff0: 3e0d 0a09 3c2f 4469 6167 7261 6d4c 6179  >...</DiagramLay
-00004000: 6572 5365 7474 696e 6773 3e0d 0a09 3c67  erSettings>...<g
-00004010: 656f 6d65 7472 794f 7074 696f 6e73 2072  eometryOptions r
-00004020: 656d 6f76 6544 7570 6c69 6361 7465 4e6f  emoveDuplicateNo
-00004030: 6465 733d 2230 2220 6765 6f6d 6574 7279  des="0" geometry
-00004040: 5072 6563 6973 696f 6e3d 2230 223e 0d0a  Precision="0">..
-00004050: 0909 3c61 6374 6976 6543 6865 636b 732f  ..<activeChecks/
-00004060: 3e0d 0a09 093c 6368 6563 6b43 6f6e 6669  >....<checkConfi
-00004070: 6775 7261 7469 6f6e 2074 7970 653d 224d  guration type="M
-00004080: 6170 223e 0d0a 0909 093c 4f70 7469 6f6e  ap">.....<Option
-00004090: 206e 616d 653d 2251 6773 4765 6f6d 6574   name="QgsGeomet
-000040a0: 7279 4761 7043 6865 636b 2220 7479 7065  ryGapCheck" type
-000040b0: 3d22 4d61 7022 3e0d 0a09 0909 093c 4f70  ="Map">......<Op
-000040c0: 7469 6f6e 206e 616d 653d 2261 6c6c 6f77  tion name="allow
-000040d0: 6564 4761 7073 4275 6666 6572 2220 7661  edGapsBuffer" va
-000040e0: 6c75 653d 2230 2220 7479 7065 3d22 646f  lue="0" type="do
-000040f0: 7562 6c65 222f 3e0d 0a09 0909 093c 4f70  uble"/>......<Op
-00004100: 7469 6f6e 206e 616d 653d 2261 6c6c 6f77  tion name="allow
-00004110: 6564 4761 7073 456e 6162 6c65 6422 2076  edGapsEnabled" v
-00004120: 616c 7565 3d22 6661 6c73 6522 2074 7970  alue="false" typ
-00004130: 653d 2262 6f6f 6c22 2f3e 0d0a 0909 0909  e="bool"/>......
-00004140: 3c4f 7074 696f 6e20 6e61 6d65 3d22 616c  <Option name="al
-00004150: 6c6f 7765 6447 6170 734c 6179 6572 2220  lowedGapsLayer" 
-00004160: 7661 6c75 653d 2222 2074 7970 653d 2251  value="" type="Q
-00004170: 5374 7269 6e67 222f 3e0d 0a09 0909 3c2f  String"/>.....</
-00004180: 4f70 7469 6f6e 3e0d 0a09 093c 2f63 6865  Option>....</che
-00004190: 636b 436f 6e66 6967 7572 6174 696f 6e3e  ckConfiguration>
-000041a0: 0d0a 093c 2f67 656f 6d65 7472 794f 7074  ...</geometryOpt
-000041b0: 696f 6e73 3e0d 0a09 3c6c 6567 656e 6420  ions>...<legend 
-000041c0: 7368 6f77 4c61 6265 6c4c 6567 656e 643d  showLabelLegend=
-000041d0: 2230 2220 7479 7065 3d22 6465 6661 756c  "0" type="defaul
-000041e0: 742d 7665 6374 6f72 222f 3e0d 0a09 3c72  t-vector"/>...<r
-000041f0: 6566 6572 656e 6365 644c 6179 6572 732f  eferencedLayers/
-00004200: 3e0d 0a09 3c66 6965 6c64 436f 6e66 6967  >...<fieldConfig
-00004210: 7572 6174 696f 6e3e 0d0a 0909 3c66 6965  uration>....<fie
-00004220: 6c64 206e 616d 653d 2266 6964 2220 636f  ld name="fid" co
-00004230: 6e66 6967 7572 6174 696f 6e46 6c61 6773  nfigurationFlags
-00004240: 3d22 4e6f 6e65 223e 0d0a 0909 093c 6564  ="None">.....<ed
-00004250: 6974 5769 6467 6574 2074 7970 653d 2254  itWidget type="T
-00004260: 6578 7445 6469 7422 3e0d 0a09 0909 093c  extEdit">......<
-00004270: 636f 6e66 6967 3e0d 0a09 0909 0909 3c4f  config>.......<O
-00004280: 7074 696f 6e2f 3e0d 0a09 0909 093c 2f63  ption/>......</c
-00004290: 6f6e 6669 673e 0d0a 0909 093c 2f65 6469  onfig>.....</edi
-000042a0: 7457 6964 6765 743e 0d0a 0909 3c2f 6669  tWidget>....</fi
-000042b0: 656c 643e 0d0a 0909 3c66 6965 6c64 206e  eld>....<field n
-000042c0: 616d 653d 2263 6c61 7373 6e61 6d65 2220  ame="classname" 
-000042d0: 636f 6e66 6967 7572 6174 696f 6e46 6c61  configurationFla
-000042e0: 6773 3d22 4e6f 6e65 223e 0d0a 0909 093c  gs="None">.....<
-000042f0: 6564 6974 5769 6467 6574 2074 7970 653d  editWidget type=
-00004300: 2254 6578 7445 6469 7422 3e0d 0a09 0909  "TextEdit">.....
-00004310: 093c 636f 6e66 6967 3e0d 0a09 0909 0909  .<config>.......
-00004320: 3c4f 7074 696f 6e2f 3e0d 0a09 0909 093c  <Option/>......<
-00004330: 2f63 6f6e 6669 673e 0d0a 0909 093c 2f65  /config>.....</e
-00004340: 6469 7457 6964 6765 743e 0d0a 0909 3c2f  ditWidget>....</
-00004350: 6669 656c 643e 0d0a 093c 2f66 6965 6c64  field>...</field
-00004360: 436f 6e66 6967 7572 6174 696f 6e3e 0d0a  Configuration>..
-00004370: 093c 616c 6961 7365 733e 0d0a 0909 3c61  .<aliases>....<a
-00004380: 6c69 6173 206e 616d 653d 2222 2069 6e64  lias name="" ind
-00004390: 6578 3d22 3022 2066 6965 6c64 3d22 6669  ex="0" field="fi
-000043a0: 6422 2f3e 0d0a 0909 3c61 6c69 6173 206e  d"/>....<alias n
-000043b0: 616d 653d 2222 2069 6e64 6578 3d22 3122  ame="" index="1"
-000043c0: 2066 6965 6c64 3d22 636c 6173 736e 616d   field="classnam
-000043d0: 6522 2f3e 0d0a 093c 2f61 6c69 6173 6573  e"/>...</aliases
-000043e0: 3e0d 0a09 3c64 6566 6175 6c74 733e 0d0a  >...<defaults>..
-000043f0: 0909 3c64 6566 6175 6c74 2061 7070 6c79  ..<default apply
-00004400: 4f6e 5570 6461 7465 3d22 3022 2066 6965  OnUpdate="0" fie
-00004410: 6c64 3d22 6669 6422 2065 7870 7265 7373  ld="fid" express
-00004420: 696f 6e3d 2222 2f3e 0d0a 0909 3c64 6566  ion=""/>....<def
-00004430: 6175 6c74 2061 7070 6c79 4f6e 5570 6461  ault applyOnUpda
-00004440: 7465 3d22 3022 2066 6965 6c64 3d22 636c  te="0" field="cl
-00004450: 6173 736e 616d 6522 2065 7870 7265 7373  assname" express
-00004460: 696f 6e3d 2222 2f3e 0d0a 093c 2f64 6566  ion=""/>...</def
-00004470: 6175 6c74 733e 0d0a 093c 636f 6e73 7472  aults>...<constr
-00004480: 6169 6e74 733e 0d0a 0909 3c63 6f6e 7374  aints>....<const
-00004490: 7261 696e 7420 756e 6971 7565 5f73 7472  raint unique_str
-000044a0: 656e 6774 683d 2231 2220 6578 705f 7374  ength="1" exp_st
-000044b0: 7265 6e67 7468 3d22 3022 206e 6f74 6e75  rength="0" notnu
-000044c0: 6c6c 5f73 7472 656e 6774 683d 2231 2220  ll_strength="1" 
-000044d0: 6669 656c 643d 2266 6964 2220 636f 6e73  field="fid" cons
-000044e0: 7472 6169 6e74 733d 2233 222f 3e0d 0a09  traints="3"/>...
-000044f0: 093c 636f 6e73 7472 6169 6e74 2075 6e69  .<constraint uni
-00004500: 7175 655f 7374 7265 6e67 7468 3d22 3022  que_strength="0"
-00004510: 2065 7870 5f73 7472 656e 6774 683d 2230   exp_strength="0
-00004520: 2220 6e6f 746e 756c 6c5f 7374 7265 6e67  " notnull_streng
-00004530: 7468 3d22 3022 2066 6965 6c64 3d22 636c  th="0" field="cl
-00004540: 6173 736e 616d 6522 2063 6f6e 7374 7261  assname" constra
-00004550: 696e 7473 3d22 3022 2f3e 0d0a 093c 2f63  ints="0"/>...</c
-00004560: 6f6e 7374 7261 696e 7473 3e0d 0a09 3c63  onstraints>...<c
-00004570: 6f6e 7374 7261 696e 7445 7870 7265 7373  onstraintExpress
-00004580: 696f 6e73 3e0d 0a09 093c 636f 6e73 7472  ions>....<constr
-00004590: 6169 6e74 2065 7870 3d22 2220 6465 7363  aint exp="" desc
-000045a0: 3d22 2220 6669 656c 643d 2266 6964 222f  ="" field="fid"/
-000045b0: 3e0d 0a09 093c 636f 6e73 7472 6169 6e74  >....<constraint
-000045c0: 2065 7870 3d22 2220 6465 7363 3d22 2220   exp="" desc="" 
-000045d0: 6669 656c 643d 2263 6c61 7373 6e61 6d65  field="classname
-000045e0: 222f 3e0d 0a09 3c2f 636f 6e73 7472 6169  "/>...</constrai
-000045f0: 6e74 4578 7072 6573 7369 6f6e 733e 0d0a  ntExpressions>..
-00004600: 093c 6578 7072 6573 7369 6f6e 6669 656c  .<expressionfiel
-00004610: 6473 2f3e 0d0a 093c 6174 7472 6962 7574  ds/>...<attribut
-00004620: 6561 6374 696f 6e73 3e0d 0a09 093c 6465  eactions>....<de
-00004630: 6661 756c 7441 6374 696f 6e20 6b65 793d  faultAction key=
-00004640: 2243 616e 7661 7322 2076 616c 7565 3d22  "Canvas" value="
-00004650: 7b30 3030 3030 3030 302d 3030 3030 2d30  {00000000-0000-0
-00004660: 3030 302d 3030 3030 2d30 3030 3030 3030  000-0000-0000000
-00004670: 3030 3030 307d 222f 3e0d 0a09 3c2f 6174  00000}"/>...</at
-00004680: 7472 6962 7574 6561 6374 696f 6e73 3e0d  tributeactions>.
-00004690: 0a09 3c61 7474 7269 6275 7465 7461 626c  ..<attributetabl
-000046a0: 6563 6f6e 6669 6720 736f 7274 4f72 6465  econfig sortOrde
-000046b0: 723d 2230 2220 736f 7274 4578 7072 6573  r="0" sortExpres
-000046c0: 7369 6f6e 3d22 2220 6163 7469 6f6e 5769  sion="" actionWi
-000046d0: 6467 6574 5374 796c 653d 2264 726f 7044  dgetStyle="dropD
-000046e0: 6f77 6e22 3e0d 0a09 093c 636f 6c75 6d6e  own">....<column
-000046f0: 733e 0d0a 0909 093c 636f 6c75 6d6e 206e  s>.....<column n
-00004700: 616d 653d 2266 6964 2220 7479 7065 3d22  ame="fid" type="
-00004710: 6669 656c 6422 2068 6964 6465 6e3d 2230  field" hidden="0
-00004720: 2220 7769 6474 683d 222d 3122 2f3e 0d0a  " width="-1"/>..
-00004730: 0909 093c 636f 6c75 6d6e 206e 616d 653d  ...<column name=
-00004740: 2263 6c61 7373 6e61 6d65 2220 7479 7065  "classname" type
-00004750: 3d22 6669 656c 6422 2068 6964 6465 6e3d  ="field" hidden=
-00004760: 2230 2220 7769 6474 683d 222d 3122 2f3e  "0" width="-1"/>
-00004770: 0d0a 0909 093c 636f 6c75 6d6e 2074 7970  .....<column typ
-00004780: 653d 2261 6374 696f 6e73 2220 6869 6464  e="actions" hidd
-00004790: 656e 3d22 3122 2077 6964 7468 3d22 2d31  en="1" width="-1
-000047a0: 222f 3e0d 0a09 093c 2f63 6f6c 756d 6e73  "/>....</columns
-000047b0: 3e0d 0a09 3c2f 6174 7472 6962 7574 6574  >...</attributet
-000047c0: 6162 6c65 636f 6e66 6967 3e0d 0a09 3c63  ableconfig>...<c
-000047d0: 6f6e 6469 7469 6f6e 616c 7374 796c 6573  onditionalstyles
-000047e0: 3e0d 0a09 093c 726f 7773 7479 6c65 732f  >....<rowstyles/
-000047f0: 3e0d 0a09 093c 6669 656c 6473 7479 6c65  >....<fieldstyle
-00004800: 732f 3e0d 0a09 3c2f 636f 6e64 6974 696f  s/>...</conditio
-00004810: 6e61 6c73 7479 6c65 733e 0d0a 093c 7374  nalstyles>...<st
-00004820: 6f72 6564 6578 7072 6573 7369 6f6e 732f  oredexpressions/
-00004830: 3e0d 0a09 3c65 6469 7466 6f72 6d20 746f  >...<editform to
-00004840: 6c65 7261 6e74 3d22 3122 3e3c 2f65 6469  lerant="1"></edi
-00004850: 7466 6f72 6d3e 0d0a 093c 6564 6974 666f  tform>...<editfo
-00004860: 726d 696e 6974 2f3e 0d0a 093c 6564 6974  rminit/>...<edit
-00004870: 666f 726d 696e 6974 636f 6465 736f 7572  forminitcodesour
-00004880: 6365 3e30 3c2f 6564 6974 666f 726d 696e  ce>0</editformin
-00004890: 6974 636f 6465 736f 7572 6365 3e0d 0a09  itcodesource>...
-000048a0: 3c65 6469 7466 6f72 6d69 6e69 7466 696c  <editforminitfil
-000048b0: 6570 6174 683e 3c2f 6564 6974 666f 726d  epath></editform
-000048c0: 696e 6974 6669 6c65 7061 7468 3e0d 0a09  initfilepath>...
-000048d0: 3c65 6469 7466 6f72 6d69 6e69 7463 6f64  <editforminitcod
-000048e0: 653e 3c21 5b43 4441 5441 5b23 202d 2a2d  e><![CDATA[# -*-
-000048f0: 2063 6f64 696e 673a 2075 7466 2d38 202d   coding: utf-8 -
-00004900: 2a2d 0d0a 2020 2020 2020 2020 2222 220d  *-..        """.
-00004910: 0a20 2020 2020 2020 2051 4749 5320 666f  .        QGIS fo
-00004920: 726d 7320 6361 6e20 6861 7665 2061 2050  rms can have a P
-00004930: 7974 686f 6e20 6675 6e63 7469 6f6e 2074  ython function t
-00004940: 6861 7420 6973 2063 616c 6c65 6420 7768  hat is called wh
-00004950: 656e 2074 6865 2066 6f72 6d20 6973 0d0a  en the form is..
-00004960: 2020 2020 2020 2020 6f70 656e 6564 2e0d          opened..
-00004970: 0a0d 0a20 2020 2020 2020 2055 7365 2074  ...        Use t
-00004980: 6869 7320 6675 6e63 7469 6f6e 2074 6f20  his function to 
-00004990: 6164 6420 6578 7472 6120 6c6f 6769 6320  add extra logic 
-000049a0: 746f 2079 6f75 7220 666f 726d 732e 0d0a  to your forms...
-000049b0: 0d0a 2020 2020 2020 2020 456e 7465 7220  ..        Enter 
-000049c0: 7468 6520 6e61 6d65 206f 6620 7468 6520  the name of the 
-000049d0: 6675 6e63 7469 6f6e 2069 6e20 7468 6520  function in the 
-000049e0: 2250 7974 686f 6e20 496e 6974 2066 756e  "Python Init fun
-000049f0: 6374 696f 6e22 0d0a 2020 2020 2020 2020  ction"..        
-00004a00: 6669 656c 642e 0d0a 2020 2020 2020 2020  field...        
-00004a10: 416e 2065 7861 6d70 6c65 2066 6f6c 6c6f  An example follo
-00004a20: 7773 3a0d 0a20 2020 2020 2020 2022 2222  ws:..        """
-00004a30: 0d0a 2020 2020 2020 2020 6672 6f6d 2071  ..        from q
-00004a40: 6769 732e 5079 5174 2e51 7457 6964 6765  gis.PyQt.QtWidge
-00004a50: 7473 2069 6d70 6f72 7420 5157 6964 6765  ts import QWidge
-00004a60: 740d 0a0d 0a20 2020 2020 2020 2064 6566  t....        def
-00004a70: 206d 795f 666f 726d 5f6f 7065 6e28 6469   my_form_open(di
-00004a80: 616c 6f67 2c20 6c61 7965 722c 2066 6561  alog, layer, fea
-00004a90: 7475 7265 293a 0d0a 2020 2020 2020 2020  ture):..        
-00004aa0: 2020 2020 6765 6f6d 203d 2066 6561 7475      geom = featu
-00004ab0: 7265 2e67 656f 6d65 7472 7928 290d 0a20  re.geometry().. 
-00004ac0: 2020 2020 2020 2020 2020 2063 6f6e 7472             contr
-00004ad0: 6f6c 203d 2064 6961 6c6f 672e 6669 6e64  ol = dialog.find
-00004ae0: 4368 696c 6428 5157 6964 6765 742c 2022  Child(QWidget, "
-00004af0: 4d79 4c69 6e65 4564 6974 2229 0d0a 2020  MyLineEdit")..  
-00004b00: 2020 2020 2020 5d5d 3e3c 2f65 6469 7466        ]]></editf
-00004b10: 6f72 6d69 6e69 7463 6f64 653e 0d0a 093c  orminitcode>...<
-00004b20: 6665 6174 666f 726d 7375 7070 7265 7373  featformsuppress
-00004b30: 3e30 3c2f 6665 6174 666f 726d 7375 7070  >0</featformsupp
-00004b40: 7265 7373 3e0d 0a09 3c65 6469 746f 726c  ress>...<editorl
-00004b50: 6179 6f75 743e 6765 6e65 7261 7465 646c  ayout>generatedl
-00004b60: 6179 6f75 743c 2f65 6469 746f 726c 6179  ayout</editorlay
-00004b70: 6f75 743e 0d0a 093c 6564 6974 6162 6c65  out>...<editable
-00004b80: 3e0d 0a09 093c 6669 656c 6420 6e61 6d65  >....<field name
-00004b90: 3d22 636c 6173 736e 616d 6522 2065 6469  ="classname" edi
-00004ba0: 7461 626c 653d 2231 222f 3e0d 0a09 093c  table="1"/>....<
-00004bb0: 6669 656c 6420 6e61 6d65 3d22 6669 6422  field name="fid"
-00004bc0: 2065 6469 7461 626c 653d 2231 222f 3e0d   editable="1"/>.
-00004bd0: 0a09 3c2f 6564 6974 6162 6c65 3e0d 0a09  ..</editable>...
-00004be0: 3c6c 6162 656c 4f6e 546f 703e 0d0a 0909  <labelOnTop>....
-00004bf0: 3c66 6965 6c64 206e 616d 653d 2263 6c61  <field name="cla
-00004c00: 7373 6e61 6d65 2220 6c61 6265 6c4f 6e54  ssname" labelOnT
-00004c10: 6f70 3d22 3022 2f3e 0d0a 0909 3c66 6965  op="0"/>....<fie
-00004c20: 6c64 206e 616d 653d 2266 6964 2220 6c61  ld name="fid" la
-00004c30: 6265 6c4f 6e54 6f70 3d22 3022 2f3e 0d0a  belOnTop="0"/>..
-00004c40: 093c 2f6c 6162 656c 4f6e 546f 703e 0d0a  .</labelOnTop>..
-00004c50: 093c 7265 7573 654c 6173 7456 616c 7565  .<reuseLastValue
-00004c60: 3e0d 0a09 093c 6669 656c 6420 7265 7573  >....<field reus
-00004c70: 654c 6173 7456 616c 7565 3d22 3022 206e  eLastValue="0" n
-00004c80: 616d 653d 2263 6c61 7373 6e61 6d65 222f  ame="classname"/
-00004c90: 3e0d 0a09 093c 6669 656c 6420 7265 7573  >....<field reus
-00004ca0: 654c 6173 7456 616c 7565 3d22 3022 206e  eLastValue="0" n
-00004cb0: 616d 653d 2266 6964 222f 3e0d 0a09 3c2f  ame="fid"/>...</
-00004cc0: 7265 7573 654c 6173 7456 616c 7565 3e0d  reuseLastValue>.
-00004cd0: 0a09 3c64 6174 6144 6566 696e 6564 4669  ..<dataDefinedFi
-00004ce0: 656c 6450 726f 7065 7274 6965 732f 3e0d  eldProperties/>.
-00004cf0: 0a09 3c77 6964 6765 7473 2f3e 0d0a 093c  ..<widgets/>...<
-00004d00: 7072 6576 6965 7745 7870 7265 7373 696f  previewExpressio
-00004d10: 6e3e 2263 6c61 7373 6e61 6d65 223c 2f70  n>"classname"</p
-00004d20: 7265 7669 6577 4578 7072 6573 7369 6f6e  reviewExpression
-00004d30: 3e0d 0a09 3c6d 6170 5469 703e 3c2f 6d61  >...<mapTip></ma
-00004d40: 7054 6970 3e0d 0a09 3c6c 6179 6572 4765  pTip>...<layerGe
-00004d50: 6f6d 6574 7279 5479 7065 3e32 3c2f 6c61  ometryType>2</la
-00004d60: 7965 7247 656f 6d65 7472 7954 7970 653e  yerGeometryType>
-00004d70: 0d0a 3c2f 7167 6973 3e                   ..</qgis>
+00003680: 616d 653d 2275 7365 5f63 7573 746f 6d5f  ame="use_custom_
+00003690: 6461 7368 2220 7661 6c75 653d 2230 2220  dash" value="0" 
+000036a0: 7479 7065 3d22 5153 7472 696e 6722 2f3e  type="QString"/>
+000036b0: 0a09 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
+000036c0: 6e61 6d65 3d22 7769 6474 685f 6d61 705f  name="width_map_
+000036d0: 756e 6974 5f73 6361 6c65 2220 7661 6c75  unit_scale" valu
+000036e0: 653d 2233 783a 302c 302c 302c 302c 302c  e="3x:0,0,0,0,0,
+000036f0: 3022 2074 7970 653d 2251 5374 7269 6e67  0" type="QString
+00003700: 222f 3e0a 0909 0909 0909 3c2f 4f70 7469  "/>.......</Opti
+00003710: 6f6e 3e0a 0909 0909 0909 3c70 726f 7020  on>.......<prop 
+00003720: 6b3d 2261 6c69 676e 5f64 6173 685f 7061  k="align_dash_pa
+00003730: 7474 6572 6e22 2076 3d22 3022 2f3e 0a09  ttern" v="0"/>..
+00003740: 0909 0909 093c 7072 6f70 206b 3d22 6361  .....<prop k="ca
+00003750: 7073 7479 6c65 2220 763d 2273 7175 6172  pstyle" v="squar
+00003760: 6522 2f3e 0a09 0909 0909 093c 7072 6f70  e"/>.......<prop
+00003770: 206b 3d22 6375 7374 6f6d 6461 7368 2220   k="customdash" 
+00003780: 763d 2235 3b32 222f 3e0a 0909 0909 0909  v="5;2"/>.......
+00003790: 3c70 726f 7020 6b3d 2263 7573 746f 6d64  <prop k="customd
+000037a0: 6173 685f 6d61 705f 756e 6974 5f73 6361  ash_map_unit_sca
+000037b0: 6c65 2220 763d 2233 783a 302c 302c 302c  le" v="3x:0,0,0,
+000037c0: 302c 302c 3022 2f3e 0a09 0909 0909 093c  0,0,0"/>.......<
+000037d0: 7072 6f70 206b 3d22 6375 7374 6f6d 6461  prop k="customda
+000037e0: 7368 5f75 6e69 7422 2076 3d22 4d4d 222f  sh_unit" v="MM"/
+000037f0: 3e0a 0909 0909 0909 3c70 726f 7020 6b3d  >.......<prop k=
+00003800: 2264 6173 685f 7061 7474 6572 6e5f 6f66  "dash_pattern_of
+00003810: 6673 6574 2220 763d 2230 222f 3e0a 0909  fset" v="0"/>...
+00003820: 0909 0909 3c70 726f 7020 6b3d 2264 6173  ....<prop k="das
+00003830: 685f 7061 7474 6572 6e5f 6f66 6673 6574  h_pattern_offset
+00003840: 5f6d 6170 5f75 6e69 745f 7363 616c 6522  _map_unit_scale"
+00003850: 2076 3d22 3378 3a30 2c30 2c30 2c30 2c30   v="3x:0,0,0,0,0
+00003860: 2c30 222f 3e0a 0909 0909 0909 3c70 726f  ,0"/>.......<pro
+00003870: 7020 6b3d 2264 6173 685f 7061 7474 6572  p k="dash_patter
+00003880: 6e5f 6f66 6673 6574 5f75 6e69 7422 2076  n_offset_unit" v
+00003890: 3d22 4d4d 222f 3e0a 0909 0909 0909 3c70  ="MM"/>.......<p
+000038a0: 726f 7020 6b3d 2264 7261 775f 696e 7369  rop k="draw_insi
+000038b0: 6465 5f70 6f6c 7967 6f6e 2220 763d 2230  de_polygon" v="0
+000038c0: 222f 3e0a 0909 0909 0909 3c70 726f 7020  "/>.......<prop 
+000038d0: 6b3d 226a 6f69 6e73 7479 6c65 2220 763d  k="joinstyle" v=
+000038e0: 2262 6576 656c 222f 3e0a 0909 0909 0909  "bevel"/>.......
+000038f0: 3c70 726f 7020 6b3d 226c 696e 655f 636f  <prop k="line_co
+00003900: 6c6f 7222 2076 3d22 3335 2c33 352c 3335  lor" v="35,35,35
+00003910: 2c32 3535 222f 3e0a 0909 0909 0909 3c70  ,255"/>.......<p
+00003920: 726f 7020 6b3d 226c 696e 655f 7374 796c  rop k="line_styl
+00003930: 6522 2076 3d22 736f 6c69 6422 2f3e 0a09  e" v="solid"/>..
+00003940: 0909 0909 093c 7072 6f70 206b 3d22 6c69  .....<prop k="li
+00003950: 6e65 5f77 6964 7468 2220 763d 2230 2e32  ne_width" v="0.2
+00003960: 3622 2f3e 0a09 0909 0909 093c 7072 6f70  6"/>.......<prop
+00003970: 206b 3d22 6c69 6e65 5f77 6964 7468 5f75   k="line_width_u
+00003980: 6e69 7422 2076 3d22 4d4d 222f 3e0a 0909  nit" v="MM"/>...
+00003990: 0909 0909 3c70 726f 7020 6b3d 226f 6666  ....<prop k="off
+000039a0: 7365 7422 2076 3d22 3022 2f3e 0a09 0909  set" v="0"/>....
+000039b0: 0909 093c 7072 6f70 206b 3d22 6f66 6673  ...<prop k="offs
+000039c0: 6574 5f6d 6170 5f75 6e69 745f 7363 616c  et_map_unit_scal
+000039d0: 6522 2076 3d22 3378 3a30 2c30 2c30 2c30  e" v="3x:0,0,0,0
+000039e0: 2c30 2c30 222f 3e0a 0909 0909 0909 3c70  ,0,0"/>.......<p
+000039f0: 726f 7020 6b3d 226f 6666 7365 745f 756e  rop k="offset_un
+00003a00: 6974 2220 763d 224d 4d22 2f3e 0a09 0909  it" v="MM"/>....
+00003a10: 0909 093c 7072 6f70 206b 3d22 7269 6e67  ...<prop k="ring
+00003a20: 5f66 696c 7465 7222 2076 3d22 3022 2f3e  _filter" v="0"/>
+00003a30: 0a09 0909 0909 093c 7072 6f70 206b 3d22  .......<prop k="
+00003a40: 7472 696d 5f64 6973 7461 6e63 655f 656e  trim_distance_en
+00003a50: 6422 2076 3d22 3022 2f3e 0a09 0909 0909  d" v="0"/>......
+00003a60: 093c 7072 6f70 206b 3d22 7472 696d 5f64  .<prop k="trim_d
+00003a70: 6973 7461 6e63 655f 656e 645f 6d61 705f  istance_end_map_
+00003a80: 756e 6974 5f73 6361 6c65 2220 763d 2233  unit_scale" v="3
+00003a90: 783a 302c 302c 302c 302c 302c 3022 2f3e  x:0,0,0,0,0,0"/>
+00003aa0: 0a09 0909 0909 093c 7072 6f70 206b 3d22  .......<prop k="
+00003ab0: 7472 696d 5f64 6973 7461 6e63 655f 656e  trim_distance_en
+00003ac0: 645f 756e 6974 2220 763d 224d 4d22 2f3e  d_unit" v="MM"/>
+00003ad0: 0a09 0909 0909 093c 7072 6f70 206b 3d22  .......<prop k="
+00003ae0: 7472 696d 5f64 6973 7461 6e63 655f 7374  trim_distance_st
+00003af0: 6172 7422 2076 3d22 3022 2f3e 0a09 0909  art" v="0"/>....
+00003b00: 0909 093c 7072 6f70 206b 3d22 7472 696d  ...<prop k="trim
+00003b10: 5f64 6973 7461 6e63 655f 7374 6172 745f  _distance_start_
+00003b20: 6d61 705f 756e 6974 5f73 6361 6c65 2220  map_unit_scale" 
+00003b30: 763d 2233 783a 302c 302c 302c 302c 302c  v="3x:0,0,0,0,0,
+00003b40: 3022 2f3e 0a09 0909 0909 093c 7072 6f70  0"/>.......<prop
+00003b50: 206b 3d22 7472 696d 5f64 6973 7461 6e63   k="trim_distanc
+00003b60: 655f 7374 6172 745f 756e 6974 2220 763d  e_start_unit" v=
+00003b70: 224d 4d22 2f3e 0a09 0909 0909 093c 7072  "MM"/>.......<pr
+00003b80: 6f70 206b 3d22 7477 6561 6b5f 6461 7368  op k="tweak_dash
+00003b90: 5f70 6174 7465 726e 5f6f 6e5f 636f 726e  _pattern_on_corn
+00003ba0: 6572 7322 2076 3d22 3022 2f3e 0a09 0909  ers" v="0"/>....
+00003bb0: 0909 093c 7072 6f70 206b 3d22 7573 655f  ...<prop k="use_
+00003bc0: 6375 7374 6f6d 5f64 6173 6822 2076 3d22  custom_dash" v="
+00003bd0: 3022 2f3e 0a09 0909 0909 093c 7072 6f70  0"/>.......<prop
+00003be0: 206b 3d22 7769 6474 685f 6d61 705f 756e   k="width_map_un
+00003bf0: 6974 5f73 6361 6c65 2220 763d 2233 783a  it_scale" v="3x:
+00003c00: 302c 302c 302c 302c 302c 3022 2f3e 0a09  0,0,0,0,0,0"/>..
+00003c10: 0909 0909 093c 6461 7461 5f64 6566 696e  .....<data_defin
+00003c20: 6564 5f70 726f 7065 7274 6965 733e 0a09  ed_properties>..
+00003c30: 0909 0909 0909 3c4f 7074 696f 6e20 7479  ......<Option ty
+00003c40: 7065 3d22 4d61 7022 3e0a 0909 0909 0909  pe="Map">.......
+00003c50: 0909 3c4f 7074 696f 6e20 6e61 6d65 3d22  ..<Option name="
+00003c60: 6e61 6d65 2220 7661 6c75 653d 2222 2074  name" value="" t
+00003c70: 7970 653d 2251 5374 7269 6e67 222f 3e0a  ype="QString"/>.
+00003c80: 0909 0909 0909 0909 3c4f 7074 696f 6e20  ........<Option 
+00003c90: 6e61 6d65 3d22 7072 6f70 6572 7469 6573  name="properties
+00003ca0: 222f 3e0a 0909 0909 0909 0909 3c4f 7074  "/>.........<Opt
+00003cb0: 696f 6e20 6e61 6d65 3d22 7479 7065 2220  ion name="type" 
+00003cc0: 7661 6c75 653d 2263 6f6c 6c65 6374 696f  value="collectio
+00003cd0: 6e22 2074 7970 653d 2251 5374 7269 6e67  n" type="QString
+00003ce0: 222f 3e0a 0909 0909 0909 093c 2f4f 7074  "/>........</Opt
+00003cf0: 696f 6e3e 0a09 0909 0909 093c 2f64 6174  ion>.......</dat
+00003d00: 615f 6465 6669 6e65 645f 7072 6f70 6572  a_defined_proper
+00003d10: 7469 6573 3e0a 0909 0909 093c 2f6c 6179  ties>......</lay
+00003d20: 6572 3e0a 0909 0909 3c2f 7379 6d62 6f6c  er>.....</symbol
+00003d30: 3e0a 0909 093c 2f61 7869 7353 796d 626f  >....</axisSymbo
+00003d40: 6c3e 0a09 093c 2f44 6961 6772 616d 4361  l>...</DiagramCa
+00003d50: 7465 676f 7279 3e0a 093c 2f53 696e 676c  tegory>..</Singl
+00003d60: 6543 6174 6567 6f72 7944 6961 6772 616d  eCategoryDiagram
+00003d70: 5265 6e64 6572 6572 3e0a 093c 4469 6167  Renderer>..<Diag
+00003d80: 7261 6d4c 6179 6572 5365 7474 696e 6773  ramLayerSettings
+00003d90: 2070 6c61 6365 6d65 6e74 3d22 3122 2070   placement="1" p
+00003da0: 7269 6f72 6974 793d 2230 2220 6f62 7374  riority="0" obst
+00003db0: 6163 6c65 3d22 3022 2073 686f 7741 6c6c  acle="0" showAll
+00003dc0: 3d22 3122 206c 696e 6550 6c61 6365 6d65  ="1" linePlaceme
+00003dd0: 6e74 466c 6167 733d 2231 3822 207a 496e  ntFlags="18" zIn
+00003de0: 6465 783d 2230 2220 6469 7374 3d22 3022  dex="0" dist="0"
+00003df0: 3e0a 0909 3c70 726f 7065 7274 6965 733e  >...<properties>
+00003e00: 0a09 0909 3c4f 7074 696f 6e20 7479 7065  ....<Option type
+00003e10: 3d22 4d61 7022 3e0a 0909 0909 3c4f 7074  ="Map">.....<Opt
+00003e20: 696f 6e20 6e61 6d65 3d22 6e61 6d65 2220  ion name="name" 
+00003e30: 7661 6c75 653d 2222 2074 7970 653d 2251  value="" type="Q
+00003e40: 5374 7269 6e67 222f 3e0a 0909 0909 3c4f  String"/>.....<O
+00003e50: 7074 696f 6e20 6e61 6d65 3d22 7072 6f70  ption name="prop
+00003e60: 6572 7469 6573 222f 3e0a 0909 0909 3c4f  erties"/>.....<O
+00003e70: 7074 696f 6e20 6e61 6d65 3d22 7479 7065  ption name="type
+00003e80: 2220 7661 6c75 653d 2263 6f6c 6c65 6374  " value="collect
+00003e90: 696f 6e22 2074 7970 653d 2251 5374 7269  ion" type="QStri
+00003ea0: 6e67 222f 3e0a 0909 093c 2f4f 7074 696f  ng"/>....</Optio
+00003eb0: 6e3e 0a09 093c 2f70 726f 7065 7274 6965  n>...</propertie
+00003ec0: 733e 0a09 3c2f 4469 6167 7261 6d4c 6179  s>..</DiagramLay
+00003ed0: 6572 5365 7474 696e 6773 3e0a 093c 6765  erSettings>..<ge
+00003ee0: 6f6d 6574 7279 4f70 7469 6f6e 7320 7265  ometryOptions re
+00003ef0: 6d6f 7665 4475 706c 6963 6174 654e 6f64  moveDuplicateNod
+00003f00: 6573 3d22 3022 2067 656f 6d65 7472 7950  es="0" geometryP
+00003f10: 7265 6369 7369 6f6e 3d22 3022 3e0a 0909  recision="0">...
+00003f20: 3c61 6374 6976 6543 6865 636b 732f 3e0a  <activeChecks/>.
+00003f30: 0909 3c63 6865 636b 436f 6e66 6967 7572  ..<checkConfigur
+00003f40: 6174 696f 6e20 7479 7065 3d22 4d61 7022  ation type="Map"
+00003f50: 3e0a 0909 093c 4f70 7469 6f6e 206e 616d  >....<Option nam
+00003f60: 653d 2251 6773 4765 6f6d 6574 7279 4761  e="QgsGeometryGa
+00003f70: 7043 6865 636b 2220 7479 7065 3d22 4d61  pCheck" type="Ma
+00003f80: 7022 3e0a 0909 0909 3c4f 7074 696f 6e20  p">.....<Option 
+00003f90: 6e61 6d65 3d22 616c 6c6f 7765 6447 6170  name="allowedGap
+00003fa0: 7342 7566 6665 7222 2076 616c 7565 3d22  sBuffer" value="
+00003fb0: 3022 2074 7970 653d 2264 6f75 626c 6522  0" type="double"
+00003fc0: 2f3e 0a09 0909 093c 4f70 7469 6f6e 206e  />.....<Option n
+00003fd0: 616d 653d 2261 6c6c 6f77 6564 4761 7073  ame="allowedGaps
+00003fe0: 456e 6162 6c65 6422 2076 616c 7565 3d22  Enabled" value="
+00003ff0: 6661 6c73 6522 2074 7970 653d 2262 6f6f  false" type="boo
+00004000: 6c22 2f3e 0a09 0909 093c 4f70 7469 6f6e  l"/>.....<Option
+00004010: 206e 616d 653d 2261 6c6c 6f77 6564 4761   name="allowedGa
+00004020: 7073 4c61 7965 7222 2076 616c 7565 3d22  psLayer" value="
+00004030: 2220 7479 7065 3d22 5153 7472 696e 6722  " type="QString"
+00004040: 2f3e 0a09 0909 3c2f 4f70 7469 6f6e 3e0a  />....</Option>.
+00004050: 0909 3c2f 6368 6563 6b43 6f6e 6669 6775  ..</checkConfigu
+00004060: 7261 7469 6f6e 3e0a 093c 2f67 656f 6d65  ration>..</geome
+00004070: 7472 794f 7074 696f 6e73 3e0a 093c 6c65  tryOptions>..<le
+00004080: 6765 6e64 2073 686f 774c 6162 656c 4c65  gend showLabelLe
+00004090: 6765 6e64 3d22 3022 2074 7970 653d 2264  gend="0" type="d
+000040a0: 6566 6175 6c74 2d76 6563 746f 7222 2f3e  efault-vector"/>
+000040b0: 0a09 3c72 6566 6572 656e 6365 644c 6179  ..<referencedLay
+000040c0: 6572 732f 3e0a 093c 6669 656c 6443 6f6e  ers/>..<fieldCon
+000040d0: 6669 6775 7261 7469 6f6e 3e0a 0909 3c66  figuration>...<f
+000040e0: 6965 6c64 206e 616d 653d 2266 6964 2220  ield name="fid" 
+000040f0: 636f 6e66 6967 7572 6174 696f 6e46 6c61  configurationFla
+00004100: 6773 3d22 4e6f 6e65 223e 0a09 0909 3c65  gs="None">....<e
+00004110: 6469 7457 6964 6765 7420 7479 7065 3d22  ditWidget type="
+00004120: 5465 7874 4564 6974 223e 0a09 0909 093c  TextEdit">.....<
+00004130: 636f 6e66 6967 3e0a 0909 0909 093c 4f70  config>......<Op
+00004140: 7469 6f6e 2f3e 0a09 0909 093c 2f63 6f6e  tion/>.....</con
+00004150: 6669 673e 0a09 0909 3c2f 6564 6974 5769  fig>....</editWi
+00004160: 6467 6574 3e0a 0909 3c2f 6669 656c 643e  dget>...</field>
+00004170: 0a09 093c 6669 656c 6420 6e61 6d65 3d22  ...<field name="
+00004180: 636c 6173 736e 616d 6522 2063 6f6e 6669  classname" confi
+00004190: 6775 7261 7469 6f6e 466c 6167 733d 224e  gurationFlags="N
+000041a0: 6f6e 6522 3e0a 0909 093c 6564 6974 5769  one">....<editWi
+000041b0: 6467 6574 2074 7970 653d 2254 6578 7445  dget type="TextE
+000041c0: 6469 7422 3e0a 0909 0909 3c63 6f6e 6669  dit">.....<confi
+000041d0: 673e 0a09 0909 0909 3c4f 7074 696f 6e2f  g>......<Option/
+000041e0: 3e0a 0909 0909 3c2f 636f 6e66 6967 3e0a  >.....</config>.
+000041f0: 0909 093c 2f65 6469 7457 6964 6765 743e  ...</editWidget>
+00004200: 0a09 093c 2f66 6965 6c64 3e0a 093c 2f66  ...</field>..</f
+00004210: 6965 6c64 436f 6e66 6967 7572 6174 696f  ieldConfiguratio
+00004220: 6e3e 0a09 3c61 6c69 6173 6573 3e0a 0909  n>..<aliases>...
+00004230: 3c61 6c69 6173 206e 616d 653d 2222 2069  <alias name="" i
+00004240: 6e64 6578 3d22 3022 2066 6965 6c64 3d22  ndex="0" field="
+00004250: 6669 6422 2f3e 0a09 093c 616c 6961 7320  fid"/>...<alias 
+00004260: 6e61 6d65 3d22 2220 696e 6465 783d 2231  name="" index="1
+00004270: 2220 6669 656c 643d 2263 6c61 7373 6e61  " field="classna
+00004280: 6d65 222f 3e0a 093c 2f61 6c69 6173 6573  me"/>..</aliases
+00004290: 3e0a 093c 6465 6661 756c 7473 3e0a 0909  >..<defaults>...
+000042a0: 3c64 6566 6175 6c74 2061 7070 6c79 4f6e  <default applyOn
+000042b0: 5570 6461 7465 3d22 3022 2066 6965 6c64  Update="0" field
+000042c0: 3d22 6669 6422 2065 7870 7265 7373 696f  ="fid" expressio
+000042d0: 6e3d 2222 2f3e 0a09 093c 6465 6661 756c  n=""/>...<defaul
+000042e0: 7420 6170 706c 794f 6e55 7064 6174 653d  t applyOnUpdate=
+000042f0: 2230 2220 6669 656c 643d 2263 6c61 7373  "0" field="class
+00004300: 6e61 6d65 2220 6578 7072 6573 7369 6f6e  name" expression
+00004310: 3d22 222f 3e0a 093c 2f64 6566 6175 6c74  =""/>..</default
+00004320: 733e 0a09 3c63 6f6e 7374 7261 696e 7473  s>..<constraints
+00004330: 3e0a 0909 3c63 6f6e 7374 7261 696e 7420  >...<constraint 
+00004340: 756e 6971 7565 5f73 7472 656e 6774 683d  unique_strength=
+00004350: 2231 2220 6578 705f 7374 7265 6e67 7468  "1" exp_strength
+00004360: 3d22 3022 206e 6f74 6e75 6c6c 5f73 7472  ="0" notnull_str
+00004370: 656e 6774 683d 2231 2220 6669 656c 643d  ength="1" field=
+00004380: 2266 6964 2220 636f 6e73 7472 6169 6e74  "fid" constraint
+00004390: 733d 2233 222f 3e0a 0909 3c63 6f6e 7374  s="3"/>...<const
+000043a0: 7261 696e 7420 756e 6971 7565 5f73 7472  raint unique_str
+000043b0: 656e 6774 683d 2230 2220 6578 705f 7374  ength="0" exp_st
+000043c0: 7265 6e67 7468 3d22 3022 206e 6f74 6e75  rength="0" notnu
+000043d0: 6c6c 5f73 7472 656e 6774 683d 2230 2220  ll_strength="0" 
+000043e0: 6669 656c 643d 2263 6c61 7373 6e61 6d65  field="classname
+000043f0: 2220 636f 6e73 7472 6169 6e74 733d 2230  " constraints="0
+00004400: 222f 3e0a 093c 2f63 6f6e 7374 7261 696e  "/>..</constrain
+00004410: 7473 3e0a 093c 636f 6e73 7472 6169 6e74  ts>..<constraint
+00004420: 4578 7072 6573 7369 6f6e 733e 0a09 093c  Expressions>...<
+00004430: 636f 6e73 7472 6169 6e74 2065 7870 3d22  constraint exp="
+00004440: 2220 6465 7363 3d22 2220 6669 656c 643d  " desc="" field=
+00004450: 2266 6964 222f 3e0a 0909 3c63 6f6e 7374  "fid"/>...<const
+00004460: 7261 696e 7420 6578 703d 2222 2064 6573  raint exp="" des
+00004470: 633d 2222 2066 6965 6c64 3d22 636c 6173  c="" field="clas
+00004480: 736e 616d 6522 2f3e 0a09 3c2f 636f 6e73  sname"/>..</cons
+00004490: 7472 6169 6e74 4578 7072 6573 7369 6f6e  traintExpression
+000044a0: 733e 0a09 3c65 7870 7265 7373 696f 6e66  s>..<expressionf
+000044b0: 6965 6c64 732f 3e0a 093c 6174 7472 6962  ields/>..<attrib
+000044c0: 7574 6561 6374 696f 6e73 3e0a 0909 3c64  uteactions>...<d
+000044d0: 6566 6175 6c74 4163 7469 6f6e 206b 6579  efaultAction key
+000044e0: 3d22 4361 6e76 6173 2220 7661 6c75 653d  ="Canvas" value=
+000044f0: 227b 3030 3030 3030 3030 2d30 3030 302d  "{00000000-0000-
+00004500: 3030 3030 2d30 3030 302d 3030 3030 3030  0000-0000-000000
+00004510: 3030 3030 3030 7d22 2f3e 0a09 3c2f 6174  000000}"/>..</at
+00004520: 7472 6962 7574 6561 6374 696f 6e73 3e0a  tributeactions>.
+00004530: 093c 6174 7472 6962 7574 6574 6162 6c65  .<attributetable
+00004540: 636f 6e66 6967 2073 6f72 744f 7264 6572  config sortOrder
+00004550: 3d22 3022 2073 6f72 7445 7870 7265 7373  ="0" sortExpress
+00004560: 696f 6e3d 2222 2061 6374 696f 6e57 6964  ion="" actionWid
+00004570: 6765 7453 7479 6c65 3d22 6472 6f70 446f  getStyle="dropDo
+00004580: 776e 223e 0a09 093c 636f 6c75 6d6e 733e  wn">...<columns>
+00004590: 0a09 0909 3c63 6f6c 756d 6e20 6e61 6d65  ....<column name
+000045a0: 3d22 6669 6422 2074 7970 653d 2266 6965  ="fid" type="fie
+000045b0: 6c64 2220 6869 6464 656e 3d22 3022 2077  ld" hidden="0" w
+000045c0: 6964 7468 3d22 2d31 222f 3e0a 0909 093c  idth="-1"/>....<
+000045d0: 636f 6c75 6d6e 206e 616d 653d 2263 6c61  column name="cla
+000045e0: 7373 6e61 6d65 2220 7479 7065 3d22 6669  ssname" type="fi
+000045f0: 656c 6422 2068 6964 6465 6e3d 2230 2220  eld" hidden="0" 
+00004600: 7769 6474 683d 222d 3122 2f3e 0a09 0909  width="-1"/>....
+00004610: 3c63 6f6c 756d 6e20 7479 7065 3d22 6163  <column type="ac
+00004620: 7469 6f6e 7322 2068 6964 6465 6e3d 2231  tions" hidden="1
+00004630: 2220 7769 6474 683d 222d 3122 2f3e 0a09  " width="-1"/>..
+00004640: 093c 2f63 6f6c 756d 6e73 3e0a 093c 2f61  .</columns>..</a
+00004650: 7474 7269 6275 7465 7461 626c 6563 6f6e  ttributetablecon
+00004660: 6669 673e 0a09 3c63 6f6e 6469 7469 6f6e  fig>..<condition
+00004670: 616c 7374 796c 6573 3e0a 0909 3c72 6f77  alstyles>...<row
+00004680: 7374 796c 6573 2f3e 0a09 093c 6669 656c  styles/>...<fiel
+00004690: 6473 7479 6c65 732f 3e0a 093c 2f63 6f6e  dstyles/>..</con
+000046a0: 6469 7469 6f6e 616c 7374 796c 6573 3e0a  ditionalstyles>.
+000046b0: 093c 7374 6f72 6564 6578 7072 6573 7369  .<storedexpressi
+000046c0: 6f6e 732f 3e0a 093c 6564 6974 666f 726d  ons/>..<editform
+000046d0: 2074 6f6c 6572 616e 743d 2231 223e 3c2f   tolerant="1"></
+000046e0: 6564 6974 666f 726d 3e0a 093c 6564 6974  editform>..<edit
+000046f0: 666f 726d 696e 6974 2f3e 0a09 3c65 6469  forminit/>..<edi
+00004700: 7466 6f72 6d69 6e69 7463 6f64 6573 6f75  tforminitcodesou
+00004710: 7263 653e 303c 2f65 6469 7466 6f72 6d69  rce>0</editformi
+00004720: 6e69 7463 6f64 6573 6f75 7263 653e 0a09  nitcodesource>..
+00004730: 3c65 6469 7466 6f72 6d69 6e69 7466 696c  <editforminitfil
+00004740: 6570 6174 683e 3c2f 6564 6974 666f 726d  epath></editform
+00004750: 696e 6974 6669 6c65 7061 7468 3e0a 093c  initfilepath>..<
+00004760: 6564 6974 666f 726d 696e 6974 636f 6465  editforminitcode
+00004770: 3e3c 215b 4344 4154 415b 2320 2d2a 2d20  ><![CDATA[# -*- 
+00004780: 636f 6469 6e67 3a20 7574 662d 3820 2d2a  coding: utf-8 -*
+00004790: 2d0a 2020 2020 2020 2020 2222 220a 2020  -.        """.  
+000047a0: 2020 2020 2020 5147 4953 2066 6f72 6d73        QGIS forms
+000047b0: 2063 616e 2068 6176 6520 6120 5079 7468   can have a Pyth
+000047c0: 6f6e 2066 756e 6374 696f 6e20 7468 6174  on function that
+000047d0: 2069 7320 6361 6c6c 6564 2077 6865 6e20   is called when 
+000047e0: 7468 6520 666f 726d 2069 730a 2020 2020  the form is.    
+000047f0: 2020 2020 6f70 656e 6564 2e0a 0a20 2020      opened...   
+00004800: 2020 2020 2055 7365 2074 6869 7320 6675       Use this fu
+00004810: 6e63 7469 6f6e 2074 6f20 6164 6420 6578  nction to add ex
+00004820: 7472 6120 6c6f 6769 6320 746f 2079 6f75  tra logic to you
+00004830: 7220 666f 726d 732e 0a0a 2020 2020 2020  r forms...      
+00004840: 2020 456e 7465 7220 7468 6520 6e61 6d65    Enter the name
+00004850: 206f 6620 7468 6520 6675 6e63 7469 6f6e   of the function
+00004860: 2069 6e20 7468 6520 2250 7974 686f 6e20   in the "Python 
+00004870: 496e 6974 2066 756e 6374 696f 6e22 0a20  Init function". 
+00004880: 2020 2020 2020 2066 6965 6c64 2e0a 2020         field..  
+00004890: 2020 2020 2020 416e 2065 7861 6d70 6c65        An example
+000048a0: 2066 6f6c 6c6f 7773 3a0a 2020 2020 2020   follows:.      
+000048b0: 2020 2222 220a 2020 2020 2020 2020 6672    """.        fr
+000048c0: 6f6d 2071 6769 732e 5079 5174 2e51 7457  om qgis.PyQt.QtW
+000048d0: 6964 6765 7473 2069 6d70 6f72 7420 5157  idgets import QW
+000048e0: 6964 6765 740a 0a20 2020 2020 2020 2064  idget..        d
+000048f0: 6566 206d 795f 666f 726d 5f6f 7065 6e28  ef my_form_open(
+00004900: 6469 616c 6f67 2c20 6c61 7965 722c 2066  dialog, layer, f
+00004910: 6561 7475 7265 293a 0a20 2020 2020 2020  eature):.       
+00004920: 2020 2020 2067 656f 6d20 3d20 6665 6174       geom = feat
+00004930: 7572 652e 6765 6f6d 6574 7279 2829 0a20  ure.geometry(). 
+00004940: 2020 2020 2020 2020 2020 2063 6f6e 7472             contr
+00004950: 6f6c 203d 2064 6961 6c6f 672e 6669 6e64  ol = dialog.find
+00004960: 4368 696c 6428 5157 6964 6765 742c 2022  Child(QWidget, "
+00004970: 4d79 4c69 6e65 4564 6974 2229 0a20 2020  MyLineEdit").   
+00004980: 2020 2020 205d 5d3e 3c2f 6564 6974 666f       ]]></editfo
+00004990: 726d 696e 6974 636f 6465 3e0a 093c 6665  rminitcode>..<fe
+000049a0: 6174 666f 726d 7375 7070 7265 7373 3e30  atformsuppress>0
+000049b0: 3c2f 6665 6174 666f 726d 7375 7070 7265  </featformsuppre
+000049c0: 7373 3e0a 093c 6564 6974 6f72 6c61 796f  ss>..<editorlayo
+000049d0: 7574 3e67 656e 6572 6174 6564 6c61 796f  ut>generatedlayo
+000049e0: 7574 3c2f 6564 6974 6f72 6c61 796f 7574  ut</editorlayout
+000049f0: 3e0a 093c 6564 6974 6162 6c65 3e0a 0909  >..<editable>...
+00004a00: 3c66 6965 6c64 206e 616d 653d 2263 6c61  <field name="cla
+00004a10: 7373 6e61 6d65 2220 6564 6974 6162 6c65  ssname" editable
+00004a20: 3d22 3122 2f3e 0a09 093c 6669 656c 6420  ="1"/>...<field 
+00004a30: 6e61 6d65 3d22 6669 6422 2065 6469 7461  name="fid" edita
+00004a40: 626c 653d 2231 222f 3e0a 093c 2f65 6469  ble="1"/>..</edi
+00004a50: 7461 626c 653e 0a09 3c6c 6162 656c 4f6e  table>..<labelOn
+00004a60: 546f 703e 0a09 093c 6669 656c 6420 6e61  Top>...<field na
+00004a70: 6d65 3d22 636c 6173 736e 616d 6522 206c  me="classname" l
+00004a80: 6162 656c 4f6e 546f 703d 2230 222f 3e0a  abelOnTop="0"/>.
+00004a90: 0909 3c66 6965 6c64 206e 616d 653d 2266  ..<field name="f
+00004aa0: 6964 2220 6c61 6265 6c4f 6e54 6f70 3d22  id" labelOnTop="
+00004ab0: 3022 2f3e 0a09 3c2f 6c61 6265 6c4f 6e54  0"/>..</labelOnT
+00004ac0: 6f70 3e0a 093c 7265 7573 654c 6173 7456  op>..<reuseLastV
+00004ad0: 616c 7565 3e0a 0909 3c66 6965 6c64 2072  alue>...<field r
+00004ae0: 6575 7365 4c61 7374 5661 6c75 653d 2230  euseLastValue="0
+00004af0: 2220 6e61 6d65 3d22 636c 6173 736e 616d  " name="classnam
+00004b00: 6522 2f3e 0a09 093c 6669 656c 6420 7265  e"/>...<field re
+00004b10: 7573 654c 6173 7456 616c 7565 3d22 3022  useLastValue="0"
+00004b20: 206e 616d 653d 2266 6964 222f 3e0a 093c   name="fid"/>..<
+00004b30: 2f72 6575 7365 4c61 7374 5661 6c75 653e  /reuseLastValue>
+00004b40: 0a09 3c64 6174 6144 6566 696e 6564 4669  ..<dataDefinedFi
+00004b50: 656c 6450 726f 7065 7274 6965 732f 3e0a  eldProperties/>.
+00004b60: 093c 7769 6467 6574 732f 3e0a 093c 7072  .<widgets/>..<pr
+00004b70: 6576 6965 7745 7870 7265 7373 696f 6e3e  eviewExpression>
+00004b80: 2263 6c61 7373 6e61 6d65 223c 2f70 7265  "classname"</pre
+00004b90: 7669 6577 4578 7072 6573 7369 6f6e 3e0a  viewExpression>.
+00004ba0: 093c 6d61 7054 6970 3e3c 2f6d 6170 5469  .<mapTip></mapTi
+00004bb0: 703e 0a09 3c6c 6179 6572 4765 6f6d 6574  p>..<layerGeomet
+00004bc0: 7279 5479 7065 3e32 3c2f 6c61 7965 7247  ryType>2</layerG
+00004bd0: 656f 6d65 7472 7954 7970 653e 0a3c 2f71  eometryType>.</q
+00004be0: 6769 733e                                gis>
```

### Comparing `geofileops-0.8.0a1/tests/data/polygonstyle.sld` & `geofileops-0.8.0a2/tests/data/polygonstyle.sld`

 * *Format-specific differences are supported for XML files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: XML 1.0 document, ASCII text, with very long lines (358), with CRLF line terminators*

 * *Files 13% similar despite different names*

```diff
@@ -1,105 +1,102 @@
 00000000: 3c3f 786d 6c20 7665 7273 696f 6e3d 2231  <?xml version="1
 00000010: 2e30 2220 656e 636f 6469 6e67 3d22 5554  .0" encoding="UT
-00000020: 462d 3822 3f3e 0d0a 3c53 7479 6c65 644c  F-8"?>..<StyledL
-00000030: 6179 6572 4465 7363 7269 7074 6f72 2078  ayerDescriptor x
-00000040: 6d6c 6e73 3d22 6874 7470 3a2f 2f77 7777  mlns="http://www
-00000050: 2e6f 7065 6e67 6973 2e6e 6574 2f73 6c64  .opengis.net/sld
-00000060: 2220 786d 6c6e 733a 6f67 633d 2268 7474  " xmlns:ogc="htt
-00000070: 703a 2f2f 7777 772e 6f70 656e 6769 732e  p://www.opengis.
-00000080: 6e65 742f 6f67 6322 2078 6d6c 6e73 3a78  net/ogc" xmlns:x
-00000090: 6c69 6e6b 3d22 6874 7470 3a2f 2f77 7777  link="http://www
-000000a0: 2e77 332e 6f72 672f 3139 3939 2f78 6c69  .w3.org/1999/xli
-000000b0: 6e6b 2220 786d 6c6e 733a 7873 693d 2268  nk" xmlns:xsi="h
-000000c0: 7474 703a 2f2f 7777 772e 7733 2e6f 7267  ttp://www.w3.org
-000000d0: 2f32 3030 312f 584d 4c53 6368 656d 612d  /2001/XMLSchema-
-000000e0: 696e 7374 616e 6365 2220 7873 693a 7363  instance" xsi:sc
-000000f0: 6865 6d61 4c6f 6361 7469 6f6e 3d22 6874  hemaLocation="ht
-00000100: 7470 3a2f 2f77 7777 2e6f 7065 6e67 6973  tp://www.opengis
-00000110: 2e6e 6574 2f73 6c64 2068 7474 703a 2f2f  .net/sld http://
-00000120: 7363 6865 6d61 732e 6f70 656e 6769 732e  schemas.opengis.
-00000130: 6e65 742f 736c 642f 312e 312e 302f 5374  net/sld/1.1.0/St
-00000140: 796c 6564 4c61 7965 7244 6573 6372 6970  yledLayerDescrip
-00000150: 746f 722e 7873 6422 2076 6572 7369 6f6e  tor.xsd" version
-00000160: 3d22 312e 312e 3022 2078 6d6c 6e73 3a73  ="1.1.0" xmlns:s
-00000170: 653d 2268 7474 703a 2f2f 7777 772e 6f70  e="http://www.op
-00000180: 656e 6769 732e 6e65 742f 7365 223e 0d0a  engis.net/se">..
-00000190: 093c 4e61 6d65 644c 6179 6572 3e0d 0a09  .<NamedLayer>...
-000001a0: 093c 7365 3a4e 616d 653e 7472 6565 735f  .<se:Name>trees_
-000001b0: 3138 5f34 3139 5f53 452d 7465 7374 726f  18_419_SE-testro
-000001c0: 692d 3230 3232 3c2f 7365 3a4e 616d 653e  i-2022</se:Name>
-000001d0: 0d0a 0909 3c55 7365 7253 7479 6c65 3e0d  ....<UserStyle>.
-000001e0: 0a09 0909 3c73 653a 4e61 6d65 3e74 7265  ....<se:Name>tre
-000001f0: 6573 5f31 385f 3431 395f 5345 2d74 6573  es_18_419_SE-tes
-00000200: 7472 6f69 2d32 3032 323c 2f73 653a 4e61  troi-2022</se:Na
-00000210: 6d65 3e0d 0a09 0909 3c73 653a 4665 6174  me>.....<se:Feat
-00000220: 7572 6554 7970 6553 7479 6c65 3e0d 0a09  ureTypeStyle>...
-00000230: 0909 093c 7365 3a52 756c 653e 0d0a 0909  ...<se:Rule>....
-00000240: 0909 093c 7365 3a4e 616d 653e 5369 6e67  ...<se:Name>Sing
-00000250: 6c65 2073 796d 626f 6c3c 2f73 653a 4e61  le symbol</se:Na
-00000260: 6d65 3e0d 0a09 0909 0909 3c73 653a 506f  me>.......<se:Po
-00000270: 6c79 676f 6e53 796d 626f 6c69 7a65 723e  lygonSymbolizer>
-00000280: 0d0a 0909 0909 0909 3c73 653a 4669 6c6c  ........<se:Fill
-00000290: 3e0d 0a09 0909 0909 0909 3c73 653a 4772  >.........<se:Gr
-000002a0: 6170 6869 6346 696c 6c3e 0d0a 0909 0909  aphicFill>......
-000002b0: 0909 0909 3c73 653a 4772 6170 6869 633e  ....<se:Graphic>
-000002c0: 0d0a 0909 0909 0909 0909 093c 7365 3a4d  ...........<se:M
-000002d0: 6172 6b3e 0d0a 0909 0909 0909 0909 0909  ark>............
-000002e0: 3c73 653a 5765 6c6c 4b6e 6f77 6e4e 616d  <se:WellKnownNam
-000002f0: 653e 686f 726c 696e 653c 2f73 653a 5765  e>horline</se:We
-00000300: 6c6c 4b6e 6f77 6e4e 616d 653e 0d0a 0909  llKnownName>....
-00000310: 0909 0909 0909 0909 3c73 653a 5374 726f  ........<se:Stro
-00000320: 6b65 3e0d 0a09 0909 0909 0909 0909 0909  ke>.............
-00000330: 3c73 653a 5376 6750 6172 616d 6574 6572  <se:SvgParameter
-00000340: 206e 616d 653d 2273 7472 6f6b 6522 3e23   name="stroke">#
-00000350: 3063 6636 3030 3c2f 7365 3a53 7667 5061  0cf600</se:SvgPa
-00000360: 7261 6d65 7465 723e 0d0a 0909 0909 0909  rameter>........
-00000370: 0909 0909 093c 7365 3a53 7667 5061 7261  .....<se:SvgPara
-00000380: 6d65 7465 7220 6e61 6d65 3d22 7374 726f  meter name="stro
-00000390: 6b65 2d77 6964 7468 223e 313c 2f73 653a  ke-width">1</se:
-000003a0: 5376 6750 6172 616d 6574 6572 3e0d 0a09  SvgParameter>...
-000003b0: 0909 0909 0909 0909 093c 2f73 653a 5374  .........</se:St
-000003c0: 726f 6b65 3e0d 0a09 0909 0909 0909 0909  roke>...........
-000003d0: 3c2f 7365 3a4d 6172 6b3e 0d0a 0909 0909  </se:Mark>......
-000003e0: 0909 0909 093c 7365 3a53 697a 653e 373c  .....<se:Size>7<
-000003f0: 2f73 653a 5369 7a65 3e0d 0a09 0909 0909  /se:Size>.......
-00000400: 0909 0909 3c73 653a 526f 7461 7469 6f6e  ....<se:Rotation
-00000410: 3e0d 0a09 0909 0909 0909 0909 093c 6f67  >............<og
-00000420: 633a 4c69 7465 7261 6c3e 3435 3c2f 6f67  c:Literal>45</og
-00000430: 633a 4c69 7465 7261 6c3e 0d0a 0909 0909  c:Literal>......
-00000440: 0909 0909 093c 2f73 653a 526f 7461 7469  .....</se:Rotati
-00000450: 6f6e 3e0d 0a09 0909 0909 0909 093c 2f73  on>..........</s
-00000460: 653a 4772 6170 6869 633e 0d0a 0909 0909  e:Graphic>......
-00000470: 0909 093c 2f73 653a 4772 6170 6869 6346  ...</se:GraphicF
-00000480: 696c 6c3e 0d0a 0909 0909 0909 3c2f 7365  ill>........</se
-00000490: 3a46 696c 6c3e 0d0a 0909 0909 093c 2f73  :Fill>.......</s
-000004a0: 653a 506f 6c79 676f 6e53 796d 626f 6c69  e:PolygonSymboli
-000004b0: 7a65 723e 0d0a 0909 0909 093c 7365 3a4c  zer>.......<se:L
-000004c0: 696e 6553 796d 626f 6c69 7a65 723e 0d0a  ineSymbolizer>..
-000004d0: 0909 0909 0909 3c73 653a 5374 726f 6b65  ......<se:Stroke
-000004e0: 3e0d 0a09 0909 0909 0909 3c73 653a 5376  >.........<se:Sv
-000004f0: 6750 6172 616d 6574 6572 206e 616d 653d  gParameter name=
-00000500: 2273 7472 6f6b 6522 3e23 3063 6636 3030  "stroke">#0cf600
-00000510: 3c2f 7365 3a53 7667 5061 7261 6d65 7465  </se:SvgParamete
-00000520: 723e 0d0a 0909 0909 0909 093c 7365 3a53  r>.........<se:S
-00000530: 7667 5061 7261 6d65 7465 7220 6e61 6d65  vgParameter name
-00000540: 3d22 7374 726f 6b65 2d77 6964 7468 223e  ="stroke-width">
-00000550: 323c 2f73 653a 5376 6750 6172 616d 6574  2</se:SvgParamet
-00000560: 6572 3e0d 0a09 0909 0909 0909 3c73 653a  er>.........<se:
-00000570: 5376 6750 6172 616d 6574 6572 206e 616d  SvgParameter nam
-00000580: 653d 2273 7472 6f6b 652d 6c69 6e65 6a6f  e="stroke-linejo
-00000590: 696e 223e 6265 7665 6c3c 2f73 653a 5376  in">bevel</se:Sv
-000005a0: 6750 6172 616d 6574 6572 3e0d 0a09 0909  gParameter>.....
-000005b0: 0909 0909 3c73 653a 5376 6750 6172 616d  ....<se:SvgParam
-000005c0: 6574 6572 206e 616d 653d 2273 7472 6f6b  eter name="strok
-000005d0: 652d 6c69 6e65 6361 7022 3e73 7175 6172  e-linecap">squar
-000005e0: 653c 2f73 653a 5376 6750 6172 616d 6574  e</se:SvgParamet
-000005f0: 6572 3e0d 0a09 0909 0909 093c 2f73 653a  er>........</se:
-00000600: 5374 726f 6b65 3e0d 0a09 0909 0909 3c2f  Stroke>.......</
-00000610: 7365 3a4c 696e 6553 796d 626f 6c69 7a65  se:LineSymbolize
-00000620: 723e 0d0a 0909 0909 3c2f 7365 3a52 756c  r>......</se:Rul
-00000630: 653e 0d0a 0909 093c 2f73 653a 4665 6174  e>.....</se:Feat
-00000640: 7572 6554 7970 6553 7479 6c65 3e0d 0a09  ureTypeStyle>...
-00000650: 093c 2f55 7365 7253 7479 6c65 3e0d 0a09  .</UserStyle>...
-00000660: 3c2f 4e61 6d65 644c 6179 6572 3e0d 0a3c  </NamedLayer>..<
-00000670: 2f53 7479 6c65 644c 6179 6572 4465 7363  /StyledLayerDesc
-00000680: 7269 7074 6f72 3e                        riptor>
+00000020: 462d 3822 3f3e 0a3c 5374 796c 6564 4c61  F-8"?>.<StyledLa
+00000030: 7965 7244 6573 6372 6970 746f 7220 786d  yerDescriptor xm
+00000040: 6c6e 733d 2268 7474 703a 2f2f 7777 772e  lns="http://www.
+00000050: 6f70 656e 6769 732e 6e65 742f 736c 6422  opengis.net/sld"
+00000060: 2078 6d6c 6e73 3a6f 6763 3d22 6874 7470   xmlns:ogc="http
+00000070: 3a2f 2f77 7777 2e6f 7065 6e67 6973 2e6e  ://www.opengis.n
+00000080: 6574 2f6f 6763 2220 786d 6c6e 733a 786c  et/ogc" xmlns:xl
+00000090: 696e 6b3d 2268 7474 703a 2f2f 7777 772e  ink="http://www.
+000000a0: 7733 2e6f 7267 2f31 3939 392f 786c 696e  w3.org/1999/xlin
+000000b0: 6b22 2078 6d6c 6e73 3a78 7369 3d22 6874  k" xmlns:xsi="ht
+000000c0: 7470 3a2f 2f77 7777 2e77 332e 6f72 672f  tp://www.w3.org/
+000000d0: 3230 3031 2f58 4d4c 5363 6865 6d61 2d69  2001/XMLSchema-i
+000000e0: 6e73 7461 6e63 6522 2078 7369 3a73 6368  nstance" xsi:sch
+000000f0: 656d 614c 6f63 6174 696f 6e3d 2268 7474  emaLocation="htt
+00000100: 703a 2f2f 7777 772e 6f70 656e 6769 732e  p://www.opengis.
+00000110: 6e65 742f 736c 6420 6874 7470 3a2f 2f73  net/sld http://s
+00000120: 6368 656d 6173 2e6f 7065 6e67 6973 2e6e  chemas.opengis.n
+00000130: 6574 2f73 6c64 2f31 2e31 2e30 2f53 7479  et/sld/1.1.0/Sty
+00000140: 6c65 644c 6179 6572 4465 7363 7269 7074  ledLayerDescript
+00000150: 6f72 2e78 7364 2220 7665 7273 696f 6e3d  or.xsd" version=
+00000160: 2231 2e31 2e30 2220 786d 6c6e 733a 7365  "1.1.0" xmlns:se
+00000170: 3d22 6874 7470 3a2f 2f77 7777 2e6f 7065  ="http://www.ope
+00000180: 6e67 6973 2e6e 6574 2f73 6522 3e0a 093c  ngis.net/se">..<
+00000190: 4e61 6d65 644c 6179 6572 3e0a 0909 3c73  NamedLayer>...<s
+000001a0: 653a 4e61 6d65 3e74 7265 6573 5f31 385f  e:Name>trees_18_
+000001b0: 3431 395f 5345 2d74 6573 7472 6f69 2d32  419_SE-testroi-2
+000001c0: 3032 323c 2f73 653a 4e61 6d65 3e0a 0909  022</se:Name>...
+000001d0: 3c55 7365 7253 7479 6c65 3e0a 0909 093c  <UserStyle>....<
+000001e0: 7365 3a4e 616d 653e 7472 6565 735f 3138  se:Name>trees_18
+000001f0: 5f34 3139 5f53 452d 7465 7374 726f 692d  _419_SE-testroi-
+00000200: 3230 3232 3c2f 7365 3a4e 616d 653e 0a09  2022</se:Name>..
+00000210: 0909 3c73 653a 4665 6174 7572 6554 7970  ..<se:FeatureTyp
+00000220: 6553 7479 6c65 3e0a 0909 0909 3c73 653a  eStyle>.....<se:
+00000230: 5275 6c65 3e0a 0909 0909 093c 7365 3a4e  Rule>......<se:N
+00000240: 616d 653e 5369 6e67 6c65 2073 796d 626f  ame>Single symbo
+00000250: 6c3c 2f73 653a 4e61 6d65 3e0a 0909 0909  l</se:Name>.....
+00000260: 093c 7365 3a50 6f6c 7967 6f6e 5379 6d62  .<se:PolygonSymb
+00000270: 6f6c 697a 6572 3e0a 0909 0909 0909 3c73  olizer>.......<s
+00000280: 653a 4669 6c6c 3e0a 0909 0909 0909 093c  e:Fill>........<
+00000290: 7365 3a47 7261 7068 6963 4669 6c6c 3e0a  se:GraphicFill>.
+000002a0: 0909 0909 0909 0909 3c73 653a 4772 6170  ........<se:Grap
+000002b0: 6869 633e 0a09 0909 0909 0909 0909 3c73  hic>..........<s
+000002c0: 653a 4d61 726b 3e0a 0909 0909 0909 0909  e:Mark>.........
+000002d0: 0909 3c73 653a 5765 6c6c 4b6e 6f77 6e4e  ..<se:WellKnownN
+000002e0: 616d 653e 686f 726c 696e 653c 2f73 653a  ame>horline</se:
+000002f0: 5765 6c6c 4b6e 6f77 6e4e 616d 653e 0a09  WellKnownName>..
+00000300: 0909 0909 0909 0909 093c 7365 3a53 7472  .........<se:Str
+00000310: 6f6b 653e 0a09 0909 0909 0909 0909 0909  oke>............
+00000320: 3c73 653a 5376 6750 6172 616d 6574 6572  <se:SvgParameter
+00000330: 206e 616d 653d 2273 7472 6f6b 6522 3e23   name="stroke">#
+00000340: 3063 6636 3030 3c2f 7365 3a53 7667 5061  0cf600</se:SvgPa
+00000350: 7261 6d65 7465 723e 0a09 0909 0909 0909  rameter>........
+00000360: 0909 0909 3c73 653a 5376 6750 6172 616d  ....<se:SvgParam
+00000370: 6574 6572 206e 616d 653d 2273 7472 6f6b  eter name="strok
+00000380: 652d 7769 6474 6822 3e31 3c2f 7365 3a53  e-width">1</se:S
+00000390: 7667 5061 7261 6d65 7465 723e 0a09 0909  vgParameter>....
+000003a0: 0909 0909 0909 093c 2f73 653a 5374 726f  .......</se:Stro
+000003b0: 6b65 3e0a 0909 0909 0909 0909 093c 2f73  ke>..........</s
+000003c0: 653a 4d61 726b 3e0a 0909 0909 0909 0909  e:Mark>.........
+000003d0: 093c 7365 3a53 697a 653e 373c 2f73 653a  .<se:Size>7</se:
+000003e0: 5369 7a65 3e0a 0909 0909 0909 0909 093c  Size>..........<
+000003f0: 7365 3a52 6f74 6174 696f 6e3e 0a09 0909  se:Rotation>....
+00000400: 0909 0909 0909 093c 6f67 633a 4c69 7465  .......<ogc:Lite
+00000410: 7261 6c3e 3435 3c2f 6f67 633a 4c69 7465  ral>45</ogc:Lite
+00000420: 7261 6c3e 0a09 0909 0909 0909 0909 3c2f  ral>..........</
+00000430: 7365 3a52 6f74 6174 696f 6e3e 0a09 0909  se:Rotation>....
+00000440: 0909 0909 093c 2f73 653a 4772 6170 6869  .....</se:Graphi
+00000450: 633e 0a09 0909 0909 0909 3c2f 7365 3a47  c>........</se:G
+00000460: 7261 7068 6963 4669 6c6c 3e0a 0909 0909  raphicFill>.....
+00000470: 0909 3c2f 7365 3a46 696c 6c3e 0a09 0909  ..</se:Fill>....
+00000480: 0909 3c2f 7365 3a50 6f6c 7967 6f6e 5379  ..</se:PolygonSy
+00000490: 6d62 6f6c 697a 6572 3e0a 0909 0909 093c  mbolizer>......<
+000004a0: 7365 3a4c 696e 6553 796d 626f 6c69 7a65  se:LineSymbolize
+000004b0: 723e 0a09 0909 0909 093c 7365 3a53 7472  r>.......<se:Str
+000004c0: 6f6b 653e 0a09 0909 0909 0909 3c73 653a  oke>........<se:
+000004d0: 5376 6750 6172 616d 6574 6572 206e 616d  SvgParameter nam
+000004e0: 653d 2273 7472 6f6b 6522 3e23 3063 6636  e="stroke">#0cf6
+000004f0: 3030 3c2f 7365 3a53 7667 5061 7261 6d65  00</se:SvgParame
+00000500: 7465 723e 0a09 0909 0909 0909 3c73 653a  ter>........<se:
+00000510: 5376 6750 6172 616d 6574 6572 206e 616d  SvgParameter nam
+00000520: 653d 2273 7472 6f6b 652d 7769 6474 6822  e="stroke-width"
+00000530: 3e32 3c2f 7365 3a53 7667 5061 7261 6d65  >2</se:SvgParame
+00000540: 7465 723e 0a09 0909 0909 0909 3c73 653a  ter>........<se:
+00000550: 5376 6750 6172 616d 6574 6572 206e 616d  SvgParameter nam
+00000560: 653d 2273 7472 6f6b 652d 6c69 6e65 6a6f  e="stroke-linejo
+00000570: 696e 223e 6265 7665 6c3c 2f73 653a 5376  in">bevel</se:Sv
+00000580: 6750 6172 616d 6574 6572 3e0a 0909 0909  gParameter>.....
+00000590: 0909 093c 7365 3a53 7667 5061 7261 6d65  ...<se:SvgParame
+000005a0: 7465 7220 6e61 6d65 3d22 7374 726f 6b65  ter name="stroke
+000005b0: 2d6c 696e 6563 6170 223e 7371 7561 7265  -linecap">square
+000005c0: 3c2f 7365 3a53 7667 5061 7261 6d65 7465  </se:SvgParamete
+000005d0: 723e 0a09 0909 0909 093c 2f73 653a 5374  r>.......</se:St
+000005e0: 726f 6b65 3e0a 0909 0909 093c 2f73 653a  roke>......</se:
+000005f0: 4c69 6e65 5379 6d62 6f6c 697a 6572 3e0a  LineSymbolizer>.
+00000600: 0909 0909 3c2f 7365 3a52 756c 653e 0a09  ....</se:Rule>..
+00000610: 0909 3c2f 7365 3a46 6561 7475 7265 5479  ..</se:FeatureTy
+00000620: 7065 5374 796c 653e 0a09 093c 2f55 7365  peStyle>...</Use
+00000630: 7253 7479 6c65 3e0a 093c 2f4e 616d 6564  rStyle>..</Named
+00000640: 4c61 7965 723e 0a3c 2f53 7479 6c65 644c  Layer>.</StyledL
+00000650: 6179 6572 4465 7363 7269 7074 6f72 3e    ayerDescriptor>
```

### Comparing `geofileops-0.8.0a1/tests/test_general_util.py` & `geofileops-0.8.0a2/tests/test_general_util.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for functionalities in _general_util.
-"""
-
-import datetime
-import time
-
-from geofileops.util import _general_util
-
-
-def test_formatbytes():
-    bytes_str = _general_util.formatbytes(1)
-    assert bytes_str == "1.0 Byte"
-    bytes_str = _general_util.formatbytes(2)
-    assert bytes_str == "2.0 Bytes"
-    bytes_str = _general_util.formatbytes(1024.0)
-    assert bytes_str == "1.00 KB"
-    bytes_str = _general_util.formatbytes(1024.0**2)
-    assert bytes_str == "1.00 MB"
-    bytes_str = _general_util.formatbytes(1024.0**3)
-    assert bytes_str == "1.00 GB"
-    bytes_str = _general_util.formatbytes(1024.0**4)
-    assert bytes_str == "1.00 TB"
-
-
-def test_format_progress():
-    start_time = datetime.datetime.now()
-    nb_todo = 10000
-    for nb_done in range(0, nb_todo + 1, 2000):
-        message = _general_util.format_progress(
-            start_time=start_time,
-            nb_done=nb_done,
-            nb_todo=nb_todo,
-            operation="test",
-            nb_parallel=2,
-        )
-        time.sleep(0.5)
-        if message is not None:
-            print(message)
+# -*- coding: utf-8 -*-
+"""
+Tests for functionalities in _general_util.
+"""
+
+import datetime
+import time
+
+from geofileops.util import _general_util
+
+
+def test_formatbytes():
+    bytes_str = _general_util.formatbytes(1)
+    assert bytes_str == "1.0 Byte"
+    bytes_str = _general_util.formatbytes(2)
+    assert bytes_str == "2.0 Bytes"
+    bytes_str = _general_util.formatbytes(1024.0)
+    assert bytes_str == "1.00 KB"
+    bytes_str = _general_util.formatbytes(1024.0**2)
+    assert bytes_str == "1.00 MB"
+    bytes_str = _general_util.formatbytes(1024.0**3)
+    assert bytes_str == "1.00 GB"
+    bytes_str = _general_util.formatbytes(1024.0**4)
+    assert bytes_str == "1.00 TB"
+
+
+def test_format_progress():
+    start_time = datetime.datetime.now()
+    nb_todo = 10000
+    for nb_done in range(0, nb_todo + 1, 2000):
+        message = _general_util.format_progress(
+            start_time=start_time,
+            nb_done=nb_done,
+            nb_todo=nb_todo,
+            operation="test",
+            nb_parallel=2,
+        )
+        time.sleep(0.5)
+        if message is not None:
+            print(message)
```

### Comparing `geofileops-0.8.0a1/tests/test_geofile.py` & `geofileops-0.8.0a2/tests/test_geofile.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,1068 +1,1070 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for functionalities in geofileops.general.
-"""
-
-import os
-from pathlib import Path
-import sys
-
-import geopandas as gpd
-import pandas as pd
-import pytest
-import shapely.geometry as sh_geom
-
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))  # noqa: E402
-import geofileops as gfo
-from geofileops import fileops
-from geofileops.util import geoseries_util
-from geofileops.util.geometry_util import GeometryType
-from geofileops.util import _io_util
-from tests import test_helper
-from tests.test_helper import DEFAULT_SUFFIXES
-from tests.test_helper import assert_geodataframe_equal
-
-
-ENGINES = ["fiona", "pyogrio"]
-
-
-@pytest.fixture(scope="module", params=ENGINES)
-def engine_setter(request):
-    engine = request.param
-    engine_backup = os.environ.get("GFO_IO_ENGINE", None)
-    if engine is None:
-        del os.environ["GFO_IO_ENGINE"]
-    else:
-        os.environ["GFO_IO_ENGINE"] = engine
-    yield engine
-    if engine_backup is None:
-        del os.environ["GFO_IO_ENGINE"]
-    else:
-        os.environ["GFO_IO_ENGINE"] = engine_backup
-
-
-def test_add_column(tmp_path):
-    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
-
-    # The area column shouldn't be in the test file yet
-    layerinfo = gfo.get_layerinfo(path=test_path, layer="parcels")
-    assert "AREA" not in layerinfo.columns
-
-    # Add area column
-    gfo.add_column(
-        test_path, layer="parcels", name="AREA", type="real", expression="ST_area(geom)"
-    )
-
-    layerinfo = gfo.get_layerinfo(path=test_path, layer="parcels")
-    assert "AREA" in layerinfo.columns
-
-    gdf = gfo.read_file(test_path)
-    assert round(gdf["AREA"].astype("float")[0], 1) == round(
-        gdf["OPPERVL"].astype("float")[0], 1
-    )
-
-    # Add perimeter column
-    gfo.add_column(
-        test_path,
-        name="PERIMETER",
-        type=gfo.DataType.REAL,
-        expression="ST_perimeter(geom)",
-    )
-
-    layerinfo = gfo.get_layerinfo(path=test_path, layer="parcels")
-    assert "AREA" in layerinfo.columns
-
-    gdf = gfo.read_file(test_path)
-    assert round(gdf["AREA"].astype("float")[0], 1) == round(
-        gdf["OPPERVL"].astype("float")[0], 1
-    )
-
-    # Add a column of different gdal types
-    gdal_types = [
-        "Binary",
-        "Date",
-        "DateTime",
-        "Integer",
-        "Integer64",
-        "String",
-        "Time",
-        "Real",
-    ]
-    for type in gdal_types:
-        gfo.add_column(test_path, name=f"column_{type}", type=type)
-    info = gfo.get_layerinfo(test_path)
-    for type in gdal_types:
-        assert f"column_{type}" in info.columns
-
-    # Adding an already existing column doesn't give an error
-    existing_column = list(info.columns)[0]
-    gfo.add_column(test_path, name=existing_column, type="TEXT")
-
-    # Force update on an existing column
-    assert gdf["HFDTLT"][0] == "1"
-    expression = "5"
-    gfo.add_column(
-        test_path, name="HFDTLT", type="TEXT", expression=expression, force_update=True
-    )
-    gdf = gfo.read_file(test_path)
-    assert gdf["HFDTLT"][0] == "5"
-
-
-def test_append_different_layer(tmp_path):
-    # Init
-    src_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
-    dst_path = tmp_path / "dst.gpkg"
-
-    # Copy src file to dst file to "layer1"
-    gfo.append_to(src_path, dst_path, dst_layer="layer1")
-    src_info = gfo.get_layerinfo(src_path)
-    dst_layer1_info = gfo.get_layerinfo(dst_path, "layer1")
-    assert src_info.featurecount == dst_layer1_info.featurecount
-
-    # Append src file layer to dst file to new layer: "layer2"
-    gfo.append_to(src_path, dst_path, dst_layer="layer2")
-    dst_layer2_info = gfo.get_layerinfo(dst_path, "layer2")
-    assert dst_layer1_info.featurecount == dst_layer2_info.featurecount
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_append_different_columns(tmp_path, suffix):
-    src_path = test_helper.get_testfile(
-        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
-    )
-    dst_path = tmp_path / f"dst{suffix}"
-    gfo.copy(src_path, dst_path)
-    gfo.add_column(src_path, name="extra_column", type=gfo.DataType.INTEGER)
-    gfo.append_to(src_path, dst_path)
-
-    src_info = gfo.get_layerinfo(src_path)
-    res_info = gfo.get_layerinfo(dst_path)
-
-    # All rows are appended tot the dst layer, but the extra column is not!
-    assert (src_info.featurecount * 2) == res_info.featurecount
-    assert len(src_info.columns) == len(res_info.columns) + 1
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_cmp(tmp_path, suffix):
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    src2 = test_helper.get_testfile("polygon-invalid", suffix=suffix)
-
-    # Copy test file to tmpdir
-    dst = tmp_path / f"polygons_parcels_output{suffix}"
-    gfo.copy(src, dst)
-
-    # Now compare source and dst files
-    assert gfo.cmp(src, dst) is True
-    assert gfo.cmp(src2, dst) is False
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_convert(tmp_path, suffix):
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-
-    # Convert
-    dst = tmp_path / f"{src.stem}-output{suffix}"
-    gfo.convert(src, dst)
-
-    # Now compare source and dst file
-    src_layerinfo = gfo.get_layerinfo(src)
-    dst_layerinfo = gfo.get_layerinfo(dst)
-    assert src_layerinfo.featurecount == dst_layerinfo.featurecount
-    assert len(src_layerinfo.columns) == len(dst_layerinfo.columns)
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_convert_emptyfile(tmp_path, suffix):
-    # Convert
-    src = test_helper.get_testfile(
-        "polygon-parcel", suffix=suffix, dst_dir=tmp_path, empty=True
-    )
-    dst = tmp_path / f"{src.stem}-output{suffix}"
-    gfo.convert(src, dst)
-
-    # Now compare source and dst file
-    assert dst.exists()
-    src_layerinfo = gfo.get_layerinfo(src)
-    dst_layerinfo = gfo.get_layerinfo(dst)
-    assert src_layerinfo.featurecount == dst_layerinfo.featurecount
-    assert len(src_layerinfo.columns) == len(dst_layerinfo.columns)
-
-
-@pytest.mark.parametrize(
-    "testfile, force_geometrytype",
-    [
-        ("polygon-parcel", GeometryType.POLYGON),
-        ("polygon-parcel", GeometryType.MULTIPOLYGON),
-        ("polygon-parcel", GeometryType.LINESTRING),
-        ("polygon-parcel", GeometryType.MULTILINESTRING),
-        ("polygon-parcel", GeometryType.POINT),
-        ("polygon-parcel", GeometryType.MULTIPOINT),
-    ],
-)
-def test_convert_force_output_geometrytype(tmp_path, testfile, force_geometrytype):
-    # The conversion is done by ogr, and the "test" is rather written to
-    # explore the behaviour of this ogr functionality
-
-    # Convert testfile and force to force_geometrytype
-    src = test_helper.get_testfile(testfile)
-    dst = tmp_path / f"{src.stem}_to_{force_geometrytype}.gpkg"
-    gfo.convert(src, dst, force_output_geometrytype=force_geometrytype)
-    assert gfo.get_layerinfo(dst).geometrytype == force_geometrytype
-
-
-def test_convert_invalid_params(tmp_path):
-    # Convert
-    src = tmp_path / "nonexisting_file.gpkg"
-    dst = tmp_path / "output.gpkg"
-    with pytest.raises(ValueError, match="src file doesn't exist: "):
-        gfo.convert(src, dst)
-
-
-@pytest.mark.parametrize(
-    "src_suffix, dst_suffix, preserve_fid, exp_preserved_fids",
-    [
-        (".shp", ".gpkg", True, True),
-        (".shp", ".gpkg", False, False),
-        (".gpkg", ".shp", True, False),
-        (".shp", ".sqlite", True, True),
-        (".shp", ".sqlite", False, False),
-    ],
-)
-def test_convert_preserve_fid(
-    tmp_path,
-    src_suffix: str,
-    dst_suffix: str,
-    preserve_fid: bool,
-    exp_preserved_fids: bool,
-):
-    src = test_helper.get_testfile("polygon-parcel", suffix=src_suffix)
-
-    # Convert with preserve_fid=None (default)
-    # ----------------------------------------
-    dst = tmp_path / f"{src.stem}-output_preserve_fid-{preserve_fid}{dst_suffix}"
-    gfo.convert(src, dst, preserve_fid=preserve_fid)
-
-    # Now compare source and dst file
-    src_gdf = gfo.read_file(src, fid_as_index=True)
-    dst_gdf = gfo.read_file(dst, fid_as_index=True)
-    assert len(src_gdf) == len(dst_gdf)
-    assert len(src_gdf.columns) == len(dst_gdf.columns)
-    if exp_preserved_fids:
-        assert src_gdf.index.tolist() == dst_gdf.index.tolist()
-    else:
-        assert src_gdf.index.tolist() != dst_gdf.index.tolist()
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_convert_reproject(tmp_path, suffix):
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-
-    # Convert with reproject
-    dst = tmp_path / f"{src.stem}-output_reproj4326{suffix}"
-    gfo.convert(src, dst, dst_crs=4326, reproject=True)
-
-    # Now compare source and dst file
-    src_layerinfo = gfo.get_layerinfo(src)
-    dst_layerinfo = gfo.get_layerinfo(dst)
-    assert src_layerinfo.featurecount == dst_layerinfo.featurecount
-    assert src_layerinfo.crs is not None
-    assert src_layerinfo.crs.to_epsg() == 31370
-    assert dst_layerinfo.crs is not None
-    assert dst_layerinfo.crs.to_epsg() == 4326
-
-    # Check if dst file actually seems to contain lat lon coordinates
-    dst_gdf = gfo.read_file(dst)
-    first_geom = dst_gdf.geometry[0]
-    first_poly = (
-        first_geom if isinstance(first_geom, sh_geom.Polygon) else first_geom.geoms[0]
-    )
-    assert first_poly.exterior is not None
-    for x, y in first_poly.exterior.coords:
-        assert x < 100 and y < 100
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_copy(tmp_path, suffix):
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-
-    # Copy to dest file
-    dst = tmp_path / f"{src.stem}-output{suffix}"
-    gfo.copy(src, dst)
-    assert src.exists()
-    assert dst.exists()
-    if suffix == ".shp":
-        assert dst.with_suffix(".shx").exists()
-
-    # Copy to dest dir
-    dst_dir = tmp_path / "dest_dir"
-    dst_dir.mkdir(parents=True, exist_ok=True)
-    gfo.copy(src, dst_dir)
-    dst = dst_dir / src.name
-    assert src.exists()
-    assert dst.exists()
-    if suffix == ".shp":
-        assert dst.with_suffix(".shx").exists()
-
-
-def test_driver_enum():
-    # Test ESRIShapefile Driver
-    # Test getting a driver for a suffix
-    geofiletype = gfo.GeofileType(".shp")
-    assert geofiletype == gfo.GeofileType.ESRIShapefile
-
-    # Test getting a driver for a Path
-    path = Path("/testje/path_naar_gfo.sHp")
-    geofiletype = gfo.GeofileType(path)
-    assert geofiletype == gfo.GeofileType.ESRIShapefile
-
-    # GPKG Driver
-    # Test getting a driver for a suffix
-    geofiletype = gfo.GeofileType(".gpkg")
-    assert geofiletype == gfo.GeofileType.GPKG
-
-    # Test getting a driver for a Path
-    path = Path("/testje/path_naar_gfo.gPkG")
-    geofiletype = gfo.GeofileType(path)
-    assert geofiletype == gfo.GeofileType.GPKG
-
-    # SQLite Driver
-    # Test getting a driver for a suffix
-    geofiletype = gfo.GeofileType(".sqlite")
-    assert geofiletype == gfo.GeofileType.SQLite
-
-    # Test getting a driver for a Path
-    path = Path("/testje/path_naar_gfo.sQlItE")
-    geofiletype = gfo.GeofileType(path)
-    assert geofiletype == gfo.GeofileType.SQLite
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_drop_column(tmp_path, suffix):
-    test_path = test_helper.get_testfile(
-        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
-    )
-    original_info = gfo.get_layerinfo(test_path)
-    assert "GEWASGROEP" in original_info.columns
-    gfo.drop_column(test_path, "GEWASGROEP")
-    new_info = gfo.get_layerinfo(test_path)
-    assert len(original_info.columns) == len(new_info.columns) + 1
-    assert "GEWASGROEP" not in new_info.columns
-
-    # dropping column that doesn't exist doesn't give an error
-    gfo.drop_column(test_path, "NOT_EXISTING_COLUMN")
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_get_crs(suffix):
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    crs = gfo.get_crs(src)
-    assert crs.to_epsg() == 31370
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_get_default_layer(suffix):
-    # Prepare test data + test
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    layer = gfo.get_default_layer(src)
-    assert layer == src.stem
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_get_layer_geometrytypes(suffix):
-    # Prepare test data + test
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    geometrytypes = gfo.get_layer_geometrytypes(src)
-    assert geometrytypes == ["POLYGON", "MULTIPOLYGON"]
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_get_layer_geometrytypes_empty(tmp_path, suffix):
-    # Prepare test data + test
-    src = test_helper.get_testfile(
-        "polygon-parcel", suffix=suffix, dst_dir=tmp_path, empty=True
-    )
-    geometrytypes = gfo.get_layer_geometrytypes(src)
-    assert geometrytypes == []
-
-
-def test_get_layer_geometrytypes_geometry(tmp_path):
-    # Prepare test data + test
-    src = test_helper.get_testfile("polygon-parcel", suffix=".gpkg")
-    test_path = tmp_path / f"{src.stem}_geometry{src.suffix}"
-    gfo.convert(src, test_path, force_output_geometrytype="GEOMETRY")
-    assert gfo.get_layerinfo(test_path).geometrytypename == "GEOMETRY"
-    geometrytypes = gfo.get_layer_geometrytypes(src)
-    assert geometrytypes == ["POLYGON", "MULTIPOLYGON"]
-
-
-@pytest.mark.parametrize(
-    "testfile, suffix, layer",
-    [
-        ("polygon-parcel", ".gpkg", None),
-        ("polygon-parcel", ".shp", None),
-        ("polygon-twolayers", ".gpkg", "parcels"),
-    ],
-)
-def test_get_layerinfo(testfile, suffix, layer):
-    src = test_helper.get_testfile(testfile, suffix=suffix)
-    # Tests
-    layerinfo = gfo.get_layerinfo(src, layer)
-    assert str(layerinfo).startswith("<class 'geofileops.fileops.LayerInfo'>")
-    assert layerinfo.featurecount == 46
-    if src.suffix == ".shp":
-        assert layerinfo.geometrycolumn == "geometry"
-        assert layerinfo.name == src.stem
-        assert layerinfo.fid_column == ""
-    elif src.suffix == ".gpkg":
-        assert layerinfo.geometrycolumn == "geom"
-        assert layerinfo.name == "parcels"
-        assert layerinfo.fid_column == "fid"
-    assert layerinfo.geometrytypename == gfo.GeometryType.MULTIPOLYGON.name
-    assert layerinfo.geometrytype == gfo.GeometryType.MULTIPOLYGON
-    assert len(layerinfo.columns) == 11
-    assert layerinfo.columns["OIDN"].gdal_type == "Integer64"
-    assert layerinfo.total_bounds is not None
-    assert layerinfo.crs is not None
-    assert layerinfo.crs.to_epsg() == 31370
-
-    # Some tests for exception cases
-    # Layer specified that doesn't exist
-    with pytest.raises(ValueError, match="Layer not_existing_layer not found in file"):
-        layerinfo = gfo.get_layerinfo(src, "not_existing_layer")
-
-    # Path specified that doesn't exist
-    with pytest.raises(ValueError, match="input_path doesn't exist"):
-        not_existing_path = _io_util.with_stem(src, "not_existing_layer")
-        layerinfo = gfo.get_layerinfo(not_existing_path)
-
-    # Multiple layers available, but no layer specified
-    if len(gfo.listlayers(src)) > 1:
-        with pytest.raises(ValueError, match="Layer has > 1 layer"):
-            layerinfo = gfo.get_layerinfo(src)
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_get_only_layer_one_layer(suffix):
-    # Test Geopackage with 1 layer
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    layer = gfo.get_only_layer(src)
-    if suffix == ".gpkg":
-        assert layer == "parcels"
-    else:
-        assert layer == src.stem
-
-
-def test_get_only_layer_two_layers():
-    # Test Geopackage with 2 layers
-    src = test_helper.get_testfile("polygon-twolayers")
-    layers = gfo.listlayers(src)
-    assert len(layers) == 2
-    with pytest.raises(ValueError, match="Layer has > 1 layer"):
-        _ = gfo.get_only_layer(src)
-
-
-def test_is_geofile():
-    assert gfo.is_geofile(test_helper.get_testfile("polygon-parcel"))
-    assert gfo.is_geofile(
-        test_helper.get_testfile("polygon-parcel").with_suffix(".shp")
-    )
-
-    assert gfo.is_geofile("/test/testje.txt") is False
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_listlayers_one_layer(suffix):
-    # Test Geopackage with 1 layer
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    layers = gfo.listlayers(src)
-    if suffix == ".gpkg":
-        assert layers[0] == "parcels"
-    else:
-        assert layers[0] == src.stem
-
-
-def test_listlayers_two_layers():
-    # Test geopackage 2 layers
-    src = test_helper.get_testfile("polygon-twolayers")
-    layers = gfo.listlayers(src)
-    assert "parcels" in layers
-    assert "zones" in layers
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_move(tmp_path, suffix):
-    src = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path, suffix=suffix)
-
-    # Test
-    dst = tmp_path / f"{src.stem}-output{suffix}"
-    gfo.move(src, dst)
-    assert src.exists() is False
-    assert dst.exists()
-    if suffix == ".shp":
-        assert dst.with_suffix(".shx").exists()
-
-    # Test move to dest dir
-    src = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path, suffix=suffix)
-    dst_dir = tmp_path / "dest_dir"
-    dst_dir.mkdir(parents=True, exist_ok=True)
-    gfo.move(src, dst_dir)
-    dst = dst_dir / src.name
-    assert src.exists() is False
-    assert dst.exists()
-    if suffix == ".shp":
-        assert dst.with_suffix(".shx").exists()
-
-    # Add column to make sure the dst file isn't locked
-    if suffix == ".gpkg":
-        gfo.add_column(
-            path=dst,
-            name="PERIMETER",
-            type=gfo.DataType.REAL,
-            expression="ST_perimeter(geom)",
-        )
-
-
-def test_update_column(tmp_path):
-    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
-
-    # The area column shouldn't be in the test file yet
-    layerinfo = gfo.get_layerinfo(path=test_path, layer="parcels")
-    assert "area" not in layerinfo.columns
-
-    # Add + update area column
-    gfo.add_column(
-        test_path, layer="parcels", name="AREA", type="real", expression="ST_area(geom)"
-    )
-    gfo.update_column(test_path, name="AreA", expression="ST_area(geom)")
-
-    layerinfo = gfo.get_layerinfo(path=test_path, layer="parcels")
-    assert "AREA" in layerinfo.columns
-    gdf = gfo.read_file(test_path)
-    assert round(gdf["AREA"].astype("float")[0], 1) == round(
-        gdf["OPPERVL"].astype("float")[0], 1
-    )
-
-    # Update column for rows where area > 5
-    gfo.update_column(test_path, name="AreA", expression="-1", where="area > 4000")
-    gdf = gfo.read_file(test_path)
-    gdf_filtered = gdf[gdf["AREA"] == -1]
-    assert len(gdf_filtered) == 20
-
-    # Trying to update column that doesn't exist should raise ValueError
-    assert "not_existing column" not in layerinfo.columns
-    with pytest.raises(ValueError, match="Column .* doesn't exist in"):
-        gfo.update_column(
-            test_path, name="not_existing column", expression="ST_area(geom)"
-        )
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_read_file(suffix, engine_setter):
-    # Prepare test data
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-
-    # Test with defaults
-    read_gdf = gfo.read_file(src)
-    assert isinstance(read_gdf, gpd.GeoDataFrame)
-    assert len(read_gdf.columns) == 12
-    assert len(read_gdf) == 46
-
-    # Test no columns
-    read_gdf = gfo.read_file(src, columns=[])
-    assert isinstance(read_gdf, gpd.GeoDataFrame)
-    assert len(read_gdf.columns) == 1
-    assert len(read_gdf) == 46
-
-    # Test specific columns (+ test case insensitivity + order)
-    columns = ["OIDN", "uidn", "HFDTLT", "lblhfdtlt", "GEWASGROEP", "lengte", "OPPERVL"]
-    read_gdf = gfo.read_file(src, columns=columns)
-    assert len(read_gdf) == 46
-    columns.append("geometry")
-    for index, column in enumerate(read_gdf.columns):
-        assert str(column) == columns[index]
-
-    # Test no geom
-    read_gdf = gfo.read_file_nogeom(src)
-    assert isinstance(read_gdf, pd.DataFrame)
-    assert len(read_gdf) == 46
-
-    # Test ignore_geometry, no columns
-    read_gdf = gfo.read_file_nogeom(src, columns=[])
-    assert isinstance(read_gdf, pd.DataFrame)
-    assert len(read_gdf) == 0
-
-
-def test_read_file_invalid_params(tmp_path, engine_setter):
-    src = tmp_path / "nonexisting_file.gpkg"
-
-    with pytest.raises(ValueError, match="file doesn't exist:"):
-        _ = gfo.read_file(src)
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_read_file_fid_as_index(suffix, engine_setter):
-    # Prepare test data
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-
-    # First read without fid_as_index=True
-    read_gdf = gfo.read_file(src, rows=slice(5, 10))
-    assert isinstance(read_gdf, pd.DataFrame)
-    assert len(read_gdf.columns) == 12
-    assert len(read_gdf) == 5
-    assert read_gdf.index[0] == 0
-
-    # Now with fid_as_index=True
-    read_gdf = gfo.read_file(src, rows=slice(5, 10), fid_as_index=True)
-    assert isinstance(read_gdf, pd.DataFrame)
-    assert len(read_gdf.columns) == 12
-    assert len(read_gdf) == 5
-    if gfo.GeofileType(src).is_fid_zerobased:
-        assert read_gdf.index[0] == 5
-    else:
-        # Geopackage fid starts at 1
-        assert read_gdf.index[0] == 6
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_read_file_sql(suffix, engine_setter):
-    # Prepare test data
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-
-    # Test
-    src_layerinfo = gfo.get_layerinfo(src)
-    sql_stmt = f'SELECT * FROM "{src_layerinfo.name}"'
-    if engine_setter == "fiona":
-        with pytest.raises(ValueError, match="sql_stmt is not supported with fiona"):
-            _ = gfo.read_file(src, sql_stmt=sql_stmt)
-        return
-
-    read_gdf = gfo.read_file(src, sql_stmt=sql_stmt)
-    assert isinstance(read_gdf, gpd.GeoDataFrame)
-    assert len(read_gdf) == 46
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_read_file_sql_deprecated(suffix, engine_setter):
-    if engine_setter == "fiona":
-        pytest.skip("sql_stmt param not supported for fiona engine")
-
-    # Prepare test data
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-
-    # Test
-    src_layerinfo = gfo.get_layerinfo(src)
-    read_gdf = gfo.read_file_sql(src, sql_stmt=f'SELECT * FROM "{src_layerinfo.name}"')
-    assert isinstance(read_gdf, gpd.GeoDataFrame)
-    assert len(read_gdf) == 46
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_read_file_sql_no_geom(suffix, engine_setter):
-    if engine_setter == "fiona":
-        pytest.skip("sql_stmt param not supported for fiona engine")
-
-    # Prepare test data
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-
-    # Test
-    src_layerinfo = gfo.get_layerinfo(src)
-    sql_stmt = f'SELECT count(*) AS aantal FROM "{src_layerinfo.name}"'
-    read_df = gfo.read_file(src, sql_stmt=sql_stmt)
-    assert isinstance(read_df, pd.DataFrame)
-    assert len(read_df) == 1
-    assert read_df["aantal"].item() == 46
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("columns", [["OIDN", "UIDN"], ["OidN", "UidN"]])
-def test_read_file_sql_placeholders(suffix, engine_setter, columns):
-    """
-    Test if placeholders are properly filled out + if casing used in columns parameter
-    is retained when using placeholders.
-    """
-    if engine_setter == "fiona":
-        pytest.skip("sql_stmt param not supported for fiona engine")
-
-    # Prepare test data
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-
-    # Test
-    sql_stmt = """
-        SELECT {geometrycolumn}
-              {columns_to_select_str}
-          FROM "{input_layer}" layer
-    """
-    read_sql_gdf = gfo.read_file(
-        src, sql_stmt=sql_stmt, sql_dialect="SQLITE", columns=columns
-    )
-    read_gdf = gfo.read_file(src, columns=columns)
-    assert_geodataframe_equal(read_gdf, read_sql_gdf)
-
-
-def test_read_file_two_layers(engine_setter):
-    src = test_helper.get_testfile("polygon-twolayers")
-    layers = gfo.listlayers(src)
-    assert "parcels" in layers
-    assert "zones" in layers
-
-    read_gdf = gfo.read_file(src, layer="zones")
-    assert isinstance(read_gdf, gpd.GeoDataFrame)
-    assert len(read_gdf) == 5
-
-    read_gdf = gfo.read_file(src, layer="parcels")
-    assert isinstance(read_gdf, gpd.GeoDataFrame)
-    assert len(read_gdf) == 46
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_rename_column(tmp_path, suffix):
-    test_path = test_helper.get_testfile(
-        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
-    )
-
-    # Check if input file is ok
-    orig_layerinfo = gfo.get_layerinfo(test_path)
-    assert "OPPERVL" in orig_layerinfo.columns
-    assert "area" not in orig_layerinfo.columns
-
-    # Rename
-    if test_path.suffix == ".shp":
-        with pytest.raises(ValueError, match="rename_column is not possible for"):
-            gfo.rename_column(test_path, "OPPERVL", "area")
-    else:
-        gfo.rename_column(test_path, "OPPERVL", "area")
-        result_layerinfo = gfo.get_layerinfo(test_path)
-        assert "OPPERVL" not in result_layerinfo.columns
-        assert "area" in result_layerinfo.columns
-
-        # Rename non-existing column to existing columns doesn't give an error
-        gfo.rename_column(test_path, "OPPERVL", "area")
-        result_layerinfo = gfo.get_layerinfo(test_path)
-        assert "OPPERVL" not in result_layerinfo.columns
-        assert "area" in result_layerinfo.columns
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_rename_layer(tmp_path, suffix):
-    test_path = test_helper.get_testfile(
-        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
-    )
-
-    if suffix == ".gpkg":
-        gfo.rename_layer(test_path, layer="parcels", new_layer="parcels_renamed")
-        layernames_renamed = gfo.listlayers(path=test_path)
-        assert layernames_renamed[0] == "parcels_renamed"
-    elif suffix == ".shp":
-        # Now test rename layer
-        with pytest.raises(ValueError, match="rename_layer is not possible"):
-            gfo.rename_layer(
-                test_path,
-                layer="polygons_parcels",
-                new_layer="polygons_parcels_renamed",
-            )
-            layernames_renamed = gfo.listlayers(path=test_path)
-            assert layernames_renamed[0] == "polygons_parcels_renamed"
-    else:
-        raise Exception(f"test not implemented for suffix {suffix}")
-
-
-def test_execute_sql(tmp_path):
-    # Prepare testfile
-    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
-
-    # Test using execute_sql for creating/dropping indexes
-    gfo.execute_sql(
-        path=test_path, sql_stmt='CREATE INDEX idx_parcels_oidn ON "parcels"("oidn")'
-    )
-    gfo.execute_sql(path=test_path, sql_stmt="DROP INDEX idx_parcels_oidn")
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_spatial_index(tmp_path, suffix):
-    test_path = test_helper.get_testfile(
-        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
-    )
-    layer = gfo.get_only_layer(test_path)
-
-    # Check if spatial index present
-    has_spatial_index = gfo.has_spatial_index(path=test_path, layer=layer)
-    assert has_spatial_index is True
-
-    # Remove spatial index
-    gfo.remove_spatial_index(path=test_path, layer=layer)
-    has_spatial_index = gfo.has_spatial_index(path=test_path, layer=layer)
-    assert has_spatial_index is False
-
-    # Create spatial index
-    gfo.create_spatial_index(path=test_path, layer=layer)
-    has_spatial_index = gfo.has_spatial_index(path=test_path, layer=layer)
-    assert has_spatial_index is True
-
-    # Spatial index if it exists already by default gives error
-    with pytest.raises(Exception, match="Error adding spatial index to"):
-        gfo.create_spatial_index(path=test_path, layer=layer)
-    gfo.create_spatial_index(path=test_path, layer=layer, exist_ok=True)
-
-    # Test of rebuild only easy on shapefile
-    if suffix == ".shp":
-        qix_path = test_path.with_suffix(".qix")
-        qix_modified_time_orig = qix_path.stat().st_mtime
-        gfo.create_spatial_index(path=test_path, layer=layer, exist_ok=True)
-        assert qix_path.stat().st_mtime == qix_modified_time_orig
-        gfo.create_spatial_index(path=test_path, layer=layer, force_rebuild=True)
-        assert qix_path.stat().st_mtime > qix_modified_time_orig
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_to_file(tmp_path, suffix, engine_setter):
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    output_path = tmp_path / f"{src.stem}-output{suffix}"
-
-    # Read test file and write to tmppath
-    read_gdf = gfo.read_file(src)
-    gfo.to_file(read_gdf, output_path)
-    written_gdf = gfo.read_file(output_path)
-    assert len(read_gdf) == len(written_gdf)
-    assert_geodataframe_equal(written_gdf, read_gdf)
-
-    # Append the file again to tmppath
-    gfo.to_file(read_gdf, output_path, append=True)
-    written_gdf = gfo.read_file(output_path)
-    assert 2 * len(read_gdf) == len(written_gdf)
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_to_file_append_to_unexisting_file(tmp_path, suffix, engine_setter):
-    test_path = test_helper.get_testfile(
-        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
-    )
-    test_gdf = gfo.read_file(test_path)
-    dst_path = tmp_path / f"dst{suffix}"
-    gfo.to_file(test_gdf, path=dst_path, append=True)
-    assert dst_path.exists()
-    dst_info = gfo.get_layerinfo(dst_path)
-    assert dst_info.featurecount == len(test_gdf)
-
-
-def test_to_file_append_different_columns(tmp_path, engine_setter):
-    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
-
-    test_gdf = gfo.read_file(test_path)
-    test_gdf["extra_column"] = 123
-    if engine_setter == "fiona":
-        ex_message = "Record does not match collection schema"
-    else:
-        ex_message = "destination layer doesn't have the same columns as gdf"
-    with pytest.raises(ValueError, match=ex_message):
-        gfo.to_file(test_gdf, path=test_path, append=True)
-
-
-def test_to_file_attribute_table_gpkg(tmp_path, engine_setter):
-    # Prepare test data
-    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
-
-    # Test writing a DataFrame to geopackage
-    test_gdf = gfo.read_file(test_path)
-    test_df = test_gdf.drop(columns="geometry")
-    assert isinstance(test_df, pd.DataFrame)
-    assert isinstance(test_df, gpd.GeoDataFrame) is False
-    gfo.to_file(test_df, test_path)
-
-    # Now check if the layer are correctly found afterwards
-    assert len(gfo.listlayers(test_path)) == 1
-    assert len(gfo.listlayers(test_path, only_spatial_layers=False)) == 2
-
-
-@pytest.mark.parametrize(
-    "suffix, create_spatial_index, expected_spatial_index",
-    [
-        [".gpkg", True, True],
-        [".gpkg", False, False],
-        [".gpkg", None, True],
-        [".shp", True, True],
-        [".shp", False, False],
-        [".shp", None, False],
-    ],
-)
-def test_to_file_create_spatial_index(
-    tmp_path,
-    suffix: str,
-    create_spatial_index: bool,
-    expected_spatial_index: bool,
-    engine_setter,
-):
-    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    output_path = tmp_path / f"{src.stem}-output{suffix}"
-
-    # Read test file and write to tmppath
-    read_gdf = gfo.read_file(src)
-    gfo.to_file(read_gdf, output_path, create_spatial_index=create_spatial_index)
-    assert gfo.has_spatial_index(output_path) is expected_spatial_index
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_to_file_emptyfile(tmp_path, suffix):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    read_gdf = gfo.read_file(input_path)
-    empty_gdf = read_gdf.drop(read_gdf.index)
-    assert isinstance(empty_gdf, gpd.GeoDataFrame)
-
-    # Test
-    # Remark: if no force_output_geometrytype is specified, the ouput geometry type in
-    # the depends on the file type, eg. Geometry for gpkg, MultiLinestring for shp.
-    output_path = tmp_path / f"output-emptyfile{suffix}"
-    gfo.to_file(
-        empty_gdf,
-        output_path,
-        force_output_geometrytype=input_layerinfo.geometrytype,
-    )
-
-    # Check result
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 0
-    assert len(input_layerinfo.columns) == len(output_layerinfo.columns)
-    assert input_layerinfo.geometrytype == output_layerinfo.geometrytype
-
-
-def test_to_file_force_geometrytype_multitype(tmp_path, engine_setter):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel")
-    read_gdf = gfo.read_file(input_path)
-    read_gdf.geometry = read_gdf.geometry.buffer(0)
-    poly_gdf = read_gdf[read_gdf.geometry.geom_type == "Polygon"]
-    assert isinstance(poly_gdf, gpd.GeoDataFrame)
-
-    # Default behaviour -> Polygon
-    output_path = tmp_path / f"{input_path.stem}-output.gpkg"
-    gfo.to_file(poly_gdf, output_path)
-    output_info = gfo.get_layerinfo(output_path)
-    assert output_info.featurecount == len(poly_gdf)
-    assert output_info.geometrytype == GeometryType.POLYGON
-
-    # force_output_geometrytype=GeometryType.MULTIPOLYGON -> MultiPolygon
-    output_force_path = tmp_path / f"{input_path.stem}-output-force.gpkg"
-    gfo.to_file(
-        poly_gdf,
-        output_force_path,
-        force_output_geometrytype=GeometryType.MULTIPOLYGON,
-    )
-    output_force_info = gfo.get_layerinfo(output_force_path)
-    assert output_force_info.featurecount == len(poly_gdf)
-    assert output_force_info.geometrytype == GeometryType.MULTIPOLYGON
-
-    # force_multitype=True -> MultiPolygon
-    output_force_path = tmp_path / f"{input_path.stem}-output-force.gpkg"
-    gfo.to_file(poly_gdf, output_force_path, force_multitype=True)
-    output_force_info = gfo.get_layerinfo(output_force_path)
-    assert output_force_info.featurecount == len(poly_gdf)
-    assert output_force_info.geometrytype == GeometryType.MULTIPOLYGON
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_to_file_geomempty(tmp_path, suffix, engine_setter):
-    # Test for gdf with an empty polygon + a polygon
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            sh_geom.GeometryCollection(),
-            test_helper.TestData.polygon_with_island,
-        ]
-    )
-    # By default, get_geometrytypes ignores the type of empty geometries.
-    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
-    assert len(test_geometrytypes) == 1
-    test_geometrytypes_includingempty = geoseries_util.get_geometrytypes(
-        test_gdf.geometry, ignore_empty_geometries=False
-    )
-    assert len(test_geometrytypes_includingempty) == 2
-    output_empty_path = tmp_path / f"testfile_with_emptygeom{suffix}"
-    test_gdf.to_file(output_empty_path, driver=gfo.GeofileType(suffix).ogrdriver)
-
-    # Now check the result if the data is still the same after being read again
-    test_read_gdf = gfo.read_file(output_empty_path)
-    test_read_geometrytypes = geoseries_util.get_geometrytypes(test_read_gdf.geometry)
-    assert len(test_gdf) == len(test_read_gdf)
-    if suffix == ".shp":
-        # When dataframe with "empty" gemetries is written to shapefile and
-        # read again, shapefile becomes of type MULTILINESTRING!?!
-        assert len(test_read_geometrytypes) == 1
-        assert test_read_geometrytypes[0] is GeometryType.MULTILINESTRING
-    else:
-        # When written to Geopackage... the empty geometries are actually saved
-        # as None. When read again they are None for fiona and empty for pyogrio.
-        assert test_read_gdf.geometry[0] is None or test_read_gdf.geometry[0].is_empty
-        assert isinstance(test_read_gdf.geometry[1], sh_geom.Polygon)
-
-        # So the geometrytype of the resulting GeoDataFrame is also POLYGON
-        assert len(test_read_geometrytypes) == 1
-        assert test_read_geometrytypes[0] is GeometryType.POLYGON
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_to_file_geomnone(tmp_path, suffix, engine_setter):
-    # Test for gdf with a None geometry + a polygon
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[None, test_helper.TestData.polygon_with_island]  # type: ignore
-    )
-    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
-    assert len(test_geometrytypes) == 1
-    output_none_path = tmp_path / f"file_with_nonegeom{suffix}"
-    gfo.to_file(test_gdf, output_none_path)
-
-    # Now check the result if the data is still the same after being read again
-    test_read_gdf = gfo.read_file(output_none_path)
-    # Result is the same as the original input
-    assert test_read_gdf.geometry[0] is None
-    assert isinstance(test_read_gdf.geometry[1], sh_geom.Polygon)
-    # The geometrytype of the column in the file is also the same as originaly
-    test_file_geometrytype = gfo.get_layerinfo(output_none_path).geometrytype
-    if suffix == ".shp":
-        assert test_file_geometrytype == GeometryType.MULTIPOLYGON
-    else:
-        assert test_file_geometrytype == test_geometrytypes[0]
-    # The result type in the geodataframe is also the same as originaly
-    test_read_geometrytypes = geoseries_util.get_geometrytypes(test_read_gdf.geometry)
-    assert len(test_gdf) == len(test_read_gdf)
-    assert test_read_geometrytypes == test_geometrytypes
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_remove(tmp_path, suffix):
-    # Prepare test data
-    src = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path, suffix=suffix)
-    assert src.exists()
-
-    # Remove and check result
-    gfo.remove(src)
-    assert src.exists() is False
-
-
-def test_launder_columns():
-    columns = [f"TOO_LONG_COLUMNNAME{index}" for index in range(0, 21)]
-    laundered = fileops._launder_column_names(columns)
-    assert laundered[0] == ("TOO_LONG_COLUMNNAME0", "TOO_LONG_C")
-    assert laundered[1] == ("TOO_LONG_COLUMNNAME1", "TOO_LONG_1")
-    assert laundered[9] == ("TOO_LONG_COLUMNNAME9", "TOO_LONG_9")
-    assert laundered[10] == ("TOO_LONG_COLUMNNAME10", "TOO_LONG10")
-    assert laundered[20] == ("TOO_LONG_COLUMNNAME20", "TOO_LONG20")
-
-    # Laundering happens case-insensitive
-    columns = ["too_LONG_COLUMNNAME", "TOO_long_COLUMNNAME2", "TOO_LONG_columnname3"]
-    laundered = fileops._launder_column_names(columns)
-    expected = [
-        ("too_LONG_COLUMNNAME", "too_LONG_C"),
-        ("TOO_long_COLUMNNAME2", "TOO_long_1"),
-        ("TOO_LONG_columnname3", "TOO_LONG_2"),
-    ]
-    assert laundered == expected
-
-    # Too many similar column names to be supported to launder
-    columns = [f"TOO_LONG_COLUMNNAME{index}" for index in range(0, 200)]
-    with pytest.raises(
-        NotImplementedError, match="Not supported to launder > 99 columns starting with"
-    ):
-        laundered = fileops._launder_column_names(columns)
+# -*- coding: utf-8 -*-
+"""
+Tests for functionalities in geofileops.general.
+"""
+
+import os
+from pathlib import Path
+import sys
+
+import geopandas as gpd
+import pandas as pd
+import pytest
+import shapely.geometry as sh_geom
+
+# Add path so the local geofileops packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent))  # noqa: E402
+import geofileops as gfo
+from geofileops import fileops
+from geofileops.util import geoseries_util
+from geofileops.util.geometry_util import GeometryType
+from geofileops.util import _io_util
+from tests import test_helper
+from tests.test_helper import DEFAULT_SUFFIXES
+from tests.test_helper import assert_geodataframe_equal
+
+
+ENGINES = ["fiona", "pyogrio"]
+
+
+@pytest.fixture(scope="module", params=ENGINES)
+def engine_setter(request):
+    engine = request.param
+    engine_backup = os.environ.get("GFO_IO_ENGINE", None)
+    if engine is None:
+        del os.environ["GFO_IO_ENGINE"]
+    else:
+        os.environ["GFO_IO_ENGINE"] = engine
+    yield engine
+    if engine_backup is None:
+        del os.environ["GFO_IO_ENGINE"]
+    else:
+        os.environ["GFO_IO_ENGINE"] = engine_backup
+
+
+def test_add_column(tmp_path):
+    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
+
+    # The area column shouldn't be in the test file yet
+    layerinfo = gfo.get_layerinfo(path=test_path, layer="parcels")
+    assert "AREA" not in layerinfo.columns
+
+    # Add area column
+    gfo.add_column(
+        test_path, layer="parcels", name="AREA", type="real", expression="ST_area(geom)"
+    )
+
+    layerinfo = gfo.get_layerinfo(path=test_path, layer="parcels")
+    assert "AREA" in layerinfo.columns
+
+    gdf = gfo.read_file(test_path)
+    assert round(gdf["AREA"].astype("float")[0], 1) == round(
+        gdf["OPPERVL"].astype("float")[0], 1
+    )
+
+    # Add perimeter column
+    gfo.add_column(
+        test_path,
+        name="PERIMETER",
+        type=gfo.DataType.REAL,
+        expression="ST_perimeter(geom)",
+    )
+
+    layerinfo = gfo.get_layerinfo(path=test_path, layer="parcels")
+    assert "AREA" in layerinfo.columns
+
+    gdf = gfo.read_file(test_path)
+    assert round(gdf["AREA"].astype("float")[0], 1) == round(
+        gdf["OPPERVL"].astype("float")[0], 1
+    )
+
+    # Add a column of different gdal types
+    gdal_types = [
+        "Binary",
+        "Date",
+        "DateTime",
+        "Integer",
+        "Integer64",
+        "String",
+        "Time",
+        "Real",
+    ]
+    for type in gdal_types:
+        gfo.add_column(test_path, name=f"column_{type}", type=type)
+    info = gfo.get_layerinfo(test_path)
+    for type in gdal_types:
+        assert f"column_{type}" in info.columns
+
+    # Adding an already existing column doesn't give an error
+    existing_column = list(info.columns)[0]
+    gfo.add_column(test_path, name=existing_column, type="TEXT")
+
+    # Force update on an existing column
+    assert gdf["HFDTLT"][0] == "1"
+    expression = "5"
+    gfo.add_column(
+        test_path, name="HFDTLT", type="TEXT", expression=expression, force_update=True
+    )
+    gdf = gfo.read_file(test_path)
+    assert gdf["HFDTLT"][0] == "5"
+
+
+def test_append_different_layer(tmp_path):
+    # Init
+    src_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
+    dst_path = tmp_path / "dst.gpkg"
+
+    # Copy src file to dst file to "layer1"
+    gfo.append_to(src_path, dst_path, dst_layer="layer1")
+    src_info = gfo.get_layerinfo(src_path)
+    dst_layer1_info = gfo.get_layerinfo(dst_path, "layer1")
+    assert src_info.featurecount == dst_layer1_info.featurecount
+
+    # Append src file layer to dst file to new layer: "layer2"
+    gfo.append_to(src_path, dst_path, dst_layer="layer2")
+    dst_layer2_info = gfo.get_layerinfo(dst_path, "layer2")
+    assert dst_layer1_info.featurecount == dst_layer2_info.featurecount
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_append_different_columns(tmp_path, suffix):
+    src_path = test_helper.get_testfile(
+        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
+    )
+    dst_path = tmp_path / f"dst{suffix}"
+    gfo.copy(src_path, dst_path)
+    gfo.add_column(src_path, name="extra_column", type=gfo.DataType.INTEGER)
+    gfo.append_to(src_path, dst_path)
+
+    src_info = gfo.get_layerinfo(src_path)
+    res_info = gfo.get_layerinfo(dst_path)
+
+    # All rows are appended tot the dst layer, but the extra column is not!
+    assert (src_info.featurecount * 2) == res_info.featurecount
+    assert len(src_info.columns) == len(res_info.columns) + 1
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_cmp(tmp_path, suffix):
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    src2 = test_helper.get_testfile("polygon-invalid", suffix=suffix)
+
+    # Copy test file to tmpdir
+    dst = tmp_path / f"polygons_parcels_output{suffix}"
+    gfo.copy(src, dst)
+
+    # Now compare source and dst files
+    assert gfo.cmp(src, dst) is True
+    assert gfo.cmp(src2, dst) is False
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_convert(tmp_path, suffix):
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # Convert
+    dst = tmp_path / f"{src.stem}-output{suffix}"
+    gfo.convert(src, dst)
+
+    # Now compare source and dst file
+    src_layerinfo = gfo.get_layerinfo(src)
+    dst_layerinfo = gfo.get_layerinfo(dst)
+    assert src_layerinfo.featurecount == dst_layerinfo.featurecount
+    assert len(src_layerinfo.columns) == len(dst_layerinfo.columns)
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_convert_emptyfile(tmp_path, suffix):
+    # Convert
+    src = test_helper.get_testfile(
+        "polygon-parcel", suffix=suffix, dst_dir=tmp_path, empty=True
+    )
+    dst = tmp_path / f"{src.stem}-output{suffix}"
+    gfo.convert(src, dst)
+
+    # Now compare source and dst file
+    assert dst.exists()
+    src_layerinfo = gfo.get_layerinfo(src)
+    dst_layerinfo = gfo.get_layerinfo(dst)
+    assert src_layerinfo.featurecount == dst_layerinfo.featurecount
+    assert len(src_layerinfo.columns) == len(dst_layerinfo.columns)
+
+
+@pytest.mark.parametrize(
+    "testfile, force_geometrytype",
+    [
+        ("polygon-parcel", GeometryType.POLYGON),
+        ("polygon-parcel", GeometryType.MULTIPOLYGON),
+        ("polygon-parcel", GeometryType.LINESTRING),
+        ("polygon-parcel", GeometryType.MULTILINESTRING),
+        ("polygon-parcel", GeometryType.POINT),
+        ("polygon-parcel", GeometryType.MULTIPOINT),
+    ],
+)
+def test_convert_force_output_geometrytype(tmp_path, testfile, force_geometrytype):
+    # The conversion is done by ogr, and the "test" is rather written to
+    # explore the behaviour of this ogr functionality
+
+    # Convert testfile and force to force_geometrytype
+    src = test_helper.get_testfile(testfile)
+    dst = tmp_path / f"{src.stem}_to_{force_geometrytype}.gpkg"
+    gfo.convert(src, dst, force_output_geometrytype=force_geometrytype)
+    assert gfo.get_layerinfo(dst).geometrytype == force_geometrytype
+
+
+def test_convert_invalid_params(tmp_path):
+    # Convert
+    src = tmp_path / "nonexisting_file.gpkg"
+    dst = tmp_path / "output.gpkg"
+    with pytest.raises(ValueError, match="src file doesn't exist: "):
+        gfo.convert(src, dst)
+
+
+@pytest.mark.parametrize(
+    "src_suffix, dst_suffix, preserve_fid, exp_preserved_fids",
+    [
+        (".shp", ".gpkg", True, True),
+        (".shp", ".gpkg", False, False),
+        (".gpkg", ".shp", True, False),
+        (".shp", ".sqlite", True, True),
+        (".shp", ".sqlite", False, False),
+    ],
+)
+def test_convert_preserve_fid(
+    tmp_path,
+    src_suffix: str,
+    dst_suffix: str,
+    preserve_fid: bool,
+    exp_preserved_fids: bool,
+):
+    src = test_helper.get_testfile("polygon-parcel", suffix=src_suffix)
+
+    # Convert with preserve_fid=None (default)
+    # ----------------------------------------
+    dst = tmp_path / f"{src.stem}-output_preserve_fid-{preserve_fid}{dst_suffix}"
+    gfo.convert(src, dst, preserve_fid=preserve_fid)
+
+    # Now compare source and dst file
+    src_gdf = gfo.read_file(src, fid_as_index=True)
+    dst_gdf = gfo.read_file(dst, fid_as_index=True)
+    assert len(src_gdf) == len(dst_gdf)
+    assert len(src_gdf.columns) == len(dst_gdf.columns)
+    if exp_preserved_fids:
+        assert src_gdf.index.tolist() == dst_gdf.index.tolist()
+    else:
+        assert src_gdf.index.tolist() != dst_gdf.index.tolist()
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_convert_reproject(tmp_path, suffix):
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # Convert with reproject
+    dst = tmp_path / f"{src.stem}-output_reproj4326{suffix}"
+    gfo.convert(src, dst, dst_crs=4326, reproject=True)
+
+    # Now compare source and dst file
+    src_layerinfo = gfo.get_layerinfo(src)
+    dst_layerinfo = gfo.get_layerinfo(dst)
+    assert src_layerinfo.featurecount == dst_layerinfo.featurecount
+    assert src_layerinfo.crs is not None
+    assert src_layerinfo.crs.to_epsg() == 31370
+    assert dst_layerinfo.crs is not None
+    assert dst_layerinfo.crs.to_epsg() == 4326
+
+    # Check if dst file actually seems to contain lat lon coordinates
+    dst_gdf = gfo.read_file(dst)
+    first_geom = dst_gdf.geometry[0]
+    first_poly = (
+        first_geom if isinstance(first_geom, sh_geom.Polygon) else first_geom.geoms[0]
+    )
+    assert first_poly.exterior is not None
+    for x, y in first_poly.exterior.coords:
+        assert x < 100 and y < 100
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_copy(tmp_path, suffix):
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # Copy to dest file
+    dst = tmp_path / f"{src.stem}-output{suffix}"
+    gfo.copy(src, dst)
+    assert src.exists()
+    assert dst.exists()
+    if suffix == ".shp":
+        assert dst.with_suffix(".shx").exists()
+
+    # Copy to dest dir
+    dst_dir = tmp_path / "dest_dir"
+    dst_dir.mkdir(parents=True, exist_ok=True)
+    gfo.copy(src, dst_dir)
+    dst = dst_dir / src.name
+    assert src.exists()
+    assert dst.exists()
+    if suffix == ".shp":
+        assert dst.with_suffix(".shx").exists()
+
+
+def test_driver_enum():
+    # Test ESRIShapefile Driver
+    # Test getting a driver for a suffix
+    geofiletype = gfo.GeofileType(".shp")
+    assert geofiletype == gfo.GeofileType.ESRIShapefile
+
+    # Test getting a driver for a Path
+    path = Path("/testje/path_naar_gfo.sHp")
+    geofiletype = gfo.GeofileType(path)
+    assert geofiletype == gfo.GeofileType.ESRIShapefile
+
+    # GPKG Driver
+    # Test getting a driver for a suffix
+    geofiletype = gfo.GeofileType(".gpkg")
+    assert geofiletype == gfo.GeofileType.GPKG
+
+    # Test getting a driver for a Path
+    path = Path("/testje/path_naar_gfo.gPkG")
+    geofiletype = gfo.GeofileType(path)
+    assert geofiletype == gfo.GeofileType.GPKG
+
+    # SQLite Driver
+    # Test getting a driver for a suffix
+    geofiletype = gfo.GeofileType(".sqlite")
+    assert geofiletype == gfo.GeofileType.SQLite
+
+    # Test getting a driver for a Path
+    path = Path("/testje/path_naar_gfo.sQlItE")
+    geofiletype = gfo.GeofileType(path)
+    assert geofiletype == gfo.GeofileType.SQLite
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_drop_column(tmp_path, suffix):
+    test_path = test_helper.get_testfile(
+        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
+    )
+    original_info = gfo.get_layerinfo(test_path)
+    assert "GEWASGROEP" in original_info.columns
+    gfo.drop_column(test_path, "GEWASGROEP")
+    new_info = gfo.get_layerinfo(test_path)
+    assert len(original_info.columns) == len(new_info.columns) + 1
+    assert "GEWASGROEP" not in new_info.columns
+
+    # dropping column that doesn't exist doesn't give an error
+    gfo.drop_column(test_path, "NOT_EXISTING_COLUMN")
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_get_crs(suffix):
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    crs = gfo.get_crs(src)
+    assert crs.to_epsg() == 31370
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_get_default_layer(suffix):
+    # Prepare test data + test
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    layer = gfo.get_default_layer(src)
+    assert layer == src.stem
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_get_layer_geometrytypes(suffix):
+    # Prepare test data + test
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    geometrytypes = gfo.get_layer_geometrytypes(src)
+    assert geometrytypes == ["POLYGON", "MULTIPOLYGON"]
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_get_layer_geometrytypes_empty(tmp_path, suffix):
+    # Prepare test data + test
+    src = test_helper.get_testfile(
+        "polygon-parcel", suffix=suffix, dst_dir=tmp_path, empty=True
+    )
+    geometrytypes = gfo.get_layer_geometrytypes(src)
+    assert geometrytypes == []
+
+
+def test_get_layer_geometrytypes_geometry(tmp_path):
+    # Prepare test data + test
+    src = test_helper.get_testfile("polygon-parcel", suffix=".gpkg")
+    test_path = tmp_path / f"{src.stem}_geometry{src.suffix}"
+    gfo.convert(src, test_path, force_output_geometrytype="GEOMETRY")
+    assert gfo.get_layerinfo(test_path).geometrytypename == "GEOMETRY"
+    geometrytypes = gfo.get_layer_geometrytypes(src)
+    assert geometrytypes == ["POLYGON", "MULTIPOLYGON"]
+
+
+@pytest.mark.parametrize(
+    "testfile, suffix, layer",
+    [
+        ("polygon-parcel", ".gpkg", None),
+        ("polygon-parcel", ".shp", None),
+        ("polygon-twolayers", ".gpkg", "parcels"),
+    ],
+)
+def test_get_layerinfo(testfile, suffix, layer):
+    src = test_helper.get_testfile(testfile, suffix=suffix)
+    # Tests
+    layerinfo = gfo.get_layerinfo(src, layer)
+    assert str(layerinfo).startswith("<class 'geofileops.fileops.LayerInfo'>")
+    assert layerinfo.featurecount == 46
+    if src.suffix == ".shp":
+        assert layerinfo.geometrycolumn == "geometry"
+        assert layerinfo.name == src.stem
+        assert layerinfo.fid_column == ""
+    elif src.suffix == ".gpkg":
+        assert layerinfo.geometrycolumn == "geom"
+        assert layerinfo.name == "parcels"
+        assert layerinfo.fid_column == "fid"
+    assert layerinfo.geometrytypename == gfo.GeometryType.MULTIPOLYGON.name
+    assert layerinfo.geometrytype == gfo.GeometryType.MULTIPOLYGON
+    assert len(layerinfo.columns) == 11
+    assert layerinfo.columns["OIDN"].gdal_type == "Integer64"
+    assert layerinfo.total_bounds is not None
+    assert layerinfo.crs is not None
+    assert layerinfo.crs.to_epsg() == 31370
+
+    # Some tests for exception cases
+    # Layer specified that doesn't exist
+    with pytest.raises(ValueError, match="Layer not_existing_layer not found in file"):
+        layerinfo = gfo.get_layerinfo(src, "not_existing_layer")
+
+    # Path specified that doesn't exist
+    with pytest.raises(ValueError, match="input_path doesn't exist"):
+        not_existing_path = _io_util.with_stem(src, "not_existing_layer")
+        layerinfo = gfo.get_layerinfo(not_existing_path)
+
+    # Multiple layers available, but no layer specified
+    if len(gfo.listlayers(src)) > 1:
+        with pytest.raises(ValueError, match="Layer has > 1 layer"):
+            layerinfo = gfo.get_layerinfo(src)
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_get_only_layer_one_layer(suffix):
+    # Test Geopackage with 1 layer
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    layer = gfo.get_only_layer(src)
+    if suffix == ".gpkg":
+        assert layer == "parcels"
+    else:
+        assert layer == src.stem
+
+
+def test_get_only_layer_two_layers():
+    # Test Geopackage with 2 layers
+    src = test_helper.get_testfile("polygon-twolayers")
+    layers = gfo.listlayers(src)
+    assert len(layers) == 2
+    with pytest.raises(ValueError, match="Layer has > 1 layer"):
+        _ = gfo.get_only_layer(src)
+
+
+def test_is_geofile():
+    assert gfo.is_geofile(test_helper.get_testfile("polygon-parcel"))
+    assert gfo.is_geofile(
+        test_helper.get_testfile("polygon-parcel").with_suffix(".shp")
+    )
+
+    assert gfo.is_geofile("/test/testje.txt") is False
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_listlayers_one_layer(suffix):
+    # Test Geopackage with 1 layer
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    layers = gfo.listlayers(src)
+    if suffix == ".gpkg":
+        assert layers[0] == "parcels"
+    else:
+        assert layers[0] == src.stem
+
+
+def test_listlayers_two_layers():
+    # Test geopackage 2 layers
+    src = test_helper.get_testfile("polygon-twolayers")
+    layers = gfo.listlayers(src)
+    assert "parcels" in layers
+    assert "zones" in layers
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_move(tmp_path, suffix):
+    src = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path, suffix=suffix)
+
+    # Test
+    dst = tmp_path / f"{src.stem}-output{suffix}"
+    gfo.move(src, dst)
+    assert src.exists() is False
+    assert dst.exists()
+    if suffix == ".shp":
+        assert dst.with_suffix(".shx").exists()
+
+    # Test move to dest dir
+    src = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path, suffix=suffix)
+    dst_dir = tmp_path / "dest_dir"
+    dst_dir.mkdir(parents=True, exist_ok=True)
+    gfo.move(src, dst_dir)
+    dst = dst_dir / src.name
+    assert src.exists() is False
+    assert dst.exists()
+    if suffix == ".shp":
+        assert dst.with_suffix(".shx").exists()
+
+    # Add column to make sure the dst file isn't locked
+    if suffix == ".gpkg":
+        gfo.add_column(
+            path=dst,
+            name="PERIMETER",
+            type=gfo.DataType.REAL,
+            expression="ST_perimeter(geom)",
+        )
+
+
+def test_update_column(tmp_path):
+    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
+
+    # The area column shouldn't be in the test file yet
+    layerinfo = gfo.get_layerinfo(path=test_path, layer="parcels")
+    assert "area" not in layerinfo.columns
+
+    # Add + update area column
+    gfo.add_column(
+        test_path, layer="parcels", name="AREA", type="real", expression="ST_area(geom)"
+    )
+    gfo.update_column(test_path, name="AreA", expression="ST_area(geom)")
+
+    layerinfo = gfo.get_layerinfo(path=test_path, layer="parcels")
+    assert "AREA" in layerinfo.columns
+    gdf = gfo.read_file(test_path)
+    assert round(gdf["AREA"].astype("float")[0], 1) == round(
+        gdf["OPPERVL"].astype("float")[0], 1
+    )
+
+    # Update column for rows where area > 5
+    gfo.update_column(test_path, name="AreA", expression="-1", where="area > 4000")
+    gdf = gfo.read_file(test_path)
+    gdf_filtered = gdf[gdf["AREA"] == -1]
+    assert len(gdf_filtered) == 20
+
+    # Trying to update column that doesn't exist should raise ValueError
+    assert "not_existing column" not in layerinfo.columns
+    with pytest.raises(ValueError, match="Column .* doesn't exist in"):
+        gfo.update_column(
+            test_path, name="not_existing column", expression="ST_area(geom)"
+        )
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_read_file(suffix, engine_setter):
+    # Prepare test data
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # Test with defaults
+    read_gdf = gfo.read_file(src)
+    assert isinstance(read_gdf, gpd.GeoDataFrame)
+    assert len(read_gdf.columns) == 12
+    assert len(read_gdf) == 46
+
+    # Test no columns
+    read_gdf = gfo.read_file(src, columns=[])
+    assert isinstance(read_gdf, gpd.GeoDataFrame)
+    assert len(read_gdf.columns) == 1
+    assert len(read_gdf) == 46
+
+    # Test specific columns (+ test case insensitivity + order)
+    columns = ["OIDN", "uidn", "HFDTLT", "lblhfdtlt", "GEWASGROEP", "lengte", "OPPERVL"]
+    read_gdf = gfo.read_file(src, columns=columns)
+    assert len(read_gdf) == 46
+    columns.append("geometry")
+    for index, column in enumerate(read_gdf.columns):
+        assert str(column) == columns[index]
+
+    # Test no geom
+    read_gdf = gfo.read_file_nogeom(src)
+    assert isinstance(read_gdf, pd.DataFrame)
+    assert len(read_gdf) == 46
+
+    # Test ignore_geometry, no columns
+    read_gdf = gfo.read_file_nogeom(src, columns=[])
+    assert isinstance(read_gdf, pd.DataFrame)
+    assert len(read_gdf) == 0
+
+
+def test_read_file_invalid_params(tmp_path, engine_setter):
+    src = tmp_path / "nonexisting_file.gpkg"
+
+    with pytest.raises(ValueError, match="file doesn't exist:"):
+        _ = gfo.read_file(src)
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_read_file_fid_as_index(suffix, engine_setter):
+    # Prepare test data
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # First read without fid_as_index=True
+    read_gdf = gfo.read_file(src, rows=slice(5, 10))
+    assert isinstance(read_gdf, pd.DataFrame)
+    assert len(read_gdf.columns) == 12
+    assert len(read_gdf) == 5
+    assert read_gdf.index[0] == 0
+
+    # Now with fid_as_index=True
+    read_gdf = gfo.read_file(src, rows=slice(5, 10), fid_as_index=True)
+    assert isinstance(read_gdf, pd.DataFrame)
+    assert len(read_gdf.columns) == 12
+    assert len(read_gdf) == 5
+    if gfo.GeofileType(src).is_fid_zerobased:
+        assert read_gdf.index[0] == 5
+    else:
+        # Geopackage fid starts at 1
+        assert read_gdf.index[0] == 6
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_read_file_sql(suffix, engine_setter):
+    # Prepare test data
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # Test
+    src_layerinfo = gfo.get_layerinfo(src)
+    sql_stmt = f'SELECT * FROM "{src_layerinfo.name}"'
+    if engine_setter == "fiona":
+        with pytest.raises(ValueError, match="sql_stmt is not supported with fiona"):
+            _ = gfo.read_file(src, sql_stmt=sql_stmt)
+        return
+
+    read_gdf = gfo.read_file(src, sql_stmt=sql_stmt)
+    assert isinstance(read_gdf, gpd.GeoDataFrame)
+    assert len(read_gdf) == 46
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_read_file_sql_deprecated(suffix, engine_setter):
+    if engine_setter == "fiona":
+        pytest.skip("sql_stmt param not supported for fiona engine")
+
+    # Prepare test data
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # Test
+    src_layerinfo = gfo.get_layerinfo(src)
+    read_gdf = gfo.read_file_sql(src, sql_stmt=f'SELECT * FROM "{src_layerinfo.name}"')
+    assert isinstance(read_gdf, gpd.GeoDataFrame)
+    assert len(read_gdf) == 46
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_read_file_sql_no_geom(suffix, engine_setter):
+    if engine_setter == "fiona":
+        pytest.skip("sql_stmt param not supported for fiona engine")
+
+    # Prepare test data
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # Test
+    src_layerinfo = gfo.get_layerinfo(src)
+    sql_stmt = f'SELECT count(*) AS aantal FROM "{src_layerinfo.name}"'
+    read_df = gfo.read_file(src, sql_stmt=sql_stmt)
+    assert isinstance(read_df, pd.DataFrame)
+    assert len(read_df) == 1
+    assert read_df.aantal.item() == 46
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("columns", [["OIDN", "UIDN"], ["OidN", "UidN"]])
+def test_read_file_sql_placeholders(suffix, engine_setter, columns):
+    """
+    Test if placeholders are properly filled out + if casing used in columns parameter
+    is retained when using placeholders.
+    """
+    if engine_setter == "fiona":
+        pytest.skip("sql_stmt param not supported for fiona engine")
+
+    # Prepare test data
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # Test
+    sql_stmt = """
+        SELECT {geometrycolumn}
+              {columns_to_select_str}
+          FROM "{input_layer}" layer
+    """
+    read_sql_gdf = gfo.read_file(
+        src, sql_stmt=sql_stmt, sql_dialect="SQLITE", columns=columns
+    )
+    read_gdf = gfo.read_file(src, columns=columns)
+    assert_geodataframe_equal(read_gdf, read_sql_gdf)
+
+
+def test_read_file_two_layers(engine_setter):
+    src = test_helper.get_testfile("polygon-twolayers")
+    layers = gfo.listlayers(src)
+    assert "parcels" in layers
+    assert "zones" in layers
+
+    read_gdf = gfo.read_file(src, layer="zones")
+    assert isinstance(read_gdf, gpd.GeoDataFrame)
+    assert len(read_gdf) == 5
+
+    read_gdf = gfo.read_file(src, layer="parcels")
+    assert isinstance(read_gdf, gpd.GeoDataFrame)
+    assert len(read_gdf) == 46
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_rename_column(tmp_path, suffix):
+    test_path = test_helper.get_testfile(
+        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
+    )
+
+    # Check if input file is ok
+    orig_layerinfo = gfo.get_layerinfo(test_path)
+    assert "OPPERVL" in orig_layerinfo.columns
+    assert "area" not in orig_layerinfo.columns
+
+    # Rename
+    if test_path.suffix == ".shp":
+        with pytest.raises(ValueError, match="rename_column is not possible for"):
+            gfo.rename_column(test_path, "OPPERVL", "area")
+    else:
+        gfo.rename_column(test_path, "OPPERVL", "area")
+        result_layerinfo = gfo.get_layerinfo(test_path)
+        assert "OPPERVL" not in result_layerinfo.columns
+        assert "area" in result_layerinfo.columns
+
+        # Rename non-existing column to existing columns doesn't give an error
+        gfo.rename_column(test_path, "OPPERVL", "area")
+        result_layerinfo = gfo.get_layerinfo(test_path)
+        assert "OPPERVL" not in result_layerinfo.columns
+        assert "area" in result_layerinfo.columns
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_rename_layer(tmp_path, suffix):
+    test_path = test_helper.get_testfile(
+        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
+    )
+
+    if suffix == ".gpkg":
+        gfo.add_layerstyle(test_path, layer="parcels", name="stylename", qml="")
+        gfo.rename_layer(test_path, layer="parcels", new_layer="parcels_renamed")
+        layernames_renamed = gfo.listlayers(path=test_path)
+        assert layernames_renamed[0] == "parcels_renamed"
+        assert len(gfo.get_layerstyles(test_path, layer="parcels_renamed")) == 1
+    elif suffix == ".shp":
+        # Now test rename layer
+        with pytest.raises(ValueError, match="rename_layer is not possible"):
+            gfo.rename_layer(
+                test_path,
+                layer="polygons_parcels",
+                new_layer="polygons_parcels_renamed",
+            )
+            layernames_renamed = gfo.listlayers(path=test_path)
+            assert layernames_renamed[0] == "polygons_parcels_renamed"
+    else:
+        raise Exception(f"test not implemented for suffix {suffix}")
+
+
+def test_execute_sql(tmp_path):
+    # Prepare testfile
+    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
+
+    # Test using execute_sql for creating/dropping indexes
+    gfo.execute_sql(
+        path=test_path, sql_stmt='CREATE INDEX idx_parcels_oidn ON "parcels"("oidn")'
+    )
+    gfo.execute_sql(path=test_path, sql_stmt="DROP INDEX idx_parcels_oidn")
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_spatial_index(tmp_path, suffix):
+    test_path = test_helper.get_testfile(
+        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
+    )
+    layer = gfo.get_only_layer(test_path)
+
+    # Check if spatial index present
+    has_spatial_index = gfo.has_spatial_index(path=test_path, layer=layer)
+    assert has_spatial_index is True
+
+    # Remove spatial index
+    gfo.remove_spatial_index(path=test_path, layer=layer)
+    has_spatial_index = gfo.has_spatial_index(path=test_path, layer=layer)
+    assert has_spatial_index is False
+
+    # Create spatial index
+    gfo.create_spatial_index(path=test_path, layer=layer)
+    has_spatial_index = gfo.has_spatial_index(path=test_path, layer=layer)
+    assert has_spatial_index is True
+
+    # Spatial index if it exists already by default gives error
+    with pytest.raises(Exception, match="Error adding spatial index to"):
+        gfo.create_spatial_index(path=test_path, layer=layer)
+    gfo.create_spatial_index(path=test_path, layer=layer, exist_ok=True)
+
+    # Test of rebuild only easy on shapefile
+    if suffix == ".shp":
+        qix_path = test_path.with_suffix(".qix")
+        qix_modified_time_orig = qix_path.stat().st_mtime
+        gfo.create_spatial_index(path=test_path, layer=layer, exist_ok=True)
+        assert qix_path.stat().st_mtime == qix_modified_time_orig
+        gfo.create_spatial_index(path=test_path, layer=layer, force_rebuild=True)
+        assert qix_path.stat().st_mtime > qix_modified_time_orig
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_to_file(tmp_path, suffix, engine_setter):
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    output_path = tmp_path / f"{src.stem}-output{suffix}"
+
+    # Read test file and write to tmppath
+    read_gdf = gfo.read_file(src)
+    gfo.to_file(read_gdf, output_path)
+    written_gdf = gfo.read_file(output_path)
+    assert len(read_gdf) == len(written_gdf)
+    assert_geodataframe_equal(written_gdf, read_gdf)
+
+    # Append the file again to tmppath
+    gfo.to_file(read_gdf, output_path, append=True)
+    written_gdf = gfo.read_file(output_path)
+    assert 2 * len(read_gdf) == len(written_gdf)
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_to_file_append_to_unexisting_file(tmp_path, suffix, engine_setter):
+    test_path = test_helper.get_testfile(
+        "polygon-parcel", dst_dir=tmp_path, suffix=suffix
+    )
+    test_gdf = gfo.read_file(test_path)
+    dst_path = tmp_path / f"dst{suffix}"
+    gfo.to_file(test_gdf, path=dst_path, append=True)
+    assert dst_path.exists()
+    dst_info = gfo.get_layerinfo(dst_path)
+    assert dst_info.featurecount == len(test_gdf)
+
+
+def test_to_file_append_different_columns(tmp_path, engine_setter):
+    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
+
+    test_gdf = gfo.read_file(test_path)
+    test_gdf["extra_column"] = 123
+    if engine_setter == "fiona":
+        ex_message = "Record does not match collection schema"
+    else:
+        ex_message = "destination layer doesn't have the same columns as gdf"
+    with pytest.raises(ValueError, match=ex_message):
+        gfo.to_file(test_gdf, path=test_path, append=True)
+
+
+def test_to_file_attribute_table_gpkg(tmp_path, engine_setter):
+    # Prepare test data
+    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
+
+    # Test writing a DataFrame to geopackage
+    test_gdf = gfo.read_file(test_path)
+    test_df = test_gdf.drop(columns="geometry")
+    assert isinstance(test_df, pd.DataFrame)
+    assert isinstance(test_df, gpd.GeoDataFrame) is False
+    gfo.to_file(test_df, test_path)
+
+    # Now check if the layer are correctly found afterwards
+    assert len(gfo.listlayers(test_path)) == 1
+    assert len(gfo.listlayers(test_path, only_spatial_layers=False)) == 2
+
+
+@pytest.mark.parametrize(
+    "suffix, create_spatial_index, expected_spatial_index",
+    [
+        [".gpkg", True, True],
+        [".gpkg", False, False],
+        [".gpkg", None, True],
+        [".shp", True, True],
+        [".shp", False, False],
+        [".shp", None, False],
+    ],
+)
+def test_to_file_create_spatial_index(
+    tmp_path,
+    suffix: str,
+    create_spatial_index: bool,
+    expected_spatial_index: bool,
+    engine_setter,
+):
+    src = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    output_path = tmp_path / f"{src.stem}-output{suffix}"
+
+    # Read test file and write to tmppath
+    read_gdf = gfo.read_file(src)
+    gfo.to_file(read_gdf, output_path, create_spatial_index=create_spatial_index)
+    assert gfo.has_spatial_index(output_path) is expected_spatial_index
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_to_file_emptyfile(tmp_path, suffix):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    read_gdf = gfo.read_file(input_path)
+    empty_gdf = read_gdf.drop(read_gdf.index)
+    assert isinstance(empty_gdf, gpd.GeoDataFrame)
+
+    # Test
+    # Remark: if no force_output_geometrytype is specified, the ouput geometry type in
+    # the depends on the file type, eg. Geometry for gpkg, MultiLinestring for shp.
+    output_path = tmp_path / f"output-emptyfile{suffix}"
+    gfo.to_file(
+        empty_gdf,
+        output_path,
+        force_output_geometrytype=input_layerinfo.geometrytype,
+    )
+
+    # Check result
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 0
+    assert len(input_layerinfo.columns) == len(output_layerinfo.columns)
+    assert input_layerinfo.geometrytype == output_layerinfo.geometrytype
+
+
+def test_to_file_force_geometrytype_multitype(tmp_path, engine_setter):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel")
+    read_gdf = gfo.read_file(input_path)
+    read_gdf.geometry = read_gdf.geometry.buffer(0)
+    poly_gdf = read_gdf[read_gdf.geometry.geom_type == "Polygon"]
+    assert isinstance(poly_gdf, gpd.GeoDataFrame)
+
+    # Default behaviour -> Polygon
+    output_path = tmp_path / f"{input_path.stem}-output.gpkg"
+    gfo.to_file(poly_gdf, output_path)
+    output_info = gfo.get_layerinfo(output_path)
+    assert output_info.featurecount == len(poly_gdf)
+    assert output_info.geometrytype == GeometryType.POLYGON
+
+    # force_output_geometrytype=GeometryType.MULTIPOLYGON -> MultiPolygon
+    output_force_path = tmp_path / f"{input_path.stem}-output-force.gpkg"
+    gfo.to_file(
+        poly_gdf,
+        output_force_path,
+        force_output_geometrytype=GeometryType.MULTIPOLYGON,
+    )
+    output_force_info = gfo.get_layerinfo(output_force_path)
+    assert output_force_info.featurecount == len(poly_gdf)
+    assert output_force_info.geometrytype == GeometryType.MULTIPOLYGON
+
+    # force_multitype=True -> MultiPolygon
+    output_force_path = tmp_path / f"{input_path.stem}-output-force.gpkg"
+    gfo.to_file(poly_gdf, output_force_path, force_multitype=True)
+    output_force_info = gfo.get_layerinfo(output_force_path)
+    assert output_force_info.featurecount == len(poly_gdf)
+    assert output_force_info.geometrytype == GeometryType.MULTIPOLYGON
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_to_file_geomempty(tmp_path, suffix, engine_setter):
+    # Test for gdf with an empty polygon + a polygon
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            sh_geom.GeometryCollection(),
+            test_helper.TestData.polygon_with_island,
+        ]
+    )
+    # By default, get_geometrytypes ignores the type of empty geometries.
+    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
+    assert len(test_geometrytypes) == 1
+    test_geometrytypes_includingempty = geoseries_util.get_geometrytypes(
+        test_gdf.geometry, ignore_empty_geometries=False
+    )
+    assert len(test_geometrytypes_includingempty) == 2
+    output_empty_path = tmp_path / f"testfile_with_emptygeom{suffix}"
+    test_gdf.to_file(output_empty_path, driver=gfo.GeofileType(suffix).ogrdriver)
+
+    # Now check the result if the data is still the same after being read again
+    test_read_gdf = gfo.read_file(output_empty_path)
+    test_read_geometrytypes = geoseries_util.get_geometrytypes(test_read_gdf.geometry)
+    assert len(test_gdf) == len(test_read_gdf)
+    if suffix == ".shp":
+        # When dataframe with "empty" gemetries is written to shapefile and
+        # read again, shapefile becomes of type MULTILINESTRING!?!
+        assert len(test_read_geometrytypes) == 1
+        assert test_read_geometrytypes[0] is GeometryType.MULTILINESTRING
+    else:
+        # When written to Geopackage... the empty geometries are actually saved
+        # as None. When read again they are None for fiona and empty for pyogrio.
+        assert test_read_gdf.geometry[0] is None or test_read_gdf.geometry[0].is_empty
+        assert isinstance(test_read_gdf.geometry[1], sh_geom.Polygon)
+
+        # So the geometrytype of the resulting GeoDataFrame is also POLYGON
+        assert len(test_read_geometrytypes) == 1
+        assert test_read_geometrytypes[0] is GeometryType.POLYGON
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_to_file_geomnone(tmp_path, suffix, engine_setter):
+    # Test for gdf with a None geometry + a polygon
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[None, test_helper.TestData.polygon_with_island]  # type: ignore
+    )
+    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
+    assert len(test_geometrytypes) == 1
+    output_none_path = tmp_path / f"file_with_nonegeom{suffix}"
+    gfo.to_file(test_gdf, output_none_path)
+
+    # Now check the result if the data is still the same after being read again
+    test_read_gdf = gfo.read_file(output_none_path)
+    # Result is the same as the original input
+    assert test_read_gdf.geometry[0] is None
+    assert isinstance(test_read_gdf.geometry[1], sh_geom.Polygon)
+    # The geometrytype of the column in the file is also the same as originaly
+    test_file_geometrytype = gfo.get_layerinfo(output_none_path).geometrytype
+    if suffix == ".shp":
+        assert test_file_geometrytype == GeometryType.MULTIPOLYGON
+    else:
+        assert test_file_geometrytype == test_geometrytypes[0]
+    # The result type in the geodataframe is also the same as originaly
+    test_read_geometrytypes = geoseries_util.get_geometrytypes(test_read_gdf.geometry)
+    assert len(test_gdf) == len(test_read_gdf)
+    assert test_read_geometrytypes == test_geometrytypes
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_remove(tmp_path, suffix):
+    # Prepare test data
+    src = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path, suffix=suffix)
+    assert src.exists()
+
+    # Remove and check result
+    gfo.remove(src)
+    assert src.exists() is False
+
+
+def test_launder_columns():
+    columns = [f"TOO_LONG_COLUMNNAME{index}" for index in range(0, 21)]
+    laundered = fileops._launder_column_names(columns)
+    assert laundered[0] == ("TOO_LONG_COLUMNNAME0", "TOO_LONG_C")
+    assert laundered[1] == ("TOO_LONG_COLUMNNAME1", "TOO_LONG_1")
+    assert laundered[9] == ("TOO_LONG_COLUMNNAME9", "TOO_LONG_9")
+    assert laundered[10] == ("TOO_LONG_COLUMNNAME10", "TOO_LONG10")
+    assert laundered[20] == ("TOO_LONG_COLUMNNAME20", "TOO_LONG20")
+
+    # Laundering happens case-insensitive
+    columns = ["too_LONG_COLUMNNAME", "TOO_long_COLUMNNAME2", "TOO_LONG_columnname3"]
+    laundered = fileops._launder_column_names(columns)
+    expected = [
+        ("too_LONG_COLUMNNAME", "too_LONG_C"),
+        ("TOO_long_COLUMNNAME2", "TOO_long_1"),
+        ("TOO_LONG_columnname3", "TOO_LONG_2"),
+    ]
+    assert laundered == expected
+
+    # Too many similar column names to be supported to launder
+    columns = [f"TOO_LONG_COLUMNNAME{index}" for index in range(0, 200)]
+    with pytest.raises(
+        NotImplementedError, match="Not supported to launder > 99 columns starting with"
+    ):
+        laundered = fileops._launder_column_names(columns)
```

### Comparing `geofileops-0.8.0a1/tests/test_geofileops_singlelayer.py` & `geofileops-0.8.0a2/tests/test_geofileops_singlelayer.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,466 +1,466 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for operations that are executed using a sql statement on one layer.
-"""
-
-from importlib import import_module
-import logging
-import math
-from pathlib import Path
-import sys
-from typing import List
-
-import pytest
-
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
-from geofileops import geoops
-from geofileops import fileops
-from geofileops import GeometryType
-from geofileops.util import _io_util
-from tests import test_helper as test_helper
-from tests.test_helper import DEFAULT_EPSGS, DEFAULT_SUFFIXES, DEFAULT_TESTFILES
-from tests.test_helper import assert_geodataframe_equal
-
-# Init gfo module
-current_fileops_module = "geofileops.fileops"
-
-
-def set_geoops_module(fileops_module: str):
-    global current_fileops_module
-    if current_fileops_module == fileops_module:
-        # The right module is already loaded, so don't do anything
-        return
-    else:
-        # Load the desired module as fileops
-        global geoops
-        geoops = import_module(fileops_module, __package__)
-        current_fileops_module = fileops_module
-        print(f"gfo module switched to: {current_fileops_module}")
-
-
-def get_combinations_to_test(
-    fileops_modules: List[str],
-    testfiles: List[str] = ["polygon-parcel", "point", "linestring-row-trees"],
-) -> list:
-    result = []
-
-    # On .gpkg test:
-    #   - all combinations of fileops_modules, testfiles and epsgs
-    #   - fixed empty_input, suffix
-    for epsg in DEFAULT_EPSGS:
-        for fileops_module in fileops_modules:
-            for testfile in testfiles:
-                result.append((".gpkg", epsg, fileops_module, testfile, False))
-
-    # On other suffixes test:
-    #   - all combinations of fileops_modules, testfiles
-    #   - fixed epsg and empty_input
-    other_suffixes = list(DEFAULT_SUFFIXES)
-    other_suffixes.remove(".gpkg")
-    for suffix in other_suffixes:
-        for fileops_module in fileops_modules:
-            for testfile in testfiles:
-                result.append((".shp", 31370, fileops_module, testfile, False))
-
-    # Test empty_input=True on
-    #   - all combinations of fileops_modules and DEFAULT_SUFFIXES
-    #   - fixed epsg, testfile and empty_input
-    for fileops_module in fileops_modules:
-        for suffix in DEFAULT_SUFFIXES:
-            result.append((suffix, 31370, fileops_module, "polygon-parcel", True))
-
-    return result
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg, fileops_module, testfile, empty_input",
-    get_combinations_to_test(["geofileops.geoops", "geofileops.util._geoops_gpd"]),
-)
-def test_buffer(tmp_path, suffix, epsg, fileops_module, testfile, empty_input):
-    """Buffer basics are available both in the gpd and sql implementations."""
-    # Prepare test data
-    input_path = test_helper.get_testfile(
-        testfile, suffix=suffix, epsg=epsg, empty=empty_input
-    )
-
-    # Now run test
-    output_path = tmp_path / f"{input_path.stem}-{fileops_module}{suffix}"
-    set_geoops_module(fileops_module)
-    input_layerinfo = fileops.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-    assert input_layerinfo.crs is not None
-    distance = 1
-    if input_layerinfo.crs.is_projected is False:
-        # 1 degree = 111 km or 111000 m
-        distance /= 111000
-
-    # Test positive buffer
-    geoops.buffer(
-        input_path=input_path,
-        output_path=output_path,
-        distance=distance,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Now check if the output file is correctly created
-    assert output_path.exists()
-    assert fileops.has_spatial_index(output_path)
-    output_layerinfo = fileops.get_layerinfo(output_path)
-    assert len(output_layerinfo.columns) == len(input_layerinfo.columns)
-
-    if not empty_input:
-        output_gdf = fileops.read_file(output_path)
-        assert output_gdf["geometry"][0] is not None
-        expected_gdf = fileops.read_file(input_path)
-        expected_gdf.geometry = expected_gdf.geometry.buffer(
-            distance=distance, resolution=5
-        )
-        check_less_precise = (
-            True if input_layerinfo.crs.is_projected is False else False
-        )
-        assert_geodataframe_equal(
-            output_gdf,
-            expected_gdf,
-            promote_to_multi=True,
-            check_less_precise=check_less_precise,
-            sort_values=True,
-        )
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("testfile", ["polygon-parcel"])
-@pytest.mark.parametrize(
-    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
-)
-def test_buffer_columns_fid(tmp_path, suffix, fileops_module, testfile):
-    """Buffer basics are available both in the gpd and sql implementations."""
-    # Prepare test data
-    input_path = test_helper.get_testfile(testfile, suffix=suffix)
-
-    # Now run test
-    output_path = tmp_path / f"{input_path.stem}-{fileops_module}{suffix}"
-    set_geoops_module(fileops_module)
-    input_layerinfo = fileops.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Test positive buffer
-    geoops.buffer(
-        input_path=input_path,
-        output_path=output_path,
-        distance=1,
-        columns=["LblHfdTlt", "fid"],
-        explodecollections=True,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Read input file and extract some info
-    input_gdf = fileops.read_file(input_path, fid_as_index=True)
-    if fileops.GeofileType(input_path).is_fid_zerobased:
-        assert input_gdf.index[0] == 0
-    else:
-        assert input_gdf.index[0] == 1
-    input_multi_gdf = input_gdf[
-        input_gdf.geometry.buffer(0).geom_type == "MultiPolygon"
-    ]
-    assert len(input_multi_gdf) == 2
-    multi_fid = input_multi_gdf.index[0]
-
-    # Now check if the output file is correctly created
-    assert output_path.exists()
-    assert fileops.has_spatial_index(output_path)
-    output_layerinfo = fileops.get_layerinfo(output_path)
-    output_gdf = fileops.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-    assert list(output_layerinfo.columns) == ["LblHfdTlt", "fid_1"]
-    assert len(output_gdf[output_gdf.fid_1 == multi_fid]) == 2
-
-
-@pytest.mark.parametrize(
-    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
-)
-def test_buffer_force(tmp_path, fileops_module):
-    input_path = test_helper.get_testfile("polygon-parcel")
-    input_layerinfo = fileops.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-    distance = 1
-    set_geoops_module(fileops_module)
-
-    # Run buffer
-    output_path = tmp_path / f"{input_path.stem}-output{input_path.suffix}"
-    assert output_path.exists() is False
-
-    geoops.buffer(
-        input_path=input_path,
-        output_path=output_path,
-        distance=distance,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Test buffer to existing output path
-    assert output_path.exists()
-    assert fileops.has_spatial_index(output_path)
-    mtime_orig = output_path.stat().st_mtime
-    geoops.buffer(
-        input_path=input_path,
-        output_path=output_path,
-        distance=distance,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-    assert output_path.stat().st_mtime == mtime_orig
-
-    # With force=True
-    geoops.buffer(
-        input_path=input_path,
-        output_path=output_path,
-        distance=distance,
-        nb_parallel=2,
-        batchsize=batchsize,
-        force=True,
-    )
-    assert output_path.stat().st_mtime != mtime_orig
-
-
-@pytest.mark.parametrize(
-    "expected_error, input_path, output_path",
-    [
-        (
-            "buffer: output_path must not equal input_path",
-            test_helper.get_testfile("polygon-parcel"),
-            test_helper.get_testfile("polygon-parcel"),
-        ),
-        (
-            "buffer: input_path doesn't exist:",
-            "not_existing_path",
-            "output.gpkg",
-        ),
-    ],
-)
-@pytest.mark.parametrize(
-    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
-)
-def test_buffer_invalid_params(
-    tmp_path, input_path, output_path, expected_error, fileops_module
-):
-    """
-    Invalid params for single layer operations.
-    """
-    # Internal functions are directly called, so need to be Path objects
-    if isinstance(output_path, str):
-        output_path = tmp_path / output_path
-    if isinstance(input_path, str):
-        input_path = tmp_path / input_path
-
-    # Now run test
-    set_geoops_module(fileops_module)
-    with pytest.raises(ValueError, match=expected_error):
-        geoops.buffer(input_path=input_path, output_path=output_path, distance=1)
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("testfile", DEFAULT_TESTFILES)
-@pytest.mark.parametrize(
-    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
-)
-def test_buffer_negative(tmp_path, suffix, fileops_module, testfile):
-    """Buffer basics are available both in the gpd and sql implementations."""
-    input_path = test_helper.get_testfile(testfile, suffix=suffix)
-
-    # Now run test
-    output_path = tmp_path / f"{input_path.stem}-{fileops_module}{suffix}"
-    set_geoops_module(fileops_module)
-    input_layerinfo = fileops.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Test negative buffer
-    distance = -10
-    output_path = output_path.parent / f"{output_path.stem}_m10m{output_path.suffix}"
-    geoops.buffer(
-        input_path=input_path,
-        output_path=output_path,
-        distance=distance,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Now check if the output file is correctly created
-    assert output_path.exists()
-    assert fileops.has_spatial_index(output_path)
-    output_layerinfo = fileops.get_layerinfo(output_path)
-    assert len(output_layerinfo.columns) == len(input_layerinfo.columns)
-
-    if input_layerinfo.geometrytype in [
-        GeometryType.MULTIPOINT,
-        GeometryType.MULTILINESTRING,
-    ]:
-        # A Negative buffer of points or linestrings doesn't give a result.
-        if output_path.exists():
-            assert fileops.get_layerinfo(output_path).featurecount == 0
-    else:
-        # A Negative buffer of polygons gives a result for large polygons.
-        # 7 polygons disappear because of the negative buffer
-        assert output_layerinfo.featurecount == input_layerinfo.featurecount - 7
-        assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-        # Read result for some more detailed checks
-        output_gdf = fileops.read_file(output_path)
-        expected_gdf = fileops.read_file(input_path)
-        expected_gdf.geometry = expected_gdf.geometry.buffer(
-            distance=distance, resolution=5
-        )
-        # Remove rows where geom is empty
-        expected_gdf = expected_gdf[~expected_gdf.geometry.is_empty]
-        expected_gdf = expected_gdf[~expected_gdf.geometry.isna()]
-        assert_geodataframe_equal(output_gdf, expected_gdf, sort_values=True)
-
-
-@pytest.mark.parametrize(
-    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
-)
-def test_buffer_negative_explode(tmp_path, fileops_module):
-    """Buffer basics are available both in the gpd and sql implementations."""
-    input_path = test_helper.get_testfile("polygon-parcel")
-
-    # Now run test
-    output_path = tmp_path / f"{input_path.stem}-output{input_path.suffix}"
-    set_geoops_module(fileops_module)
-    input_layerinfo = fileops.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Test negative buffer with explodecollections
-    output_path = (
-        output_path.parent / f"{output_path.stem}_m10m_explode{output_path.suffix}"
-    )
-    distance = -10
-    geoops.buffer(
-        input_path=input_path,
-        output_path=output_path,
-        distance=distance,
-        explodecollections=True,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Now check if the output file is correctly created
-    assert output_path.exists()
-    assert fileops.has_spatial_index(output_path)
-    layerinfo_output = fileops.get_layerinfo(output_path)
-    assert len(layerinfo_output.columns) == len(input_layerinfo.columns)
-
-    # 6 polygons disappear because of the negative buffer, 3 polygons are
-    # split in 2 because of the negative buffer and/or explodecollections=True.
-    assert layerinfo_output.featurecount == input_layerinfo.featurecount - 7 + 3
-    assert layerinfo_output.geometrytype == GeometryType.POLYGON
-
-    # Read result for some more detailed checks
-    output_gdf = fileops.read_file(output_path)
-    expected_gdf = fileops.read_file(input_path)
-    expected_gdf.geometry = expected_gdf.geometry.buffer(
-        distance=distance, resolution=5
-    )
-    # Remove rows where geom is empty
-    expected_gdf = expected_gdf[~expected_gdf.geometry.is_empty]
-    expected_gdf = expected_gdf[~expected_gdf.geometry.isna()]
-    expected_gdf = expected_gdf.explode(ignore_index=True)  # type: ignore
-    assert_geodataframe_equal(
-        output_gdf, expected_gdf, promote_to_multi=True, sort_values=True
-    )
-
-
-@pytest.mark.parametrize(
-    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
-)
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("empty_input", [True, False])
-def test_convexhull(tmp_path, fileops_module, suffix, empty_input):
-    logging.basicConfig(level=logging.DEBUG)
-    input_path = test_helper.get_testfile(
-        "polygon-parcel", suffix=suffix, empty=empty_input
-    )
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-    set_geoops_module(fileops_module)
-    input_layerinfo = fileops.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Also check if columns parameter works (case insensitive)
-    columns = ["OIDN", "uidn", "HFDTLT", "lblhfdtlt", "GEWASGROEP", "lengte", "OPPERVL"]
-    geoops.convexhull(
-        input_path=input_path,
-        columns=columns,
-        output_path=output_path,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Now check if the output file is correctly created
-    assert output_path.exists()
-    assert fileops.has_spatial_index(output_path)
-    layerinfo_output = fileops.get_layerinfo(output_path)
-    assert "OIDN" in layerinfo_output.columns
-    assert "uidn" in layerinfo_output.columns
-    assert len(layerinfo_output.columns) == len(columns)
-    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
-
-    if not empty_input:
-        assert input_layerinfo.featurecount == layerinfo_output.featurecount
-
-        # Read result for some more detailed checks
-        output_gdf = fileops.read_file(output_path)
-        assert output_gdf["geometry"][0] is not None
-        expected_gdf = fileops.read_file(input_path, columns=columns)
-        expected_gdf.geometry = expected_gdf.geometry.convex_hull
-        assert_geodataframe_equal(output_gdf, expected_gdf, sort_values=True)
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg, fileops_module, testfile, empty_input",
-    get_combinations_to_test(
-        fileops_modules=["geofileops.geoops", "geofileops.util._geoops_gpd"],
-        testfiles=["polygon-parcel", "linestring-row-trees"],
-    ),
-)
-def test_simplify(tmp_path, suffix, epsg, fileops_module, testfile, empty_input):
-    # Prepare test data
-    tmp_dir = tmp_path / f"{fileops_module}_{epsg}"
-    tmp_dir.mkdir(parents=True, exist_ok=True)
-    input_path = test_helper.get_testfile(
-        testfile, dst_dir=tmp_dir, suffix=suffix, epsg=epsg, empty=empty_input
-    )
-    output_path = tmp_dir / f"{input_path.stem}-output{suffix}"
-    set_geoops_module(fileops_module)
-    input_layerinfo = fileops.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-    assert input_layerinfo.crs is not None
-    if input_layerinfo.crs.is_projected:
-        tolerance = 5
-    else:
-        # 1 degree = 111 km or 111000 m
-        tolerance = 5 / 111000
-
-    # Test default algorithm (rdp)
-    output_path = _io_util.with_stem(input_path, output_path)
-    geoops.simplify(
-        input_path=input_path,
-        output_path=output_path,
-        tolerance=tolerance,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Now check if the tmp file is correctly created
-    assert output_path.exists()
-    assert fileops.has_spatial_index(output_path)
-    output_layerinfo = fileops.get_layerinfo(output_path)
-    assert len(output_layerinfo.columns) == len(input_layerinfo.columns)
-
-    if not empty_input:
-        output_gdf = fileops.read_file(output_path)
-        expected_gdf = fileops.read_file(input_path)
-        expected_gdf.geometry = expected_gdf.geometry.simplify(
-            tolerance=tolerance, preserve_topology=True
-        )
-        assert_geodataframe_equal(output_gdf, expected_gdf, sort_values=True)
+# -*- coding: utf-8 -*-
+"""
+Tests for operations that are executed using a sql statement on one layer.
+"""
+
+from importlib import import_module
+import logging
+import math
+from pathlib import Path
+import sys
+from typing import List
+
+import pytest
+
+# Add path so the local geofileops packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
+from geofileops import geoops
+from geofileops import fileops
+from geofileops import GeometryType
+from geofileops.util import _io_util
+from tests import test_helper as test_helper
+from tests.test_helper import DEFAULT_EPSGS, DEFAULT_SUFFIXES, DEFAULT_TESTFILES
+from tests.test_helper import assert_geodataframe_equal
+
+# Init gfo module
+current_fileops_module = "geofileops.fileops"
+
+
+def set_geoops_module(fileops_module: str):
+    global current_fileops_module
+    if current_fileops_module == fileops_module:
+        # The right module is already loaded, so don't do anything
+        return
+    else:
+        # Load the desired module as fileops
+        global geoops
+        geoops = import_module(fileops_module, __package__)
+        current_fileops_module = fileops_module
+        print(f"gfo module switched to: {current_fileops_module}")
+
+
+def get_combinations_to_test(
+    fileops_modules: List[str],
+    testfiles: List[str] = ["polygon-parcel", "point", "linestring-row-trees"],
+) -> list:
+    result = []
+
+    # On .gpkg test:
+    #   - all combinations of fileops_modules, testfiles and epsgs
+    #   - fixed empty_input, suffix
+    for epsg in DEFAULT_EPSGS:
+        for fileops_module in fileops_modules:
+            for testfile in testfiles:
+                result.append((".gpkg", epsg, fileops_module, testfile, False))
+
+    # On other suffixes test:
+    #   - all combinations of fileops_modules, testfiles
+    #   - fixed epsg and empty_input
+    other_suffixes = list(DEFAULT_SUFFIXES)
+    other_suffixes.remove(".gpkg")
+    for suffix in other_suffixes:
+        for fileops_module in fileops_modules:
+            for testfile in testfiles:
+                result.append((".shp", 31370, fileops_module, testfile, False))
+
+    # Test empty_input=True on
+    #   - all combinations of fileops_modules and DEFAULT_SUFFIXES
+    #   - fixed epsg, testfile and empty_input
+    for fileops_module in fileops_modules:
+        for suffix in DEFAULT_SUFFIXES:
+            result.append((suffix, 31370, fileops_module, "polygon-parcel", True))
+
+    return result
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg, fileops_module, testfile, empty_input",
+    get_combinations_to_test(["geofileops.geoops", "geofileops.util._geoops_gpd"]),
+)
+def test_buffer(tmp_path, suffix, epsg, fileops_module, testfile, empty_input):
+    """Buffer basics are available both in the gpd and sql implementations."""
+    # Prepare test data
+    input_path = test_helper.get_testfile(
+        testfile, suffix=suffix, epsg=epsg, empty=empty_input
+    )
+
+    # Now run test
+    output_path = tmp_path / f"{input_path.stem}-{fileops_module}{suffix}"
+    set_geoops_module(fileops_module)
+    input_layerinfo = fileops.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+    assert input_layerinfo.crs is not None
+    distance = 1
+    if input_layerinfo.crs.is_projected is False:
+        # 1 degree = 111 km or 111000 m
+        distance /= 111000
+
+    # Test positive buffer
+    geoops.buffer(
+        input_path=input_path,
+        output_path=output_path,
+        distance=distance,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Now check if the output file is correctly created
+    assert output_path.exists()
+    assert fileops.has_spatial_index(output_path)
+    output_layerinfo = fileops.get_layerinfo(output_path)
+    assert len(output_layerinfo.columns) == len(input_layerinfo.columns)
+
+    if not empty_input:
+        output_gdf = fileops.read_file(output_path)
+        assert output_gdf["geometry"][0] is not None
+        expected_gdf = fileops.read_file(input_path)
+        expected_gdf.geometry = expected_gdf.geometry.buffer(
+            distance=distance, resolution=5
+        )
+        check_less_precise = (
+            True if input_layerinfo.crs.is_projected is False else False
+        )
+        assert_geodataframe_equal(
+            output_gdf,
+            expected_gdf,
+            promote_to_multi=True,
+            check_less_precise=check_less_precise,
+            sort_values=True,
+        )
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("testfile", ["polygon-parcel"])
+@pytest.mark.parametrize(
+    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
+)
+def test_buffer_columns_fid(tmp_path, suffix, fileops_module, testfile):
+    """Buffer basics are available both in the gpd and sql implementations."""
+    # Prepare test data
+    input_path = test_helper.get_testfile(testfile, suffix=suffix)
+
+    # Now run test
+    output_path = tmp_path / f"{input_path.stem}-{fileops_module}{suffix}"
+    set_geoops_module(fileops_module)
+    input_layerinfo = fileops.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Test positive buffer
+    geoops.buffer(
+        input_path=input_path,
+        output_path=output_path,
+        distance=1,
+        columns=["LblHfdTlt", "fid"],
+        explodecollections=True,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Read input file and extract some info
+    input_gdf = fileops.read_file(input_path, fid_as_index=True)
+    if fileops.GeofileType(input_path).is_fid_zerobased:
+        assert input_gdf.index[0] == 0
+    else:
+        assert input_gdf.index[0] == 1
+    input_multi_gdf = input_gdf[
+        input_gdf.geometry.buffer(0).geom_type == "MultiPolygon"
+    ]
+    assert len(input_multi_gdf) == 2
+    multi_fid = input_multi_gdf.index[0]
+
+    # Now check if the output file is correctly created
+    assert output_path.exists()
+    assert fileops.has_spatial_index(output_path)
+    output_layerinfo = fileops.get_layerinfo(output_path)
+    output_gdf = fileops.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+    assert list(output_layerinfo.columns) == ["LblHfdTlt", "fid_1"]
+    assert len(output_gdf[output_gdf.fid_1 == multi_fid]) == 2
+
+
+@pytest.mark.parametrize(
+    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
+)
+def test_buffer_force(tmp_path, fileops_module):
+    input_path = test_helper.get_testfile("polygon-parcel")
+    input_layerinfo = fileops.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+    distance = 1
+    set_geoops_module(fileops_module)
+
+    # Run buffer
+    output_path = tmp_path / f"{input_path.stem}-output{input_path.suffix}"
+    assert output_path.exists() is False
+
+    geoops.buffer(
+        input_path=input_path,
+        output_path=output_path,
+        distance=distance,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Test buffer to existing output path
+    assert output_path.exists()
+    assert fileops.has_spatial_index(output_path)
+    mtime_orig = output_path.stat().st_mtime
+    geoops.buffer(
+        input_path=input_path,
+        output_path=output_path,
+        distance=distance,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+    assert output_path.stat().st_mtime == mtime_orig
+
+    # With force=True
+    geoops.buffer(
+        input_path=input_path,
+        output_path=output_path,
+        distance=distance,
+        nb_parallel=2,
+        batchsize=batchsize,
+        force=True,
+    )
+    assert output_path.stat().st_mtime != mtime_orig
+
+
+@pytest.mark.parametrize(
+    "expected_error, input_path, output_path",
+    [
+        (
+            "buffer: output_path must not equal input_path",
+            test_helper.get_testfile("polygon-parcel"),
+            test_helper.get_testfile("polygon-parcel"),
+        ),
+        (
+            "buffer: input_path doesn't exist:",
+            "not_existing_path",
+            "output.gpkg",
+        ),
+    ],
+)
+@pytest.mark.parametrize(
+    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
+)
+def test_buffer_invalid_params(
+    tmp_path, input_path, output_path, expected_error, fileops_module
+):
+    """
+    Invalid params for single layer operations.
+    """
+    # Internal functions are directly called, so need to be Path objects
+    if isinstance(output_path, str):
+        output_path = tmp_path / output_path
+    if isinstance(input_path, str):
+        input_path = tmp_path / input_path
+
+    # Now run test
+    set_geoops_module(fileops_module)
+    with pytest.raises(ValueError, match=expected_error):
+        geoops.buffer(input_path=input_path, output_path=output_path, distance=1)
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("testfile", DEFAULT_TESTFILES)
+@pytest.mark.parametrize(
+    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
+)
+def test_buffer_negative(tmp_path, suffix, fileops_module, testfile):
+    """Buffer basics are available both in the gpd and sql implementations."""
+    input_path = test_helper.get_testfile(testfile, suffix=suffix)
+
+    # Now run test
+    output_path = tmp_path / f"{input_path.stem}-{fileops_module}{suffix}"
+    set_geoops_module(fileops_module)
+    input_layerinfo = fileops.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Test negative buffer
+    distance = -10
+    output_path = output_path.parent / f"{output_path.stem}_m10m{output_path.suffix}"
+    geoops.buffer(
+        input_path=input_path,
+        output_path=output_path,
+        distance=distance,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Now check if the output file is correctly created
+    assert output_path.exists()
+    assert fileops.has_spatial_index(output_path)
+    output_layerinfo = fileops.get_layerinfo(output_path)
+    assert len(output_layerinfo.columns) == len(input_layerinfo.columns)
+
+    if input_layerinfo.geometrytype in [
+        GeometryType.MULTIPOINT,
+        GeometryType.MULTILINESTRING,
+    ]:
+        # A Negative buffer of points or linestrings doesn't give a result.
+        if output_path.exists():
+            assert fileops.get_layerinfo(output_path).featurecount == 0
+    else:
+        # A Negative buffer of polygons gives a result for large polygons.
+        # 7 polygons disappear because of the negative buffer
+        assert output_layerinfo.featurecount == input_layerinfo.featurecount - 7
+        assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+        # Read result for some more detailed checks
+        output_gdf = fileops.read_file(output_path)
+        expected_gdf = fileops.read_file(input_path)
+        expected_gdf.geometry = expected_gdf.geometry.buffer(
+            distance=distance, resolution=5
+        )
+        # Remove rows where geom is empty
+        expected_gdf = expected_gdf[~expected_gdf.geometry.is_empty]
+        expected_gdf = expected_gdf[~expected_gdf.geometry.isna()]
+        assert_geodataframe_equal(output_gdf, expected_gdf, sort_values=True)
+
+
+@pytest.mark.parametrize(
+    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
+)
+def test_buffer_negative_explode(tmp_path, fileops_module):
+    """Buffer basics are available both in the gpd and sql implementations."""
+    input_path = test_helper.get_testfile("polygon-parcel")
+
+    # Now run test
+    output_path = tmp_path / f"{input_path.stem}-output{input_path.suffix}"
+    set_geoops_module(fileops_module)
+    input_layerinfo = fileops.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Test negative buffer with explodecollections
+    output_path = (
+        output_path.parent / f"{output_path.stem}_m10m_explode{output_path.suffix}"
+    )
+    distance = -10
+    geoops.buffer(
+        input_path=input_path,
+        output_path=output_path,
+        distance=distance,
+        explodecollections=True,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Now check if the output file is correctly created
+    assert output_path.exists()
+    assert fileops.has_spatial_index(output_path)
+    layerinfo_output = fileops.get_layerinfo(output_path)
+    assert len(layerinfo_output.columns) == len(input_layerinfo.columns)
+
+    # 6 polygons disappear because of the negative buffer, 3 polygons are
+    # split in 2 because of the negative buffer and/or explodecollections=True.
+    assert layerinfo_output.featurecount == input_layerinfo.featurecount - 7 + 3
+    assert layerinfo_output.geometrytype == GeometryType.POLYGON
+
+    # Read result for some more detailed checks
+    output_gdf = fileops.read_file(output_path)
+    expected_gdf = fileops.read_file(input_path)
+    expected_gdf.geometry = expected_gdf.geometry.buffer(
+        distance=distance, resolution=5
+    )
+    # Remove rows where geom is empty
+    expected_gdf = expected_gdf[~expected_gdf.geometry.is_empty]
+    expected_gdf = expected_gdf[~expected_gdf.geometry.isna()]
+    expected_gdf = expected_gdf.explode(ignore_index=True)  # type: ignore
+    assert_geodataframe_equal(
+        output_gdf, expected_gdf, promote_to_multi=True, sort_values=True
+    )
+
+
+@pytest.mark.parametrize(
+    "fileops_module", ["geofileops.geoops", "geofileops.util._geoops_gpd"]
+)
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("empty_input", [True, False])
+def test_convexhull(tmp_path, fileops_module, suffix, empty_input):
+    logging.basicConfig(level=logging.DEBUG)
+    input_path = test_helper.get_testfile(
+        "polygon-parcel", suffix=suffix, empty=empty_input
+    )
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    set_geoops_module(fileops_module)
+    input_layerinfo = fileops.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Also check if columns parameter works (case insensitive)
+    columns = ["OIDN", "uidn", "HFDTLT", "lblhfdtlt", "GEWASGROEP", "lengte", "OPPERVL"]
+    geoops.convexhull(
+        input_path=input_path,
+        columns=columns,
+        output_path=output_path,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Now check if the output file is correctly created
+    assert output_path.exists()
+    assert fileops.has_spatial_index(output_path)
+    layerinfo_output = fileops.get_layerinfo(output_path)
+    assert "OIDN" in layerinfo_output.columns
+    assert "uidn" in layerinfo_output.columns
+    assert len(layerinfo_output.columns) == len(columns)
+    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
+
+    if not empty_input:
+        assert input_layerinfo.featurecount == layerinfo_output.featurecount
+
+        # Read result for some more detailed checks
+        output_gdf = fileops.read_file(output_path)
+        assert output_gdf["geometry"][0] is not None
+        expected_gdf = fileops.read_file(input_path, columns=columns)
+        expected_gdf.geometry = expected_gdf.geometry.convex_hull
+        assert_geodataframe_equal(output_gdf, expected_gdf, sort_values=True)
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg, fileops_module, testfile, empty_input",
+    get_combinations_to_test(
+        fileops_modules=["geofileops.geoops", "geofileops.util._geoops_gpd"],
+        testfiles=["polygon-parcel", "linestring-row-trees"],
+    ),
+)
+def test_simplify(tmp_path, suffix, epsg, fileops_module, testfile, empty_input):
+    # Prepare test data
+    tmp_dir = tmp_path / f"{fileops_module}_{epsg}"
+    tmp_dir.mkdir(parents=True, exist_ok=True)
+    input_path = test_helper.get_testfile(
+        testfile, dst_dir=tmp_dir, suffix=suffix, epsg=epsg, empty=empty_input
+    )
+    output_path = tmp_dir / f"{input_path.stem}-output{suffix}"
+    set_geoops_module(fileops_module)
+    input_layerinfo = fileops.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+    assert input_layerinfo.crs is not None
+    if input_layerinfo.crs.is_projected:
+        tolerance = 5
+    else:
+        # 1 degree = 111 km or 111000 m
+        tolerance = 5 / 111000
+
+    # Test default algorithm (rdp)
+    output_path = _io_util.with_stem(input_path, output_path)
+    geoops.simplify(
+        input_path=input_path,
+        output_path=output_path,
+        tolerance=tolerance,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Now check if the tmp file is correctly created
+    assert output_path.exists()
+    assert fileops.has_spatial_index(output_path)
+    output_layerinfo = fileops.get_layerinfo(output_path)
+    assert len(output_layerinfo.columns) == len(input_layerinfo.columns)
+
+    if not empty_input:
+        output_gdf = fileops.read_file(output_path)
+        expected_gdf = fileops.read_file(input_path)
+        expected_gdf.geometry = expected_gdf.geometry.simplify(
+            tolerance=tolerance, preserve_topology=True
+        )
+        assert_geodataframe_equal(output_gdf, expected_gdf, sort_values=True)
```

### Comparing `geofileops-0.8.0a1/tests/test_geofileops_singlelayer_gpd.py` & `geofileops-0.8.0a2/tests/test_geofileops_singlelayer_gpd.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,993 +1,995 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for operations using GeoPandas.
-"""
-
-import json
-import math
-from pathlib import Path
-import sys
-
-import geopandas as gpd
-import pytest
-import shapely.geometry as sh_geom
-
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
-import geofileops as gfo
-from geofileops import GeometryType
-from geofileops.util import _geoops_gpd, grid_util
-from geofileops.util import geometry_util
-from tests import test_helper
-from tests.test_helper import DEFAULT_EPSGS, DEFAULT_SUFFIXES
-
-
-def test_get_parallelization_params():
-    parallelization_params = _geoops_gpd.get_parallelization_params(500000)
-    assert parallelization_params is not None
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("only_geom_input", [True, False])
-@pytest.mark.parametrize("force_output_geometrytype", [None, GeometryType.POLYGON])
-def test_apply(tmp_path, suffix, only_geom_input, force_output_geometrytype):
-    # Prepare test data
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            test_helper.TestData.polygon_small_island,
-            test_helper.TestData.polygon_with_island,
-            None,
-        ],
-        crs=31370,  # type: ignore
-    )
-    input_path = tmp_path / f"polygons_small_holes_{suffix}"
-    gfo.to_file(test_gdf, input_path)
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    if only_geom_input:
-        gfo.apply(
-            input_path=input_path,
-            output_path=output_path,
-            func=lambda geom: geometry_util.remove_inner_rings(
-                geometry=geom, min_area_to_keep=2, crs=input_layerinfo.crs
-            ),
-            only_geom_input=True,
-            force_output_geometrytype=force_output_geometrytype,
-            batchsize=batchsize,
-        )
-    else:
-        gfo.apply(
-            input_path=input_path,
-            output_path=output_path,
-            func=lambda row: geometry_util.remove_inner_rings(
-                row.geometry, min_area_to_keep=2, crs=input_layerinfo.crs
-            ),
-            only_geom_input=False,
-            force_output_geometrytype=force_output_geometrytype,
-            batchsize=batchsize,
-        )
-
-    # Now check if the output file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert input_layerinfo.featurecount == (output_layerinfo.featurecount + 1)
-    assert len(output_layerinfo.columns) == len(input_layerinfo.columns)
-    if force_output_geometrytype is None or suffix == ".shp":
-        assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-    else:
-        assert output_layerinfo.geometrytype == GeometryType.POLYGON
-
-    # Read result for some more detailed checks
-    output_gdf = gfo.read_file(output_path)
-    for index in range(0, 2):
-        output_geometry = output_gdf["geometry"][index]
-        assert output_geometry is not None
-        if isinstance(output_geometry, sh_geom.MultiPolygon):
-            assert len(output_geometry.geoms) == 1
-            output_geometry = output_geometry.geoms[0]
-        assert isinstance(output_geometry, sh_geom.Polygon)
-
-        if index == 0:
-            # In the 1st polygon the island must be removed
-            assert len(output_geometry.interiors) == 0
-        elif index == 1:
-            # In the 2nd polygon the island is larger, so should be there
-            assert len(output_geometry.interiors) == 1
-
-
-def test_apply_geooperation_invalid_operation(tmp_path):
-    with pytest.raises(ValueError, match="operation not supported: INVALID"):
-        _geoops_gpd._apply_geooperation(
-            input_path=test_helper.get_testfile("polygon-parcel"),
-            output_path=tmp_path / "output.gpkg",
-            operation="INVALID",  # type: ignore
-            operation_params={},
-        )
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
-)
-def test_buffer_styles(tmp_path, suffix, epsg):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    assert input_layerinfo.crs is not None
-    distance = 1
-    if input_layerinfo.crs.is_projected is False:
-        # 1 degree = 111 km or 111000 m
-        distance /= 111000
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Run standard buffer to compare with
-    gfo.buffer(
-        input_path=input_path,
-        output_path=output_path,
-        distance=distance,
-        batchsize=batchsize,
-    )
-
-    # Read result
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-    area_default_buffer = sum(output_gdf.area)
-
-    # Test polygon buffer with square endcaps
-    output_path = (
-        output_path.parent / f"{output_path.stem}_endcap_join{output_path.suffix}"
-    )
-    gfo.buffer(
-        input_path=input_path,
-        output_path=output_path,
-        distance=distance,
-        endcap_style=geometry_util.BufferEndCapStyle.SQUARE,
-        join_style=geometry_util.BufferJoinStyle.MITRE,
-        batchsize=batchsize,
-    )
-
-    # Now check if the output file is correctly created
-    assert output_path.exists()
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert input_layerinfo.featurecount == output_layerinfo.featurecount
-    assert len(output_layerinfo.columns) == len(input_layerinfo.columns)
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Read result for some more detailed checks
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-    area_square_buffer = sum(output_gdf.area)
-    assert area_square_buffer > area_default_buffer
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("epsg", DEFAULT_EPSGS)
-def test_dissolve_linestrings(tmp_path, suffix, epsg):
-    # Prepare test data
-    input_path = test_helper.get_testfile(
-        "linestring-watercourse", suffix=suffix, epsg=epsg
-    )
-    output_basepath = tmp_path / f"{input_path.stem}-output{suffix}"
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Dissolve, no groupby, explodecollections=True
-    # ---------------------------------------------
-    output_path = (
-        output_basepath.parent / f"{output_basepath.stem}_expl{output_basepath.suffix}"
-    )
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        explodecollections=True,
-        batchsize=batchsize,
-    )
-
-    # Check if the result file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 83
-    assert output_layerinfo.geometrytype in [
-        GeometryType.LINESTRING,
-        GeometryType.MULTILINESTRING,
-    ]
-    assert len(output_layerinfo.columns) >= 0
-
-    # Now check the contents of the result file
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert input_gdf.crs == output_gdf.crs
-    assert len(output_gdf) == output_layerinfo.featurecount
-    assert output_gdf["geometry"][0] is not None
-    # TODO: add more in depth check of result
-
-    # Dissolve, no groupby, explodecollections=False
-    # ----------------------------------------------
-    output_path = (
-        output_basepath.parent
-        / f"{output_basepath.stem}_noexpl{output_basepath.suffix}"
-    )
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        explodecollections=False,
-        batchsize=batchsize,
-    )
-
-    # Check if the result file is correctly created
-    assert output_path.exists()
-    input_layerinfo = gfo.get_layerinfo(input_path)
-
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 1
-    assert output_layerinfo.geometrytype is input_layerinfo.geometrytype
-    assert len(output_layerinfo.columns) >= 0
-
-    # Now check the contents of the result file
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert input_gdf.crs == output_gdf.crs
-    assert len(output_gdf) == output_layerinfo.featurecount
-    assert output_gdf["geometry"][0] is not None
-    # TODO: add more in depth check of result
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("epsg", DEFAULT_EPSGS)
-def test_dissolve_linestrings_groupby(tmp_path, suffix, epsg):
-    # Prepare test data
-    input_path = test_helper.get_testfile(
-        "linestring-watercourse", suffix=suffix, epsg=epsg
-    )
-    output_basepath = tmp_path / f"{input_path.stem}-output{suffix}"
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Dissolve, groupby, explodecollections=False
-    # -------------------------------------------
-    output_path = (
-        output_basepath.parent
-        / f"{output_basepath.stem}_groupby_noexpl{output_basepath.suffix}"
-    )
-    groupby_columns = ["NISCODE"]
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        groupby_columns=groupby_columns,
-        explodecollections=False,
-        batchsize=batchsize,
-    )
-
-    # Check if the result file is correctly created
-    assert output_path.exists()
-    input_layerinfo = gfo.get_layerinfo(input_path)
-
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 26
-    assert output_layerinfo.geometrytype is input_layerinfo.geometrytype
-    assert len(output_layerinfo.columns) >= 0
-
-    # Now check the contents of the result file
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert input_gdf.crs == output_gdf.crs
-    assert len(output_gdf) == output_layerinfo.featurecount
-    assert output_gdf["geometry"][0] is not None
-    # TODO: add more in depth check of result
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("epsg", DEFAULT_EPSGS)
-def test_dissolve_linestrings_aggcolumns_columns(tmp_path, suffix, epsg):
-    # Prepare test data
-    input_path = test_helper.get_testfile(
-        "linestring-watercourse", suffix=suffix, epsg=epsg
-    )
-    output_basepath = tmp_path / f"{input_path.stem}-output{suffix}"
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Dissolve, groupby, explodecollections=False
-    # -------------------------------------------
-    output_path = (
-        output_basepath.parent
-        / f"{output_basepath.stem}_groupby_noexpl{output_basepath.suffix}"
-    )
-    # Also play a bit with casing to check case insnsitivity towards input file, but
-    # retaining the casing used in the groupby_columns parameter in output.
-    groupby_columns = ["NIScode"]
-    agg_columns = {
-        "columns": [
-            {"column": "fid", "agg": "concat", "as": "fid_concat"},
-            {"column": "NaaM", "agg": "max", "as": "naam_MAX"},
-        ]
-    }
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        groupby_columns=groupby_columns,
-        agg_columns=agg_columns,
-        explodecollections=False,
-        batchsize=batchsize,
-    )
-
-    # Check if the result file is correctly created
-    assert output_path.exists()
-    input_layerinfo = gfo.get_layerinfo(input_path)
-
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 26
-    assert output_layerinfo.geometrytype is input_layerinfo.geometrytype
-    assert len(output_layerinfo.columns) == (
-        len(groupby_columns) + len(agg_columns["columns"])
-    )
-
-    # Now check the contents of the result file
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert input_gdf.crs == output_gdf.crs
-    assert len(output_gdf) == output_layerinfo.featurecount
-    assert output_gdf["geometry"][0] is not None
-
-    # Some more default checks for NISCODE 12009
-    niscode_idx = output_gdf[output_gdf["NIScode"] == "12009"].index.item()
-    if gfo.GeofileType(input_path).is_fid_zerobased:
-        assert output_gdf["fid_concat"][niscode_idx] == "38,42,44,54"
-    else:
-        assert output_gdf["fid_concat"][niscode_idx] == "39,43,45,55"
-    assert output_gdf["naam_MAX"][niscode_idx] == "Vosbergbeek"
-    # TODO: add more in depth check of result
-
-
-@pytest.mark.parametrize("agg_columns", [{"json": ["fid", "NaaM"]}, {"json": None}])
-def test_dissolve_linestrings_aggcolumns_json(tmp_path, agg_columns):
-    # Prepare test data
-    input_path = test_helper.get_testfile("linestring-watercourse")
-    output_basepath = tmp_path / f"{input_path.stem}-output.gpkg"
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Dissolve, groupby, explodecollections=False
-    # -------------------------------------------
-    output_path = (
-        output_basepath.parent
-        / f"{output_basepath.stem}_groupby_noexpl{output_basepath.suffix}"
-    )
-    # Also play a bit with casing to check case insnsitivity towards input file, but
-    # retaining the casing used in the groupby_columns parameter in output.
-    groupby_columns = ["NIScode"]
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        groupby_columns=groupby_columns,
-        agg_columns=agg_columns,
-        explodecollections=False,
-        batchsize=batchsize,
-    )
-
-    # Check if the result file is correctly created
-    assert output_path.exists()
-    input_layerinfo = gfo.get_layerinfo(input_path)
-
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 26
-    assert output_layerinfo.geometrytype is input_layerinfo.geometrytype
-    assert len(output_layerinfo.columns) == len(groupby_columns) + 1
-
-    # Now check the contents of the result file
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert input_gdf.crs == output_gdf.crs
-    assert len(output_gdf) == output_layerinfo.featurecount
-    assert output_gdf["geometry"][0] is not None
-
-    # Some more default checks for NISCODE 12009
-    niscode_idx = output_gdf[output_gdf["NIScode"] == "12009"].index.item()
-    json_value = json.loads(str(output_gdf["json"][niscode_idx]))
-
-    # Check NAAM
-    naam_str = ",".join([value["NAAM"] for value in json_value])
-    exp = "Duffelse en Rumstse Scheibeek,Vosbergbeek,Maltaveldenloop,Grote Nete"
-    assert naam_str == exp
-    fid_str = ",".join([str(value["fid_orig"]) for value in json_value])
-    if gfo.GeofileType(input_path).is_fid_zerobased:
-        assert fid_str == "38,42,44,54"
-    else:
-        assert fid_str == "39,43,45,55"
-
-    # Some specific tests depending on whether all columns asked or not
-    if agg_columns["json"] is None:
-        # fid_orig is added to json
-        assert len(json_value[0]) == len(input_layerinfo.columns) + 1
-    else:
-        # fid_orig is added to json
-        assert len(json_value[0]) == len(agg_columns["json"]) + 1
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg, groupby_columns, explode, expected_featurecount",
-    [
-        (".gpkg", 31370, ["GEWASGROEP"], True, 25),
-        (".gpkg", 31370, ["GEWASGROEP"], False, 6),
-        (".gpkg", 31370, ["gewasGROEP"], False, 6),
-        (".gpkg", 31370, [], True, 23),
-        (".gpkg", 31370, None, False, 1),
-        (".gpkg", 4326, ["GEWASGROEP"], True, 25),
-        (".shp", 31370, ["GEWASGROEP"], True, 25),
-        (".shp", 31370, [], True, 23),
-    ],
-)
-def test_dissolve_polygons(
-    tmp_path, suffix, epsg, groupby_columns, explode, expected_featurecount
-):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Test dissolve polygons with different options for groupby and explodecollections
-    # --------------------------------------------------------------------------------
-    groupby = True if (groupby_columns is None or len(groupby_columns) == 0) else False
-    output_path = (
-        tmp_path / f"{input_path.stem}_groupby-{groupby}_explode-{explode}{suffix}"
-    )
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        groupby_columns=groupby_columns,
-        explodecollections=explode,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Now check if the tmp file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == expected_featurecount
-    if groupby is True:
-        # No groupby -> normally no columns.
-        # Shapefile needs at least one column, if no columns: fid
-        if suffix == ".shp":
-            assert len(output_layerinfo.columns) == 1
-        else:
-            assert len(output_layerinfo.columns) == 0
-    else:
-        assert len(output_layerinfo.columns) == len(groupby_columns)
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Now check the contents of the result file
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert input_gdf.crs == output_gdf.crs
-    assert len(output_gdf) == output_layerinfo.featurecount
-    assert output_gdf["geometry"][0] is not None
-
-    # Compare result with geopandas
-    columns = ["geometry"]
-    if groupby_columns is None or len(groupby_columns) == 0:
-        output_gpd_gdf = input_gdf[columns].dissolve()
-    else:
-        groupby_columns_upper = {column.upper(): column for column in groupby_columns}
-        columns += list(groupby_columns_upper)
-        output_gpd_gdf = (
-            input_gdf[columns].dissolve(by=list(groupby_columns_upper)).reset_index()
-        ).rename(columns=groupby_columns_upper)
-    if explode:
-        output_gpd_gdf = output_gpd_gdf.explode(ignore_index=True)
-    output_gpd_path = tmp_path / f"{input_path.stem}_gpd-output{suffix}"
-    gfo.to_file(output_gpd_gdf, output_gpd_path)
-
-    # Small differences with the geopandas result are expected, because gfo
-    # adds points in the tiling process. So only basic checks possible.
-    # assert_geodataframe_equal(
-    #        output_gdf, output_gpd_gdf, promote_to_multi=True, sort_values=True,
-    #        normalize=True, check_less_precise=True, output_dir=tmp_path)
-    if suffix != ".shp":
-        # Shapefile needs at least one column, if no columns: fid
-        assert list(output_gdf.columns) == list(output_gpd_gdf.columns)
-    assert len(output_gdf) == len(output_gpd_gdf)
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_dissolve_emptyfile(tmp_path, suffix):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, empty=True)
-
-    # Test dissolve polygons with different options for groupby and explodecollections
-    output_path = tmp_path / f"{input_path.stem}_dissolve-emptyfile{suffix}"
-    groupby_columns = ["GEWASGROEP"]
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        explodecollections=True,
-        groupby_columns=groupby_columns,
-    )
-
-    # Now check if the tmp file is correctly created
-    assert output_path.exists()
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 0
-    assert output_layerinfo.geometrytype == input_layerinfo.geometrytype
-    assert list(output_layerinfo.columns) == groupby_columns
-
-
-@pytest.mark.parametrize("sql_singlethread", [True, False])
-@pytest.mark.parametrize(
-    "exp_match, invalid_params",
-    [
-        ("column in groupby_columns not", {"groupby_columns": "NON_EXISTING_COLUMN"}),
-        ("input_path doesn't exist: ", {"input_path": Path("nonexisting.abc")}),
-        (
-            "output_path must not equal input_path",
-            {
-                "input_path": test_helper.get_testfile("polygon-parcel"),
-                "output_path": test_helper.get_testfile("polygon-parcel"),
-            },
-        ),
-        (
-            "Dissolve to tiles is not supported for GeometryType.MULTILINESTRING, ",
-            {
-                "input_path": test_helper.get_testfile("linestring-watercourse"),
-                "nb_squarish_tiles": 2,
-            },
-        ),
-        (
-            "abc not available in: ",
-            {
-                "agg_columns": {
-                    "columns": [{"column": "abc", "agg": "count", "as": "cba"}]
-                }
-            },
-        ),
-    ],
-)
-def test_dissolve_invalid_params(tmp_path, sql_singlethread, invalid_params, exp_match):
-    """
-    Test dissolve with some invalid input params.
-
-    Remark: the structure of agg_columns parameter is tested in
-      test_parameter_helper.test_validate_agg_columns_invalid.
-    """
-    # Prepare test data / params
-    input_path = test_helper.get_testfile("polygon-parcel")
-    groupby_columns = ["GEWASGROEP"]
-    nb_squarish_tiles = 1
-    agg_columns = None
-    output_path = tmp_path / "output.gpkg"
-    for invalid_param in invalid_params:
-        if invalid_param == "input_path":
-            input_path = invalid_params[invalid_param]
-        elif invalid_param == "groupby_columns":
-            groupby_columns = invalid_params[invalid_param]
-        elif invalid_param == "nb_squarish_tiles":
-            nb_squarish_tiles = invalid_params[invalid_param]
-        elif invalid_param == "agg_columns":
-            agg_columns = invalid_params[invalid_param]
-        elif invalid_param == "output_path":
-            output_path = invalid_params[invalid_param]
-        else:
-            ValueError(f"unsupported invalid_param: {invalid_param}")
-
-    # Run test
-    with pytest.raises(ValueError, match=exp_match):
-        if sql_singlethread:
-            if nb_squarish_tiles > 1:
-                pytest.skip("nb_squarish_tiles not relevant for dissolve_singlethread")
-            from geofileops.util import _geoops_sql
-
-            _geoops_sql.dissolve_singlethread(
-                input_path=input_path,
-                output_path=output_path,
-                groupby_columns=groupby_columns,
-                explodecollections=True,
-                agg_columns=agg_columns,
-            )
-        else:
-            gfo.dissolve(
-                input_path=input_path,
-                output_path=output_path,
-                groupby_columns=groupby_columns,
-                explodecollections=True,
-                nb_squarish_tiles=nb_squarish_tiles,
-                agg_columns=agg_columns,
-            )
-
-
-def test_dissolve_polygons_groupby_None(tmp_path):
-    """
-    Test dissolve polygons with a column with None values. There was once an issue
-    that the type of the column with None Values always ended up as a REAL column after
-    the dissolve/group by instead of the original type.
-    """
-
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
-    gfo.add_column(input_path, name="none_values", type=gfo.DataType.TEXT)
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Run test
-    output_path = tmp_path / "output.gpkg"
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        groupby_columns="none_values",
-        explodecollections=True,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Now check if the tmp file is correctly created
-    assert output_path.exists()
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-    assert (
-        output_layerinfo.columns["none_values"].gdal_type
-        == input_layerinfo.columns["none_values"].gdal_type
-    )
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_dissolve_polygons_specialcases(tmp_path, suffix):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    output_basepath = tmp_path / f"{input_path.stem}-output{suffix}"
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Test dissolve polygons with specified output layer
-    # --------------------------------------------------
-    # A different output layer is not supported for shapefile!!!
-    output_path = (
-        output_basepath.parent
-        / f"{output_basepath.stem}_group_outputlayer{output_basepath.suffix}"
-    )
-    try:
-        gfo.dissolve(
-            input_path=input_path,
-            output_path=output_path,
-            groupby_columns=["GEWASGROEP"],
-            output_layer="banana",
-            explodecollections=True,
-            nb_parallel=2,
-            batchsize=batchsize,
-        )
-    except Exception:
-        # A different output_layer is not supported for shapefile, so normal
-        # that an exception is thrown!
-        assert output_path.suffix.lower() == ".shp"
-
-    # Now check if the tmp file is correctly created
-    if output_path.suffix.lower() != ".shp":
-        assert output_path.exists()
-        output_layerinfo = gfo.get_layerinfo(output_path)
-        assert output_layerinfo.featurecount == 25
-        assert len(output_layerinfo.columns) == 1
-        assert output_layerinfo.name == "banana"
-        assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-        # Now check the contents of the result file
-        input_gdf = gfo.read_file(input_path)
-        output_gdf = gfo.read_file(output_path)
-        assert input_gdf.crs == output_gdf.crs
-        assert len(output_gdf) == output_layerinfo.featurecount
-        assert output_gdf["geometry"][0] is not None
-
-    # Test dissolve polygons with tiles_path
-    # --------------------------------------
-    output_path = (
-        output_basepath.parent
-        / f"{output_basepath.stem}_tilespath{output_basepath.suffix}"
-    )
-    tiles_path = output_basepath.parent / "tiles.gpkg"
-    tiles_gdf = grid_util.create_grid2(
-        input_layerinfo.total_bounds, nb_squarish_tiles=4, crs=31370
-    )
-    gfo.to_file(tiles_gdf, tiles_path)
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        tiles_path=tiles_path,
-        explodecollections=False,
-        nb_parallel=2,
-        batchsize=batchsize,
-        force=True,
-    )
-
-    # Now check if the result file is correctly created
-    assert output_path.exists()
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 4
-    if output_basepath.suffix == ".shp":
-        # Shapefile always has an FID field
-        # but only if there is no other column???
-        # TODO: think about whether this should also be the case for geopackage???
-        assert len(output_layerinfo.columns) == 1
-    else:
-        assert len(output_layerinfo.columns) == 1
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Now check the contents of the result file
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert input_gdf.crs == output_gdf.crs
-    assert len(output_gdf) == output_layerinfo.featurecount
-    assert output_gdf["geometry"][0] is not None
-
-    # Test dissolve to existing output path without and without force
-    # ---------------------------------------------------------------
-    for force in [True, False]:
-        assert output_path.exists() is True
-        mtime_orig = output_path.stat().st_mtime
-        gfo.dissolve(
-            input_path=input_path,
-            output_path=output_path,
-            explodecollections=True,
-            nb_parallel=2,
-            batchsize=batchsize,
-            force=force,
-        )
-        if force is False:
-            assert output_path.stat().st_mtime == mtime_orig
-        else:
-            assert output_path.stat().st_mtime != mtime_orig
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_dissolve_polygons_aggcolumns_columns(tmp_path, suffix):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-    output_basepath = tmp_path / f"{input_path.stem}-output{suffix}"
-
-    # Test dissolve polygons with groupby + agg_columns to columns
-    output_path = (
-        output_basepath.parent
-        / f"{output_basepath.stem}_group_aggcolumns{output_basepath.suffix}"
-    )
-    # Remarks:
-    #     - column names are shortened so it also works for shapefile!
-    #     - the columns for agg_columns are choosen so they do not contain
-    #       unique values, to be a better test case!
-    agg_columns = {
-        "columns": [
-            {"column": "lblhfdtlt", "agg": "max", "as": "lbl_max"},
-            {"column": "GEWASGROEP", "agg": "count", "as": "gwsgrp_cnt"},
-            {"column": "lblhfdtlt", "agg": "count", "as": "lbl_count"},
-            {
-                "column": "lblhfdtlt",
-                "agg": "count",
-                "distinct": True,
-                "as": "lbl_cnt_d",
-            },
-            {"column": "lblhfdtlt", "agg": "concat", "as": "lbl_conc"},
-            {
-                "column": "lblhfdtlt",
-                "agg": "concat",
-                "sep": ";",
-                "as": "lbl_conc_s",
-            },
-            {
-                "column": "lblhfdtlt",
-                "agg": "concat",
-                "distinct": True,
-                "as": "lbl_conc_d",
-            },
-            {"column": "hfdtlt", "agg": "mean", "as": "tlt_mea"},
-            {"column": "hfdtlt", "agg": "min", "as": "tlt_min"},
-            {"column": "hfdtlt", "agg": "sum", "as": "tlt_sum"},
-            {"column": "fid", "agg": "concat", "as": "fid_concat"},
-        ]
-    }
-    groupby_columns = ["GEWASGROEP"]
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        groupby_columns=groupby_columns,
-        agg_columns=agg_columns,
-        explodecollections=False,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Now check if the tmp file is correctly created
-    assert output_path.exists()
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 6
-    assert len(output_layerinfo.columns) == (
-        len(groupby_columns) + len(agg_columns["columns"])
-    )
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Now check the contents of the result file
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert input_gdf.crs == output_gdf.crs
-    assert len(output_gdf) == output_layerinfo.featurecount
-    assert output_gdf["geometry"][0] is not None
-
-    # Check agg_columns results
-    grasland_idx = output_gdf[output_gdf["GEWASGROEP"] == "Grasland"].index.to_list()[0]
-    assert output_gdf["lbl_max"][grasland_idx] == "Grasland"
-    assert output_gdf["gwsgrp_cnt"][grasland_idx] == 30
-    assert output_gdf["lbl_count"][grasland_idx] == 30
-    print(f"output_gdf.lbl_concat_distinct: {output_gdf['lbl_conc_d'][grasland_idx]}")
-    assert output_gdf["lbl_cnt_d"][grasland_idx] == 1
-    assert output_gdf["lbl_conc"][grasland_idx].startswith("Grasland,Grasland,")
-    assert output_gdf["lbl_conc_s"][grasland_idx].startswith("Grasland;Grasland;")
-    assert output_gdf["lbl_conc_d"][grasland_idx] == "Grasland"
-    assert output_gdf["tlt_mea"][grasland_idx] == 60  # type: ignore
-    assert int(output_gdf["tlt_min"][grasland_idx]) == 60  # type: ignore
-    assert output_gdf["tlt_sum"][grasland_idx] == 1800  # type: ignore
-
-    groenten_idx = output_gdf[
-        output_gdf["GEWASGROEP"] == "Groenten, kruiden en sierplanten"
-    ].index.to_list()[0]
-    assert output_gdf["lbl_count"][groenten_idx] == 5
-    print(
-        "groenten.lblhfdtlt_concat_distinct: "
-        "f{output_gdf['lbl_conc_d'][groenten_idx]}"
-    )
-    assert output_gdf["lbl_cnt_d"][groenten_idx] == 4
-    if gfo.GeofileType(input_path).is_fid_zerobased:
-        assert output_gdf["fid_concat"][groenten_idx] == "41,42,43,44,45"
-    else:
-        assert output_gdf["fid_concat"][groenten_idx] == "42,43,44,45,46"
-
-
-@pytest.mark.parametrize(
-    "agg_columns", [{"json": ["lengte", "oppervl", "lblhfdtlt"]}, {"json": None}]
-)
-def test_dissolve_polygons_aggcolumns_json(tmp_path, agg_columns):
-    # In shapefiles, the length of str columns is very limited, so the json
-    # test would fail.
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel")
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-    output_basepath = tmp_path / f"{input_path.stem}-output.gpkg"
-
-    # Test dissolve polygons with groupby + agg_columns to json
-    output_path = (
-        output_basepath.parent
-        / f"{output_basepath.stem}_group_aggjson{output_basepath.suffix}"
-    )
-    gfo.dissolve(
-        input_path=input_path,
-        output_path=output_path,
-        groupby_columns=["GEWASGROEP"],
-        agg_columns=agg_columns,
-        explodecollections=False,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Now check if the tmp file is correctly created
-    assert output_path.exists()
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 6
-    assert len(output_layerinfo.columns) == 2
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Now check the contents of the result file
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert input_gdf.crs == output_gdf.crs
-    assert len(output_gdf) == output_layerinfo.featurecount
-    assert output_gdf["geometry"][0] is not None
-    grasland_json = json.loads(str(output_gdf["json"][0]))
-    assert len(grasland_json) == 30
-    grasland_json_firstrow = json.loads(str(grasland_json[0]))
-    if agg_columns["json"] is None:
-        # fid_orig column is added in json, but index column disappeared ???
-        assert len(grasland_json_firstrow) == len(input_layerinfo.columns)
-    else:
-        # fid_orig column is added in json
-        assert len(grasland_json_firstrow) == len(agg_columns["json"]) + 1
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg, testfile",
-    [
-        (".gpkg", 31370, "polygon-parcel"),
-        (".gpkg", 31370, "linestring-row-trees"),
-        (".gpkg", 4326, "polygon-parcel"),
-        (".shp", 31370, "polygon-parcel"),
-        (".shp", 4326, "polygon-parcel"),
-    ],
-)
-def test_simplify_vw(tmp_path, suffix, epsg, testfile):
-    # Skip test if simplification is not available
-    _ = pytest.importorskip("simplification")
-
-    # Init
-    input_path = test_helper.get_testfile(testfile, suffix=suffix, epsg=epsg)
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-    assert input_layerinfo.crs is not None
-    if input_layerinfo.crs.is_projected:
-        tolerance = 5
-    else:
-        # 1 degree = 111 km or 111000 m
-        tolerance = 5 / 111000
-
-    # Test vw (visvalingam-whyatt) algorithm
-    output_path = tmp_path / f"{input_path.stem}-output_vw{suffix}"
-    gfo.simplify(
-        input_path=input_path,
-        output_path=output_path,
-        tolerance=tolerance,
-        algorithm=geometry_util.SimplifyAlgorithm.VISVALINGAM_WHYATT,
-        batchsize=batchsize,
-    )
-
-    # Check if the file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert input_layerinfo.featurecount == output_layerinfo.featurecount
-    assert len(input_layerinfo.columns) == len(output_layerinfo.columns)
-    assert output_layerinfo.geometrytype == input_layerinfo.geometrytype
-
-    # Check the contents of the result file
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert input_gdf.crs == output_gdf.crs
-    assert len(output_gdf) == output_layerinfo.featurecount
-    assert output_gdf["geometry"][0] is not None
-    # TODO: a more in-depth check would be better
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg, testfile",
-    [
-        (".gpkg", 31370, "polygon-parcel"),
-        (".gpkg", 31370, "linestring-row-trees"),
-        (".gpkg", 4326, "polygon-parcel"),
-        (".shp", 31370, "polygon-parcel"),
-        (".shp", 4326, "polygon-parcel"),
-    ],
-)
-def test_simplify_lang(tmp_path, suffix, epsg, testfile):
-    input_path = test_helper.get_testfile(testfile, suffix=suffix, epsg=epsg)
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-    assert input_layerinfo.crs is not None
-    if input_layerinfo.crs.is_projected:
-        tolerance = 5
-    else:
-        # 1 degree = 111 km or 111000 m
-        tolerance = 5 / 111000
-    # Test lang algorithm
-    output_path = tmp_path / f"{input_path.stem}-output_lang{suffix}"
-    gfo.simplify(
-        input_path=input_path,
-        output_path=output_path,
-        tolerance=tolerance,
-        algorithm=geometry_util.SimplifyAlgorithm.LANG,
-        lookahead=8,
-        batchsize=batchsize,
-    )
-
-    # Check if the tmp file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert input_layerinfo.featurecount == output_layerinfo.featurecount
-    assert len(input_layerinfo.columns) == len(output_layerinfo.columns)
-    assert output_layerinfo.geometrytype == input_layerinfo.geometrytype
-
-    # Check the contents of the result file
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert input_gdf.crs == output_gdf.crs
-    assert len(output_gdf) == output_layerinfo.featurecount
-    assert output_gdf["geometry"][0] is not None
-    # TODO: some more in-depth validations would be better
+# -*- coding: utf-8 -*-
+"""
+Tests for operations using GeoPandas.
+"""
+
+import json
+import math
+from pathlib import Path
+import sys
+
+import geopandas as gpd
+import pytest
+import shapely.geometry as sh_geom
+
+# Add path so the local geofileops packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
+import geofileops as gfo
+from geofileops import GeometryType
+from geofileops.util import _geoops_gpd, grid_util
+from geofileops.util import geometry_util
+from tests import test_helper
+from tests.test_helper import DEFAULT_EPSGS, DEFAULT_SUFFIXES
+
+
+def test_get_parallelization_params():
+    parallelization_params = _geoops_gpd.get_parallelization_params(500000)
+    assert parallelization_params is not None
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("only_geom_input", [True, False])
+@pytest.mark.parametrize("force_output_geometrytype", [None, GeometryType.POLYGON])
+def test_apply(tmp_path, suffix, only_geom_input, force_output_geometrytype):
+    # Prepare test data
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            test_helper.TestData.polygon_small_island,
+            test_helper.TestData.polygon_with_island,
+            None,
+        ],
+        crs=31370,  # type: ignore
+    )
+    input_path = tmp_path / f"polygons_small_holes_{suffix}"
+    gfo.to_file(test_gdf, input_path)
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    if only_geom_input:
+        gfo.apply(
+            input_path=input_path,
+            output_path=output_path,
+            func=lambda geom: geometry_util.remove_inner_rings(
+                geometry=geom, min_area_to_keep=2, crs=input_layerinfo.crs
+            ),
+            only_geom_input=True,
+            force_output_geometrytype=force_output_geometrytype,
+            batchsize=batchsize,
+        )
+    else:
+        gfo.apply(
+            input_path=input_path,
+            output_path=output_path,
+            func=lambda row: geometry_util.remove_inner_rings(
+                row.geometry, min_area_to_keep=2, crs=input_layerinfo.crs
+            ),
+            only_geom_input=False,
+            force_output_geometrytype=force_output_geometrytype,
+            batchsize=batchsize,
+        )
+
+    # Now check if the output file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert input_layerinfo.featurecount == (output_layerinfo.featurecount + 1)
+    assert len(output_layerinfo.columns) == len(input_layerinfo.columns)
+    if force_output_geometrytype is None or suffix == ".shp":
+        assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+    else:
+        assert output_layerinfo.geometrytype == GeometryType.POLYGON
+
+    # Read result for some more detailed checks
+    output_gdf = gfo.read_file(output_path)
+    for index in range(0, 2):
+        output_geometry = output_gdf["geometry"][index]
+        assert output_geometry is not None
+        if isinstance(output_geometry, sh_geom.MultiPolygon):
+            assert len(output_geometry.geoms) == 1
+            output_geometry = output_geometry.geoms[0]
+        assert isinstance(output_geometry, sh_geom.Polygon)
+
+        if index == 0:
+            # In the 1st polygon the island must be removed
+            assert len(output_geometry.interiors) == 0
+        elif index == 1:
+            # In the 2nd polygon the island is larger, so should be there
+            assert len(output_geometry.interiors) == 1
+
+
+def test_apply_geooperation_invalid_operation(tmp_path):
+    with pytest.raises(ValueError, match="operation not supported: INVALID"):
+        _geoops_gpd._apply_geooperation(
+            input_path=test_helper.get_testfile("polygon-parcel"),
+            output_path=tmp_path / "output.gpkg",
+            operation="INVALID",  # type: ignore
+            operation_params={},
+        )
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
+)
+def test_buffer_styles(tmp_path, suffix, epsg):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    assert input_layerinfo.crs is not None
+    distance = 1
+    if input_layerinfo.crs.is_projected is False:
+        # 1 degree = 111 km or 111000 m
+        distance /= 111000
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Run standard buffer to compare with
+    gfo.buffer(
+        input_path=input_path,
+        output_path=output_path,
+        distance=distance,
+        batchsize=batchsize,
+    )
+
+    # Read result
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+    area_default_buffer = sum(output_gdf.area)
+
+    # Test polygon buffer with square endcaps
+    output_path = (
+        output_path.parent / f"{output_path.stem}_endcap_join{output_path.suffix}"
+    )
+    gfo.buffer(
+        input_path=input_path,
+        output_path=output_path,
+        distance=distance,
+        endcap_style=geometry_util.BufferEndCapStyle.SQUARE,
+        join_style=geometry_util.BufferJoinStyle.MITRE,
+        batchsize=batchsize,
+    )
+
+    # Now check if the output file is correctly created
+    assert output_path.exists()
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert input_layerinfo.featurecount == output_layerinfo.featurecount
+    assert len(output_layerinfo.columns) == len(input_layerinfo.columns)
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Read result for some more detailed checks
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+    area_square_buffer = sum(output_gdf.area)
+    assert area_square_buffer > area_default_buffer
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("epsg", DEFAULT_EPSGS)
+def test_dissolve_linestrings(tmp_path, suffix, epsg):
+    # Prepare test data
+    input_path = test_helper.get_testfile(
+        "linestring-watercourse", suffix=suffix, epsg=epsg
+    )
+    output_basepath = tmp_path / f"{input_path.stem}-output{suffix}"
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Dissolve, no groupby, explodecollections=True
+    # ---------------------------------------------
+    output_path = (
+        output_basepath.parent / f"{output_basepath.stem}_expl{output_basepath.suffix}"
+    )
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        explodecollections=True,
+        batchsize=batchsize,
+    )
+
+    # Check if the result file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 83
+    assert output_layerinfo.geometrytype in [
+        GeometryType.LINESTRING,
+        GeometryType.MULTILINESTRING,
+    ]
+    assert len(output_layerinfo.columns) >= 0
+
+    # Now check the contents of the result file
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert input_gdf.crs == output_gdf.crs
+    assert len(output_gdf) == output_layerinfo.featurecount
+    assert output_gdf["geometry"][0] is not None
+    # TODO: add more in depth check of result
+
+    # Dissolve, no groupby, explodecollections=False
+    # ----------------------------------------------
+    output_path = (
+        output_basepath.parent
+        / f"{output_basepath.stem}_noexpl{output_basepath.suffix}"
+    )
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        explodecollections=False,
+        batchsize=batchsize,
+    )
+
+    # Check if the result file is correctly created
+    assert output_path.exists()
+    input_layerinfo = gfo.get_layerinfo(input_path)
+
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 1
+    assert output_layerinfo.geometrytype is input_layerinfo.geometrytype
+    assert len(output_layerinfo.columns) >= 0
+
+    # Now check the contents of the result file
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert input_gdf.crs == output_gdf.crs
+    assert len(output_gdf) == output_layerinfo.featurecount
+    assert output_gdf["geometry"][0] is not None
+    # TODO: add more in depth check of result
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("epsg", DEFAULT_EPSGS)
+def test_dissolve_linestrings_groupby(tmp_path, suffix, epsg):
+    # Prepare test data
+    input_path = test_helper.get_testfile(
+        "linestring-watercourse", suffix=suffix, epsg=epsg
+    )
+    output_basepath = tmp_path / f"{input_path.stem}-output{suffix}"
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Dissolve, groupby, explodecollections=False
+    # -------------------------------------------
+    output_path = (
+        output_basepath.parent
+        / f"{output_basepath.stem}_groupby_noexpl{output_basepath.suffix}"
+    )
+    groupby_columns = ["NISCODE"]
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        groupby_columns=groupby_columns,
+        explodecollections=False,
+        batchsize=batchsize,
+    )
+
+    # Check if the result file is correctly created
+    assert output_path.exists()
+    input_layerinfo = gfo.get_layerinfo(input_path)
+
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 26
+    assert output_layerinfo.geometrytype is input_layerinfo.geometrytype
+    assert len(output_layerinfo.columns) >= 0
+
+    # Now check the contents of the result file
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert input_gdf.crs == output_gdf.crs
+    assert len(output_gdf) == output_layerinfo.featurecount
+    assert output_gdf["geometry"][0] is not None
+    # TODO: add more in depth check of result
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("epsg", DEFAULT_EPSGS)
+def test_dissolve_linestrings_aggcolumns_columns(tmp_path, suffix, epsg):
+    # Prepare test data
+    input_path = test_helper.get_testfile(
+        "linestring-watercourse", suffix=suffix, epsg=epsg
+    )
+    output_basepath = tmp_path / f"{input_path.stem}-output{suffix}"
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Dissolve, groupby, explodecollections=False
+    # -------------------------------------------
+    output_path = (
+        output_basepath.parent
+        / f"{output_basepath.stem}_groupby_noexpl{output_basepath.suffix}"
+    )
+    # Also play a bit with casing to check case insnsitivity towards input file, but
+    # retaining the casing used in the groupby_columns parameter in output.
+    groupby_columns = ["NIScode"]
+    agg_columns = {
+        "columns": [
+            {"column": "fid", "agg": "concat", "as": "fid_concat"},
+            {"column": "NaaM", "agg": "max", "as": "naam_MAX"},
+        ]
+    }
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        groupby_columns=groupby_columns,
+        agg_columns=agg_columns,
+        explodecollections=False,
+        batchsize=batchsize,
+    )
+
+    # Check if the result file is correctly created
+    assert output_path.exists()
+    input_layerinfo = gfo.get_layerinfo(input_path)
+
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 26
+    assert output_layerinfo.geometrytype is input_layerinfo.geometrytype
+    assert len(output_layerinfo.columns) == (
+        len(groupby_columns) + len(agg_columns["columns"])
+    )
+
+    # Now check the contents of the result file
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert input_gdf.crs == output_gdf.crs
+    assert len(output_gdf) == output_layerinfo.featurecount
+    assert output_gdf["geometry"][0] is not None
+
+    # Some more default checks for NISCODE 12009
+    niscode_idx = output_gdf[output_gdf["NIScode"] == "12009"].index.item()
+    if gfo.GeofileType(input_path).is_fid_zerobased:
+        assert output_gdf["fid_concat"][niscode_idx] == "38,42,44,54"
+    else:
+        assert output_gdf["fid_concat"][niscode_idx] == "39,43,45,55"
+    assert output_gdf["naam_MAX"][niscode_idx] == "Vosbergbeek"
+    # TODO: add more in depth check of result
+
+
+@pytest.mark.parametrize("agg_columns", [{"json": ["fid", "NaaM"]}, {"json": None}])
+def test_dissolve_linestrings_aggcolumns_json(tmp_path, agg_columns):
+    # Prepare test data
+    input_path = test_helper.get_testfile("linestring-watercourse")
+    output_basepath = tmp_path / f"{input_path.stem}-output.gpkg"
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Dissolve, groupby, explodecollections=False
+    # -------------------------------------------
+    output_path = (
+        output_basepath.parent
+        / f"{output_basepath.stem}_groupby_noexpl{output_basepath.suffix}"
+    )
+    # Also play a bit with casing to check case insnsitivity towards input file, but
+    # retaining the casing used in the groupby_columns parameter in output.
+    groupby_columns = ["NIScode"]
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        groupby_columns=groupby_columns,
+        agg_columns=agg_columns,
+        explodecollections=False,
+        batchsize=batchsize,
+    )
+
+    # Check if the result file is correctly created
+    assert output_path.exists()
+    input_layerinfo = gfo.get_layerinfo(input_path)
+
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 26
+    assert output_layerinfo.geometrytype is input_layerinfo.geometrytype
+    assert len(output_layerinfo.columns) == len(groupby_columns) + 1
+
+    # Now check the contents of the result file
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert input_gdf.crs == output_gdf.crs
+    assert len(output_gdf) == output_layerinfo.featurecount
+    assert output_gdf["geometry"][0] is not None
+
+    # Some more default checks for NISCODE 12009
+    niscode_idx = output_gdf[output_gdf["NIScode"] == "12009"].index.item()
+    json_value = json.loads(str(output_gdf["json"][niscode_idx]))
+
+    # Check NAAM
+    naam_str = ",".join([value["NAAM"] for value in json_value])
+    exp = "Duffelse en Rumstse Scheibeek,Vosbergbeek,Maltaveldenloop,Grote Nete"
+    assert naam_str == exp
+    fid_str = ",".join([str(value["fid_orig"]) for value in json_value])
+    if gfo.GeofileType(input_path).is_fid_zerobased:
+        assert fid_str == "38,42,44,54"
+    else:
+        assert fid_str == "39,43,45,55"
+
+    # Some specific tests depending on whether all columns asked or not
+    if agg_columns["json"] is None:
+        # fid_orig is added to json
+        assert len(json_value[0]) == len(input_layerinfo.columns) + 1
+    else:
+        # fid_orig is added to json
+        assert len(json_value[0]) == len(agg_columns["json"]) + 1
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg, groupby_columns, explode, expected_featurecount",
+    [
+        (".gpkg", 31370, ["GEWASGROEP"], True, 25),
+        (".gpkg", 31370, ["GEWASGROEP"], False, 6),
+        (".gpkg", 31370, ["gewasGROEP"], False, 6),
+        (".gpkg", 31370, [], True, 23),
+        (".gpkg", 31370, None, False, 1),
+        (".gpkg", 4326, ["GEWASGROEP"], True, 25),
+        (".shp", 31370, ["GEWASGROEP"], True, 25),
+        (".shp", 31370, [], True, 23),
+    ],
+)
+def test_dissolve_polygons(
+    tmp_path, suffix, epsg, groupby_columns, explode, expected_featurecount
+):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Test dissolve polygons with different options for groupby and explodecollections
+    # --------------------------------------------------------------------------------
+    groupby = True if (groupby_columns is None or len(groupby_columns) == 0) else False
+    output_path = (
+        tmp_path / f"{input_path.stem}_groupby-{groupby}_explode-{explode}{suffix}"
+    )
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        groupby_columns=groupby_columns,
+        explodecollections=explode,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Now check if the tmp file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == expected_featurecount
+    if groupby is True:
+        # No groupby -> normally no columns.
+        # Shapefile needs at least one column, if no columns: fid
+        if suffix == ".shp":
+            assert len(output_layerinfo.columns) == 1
+        else:
+            assert len(output_layerinfo.columns) == 0
+    else:
+        assert len(output_layerinfo.columns) == len(groupby_columns)
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Now check the contents of the result file
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert input_gdf.crs == output_gdf.crs
+    assert len(output_gdf) == output_layerinfo.featurecount
+    assert output_gdf["geometry"][0] is not None
+
+    # Compare result with geopandas
+    columns = ["geometry"]
+    if groupby_columns is None or len(groupby_columns) == 0:
+        output_gpd_gdf = input_gdf[columns].dissolve()  # type: ignore
+    else:
+        groupby_columns_upper = {column.upper(): column for column in groupby_columns}
+        columns += list(groupby_columns_upper)
+        output_gpd_gdf = (
+            input_gdf[columns]
+            .dissolve(by=list(groupby_columns_upper))  # type: ignore
+            .reset_index()
+        ).rename(columns=groupby_columns_upper)
+    if explode:
+        output_gpd_gdf = output_gpd_gdf.explode(ignore_index=True)
+    output_gpd_path = tmp_path / f"{input_path.stem}_gpd-output{suffix}"
+    gfo.to_file(output_gpd_gdf, output_gpd_path)
+
+    # Small differences with the geopandas result are expected, because gfo
+    # adds points in the tiling process. So only basic checks possible.
+    # assert_geodataframe_equal(
+    #        output_gdf, output_gpd_gdf, promote_to_multi=True, sort_values=True,
+    #        normalize=True, check_less_precise=True, output_dir=tmp_path)
+    if suffix != ".shp":
+        # Shapefile needs at least one column, if no columns: fid
+        assert list(output_gdf.columns) == list(output_gpd_gdf.columns)
+    assert len(output_gdf) == len(output_gpd_gdf)
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_dissolve_emptyfile(tmp_path, suffix):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, empty=True)
+
+    # Test dissolve polygons with different options for groupby and explodecollections
+    output_path = tmp_path / f"{input_path.stem}_dissolve-emptyfile{suffix}"
+    groupby_columns = ["GEWASGROEP"]
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        explodecollections=True,
+        groupby_columns=groupby_columns,
+    )
+
+    # Now check if the tmp file is correctly created
+    assert output_path.exists()
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 0
+    assert output_layerinfo.geometrytype == input_layerinfo.geometrytype
+    assert list(output_layerinfo.columns) == groupby_columns
+
+
+@pytest.mark.parametrize("sql_singlethread", [True, False])
+@pytest.mark.parametrize(
+    "exp_match, invalid_params",
+    [
+        ("column in groupby_columns not", {"groupby_columns": "NON_EXISTING_COLUMN"}),
+        ("input_path doesn't exist: ", {"input_path": Path("nonexisting.abc")}),
+        (
+            "output_path must not equal input_path",
+            {
+                "input_path": test_helper.get_testfile("polygon-parcel"),
+                "output_path": test_helper.get_testfile("polygon-parcel"),
+            },
+        ),
+        (
+            "Dissolve to tiles is not supported for GeometryType.MULTILINESTRING, ",
+            {
+                "input_path": test_helper.get_testfile("linestring-watercourse"),
+                "nb_squarish_tiles": 2,
+            },
+        ),
+        (
+            "abc not available in: ",
+            {
+                "agg_columns": {
+                    "columns": [{"column": "abc", "agg": "count", "as": "cba"}]
+                }
+            },
+        ),
+    ],
+)
+def test_dissolve_invalid_params(tmp_path, sql_singlethread, invalid_params, exp_match):
+    """
+    Test dissolve with some invalid input params.
+
+    Remark: the structure of agg_columns parameter is tested in
+      test_parameter_helper.test_validate_agg_columns_invalid.
+    """
+    # Prepare test data / params
+    input_path = test_helper.get_testfile("polygon-parcel")
+    groupby_columns = ["GEWASGROEP"]
+    nb_squarish_tiles = 1
+    agg_columns = None
+    output_path = tmp_path / "output.gpkg"
+    for invalid_param in invalid_params:
+        if invalid_param == "input_path":
+            input_path = invalid_params[invalid_param]
+        elif invalid_param == "groupby_columns":
+            groupby_columns = invalid_params[invalid_param]
+        elif invalid_param == "nb_squarish_tiles":
+            nb_squarish_tiles = invalid_params[invalid_param]
+        elif invalid_param == "agg_columns":
+            agg_columns = invalid_params[invalid_param]
+        elif invalid_param == "output_path":
+            output_path = invalid_params[invalid_param]
+        else:
+            ValueError(f"unsupported invalid_param: {invalid_param}")
+
+    # Run test
+    with pytest.raises(ValueError, match=exp_match):
+        if sql_singlethread:
+            if nb_squarish_tiles > 1:
+                pytest.skip("nb_squarish_tiles not relevant for dissolve_singlethread")
+            from geofileops.util import _geoops_sql
+
+            _geoops_sql.dissolve_singlethread(
+                input_path=input_path,
+                output_path=output_path,
+                groupby_columns=groupby_columns,
+                explodecollections=True,
+                agg_columns=agg_columns,
+            )
+        else:
+            gfo.dissolve(
+                input_path=input_path,
+                output_path=output_path,
+                groupby_columns=groupby_columns,
+                explodecollections=True,
+                nb_squarish_tiles=nb_squarish_tiles,
+                agg_columns=agg_columns,
+            )
+
+
+def test_dissolve_polygons_groupby_None(tmp_path):
+    """
+    Test dissolve polygons with a column with None values. There was once an issue
+    that the type of the column with None Values always ended up as a REAL column after
+    the dissolve/group by instead of the original type.
+    """
+
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
+    gfo.add_column(input_path, name="none_values", type=gfo.DataType.TEXT)
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Run test
+    output_path = tmp_path / "output.gpkg"
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        groupby_columns="none_values",
+        explodecollections=True,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Now check if the tmp file is correctly created
+    assert output_path.exists()
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+    assert (
+        output_layerinfo.columns["none_values"].gdal_type
+        == input_layerinfo.columns["none_values"].gdal_type
+    )
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_dissolve_polygons_specialcases(tmp_path, suffix):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    output_basepath = tmp_path / f"{input_path.stem}-output{suffix}"
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Test dissolve polygons with specified output layer
+    # --------------------------------------------------
+    # A different output layer is not supported for shapefile!!!
+    output_path = (
+        output_basepath.parent
+        / f"{output_basepath.stem}_group_outputlayer{output_basepath.suffix}"
+    )
+    try:
+        gfo.dissolve(
+            input_path=input_path,
+            output_path=output_path,
+            groupby_columns=["GEWASGROEP"],
+            output_layer="banana",
+            explodecollections=True,
+            nb_parallel=2,
+            batchsize=batchsize,
+        )
+    except Exception:
+        # A different output_layer is not supported for shapefile, so normal
+        # that an exception is thrown!
+        assert output_path.suffix.lower() == ".shp"
+
+    # Now check if the tmp file is correctly created
+    if output_path.suffix.lower() != ".shp":
+        assert output_path.exists()
+        output_layerinfo = gfo.get_layerinfo(output_path)
+        assert output_layerinfo.featurecount == 25
+        assert len(output_layerinfo.columns) == 1
+        assert output_layerinfo.name == "banana"
+        assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+        # Now check the contents of the result file
+        input_gdf = gfo.read_file(input_path)
+        output_gdf = gfo.read_file(output_path)
+        assert input_gdf.crs == output_gdf.crs
+        assert len(output_gdf) == output_layerinfo.featurecount
+        assert output_gdf["geometry"][0] is not None
+
+    # Test dissolve polygons with tiles_path
+    # --------------------------------------
+    output_path = (
+        output_basepath.parent
+        / f"{output_basepath.stem}_tilespath{output_basepath.suffix}"
+    )
+    tiles_path = output_basepath.parent / "tiles.gpkg"
+    tiles_gdf = grid_util.create_grid2(
+        input_layerinfo.total_bounds, nb_squarish_tiles=4, crs=31370
+    )
+    gfo.to_file(tiles_gdf, tiles_path)
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        tiles_path=tiles_path,
+        explodecollections=False,
+        nb_parallel=2,
+        batchsize=batchsize,
+        force=True,
+    )
+
+    # Now check if the result file is correctly created
+    assert output_path.exists()
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 4
+    if output_basepath.suffix == ".shp":
+        # Shapefile always has an FID field
+        # but only if there is no other column???
+        # TODO: think about whether this should also be the case for geopackage???
+        assert len(output_layerinfo.columns) == 1
+    else:
+        assert len(output_layerinfo.columns) == 1
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Now check the contents of the result file
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert input_gdf.crs == output_gdf.crs
+    assert len(output_gdf) == output_layerinfo.featurecount
+    assert output_gdf["geometry"][0] is not None
+
+    # Test dissolve to existing output path without and without force
+    # ---------------------------------------------------------------
+    for force in [True, False]:
+        assert output_path.exists() is True
+        mtime_orig = output_path.stat().st_mtime
+        gfo.dissolve(
+            input_path=input_path,
+            output_path=output_path,
+            explodecollections=True,
+            nb_parallel=2,
+            batchsize=batchsize,
+            force=force,
+        )
+        if force is False:
+            assert output_path.stat().st_mtime == mtime_orig
+        else:
+            assert output_path.stat().st_mtime != mtime_orig
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_dissolve_polygons_aggcolumns_columns(tmp_path, suffix):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+    output_basepath = tmp_path / f"{input_path.stem}-output{suffix}"
+
+    # Test dissolve polygons with groupby + agg_columns to columns
+    output_path = (
+        output_basepath.parent
+        / f"{output_basepath.stem}_group_aggcolumns{output_basepath.suffix}"
+    )
+    # Remarks:
+    #     - column names are shortened so it also works for shapefile!
+    #     - the columns for agg_columns are choosen so they do not contain
+    #       unique values, to be a better test case!
+    agg_columns = {
+        "columns": [
+            {"column": "lblhfdtlt", "agg": "max", "as": "lbl_max"},
+            {"column": "GEWASGROEP", "agg": "count", "as": "gwsgrp_cnt"},
+            {"column": "lblhfdtlt", "agg": "count", "as": "lbl_count"},
+            {
+                "column": "lblhfdtlt",
+                "agg": "count",
+                "distinct": True,
+                "as": "lbl_cnt_d",
+            },
+            {"column": "lblhfdtlt", "agg": "concat", "as": "lbl_conc"},
+            {
+                "column": "lblhfdtlt",
+                "agg": "concat",
+                "sep": ";",
+                "as": "lbl_conc_s",
+            },
+            {
+                "column": "lblhfdtlt",
+                "agg": "concat",
+                "distinct": True,
+                "as": "lbl_conc_d",
+            },
+            {"column": "hfdtlt", "agg": "mean", "as": "tlt_mea"},
+            {"column": "hfdtlt", "agg": "min", "as": "tlt_min"},
+            {"column": "hfdtlt", "agg": "sum", "as": "tlt_sum"},
+            {"column": "fid", "agg": "concat", "as": "fid_concat"},
+        ]
+    }
+    groupby_columns = ["GEWASGROEP"]
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        groupby_columns=groupby_columns,
+        agg_columns=agg_columns,
+        explodecollections=False,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Now check if the tmp file is correctly created
+    assert output_path.exists()
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 6
+    assert len(output_layerinfo.columns) == (
+        len(groupby_columns) + len(agg_columns["columns"])
+    )
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Now check the contents of the result file
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert input_gdf.crs == output_gdf.crs
+    assert len(output_gdf) == output_layerinfo.featurecount
+    assert output_gdf["geometry"][0] is not None
+
+    # Check agg_columns results
+    grasland_idx = output_gdf[output_gdf["GEWASGROEP"] == "Grasland"].index.to_list()[0]
+    assert output_gdf["lbl_max"][grasland_idx] == "Grasland"
+    assert output_gdf["gwsgrp_cnt"][grasland_idx] == 30
+    assert output_gdf["lbl_count"][grasland_idx] == 30
+    print(f"output_gdf.lbl_concat_distinct: {output_gdf['lbl_conc_d'][grasland_idx]}")
+    assert output_gdf["lbl_cnt_d"][grasland_idx] == 1
+    assert output_gdf["lbl_conc"][grasland_idx].startswith("Grasland,Grasland,")
+    assert output_gdf["lbl_conc_s"][grasland_idx].startswith("Grasland;Grasland;")
+    assert output_gdf["lbl_conc_d"][grasland_idx] == "Grasland"
+    assert output_gdf["tlt_mea"][grasland_idx] == 60  # type: ignore
+    assert int(output_gdf["tlt_min"][grasland_idx]) == 60  # type: ignore
+    assert output_gdf["tlt_sum"][grasland_idx] == 1800  # type: ignore
+
+    groenten_idx = output_gdf[
+        output_gdf["GEWASGROEP"] == "Groenten, kruiden en sierplanten"
+    ].index.to_list()[0]
+    assert output_gdf["lbl_count"][groenten_idx] == 5
+    print(
+        "groenten.lblhfdtlt_concat_distinct: "
+        "f{output_gdf['lbl_conc_d'][groenten_idx]}"
+    )
+    assert output_gdf["lbl_cnt_d"][groenten_idx] == 4
+    if gfo.GeofileType(input_path).is_fid_zerobased:
+        assert output_gdf["fid_concat"][groenten_idx] == "41,42,43,44,45"
+    else:
+        assert output_gdf["fid_concat"][groenten_idx] == "42,43,44,45,46"
+
+
+@pytest.mark.parametrize(
+    "agg_columns", [{"json": ["lengte", "oppervl", "lblhfdtlt"]}, {"json": None}]
+)
+def test_dissolve_polygons_aggcolumns_json(tmp_path, agg_columns):
+    # In shapefiles, the length of str columns is very limited, so the json
+    # test would fail.
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel")
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+    output_basepath = tmp_path / f"{input_path.stem}-output.gpkg"
+
+    # Test dissolve polygons with groupby + agg_columns to json
+    output_path = (
+        output_basepath.parent
+        / f"{output_basepath.stem}_group_aggjson{output_basepath.suffix}"
+    )
+    gfo.dissolve(
+        input_path=input_path,
+        output_path=output_path,
+        groupby_columns=["GEWASGROEP"],
+        agg_columns=agg_columns,
+        explodecollections=False,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Now check if the tmp file is correctly created
+    assert output_path.exists()
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 6
+    assert len(output_layerinfo.columns) == 2
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Now check the contents of the result file
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert input_gdf.crs == output_gdf.crs
+    assert len(output_gdf) == output_layerinfo.featurecount
+    assert output_gdf["geometry"][0] is not None
+    grasland_json = json.loads(str(output_gdf["json"][0]))
+    assert len(grasland_json) == 30
+    grasland_json_firstrow = json.loads(str(grasland_json[0]))
+    if agg_columns["json"] is None:
+        # fid_orig column is added in json, but index column disappeared ???
+        assert len(grasland_json_firstrow) == len(input_layerinfo.columns)
+    else:
+        # fid_orig column is added in json
+        assert len(grasland_json_firstrow) == len(agg_columns["json"]) + 1
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg, testfile",
+    [
+        (".gpkg", 31370, "polygon-parcel"),
+        (".gpkg", 31370, "linestring-row-trees"),
+        (".gpkg", 4326, "polygon-parcel"),
+        (".shp", 31370, "polygon-parcel"),
+        (".shp", 4326, "polygon-parcel"),
+    ],
+)
+def test_simplify_vw(tmp_path, suffix, epsg, testfile):
+    # Skip test if simplification is not available
+    _ = pytest.importorskip("simplification")
+
+    # Init
+    input_path = test_helper.get_testfile(testfile, suffix=suffix, epsg=epsg)
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+    assert input_layerinfo.crs is not None
+    if input_layerinfo.crs.is_projected:
+        tolerance = 5
+    else:
+        # 1 degree = 111 km or 111000 m
+        tolerance = 5 / 111000
+
+    # Test vw (visvalingam-whyatt) algorithm
+    output_path = tmp_path / f"{input_path.stem}-output_vw{suffix}"
+    gfo.simplify(
+        input_path=input_path,
+        output_path=output_path,
+        tolerance=tolerance,
+        algorithm=geometry_util.SimplifyAlgorithm.VISVALINGAM_WHYATT,
+        batchsize=batchsize,
+    )
+
+    # Check if the file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert input_layerinfo.featurecount == output_layerinfo.featurecount
+    assert len(input_layerinfo.columns) == len(output_layerinfo.columns)
+    assert output_layerinfo.geometrytype == input_layerinfo.geometrytype
+
+    # Check the contents of the result file
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert input_gdf.crs == output_gdf.crs
+    assert len(output_gdf) == output_layerinfo.featurecount
+    assert output_gdf["geometry"][0] is not None
+    # TODO: a more in-depth check would be better
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg, testfile",
+    [
+        (".gpkg", 31370, "polygon-parcel"),
+        (".gpkg", 31370, "linestring-row-trees"),
+        (".gpkg", 4326, "polygon-parcel"),
+        (".shp", 31370, "polygon-parcel"),
+        (".shp", 4326, "polygon-parcel"),
+    ],
+)
+def test_simplify_lang(tmp_path, suffix, epsg, testfile):
+    input_path = test_helper.get_testfile(testfile, suffix=suffix, epsg=epsg)
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+    assert input_layerinfo.crs is not None
+    if input_layerinfo.crs.is_projected:
+        tolerance = 5
+    else:
+        # 1 degree = 111 km or 111000 m
+        tolerance = 5 / 111000
+    # Test lang algorithm
+    output_path = tmp_path / f"{input_path.stem}-output_lang{suffix}"
+    gfo.simplify(
+        input_path=input_path,
+        output_path=output_path,
+        tolerance=tolerance,
+        algorithm=geometry_util.SimplifyAlgorithm.LANG,
+        lookahead=8,
+        batchsize=batchsize,
+    )
+
+    # Check if the tmp file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert input_layerinfo.featurecount == output_layerinfo.featurecount
+    assert len(input_layerinfo.columns) == len(output_layerinfo.columns)
+    assert output_layerinfo.geometrytype == input_layerinfo.geometrytype
+
+    # Check the contents of the result file
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert input_gdf.crs == output_gdf.crs
+    assert len(output_gdf) == output_layerinfo.featurecount
+    assert output_gdf["geometry"][0] is not None
+    # TODO: some more in-depth validations would be better
```

### Comparing `geofileops-0.8.0a1/tests/test_geofileops_singlelayer_ogr.py` & `geofileops-0.8.0a2/tests/test_geofileops_singlelayer_ogr.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,111 +1,123 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for operations using GeoPandas.
-"""
-
-from pathlib import Path
-import sys
-
-import pytest
-
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
-import geofileops as gfo
-from geofileops import GeometryType
-from tests import test_helper
-from tests.test_helper import DEFAULT_SUFFIXES
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_clip_by_geometry(tmp_path, suffix):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-
-    # Do operation
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-    clip_wkt = (
-        "Polygon ((156072 196691, 156036 196836, 156326 196927, 156368 196750, "
-        "156072 196691))"
-    )
-    gfo.clip_by_geometry(
-        input_path=input_path, output_path=output_path, clip_geometry=clip_wkt
-    )
-
-    # Now check if the output file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    layerinfo_orig = gfo.get_layerinfo(input_path)
-    layerinfo_output = gfo.get_layerinfo(output_path)
-    assert layerinfo_output.featurecount == 22
-    assert len(layerinfo_orig.columns) == len(layerinfo_output.columns)
-    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Now check the contents of the result file
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_export_by_bounds(tmp_path, suffix):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-
-    # Do operation
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-    filter = (156036, 196691, 156368, 196927)
-    gfo.export_by_bounds(input_path=input_path, output_path=output_path, bounds=filter)
-
-    # Now check if the output file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    layerinfo_orig = gfo.get_layerinfo(input_path)
-    layerinfo_output = gfo.get_layerinfo(output_path)
-    assert layerinfo_output.featurecount == 25
-    assert len(layerinfo_orig.columns) == len(layerinfo_output.columns)
-    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Now check the contents of the result file
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-
-
-def test_warp(tmp_path):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel")
-    input_gdf = gfo.read_file(input_path)
-    input_bounds = input_gdf.total_bounds
-    warped_min = 0
-    warped_max = 10000
-    gcps = [
-        (input_bounds[0], input_bounds[1], warped_min, warped_min, None),
-        (input_bounds[0], input_bounds[3], warped_min, warped_max, None),
-        (input_bounds[2], input_bounds[3], warped_max, warped_max, None),
-        (input_bounds[2], input_bounds[1], warped_max, warped_min, None),
-    ]
-
-    # Do operation
-    output_path = tmp_path / f"{input_path.stem}-output.gpkg"
-    gfo.warp(
-        input_path=input_path,
-        output_path=output_path,
-        gcps=gcps,
-        algorithm="tps",
-    )
-
-    # Now check if the output file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    layerinfo_orig = gfo.get_layerinfo(input_path)
-    layerinfo_output = gfo.get_layerinfo(output_path)
-    assert layerinfo_output.featurecount == layerinfo_orig.featurecount
-    assert len(layerinfo_orig.columns) == len(layerinfo_output.columns)
-    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Now check the contents of the result file
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-    output_bounds = output_gdf.total_bounds
-    assert output_bounds[0] >= warped_min
-    assert output_bounds[1] >= warped_min
-    assert output_bounds[2] <= warped_max
-    assert output_bounds[3] <= warped_max
+# -*- coding: utf-8 -*-
+"""
+Tests for operations using GeoPandas.
+"""
+
+from pathlib import Path
+import sys
+
+import pytest
+
+# Add path so the local geofileops packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
+import geofileops as gfo
+from geofileops import GeometryType
+from tests import test_helper
+from tests.test_helper import DEFAULT_SUFFIXES
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_clip_by_geometry(tmp_path, suffix):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # Do operation
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    clip_wkt = (
+        "Polygon ((156072 196691, 156036 196836, 156326 196927, 156368 196750, "
+        "156072 196691))"
+    )
+    gfo.clip_by_geometry(
+        input_path=input_path, output_path=output_path, clip_geometry=clip_wkt
+    )
+
+    # Now check if the output file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    layerinfo_orig = gfo.get_layerinfo(input_path)
+    layerinfo_output = gfo.get_layerinfo(output_path)
+    assert layerinfo_output.featurecount == 22
+    assert len(layerinfo_orig.columns) == len(layerinfo_output.columns)
+    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Now check the contents of the result file
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_export_by_bounds(tmp_path, suffix):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # Do operation
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    filter = (156036, 196691, 156368, 196927)
+    gfo.export_by_bounds(input_path=input_path, output_path=output_path, bounds=filter)
+
+    # Now check if the output file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    layerinfo_orig = gfo.get_layerinfo(input_path)
+    layerinfo_output = gfo.get_layerinfo(output_path)
+    assert layerinfo_output.featurecount == 25
+    assert len(layerinfo_orig.columns) == len(layerinfo_output.columns)
+    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Now check the contents of the result file
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+
+
+def test_warp(tmp_path):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel")
+    input_gdf = gfo.read_file(input_path)
+    input_bounds = input_gdf.total_bounds
+    warped_min = 0
+    warped_max = 10000
+    gcps = [
+        (input_bounds[0], input_bounds[1], warped_min, warped_min, None),
+        (input_bounds[0], input_bounds[3], warped_min, warped_max, None),
+        (input_bounds[2], input_bounds[3], warped_max, warped_max, None),
+        (input_bounds[2], input_bounds[1], warped_max, warped_min, None),
+    ]
+
+    # Test first with existing output path and force=False
+    output_path = tmp_path / f"{input_path.stem}-output.gpkg"
+    output_path.touch()
+    gfo.warp(
+        input_path=input_path,
+        output_path=output_path,
+        gcps=gcps,
+        algorithm="tps",
+    )
+    assert output_path.exists()
+    assert output_path.stat().st_size == 0
+
+    # Test force=True
+    gfo.warp(
+        input_path=input_path,
+        output_path=output_path,
+        gcps=gcps,
+        algorithm="tps",
+        force=True,
+    )
+
+    # Now check if the output file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    layerinfo_orig = gfo.get_layerinfo(input_path)
+    layerinfo_output = gfo.get_layerinfo(output_path)
+    assert layerinfo_output.featurecount == layerinfo_orig.featurecount
+    assert len(layerinfo_orig.columns) == len(layerinfo_output.columns)
+    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Now check the contents of the result file
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+    output_bounds = output_gdf.total_bounds
+    assert output_bounds[0] >= warped_min
+    assert output_bounds[1] >= warped_min
+    assert output_bounds[2] <= warped_max
+    assert output_bounds[3] <= warped_max
```

### Comparing `geofileops-0.8.0a1/tests/test_geofileops_singlelayer_sql.py` & `geofileops-0.8.0a2/tests/test_geofileops_singlelayer_sql.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,321 +1,430 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for operations that are executed using a sql statement on one layer.
-"""
-
-import math
-from pathlib import Path
-import sys
-
-import geopandas as gpd
-import pytest
-
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
-import geofileops as gfo
-from geofileops import GeometryType
-from tests import test_helper
-from tests.test_helper import DEFAULT_EPSGS, DEFAULT_SUFFIXES
-
-
-def test_delete_duplicate_geometries(tmp_path):
-    # Prepare test data
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            test_helper.TestData.polygon_with_island,
-            test_helper.TestData.polygon_with_island,
-            test_helper.TestData.polygon_no_islands,
-            test_helper.TestData.polygon_no_islands,
-            test_helper.TestData.polygon_with_island2,
-        ],
-        crs=test_helper.TestData.crs_epsg,  # type: ignore
-    )
-    suffix = ".gpkg"
-    input_path = tmp_path / f"input_test_data{suffix}"
-    gfo.to_file(test_gdf, input_path)
-    input_info = gfo.get_layerinfo(input_path)
-
-    # Run test
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-    print(f"Run test for suffix {suffix}")
-    # delete_duplicate_geometries isn't multiprocess, so no batchsize needed
-    gfo.delete_duplicate_geometries(input_path=input_path, output_path=output_path)
-
-    # Check result, 2 duplicates should be removed
-    result_info = gfo.get_layerinfo(output_path)
-    assert result_info.featurecount == input_info.featurecount - 2
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("epsg", DEFAULT_EPSGS)
-def test_isvalid(tmp_path, suffix, epsg):
-    # Prepare test data
-    input_path = test_helper.get_testfile(
-        "polygon-invalid", dst_dir=tmp_path, suffix=suffix, epsg=epsg
-    )
-
-    # Now run test
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-    gfo.isvalid(input_path=input_path, output_path=output_path, batchsize=batchsize)
-
-    # Now check if the tmp file is correctly created
-    assert output_path.exists() is True
-    result_layerinfo = gfo.get_layerinfo(output_path)
-    assert input_layerinfo.featurecount == result_layerinfo.featurecount
-    assert len(input_layerinfo.columns) == len(result_layerinfo.columns) - 2
-
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-    assert output_gdf["isvalid"][0] == 0
-
-    # Do operation, without specifying output path
-    gfo.isvalid(
-        input_path=input_path, batchsize=batchsize, validate_attribute_data=True
-    )
-
-    # Now check if the tmp file is correctly created
-    output_auto_path = (
-        output_path.parent / f"{input_path.stem}_isvalid{output_path.suffix}"
-    )
-    assert output_auto_path.exists()
-    result_auto_layerinfo = gfo.get_layerinfo(output_auto_path)
-    assert input_layerinfo.featurecount == result_auto_layerinfo.featurecount
-    assert len(input_layerinfo.columns) == len(result_auto_layerinfo.columns) - 2
-
-    output_auto_gdf = gfo.read_file(output_auto_path)
-    assert output_auto_gdf["geometry"][0] is not None
-    assert output_auto_gdf["isvalid"][0] == 0
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("input_empty", [True, False])
-def test_makevalid(tmp_path, suffix, input_empty):
-    # Prepare test data
-    input_path = test_helper.get_testfile(
-        "polygon-invalid", suffix=suffix, empty=input_empty
-    )
-
-    # If the input file is not empty, it should have invalid geoms
-    if not input_empty:
-        input_isvalid_path = tmp_path / f"{input_path.stem}_is-valid{suffix}"
-        isvalid = gfo.isvalid(input_path=input_path, output_path=input_isvalid_path)
-        assert isvalid is False, "Input file should contain invalid features"
-
-    # Make sure the input file is not valid
-    if not input_empty:
-        output_isvalid_path = (
-            tmp_path / f"{input_path.stem}_is-valid{input_path.suffix}"
-        )
-        isvalid = gfo.isvalid(input_path=input_path, output_path=output_isvalid_path)
-        assert isvalid is False, "Input file should contain invalid features"
-
-    # Do operation
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-    gfo.makevalid(
-        input_path=input_path,
-        output_path=output_path,
-        nb_parallel=2,
-        force_output_geometrytype=gfo.GeometryType.MULTIPOLYGON,
-        validate_attribute_data=True,
-    )
-
-    # Now check if the output file is correctly created
-    assert output_path.exists()
-    layerinfo_orig = gfo.get_layerinfo(input_path)
-    layerinfo_output = gfo.get_layerinfo(output_path)
-    assert len(layerinfo_orig.columns) == len(layerinfo_output.columns)
-    assert layerinfo_output.geometrytype in [
-        GeometryType.POLYGON,
-        GeometryType.MULTIPOLYGON,
-    ]
-
-    if not input_empty:
-        assert layerinfo_orig.featurecount == layerinfo_output.featurecount
-
-    # Check if the result file is valid
-    output_new_isvalid_path = (
-        tmp_path / f"{output_path.stem}_new_is-valid{output_path.suffix}"
-    )
-    isvalid = gfo.isvalid(input_path=output_path, output_path=output_new_isvalid_path)
-    assert isvalid is True, "Output file shouldn't contain invalid features"
-
-    # Run makevalid with existing output file and force=False (=default)
-    gfo.makevalid(input_path=input_path, output_path=output_path)
-
-
-@pytest.mark.parametrize("input_suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("output_suffix", DEFAULT_SUFFIXES)
-def test_select(tmp_path, input_suffix, output_suffix):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", suffix=input_suffix)
-
-    # Now run test
-    output_path = (
-        tmp_path
-        / f"{input_path.stem}-{input_suffix.replace('.', '')}-output{output_suffix}"
-    )
-    layerinfo_input = gfo.get_layerinfo(input_path)
-    sql_stmt = 'SELECT {geometrycolumn}, oidn, uidn FROM "{input_layer}"'
-    gfo.select(input_path=input_path, output_path=output_path, sql_stmt=sql_stmt)
-
-    # Now check if the tmp file is correctly created
-    layerinfo_output = gfo.get_layerinfo(output_path)
-    assert layerinfo_input.featurecount == layerinfo_output.featurecount
-    assert "OIDN" in layerinfo_output.columns
-    assert "UIDN" in layerinfo_output.columns
-    assert len(layerinfo_output.columns) == 2
-    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Now check the contents of the result file
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_select_column_casing(tmp_path, suffix):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", tmp_path, suffix)
-
-    # Check if columns parameter works (case insensitive)
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-    columns = ["OIDN", "uidn", "HFDTLT", "lblhfdtlt", "GEWASGROEP", "lengte", "OPPERVL"]
-    layerinfo_input = gfo.get_layerinfo(input_path)
-    sql_stmt = '''SELECT {geometrycolumn}
-                        {columns_to_select_str}
-                    FROM "{input_layer}"'''
-    gfo.select(
-        input_path=input_path,
-        output_path=output_path,
-        columns=columns,
-        sql_stmt=sql_stmt,
-    )
-
-    # Now check if the tmp file is correctly created
-    layerinfo_select = gfo.get_layerinfo(output_path)
-    assert layerinfo_input.featurecount == layerinfo_select.featurecount
-    assert "OIDN" in layerinfo_select.columns
-    assert "uidn" in layerinfo_select.columns
-    assert len(layerinfo_select.columns) == len(columns)
-
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-
-
-@pytest.mark.parametrize("input_suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("output_suffix", DEFAULT_SUFFIXES)
-def test_select_emptyinput(tmp_path, input_suffix, output_suffix):
-    # Prepare test data
-    input_path = test_helper.get_testfile(
-        "polygon-parcel", suffix=input_suffix, dst_dir=tmp_path, empty=True
-    )
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    assert input_layerinfo.featurecount == 0
-
-    # Test with simple select
-    # -----------------------
-    output_stem = f"{input_path.stem}-{input_suffix.replace('.', '')}-simple"
-    output_path = tmp_path / f"{output_stem}{output_suffix}"
-    sql_stmt = 'SELECT {geometrycolumn}, oidn, uidn FROM "{input_layer}"'
-
-    gfo.select(input_path=input_path, output_path=output_path, sql_stmt=sql_stmt)
-
-    # Now check if the tmp file is correctly created
-    layerinfo_output = gfo.get_layerinfo(output_path)
-    assert layerinfo_output.featurecount == 0
-    assert "OIDN" in layerinfo_output.columns
-    assert "UIDN" in layerinfo_output.columns
-    assert len(layerinfo_output.columns) == 2
-    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
-
-
-@pytest.mark.parametrize(
-    "input_suffix, output_suffix",
-    [
-        (".gpkg", ".gpkg"),
-        # (".gpkg", ".shp"),
-        (".shp", ".gpkg"),
-        (".shp", ".shp"),
-    ],
-)
-def test_select_emptyinput_operation(tmp_path, input_suffix, output_suffix):
-    """
-    A select with a geometry operation (eg. buffer,...) on an empty input file should
-    result in an empty output file.
-    """
-    # Prepare test data
-    input_path = test_helper.get_testfile(
-        "polygon-parcel", suffix=input_suffix, dst_dir=tmp_path, empty=True
-    )
-
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    assert input_layerinfo.featurecount == 0
-
-    # Test with complex select: with geometry operation
-    # -------------------------------------------------
-    output_stem = f"{input_path.stem}-{input_suffix.replace('.', '')}-complex"
-    output_path = tmp_path / f"{output_stem}{output_suffix}"
-    sql_stmt = """
-        SELECT st_buffer({geometrycolumn}, 1, 5) as geom, oidn, uidn
-          FROM "{input_layer}"
-    """
-    gfo.select(input_path=input_path, output_path=output_path, sql_stmt=sql_stmt)
-
-    assert output_path.exists()
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 0
-
-
-@pytest.mark.parametrize("input_suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize("output_suffix", DEFAULT_SUFFIXES)
-def test_select_emptyresult(tmp_path, input_suffix, output_suffix):
-    # Prepare test data
-    input_path = test_helper.get_testfile("polygon-parcel", suffix=input_suffix)
-
-    # Now run test
-    output_stem = f"{input_path.stem}-{input_suffix.replace('.', '')}-output"
-    output_path = tmp_path / f"{output_stem}{output_suffix}"
-    sql_stmt = 'SELECT {geometrycolumn}, oidn, uidn FROM "{input_layer}" WHERE 1=0'
-
-    gfo.select(input_path=input_path, output_path=output_path, sql_stmt=sql_stmt)
-
-    # Now check if the tmp file is correctly created
-    layerinfo_output = gfo.get_layerinfo(output_path)
-    assert layerinfo_output.featurecount == 0
-    assert "OIDN" in layerinfo_output.columns
-    assert "UIDN" in layerinfo_output.columns
-    assert len(layerinfo_output.columns) == 2
-    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize(
-    "nb_parallel, has_batch_filter, exp_raise",
-    [(1, False, False), (2, True, False), (2, False, True)],
-)
-def test_select_batch_filter(
-    tmp_path, suffix, nb_parallel, has_batch_filter, exp_raise
-):
-    """
-    Test if batch_filter checks are OK.
-    """
-    input_path = test_helper.get_testfile("polygon-parcel", tmp_path, suffix)
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-    sql_stmt = """
-        SELECT {geometrycolumn}
-              {columns_to_select_str}
-          FROM "{input_layer}" layer
-         WHERE 1=1
-    """
-    if has_batch_filter:
-        sql_stmt += "{batch_filter}"
-
-    if exp_raise:
-        with pytest.raises(
-            ValueError,
-            match="Number batches > 1 requires a batch_filter placeholder in ",
-        ):
-            gfo.select(input_path, output_path, sql_stmt, nb_parallel=nb_parallel)
-    else:
-        gfo.select(input_path, output_path, sql_stmt, nb_parallel=nb_parallel)
+# -*- coding: utf-8 -*-
+"""
+Tests for operations that are executed using a sql statement on one layer.
+"""
+
+import math
+
+import geopandas as gpd
+import pytest
+from shapely.geometry import MultiPolygon, Polygon
+
+import geofileops as gfo
+from geofileops import GeometryType
+from geofileops.util import _geoops_sql
+from tests import test_helper
+from tests.test_helper import DEFAULT_EPSGS, DEFAULT_SUFFIXES
+from tests.test_helper import assert_geodataframe_equal
+
+
+def test_delete_duplicate_geometries(tmp_path):
+    # Prepare test data
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            test_helper.TestData.polygon_with_island,
+            test_helper.TestData.polygon_with_island,
+            test_helper.TestData.polygon_no_islands,
+            test_helper.TestData.polygon_no_islands,
+            test_helper.TestData.polygon_with_island2,
+        ],
+        crs=test_helper.TestData.crs_epsg,  # type: ignore
+    )
+    suffix = ".gpkg"
+    input_path = tmp_path / f"input_test_data{suffix}"
+    gfo.to_file(test_gdf, input_path)
+    input_info = gfo.get_layerinfo(input_path)
+
+    # Run test
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    print(f"Run test for suffix {suffix}")
+    # delete_duplicate_geometries isn't multiprocess, so no batchsize needed
+    gfo.delete_duplicate_geometries(input_path=input_path, output_path=output_path)
+
+    # Check result, 2 duplicates should be removed
+    result_info = gfo.get_layerinfo(output_path)
+    assert result_info.featurecount == input_info.featurecount - 2
+
+
+def test_dissolve_singlethread_output_exists(tmp_path):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel")
+    output_path = tmp_path / f"{input_path.stem}-output{input_path.suffix}"
+    output_path.touch()
+
+    # Run test without force
+    _geoops_sql.dissolve_singlethread(
+        input_path=input_path,
+        output_path=output_path,
+    )
+    assert output_path.exists()
+    assert output_path.stat().st_size == 0
+
+    # Run test with force
+    _geoops_sql.dissolve_singlethread(
+        input_path=input_path,
+        output_path=output_path,
+        force=True,
+    )
+    assert output_path.exists()
+    assert output_path.stat().st_size != 0
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("epsg", DEFAULT_EPSGS)
+def test_isvalid(tmp_path, suffix, epsg):
+    # Prepare test data
+    input_path = test_helper.get_testfile(
+        "polygon-invalid", dst_dir=tmp_path, suffix=suffix, epsg=epsg
+    )
+
+    # Now run test
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+    gfo.isvalid(input_path=input_path, output_path=output_path, batchsize=batchsize)
+
+    # Now check if the tmp file is correctly created
+    assert output_path.exists() is True
+    result_layerinfo = gfo.get_layerinfo(output_path)
+    assert input_layerinfo.featurecount == result_layerinfo.featurecount
+    assert len(input_layerinfo.columns) == len(result_layerinfo.columns) - 2
+
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+    assert output_gdf["isvalid"][0] == 0
+
+    # Do operation, without specifying output path
+    gfo.isvalid(
+        input_path=input_path, batchsize=batchsize, validate_attribute_data=True
+    )
+
+    # Now check if the tmp file is correctly created
+    output_auto_path = (
+        output_path.parent / f"{input_path.stem}_isvalid{output_path.suffix}"
+    )
+    assert output_auto_path.exists()
+    result_auto_layerinfo = gfo.get_layerinfo(output_auto_path)
+    assert input_layerinfo.featurecount == result_auto_layerinfo.featurecount
+    assert len(input_layerinfo.columns) == len(result_auto_layerinfo.columns) - 2
+
+    output_auto_gdf = gfo.read_file(output_auto_path)
+    assert output_auto_gdf["geometry"][0] is not None
+    assert output_auto_gdf["isvalid"][0] == 0
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("input_empty", [True, False])
+def test_makevalid(tmp_path, suffix, input_empty):
+    # Prepare test data
+    input_path = test_helper.get_testfile(
+        "polygon-invalid", suffix=suffix, empty=input_empty
+    )
+
+    # If the input file is not empty, it should have invalid geoms
+    if not input_empty:
+        input_isvalid_path = tmp_path / f"{input_path.stem}_is-valid{suffix}"
+        isvalid = gfo.isvalid(input_path=input_path, output_path=input_isvalid_path)
+        assert isvalid is False, "Input file should contain invalid features"
+
+    # Make sure the input file is not valid
+    if not input_empty:
+        output_isvalid_path = (
+            tmp_path / f"{input_path.stem}_is-valid{input_path.suffix}"
+        )
+        isvalid = gfo.isvalid(input_path=input_path, output_path=output_isvalid_path)
+        assert isvalid is False, "Input file should contain invalid features"
+
+    # Do operation
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    gfo.makevalid(
+        input_path=input_path,
+        output_path=output_path,
+        nb_parallel=2,
+        force_output_geometrytype=gfo.GeometryType.MULTIPOLYGON,
+        validate_attribute_data=True,
+    )
+
+    # Now check if the output file is correctly created
+    assert output_path.exists()
+    layerinfo_orig = gfo.get_layerinfo(input_path)
+    layerinfo_output = gfo.get_layerinfo(output_path)
+    assert len(layerinfo_orig.columns) == len(layerinfo_output.columns)
+    assert layerinfo_output.geometrytype in [
+        GeometryType.POLYGON,
+        GeometryType.MULTIPOLYGON,
+    ]
+
+    if not input_empty:
+        assert layerinfo_orig.featurecount == layerinfo_output.featurecount
+
+    # Check if the result file is valid
+    output_new_isvalid_path = (
+        tmp_path / f"{output_path.stem}_new_is-valid{output_path.suffix}"
+    )
+    isvalid = gfo.isvalid(input_path=output_path, output_path=output_new_isvalid_path)
+    assert isvalid is True, "Output file shouldn't contain invalid features"
+
+    # Run makevalid with existing output file and force=False (=default)
+    gfo.makevalid(input_path=input_path, output_path=output_path)
+
+
+@pytest.mark.parametrize(
+    "descr, geometry, expected_geometry",
+    [
+        ("sliver", Polygon([(0, 0), (10, 0), (10, 0.5), (0, 0)]), Polygon()),
+        (
+            "poly + sliver",
+            MultiPolygon(
+                [
+                    Polygon([(0, 5), (5, 5), (5, 10), (0, 10), (0, 5)]),
+                    Polygon([(0, 0), (10, 0), (10, 0.5), (0, 0)]),
+                ]
+            ),
+            Polygon([(0, 5), (5, 5), (5, 10), (0, 10), (0, 5)]),
+        ),
+    ],
+)
+def test_makevalid_gridsize(tmp_path, descr: str, geometry, expected_geometry):
+    # Prepare test data
+    # -----------------
+    input_gdf = gpd.GeoDataFrame(
+        {"descr": [descr]}, geometry=[geometry], crs=31370
+    )  # type: ignore
+    input_path = tmp_path / "test.gpkg"
+    gfo.to_file(input_gdf, input_path)
+    gridsize = 1
+
+    # Now we are ready to test
+    # ------------------------
+    result_path = tmp_path / "test_makevalid.gpkg"
+    gfo.makevalid(
+        input_path=input_path,
+        output_path=result_path,
+        gridsize=gridsize,
+        force=True,
+    )
+    result_gdf = gfo.read_file(result_path)
+
+    # Compare with expected result
+    expected_gdf = gpd.GeoDataFrame(
+        {"descr": [descr]}, geometry=[expected_geometry], crs=31370
+    )  # type: ignore
+    expected_gdf = expected_gdf[~expected_gdf.geometry.is_empty]
+    if len(expected_gdf) == 0:
+        assert len(result_gdf) == 0
+    else:
+        assert_geodataframe_equal(result_gdf, expected_gdf)
+
+
+def test_makevalid_invalidparams():
+    expected_error = (
+        "the precision parameter is deprecated and cannot be combined with gridsize"
+    )
+    with pytest.raises(ValueError, match=expected_error):
+        gfo.makevalid(
+            input_path="abc",
+            output_path="def",
+            gridsize=1,
+            precision=1,
+        )
+
+
+@pytest.mark.parametrize("input_suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("output_suffix", DEFAULT_SUFFIXES)
+def test_select(tmp_path, input_suffix, output_suffix):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", suffix=input_suffix)
+
+    # Now run test
+    output_path = (
+        tmp_path
+        / f"{input_path.stem}-{input_suffix.replace('.', '')}-output{output_suffix}"
+    )
+    layerinfo_input = gfo.get_layerinfo(input_path)
+    sql_stmt = 'SELECT {geometrycolumn}, oidn, uidn FROM "{input_layer}"'
+    gfo.select(input_path=input_path, output_path=output_path, sql_stmt=sql_stmt)
+
+    # Now check if the tmp file is correctly created
+    layerinfo_output = gfo.get_layerinfo(output_path)
+    assert layerinfo_input.featurecount == layerinfo_output.featurecount
+    assert "OIDN" in layerinfo_output.columns
+    assert "UIDN" in layerinfo_output.columns
+    assert len(layerinfo_output.columns) == 2
+    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Now check the contents of the result file
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_select_column_casing(tmp_path, suffix):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", tmp_path, suffix)
+
+    # Check if columns parameter works (case insensitive)
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    columns = ["OIDN", "uidn", "HFDTLT", "lblhfdtlt", "GEWASGROEP", "lengte", "OPPERVL"]
+    layerinfo_input = gfo.get_layerinfo(input_path)
+    sql_stmt = '''SELECT {geometrycolumn}
+                        {columns_to_select_str}
+                    FROM "{input_layer}"'''
+    gfo.select(
+        input_path=input_path,
+        output_path=output_path,
+        columns=columns,
+        sql_stmt=sql_stmt,
+    )
+
+    # Now check if the tmp file is correctly created
+    layerinfo_select = gfo.get_layerinfo(output_path)
+    assert layerinfo_input.featurecount == layerinfo_select.featurecount
+    assert "OIDN" in layerinfo_select.columns
+    assert "uidn" in layerinfo_select.columns
+    assert len(layerinfo_select.columns) == len(columns)
+
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+
+
+@pytest.mark.parametrize("input_suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("output_suffix", DEFAULT_SUFFIXES)
+def test_select_emptyinput(tmp_path, input_suffix, output_suffix):
+    # Prepare test data
+    input_path = test_helper.get_testfile(
+        "polygon-parcel", suffix=input_suffix, dst_dir=tmp_path, empty=True
+    )
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    assert input_layerinfo.featurecount == 0
+
+    # Test with simple select
+    # -----------------------
+    output_stem = f"{input_path.stem}-{input_suffix.replace('.', '')}-simple"
+    output_path = tmp_path / f"{output_stem}{output_suffix}"
+    sql_stmt = 'SELECT {geometrycolumn}, oidn, uidn FROM "{input_layer}"'
+
+    gfo.select(input_path=input_path, output_path=output_path, sql_stmt=sql_stmt)
+
+    # Now check if the tmp file is correctly created
+    layerinfo_output = gfo.get_layerinfo(output_path)
+    assert layerinfo_output.featurecount == 0
+    assert "OIDN" in layerinfo_output.columns
+    assert "UIDN" in layerinfo_output.columns
+    assert len(layerinfo_output.columns) == 2
+    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
+
+
+@pytest.mark.parametrize(
+    "input_suffix, output_suffix",
+    [
+        (".gpkg", ".gpkg"),
+        # (".gpkg", ".shp"),
+        (".shp", ".gpkg"),
+        (".shp", ".shp"),
+    ],
+)
+def test_select_emptyinput_operation(tmp_path, input_suffix, output_suffix):
+    """
+    A select with a geometry operation (eg. buffer,...) on an empty input file should
+    result in an empty output file.
+    """
+    # Prepare test data
+    input_path = test_helper.get_testfile(
+        "polygon-parcel", suffix=input_suffix, dst_dir=tmp_path, empty=True
+    )
+
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    assert input_layerinfo.featurecount == 0
+
+    # Test with complex select: with geometry operation
+    # -------------------------------------------------
+    output_stem = f"{input_path.stem}-{input_suffix.replace('.', '')}-complex"
+    output_path = tmp_path / f"{output_stem}{output_suffix}"
+    sql_stmt = """
+        SELECT st_buffer({geometrycolumn}, 1, 5) as geom, oidn, uidn
+          FROM "{input_layer}"
+    """
+    gfo.select(input_path=input_path, output_path=output_path, sql_stmt=sql_stmt)
+
+    assert output_path.exists()
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 0
+
+
+@pytest.mark.parametrize("input_suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize("output_suffix", DEFAULT_SUFFIXES)
+def test_select_emptyresult(tmp_path, input_suffix, output_suffix):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", suffix=input_suffix)
+
+    # Now run test
+    output_stem = f"{input_path.stem}-{input_suffix.replace('.', '')}-output"
+    output_path = tmp_path / f"{output_stem}{output_suffix}"
+    sql_stmt = 'SELECT {geometrycolumn}, oidn, uidn FROM "{input_layer}" WHERE 1=0'
+
+    gfo.select(input_path=input_path, output_path=output_path, sql_stmt=sql_stmt)
+
+    # Now check if the tmp file is correctly created
+    layerinfo_output = gfo.get_layerinfo(output_path)
+    assert layerinfo_output.featurecount == 0
+    assert "OIDN" in layerinfo_output.columns
+    assert "UIDN" in layerinfo_output.columns
+    assert len(layerinfo_output.columns) == 2
+    assert layerinfo_output.geometrytype == GeometryType.MULTIPOLYGON
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_select_invalid_sql(tmp_path, suffix):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+
+    # Now run test
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    sql_stmt = 'SELECT {geometrycolumn}, not_existing_column FROM "{input_layer}"'
+
+    with pytest.raises(Exception, match="Error <"):
+        gfo.select(input_path=input_path, output_path=output_path, sql_stmt=sql_stmt)
+
+
+def test_select_output_exists(tmp_path):
+    # Prepare test data
+    input_path = test_helper.get_testfile("polygon-parcel")
+    output_path = tmp_path / f"{input_path.stem}-output{input_path.suffix}"
+    output_path.touch()
+    sql_stmt = 'SELECT {geometrycolumn}, oidn, uidn FROM "{input_layer}"'
+
+    # Now run test
+    gfo.select(input_path=input_path, output_path=output_path, sql_stmt=sql_stmt)
+    assert output_path.stat().st_size == 0
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize(
+    "nb_parallel, has_batch_filter, exp_raise",
+    [(1, False, False), (2, True, False), (2, False, True)],
+)
+def test_select_batch_filter(
+    tmp_path, suffix, nb_parallel, has_batch_filter, exp_raise
+):
+    """
+    Test if batch_filter checks are OK.
+    """
+    input_path = test_helper.get_testfile("polygon-parcel", tmp_path, suffix)
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    sql_stmt = """
+        SELECT {geometrycolumn}
+              {columns_to_select_str}
+          FROM "{input_layer}" layer
+         WHERE 1=1
+    """
+    if has_batch_filter:
+        sql_stmt += "{batch_filter}"
+
+    if exp_raise:
+        with pytest.raises(
+            ValueError,
+            match="Number batches > 1 requires a batch_filter placeholder in ",
+        ):
+            gfo.select(input_path, output_path, sql_stmt, nb_parallel=nb_parallel)
+    else:
+        gfo.select(input_path, output_path, sql_stmt, nb_parallel=nb_parallel)
```

### Comparing `geofileops-0.8.0a1/tests/test_geofileops_twolayers.py` & `geofileops-0.8.0a2/tests/test_geofileops_twolayers.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,1011 +1,1042 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for operations that are executed using a sql statement on two layers.
-"""
-
-import math
-from pathlib import Path
-import sys
-
-import geopandas as gpd
-import pandas as pd
-import pytest
-
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
-import geofileops as gfo
-from geofileops import GeometryType, PrimitiveType
-from geofileops.util import _geoops_sql
-from tests import test_helper
-from tests.test_helper import DEFAULT_SUFFIXES, DEFAULT_TESTFILES
-from tests.test_helper import assert_geodataframe_equal
-
-
-@pytest.mark.parametrize("testfile", DEFAULT_TESTFILES)
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_clip(tmp_path, testfile, suffix):
-    input_path = test_helper.get_testfile(testfile, suffix=suffix)
-    clip_path = test_helper.get_testfile("polygon-zone", suffix=suffix)
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-    gfo.clip(
-        input_path=input_path,
-        clip_path=clip_path,
-        output_path=output_path,
-        batchsize=batchsize,
-    )
-
-    # Compare result with geopandas
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_gdf = gfo.read_file(output_path)
-    input_gdf = gfo.read_file(input_path)
-    clip_gdf = gfo.read_file(clip_path)
-    output_gpd_gdf = gpd.clip(input_gdf, clip_gdf, keep_geom_type=True)
-    assert_geodataframe_equal(
-        output_gdf, output_gpd_gdf, promote_to_multi=True, sort_values=True
-    )
-
-
-@pytest.mark.parametrize("testfile", DEFAULT_TESTFILES)
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_erase(tmp_path, testfile, suffix):
-    input_path = test_helper.get_testfile(testfile, suffix=suffix)
-    erase_path = test_helper.get_testfile("polygon-zone", suffix=suffix)
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
-
-    gfo.erase(
-        input_path=input_path,
-        erase_path=erase_path,
-        output_path=output_path,
-        batchsize=batchsize,
-    )
-
-    # Compare result with geopandas
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_gdf = gfo.read_file(output_path)
-    input_gdf = gfo.read_file(input_path)
-    erase_gdf = gfo.read_file(erase_path)
-    output_gpd_gdf = gpd.overlay(
-        input_gdf, erase_gdf, how="difference", keep_geom_type=True
-    )
-    assert_geodataframe_equal(
-        output_gdf,
-        output_gpd_gdf,
-        promote_to_multi=True,
-        sort_values=True,
-        check_less_precise=True,
-        normalize=True,
-    )
-
-
-def test_erase_explodecollections(tmp_path):
-    input_path = test_helper.get_testfile("polygon-parcel")
-    erase_path = test_helper.get_testfile("polygon-zone")
-    input_layerinfo = gfo.get_layerinfo(input_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    output_path = tmp_path / f"{input_path.stem}-output_exploded{input_path.suffix}"
-    gfo.erase(
-        input_path=input_path,
-        erase_path=erase_path,
-        output_path=output_path,
-        explodecollections=True,
-        batchsize=batchsize,
-    )
-
-    # Compare result with geopandas
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_gdf = gfo.read_file(output_path)
-    input_gdf = gfo.read_file(input_path)
-    erase_gdf = gfo.read_file(erase_path)
-    output_gpd_gdf = gpd.overlay(
-        input_gdf, erase_gdf, how="difference", keep_geom_type=True
-    )
-    output_gpd_gdf = output_gpd_gdf.explode(ignore_index=True)  # type: ignore
-    assert_geodataframe_equal(
-        output_gdf,
-        output_gpd_gdf,
-        promote_to_multi=True,
-        sort_values=True,
-        check_less_precise=True,
-        normalize=True,
-    )
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_export_by_location(tmp_path, suffix):
-    input_to_select_from_path = test_helper.get_testfile(
-        "polygon-parcel", suffix=suffix
-    )
-    input_to_compare_with_path = test_helper.get_testfile("polygon-zone", suffix=suffix)
-    output_path = tmp_path / f"{input_to_select_from_path.stem}-output{suffix}"
-    input_layerinfo = gfo.get_layerinfo(input_to_select_from_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-
-    # Test
-    gfo.export_by_location(
-        input_to_select_from_path=input_to_select_from_path,
-        input_to_compare_with_path=input_to_compare_with_path,
-        output_path=output_path,
-        batchsize=batchsize,
-    )
-
-    # Check if the output file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 26
-    assert len(output_layerinfo.columns) == len(input_layerinfo.columns) + 1
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Check the contents of the result file
-    # TODO: this test should be more elaborate...
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-
-
-@pytest.mark.parametrize("testfile", ["polygon-parcel"])
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_export_by_distance(tmp_path, testfile, suffix):
-    input_to_select_from_path = test_helper.get_testfile(testfile, suffix=suffix)
-    input_to_compare_with_path = test_helper.get_testfile("polygon-zone", suffix=suffix)
-    input_layerinfo = gfo.get_layerinfo(input_to_select_from_path)
-    batchsize = math.ceil(input_layerinfo.featurecount / 2)
-    output_path = tmp_path / f"{input_to_select_from_path.stem}-output{suffix}"
-
-    # Test
-    gfo.export_by_distance(
-        input_to_select_from_path=input_to_select_from_path,
-        input_to_compare_with_path=input_to_compare_with_path,
-        max_distance=10,
-        output_path=output_path,
-        batchsize=batchsize,
-    )
-
-    # Check if the tmp file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_layerinfo = gfo.get_layerinfo(input_to_select_from_path)
-    assert input_layerinfo.featurecount == output_layerinfo.featurecount
-    assert len(input_layerinfo.columns) == len(output_layerinfo.columns)
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Check the contents of the result file
-    # TODO: this test should be more elaborate...
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-
-
-@pytest.mark.parametrize("testfile", ["polygon-parcel"])
-@pytest.mark.parametrize(
-    "suffix, epsg, nb_parallel",
-    [
-        (".gpkg", 31370, 1),
-        (".gpkg", 31370, 2),
-        (".gpkg", 4326, 2),
-        (".shp", 31370, 1),
-        (".shp", 31370, 2),
-    ],
-)
-def test_intersection(tmp_path, testfile, suffix, epsg, nb_parallel):
-    input1_path = test_helper.get_testfile(testfile, suffix=suffix, epsg=epsg)
-    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
-
-    # Now run test
-    output_path = (
-        tmp_path / f"{input1_path.stem}_intersection_{input2_path.stem}{suffix}"
-    )
-    batchsize = -1
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    if nb_parallel > 1:
-        batchsize = math.ceil(input1_layerinfo.featurecount / 2)
-    gfo.intersection(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-    )
-
-    # Check if the tmp file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    input2_layerinfo = gfo.get_layerinfo(input2_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 29
-    assert len(output_layerinfo.columns) == (
-        len(input1_layerinfo.columns) + len(input2_layerinfo.columns)
-    )
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Check the contents of the result file
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-
-    input1_gdf = gfo.read_file(input1_path)
-    input2_gdf = gfo.read_file(input2_path)
-    overlay_operation = "intersection"
-    output_gpd_gdf = input1_gdf.overlay(
-        input2_gdf, how=overlay_operation, keep_geom_type=True
-    )
-    renames = {
-        name_gpd: name_gfo
-        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gdf.columns)
-    }
-    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
-    assert_geodataframe_equal(
-        output_gdf, output_gpd_gdf, check_dtype=False, sort_values=True
-    )
-
-
-def test_intersection_input_no_index(tmp_path):
-    """
-    Test if intersection works if the input gpkg files don't have a spatial index.
-    """
-    input1_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
-    input2_path = test_helper.get_testfile("polygon-zone", dst_dir=tmp_path)
-    gfo.remove_spatial_index(input1_path)
-    gfo.remove_spatial_index(input2_path)
-
-    # Now run test
-    output_path = tmp_path / f"{input1_path.stem}_intersection_{input2_path.stem}.gpkg"
-    gfo.intersection(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-    )
-
-    # Check if the tmp file is correctly created
-    assert output_path.exists()
-
-
-@pytest.mark.parametrize(
-    "expected_error, input1_path, input2_path, output_path",
-    [
-        (
-            "intersection: output_path must not equal one of input paths",
-            test_helper.get_testfile("polygon-parcel"),
-            test_helper.get_testfile("polygon-zone"),
-            test_helper.get_testfile("polygon-parcel"),
-        ),
-        (
-            "intersection: output_path must not equal one of input paths",
-            test_helper.get_testfile("polygon-parcel"),
-            test_helper.get_testfile("polygon-zone"),
-            test_helper.get_testfile("polygon-zone"),
-        ),
-        (
-            "input_path doesn't exist: ",
-            "not_existing_path",
-            test_helper.get_testfile("polygon-zone"),
-            "output.gpkg",
-        ),
-        (
-            "input_path doesn't exist: ",
-            test_helper.get_testfile("polygon-zone"),
-            "not_existing_path",
-            "output.gpkg",
-        ),
-    ],
-)
-def test_intersection_invalid_params(
-    tmp_path, input1_path, input2_path, output_path, expected_error
-):
-    """
-    Test if intersection works if the input gpkg files don't have a spatial index.
-    """
-    # Now run test
-    if isinstance(output_path, str):
-        output_path = tmp_path / output_path
-    with pytest.raises(ValueError, match=expected_error):
-        gfo.intersection(
-            input1_path=input1_path,
-            input2_path=input2_path,
-            output_path=output_path,
-        )
-
-
-def test_intersection_output_path_exists(tmp_path):
-    # Prepare test data
-    input1_path = test_helper.get_testfile("polygon-parcel")
-    input2_path = test_helper.get_testfile("polygon-parcel")
-
-    # Now run test
-    output_path = test_helper.get_testfile("polygon-zone")
-    assert output_path.exists()
-    gfo.intersection(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        force=False,
-    )
-
-    # The output file should still be there
-    assert output_path.exists()
-
-
-@pytest.mark.parametrize("suffix", [".gpkg", ".shp"])
-def test_intersection_resultempty(tmp_path, suffix):
-    # Prepare test data
-    # -----------------
-    input1_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
-    input2_path = test_helper.get_testfile(
-        "polygon-zone", suffix=suffix, dst_dir=tmp_path, empty=True
-    )
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
-    input2_layerinfo = gfo.get_layerinfo(input2_path)
-    assert input2_layerinfo.featurecount == 0
-
-    # Now run test
-    # ------------
-    output_path = (
-        tmp_path / f"{input1_path.stem}_intersection_{input2_path.stem}{suffix}"
-    )
-    gfo.intersection(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Check if the output file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 0
-    assert len(output_layerinfo.columns) == (
-        len(input1_layerinfo.columns) + len(input2_layerinfo.columns)
-    )
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-
-@pytest.mark.parametrize("testfile", ["polygon-parcel"])
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-def test_intersection_columns_fid(tmp_path, testfile, suffix):
-    input1_path = test_helper.get_testfile(testfile, suffix=suffix)
-    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix)
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
-
-    # Now run test
-    output_path = (
-        tmp_path / f"{input1_path.stem}_intersection_{input2_path.stem}{suffix}"
-    )
-    # Also check if fid casing is preserved in output
-    input1_columns = ["lblhfdtlt", "fid"]
-    input2_columns = ["naam", "FiD"]
-    gfo.intersection(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        input1_columns=input1_columns,
-        input2_columns=input2_columns,
-        nb_parallel=2,
-        batchsize=batchsize,
-    )
-
-    # Check if the tmp file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 29
-    assert len(output_layerinfo.columns) == len(input1_columns) + len(input2_columns)
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Check the contents of the result file
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-    assert "l1_fid" in output_gdf.columns
-    assert "l2_FiD" in output_gdf.columns
-    if gfo.GeofileType(input2_path).is_fid_zerobased:
-        assert sorted(output_gdf["l2_FiD"].unique().tolist()) == [0, 1, 2, 3, 4]
-    else:
-        assert sorted(output_gdf["l2_FiD"].unique().tolist()) == [1, 2, 3, 4, 5]
-
-
-def test_prepare_spatial_relations_filter():
-    # Test all existing named relations
-    named_relations = [
-        "equals",
-        "touches",
-        "within",
-        "overlaps",
-        "crosses",
-        "intersects",
-        "contains",
-        "covers",
-        "coveredby",
-    ]
-    for relation in named_relations:
-        query = f"{relation} is True"
-        filter = _geoops_sql._prepare_spatial_relations_filter(query)
-        assert filter is not None and filter != ""
-
-    # Test extra queries that should work
-    ok_queries = [
-        "intersects is False",
-        "(intersects is False and within is True) and crosses is False"
-        "(((T******** is False)))",
-    ]
-    for query in ok_queries:
-        filter = _geoops_sql._prepare_spatial_relations_filter(query)
-        assert filter is not None and filter != ""
-
-    # Test queries that should fail
-    error_queries = [
-        ("Intersects is False", "named relations should be in lowercase"),
-        ("intersects Is False", "is should be in lowercase"),
-        ("intersects is false", "false should be False"),
-        ("intersects = false", "= should be is"),
-        ("(intersects is False", "not all brackets are closed"),
-        ("intersects is False)", "more closing brackets then opened ones"),
-        ("T**T**T* is False", "predicate should be 9 characters, not 8"),
-        ("T**T**T**T is False", "predicate should be 9 characters, not 10"),
-        ("A**T**T** is False", "A is not a valid character in a predicate"),
-        ("'T**T**T**' is False", "predicates should not be quoted"),
-        ("[T**T**T** is False ]", "square brackets are not supported"),
-    ]
-    for query, error_reason in error_queries:
-        try:
-            _ = _geoops_sql._prepare_spatial_relations_filter(query)
-            error = False
-        except Exception:
-            error = True
-        assert error is True, error_reason
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg, spatial_relations_query, discard_nonmatching, "
-    "min_area_intersect, expected_featurecount",
-    [
-        (".gpkg", 31370, "intersects is False", False, None, 46),
-        (".gpkg", 31370, "intersects is False", True, None, 0),
-        (".gpkg", 31370, "intersects is True", False, 1000, 48),
-        (".gpkg", 31370, "intersects is True", False, None, 49),
-        (".gpkg", 31370, "intersects is True", True, 1000, 25),
-        (".gpkg", 31370, "intersects is True", True, None, 29),
-        (".gpkg", 31370, "T******** is True or *T******* is True", True, None, 29),
-        (".gpkg", 4326, "intersects is True", False, None, 49),
-        (".shp", 31370, "intersects is True", False, None, 49),
-    ],
-)
-def test_join_by_location(
-    tmp_path,
-    suffix: str,
-    spatial_relations_query: str,
-    epsg: int,
-    discard_nonmatching: bool,
-    min_area_intersect: float,
-    expected_featurecount: int,
-):
-    input1_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
-    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
-    output_path = (
-        tmp_path
-        / f"{input1_path.stem}_{discard_nonmatching}_{min_area_intersect}{suffix}"
-    )
-    gfo.join_by_location(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        spatial_relations_query=spatial_relations_query,
-        discard_nonmatching=discard_nonmatching,
-        min_area_intersect=min_area_intersect,
-        batchsize=batchsize,
-        force=True,
-    )
-
-    # Check if the output file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    input2_layerinfo = gfo.get_layerinfo(input2_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == expected_featurecount
-    assert len(output_layerinfo.columns) == (
-        len(input1_layerinfo.columns) + len(input2_layerinfo.columns) + 1
-    )
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Check the contents of the result file
-    # TODO: this test should be more elaborate...
-    output_gdf = gfo.read_file(output_path)
-    assert len(output_gdf) == expected_featurecount
-    if expected_featurecount > 0:
-        assert output_gdf["geometry"][0] is not None
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4384), (".shp", 31370)]
-)
-def test_join_nearest(tmp_path, suffix, epsg):
-    # Prepare test data
-    input1_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
-    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
-
-    # Now run test
-    output_path = tmp_path / f"{input1_path.stem}-output{suffix}"
-    nb_nearest = 2
-    input1_columns = ["OIDN", "UIDN", "HFDTLT", "fid"]
-    gfo.join_nearest(
-        input1_path=input1_path,
-        input1_columns=input1_columns,
-        input2_path=input2_path,
-        output_path=output_path,
-        nb_nearest=nb_nearest,
-        batchsize=batchsize,
-        force=True,
-    )
-
-    # Check if the output file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    input2_layerinfo = gfo.get_layerinfo(input2_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == nb_nearest * input1_layerinfo.featurecount
-    assert len(output_layerinfo.columns) == (
-        len(input1_columns) + len(input2_layerinfo.columns) + 2
-    )
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Check the contents of the result file
-    # TODO: this test should be more elaborate...
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-    if gfo.GeofileType(input1_path).is_fid_zerobased:
-        assert output_gdf.l1_fid.min() == 0
-    else:
-        assert output_gdf.l1_fid.min() == 1
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
-)
-def test_select_two_layers(tmp_path, suffix, epsg):
-    # Prepare test data
-    input1_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
-    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
-    output_path = tmp_path / f"{input1_path.stem}-output{suffix}"
-
-    # Prepare query to execute. At the moment this is just the query for the
-    # intersection() operation.
-    input1_layer_info = gfo.get_layerinfo(input1_path)
-    input2_layer_info = gfo.get_layerinfo(input2_path)
-    primitivetype_to_extract = PrimitiveType(
-        min(
-            input1_layer_info.geometrytype.to_primitivetype.value,
-            input2_layer_info.geometrytype.to_primitivetype.value,
-        )
-    )
-    rtree_layer1 = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    rtree_layer2 = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_stmt = f"""
-        SELECT ST_CollectionExtract(
-                 ST_Intersection(
-                     layer1.{{input1_geometrycolumn}},
-                     layer2.{{input2_geometrycolumn}}),
-              {primitivetype_to_extract.value}) as geom
-              {{layer1_columns_prefix_alias_str}}
-              {{layer2_columns_prefix_alias_str}}
-              ,CASE
-                 WHEN layer2.naam = 'zone1' THEN 'in_zone1'
-                 ELSE 'niet_in_zone1'
-               END AS category
-          FROM {{input1_databasename}}."{{input1_layer}}" layer1
-          JOIN {{input1_databasename}}."{rtree_layer1}" layer1tree
-            ON layer1.fid = layer1tree.id
-          JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-          JOIN {{input2_databasename}}."{rtree_layer2}" layer2tree
-            ON layer2.fid = layer2tree.id
-         WHERE 1=1
-           {{batch_filter}}
-           AND layer1tree.minx <= layer2tree.maxx
-           AND layer1tree.maxx >= layer2tree.minx
-           AND layer1tree.miny <= layer2tree.maxy
-           AND layer1tree.maxy >= layer2tree.miny
-           AND ST_Intersects(
-                  layer1.{{input1_geometrycolumn}},
-                  layer2.{{input2_geometrycolumn}}) = 1
-           AND ST_Touches(
-                  layer1.{{input1_geometrycolumn}},
-                  layer2.{{input2_geometrycolumn}}) = 0
-    """
-    gfo.select_two_layers(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        sql_stmt=sql_stmt,
-    )
-
-    # Check if the tmp file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    input2_layerinfo = gfo.get_layerinfo(input2_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 29
-    assert len(output_layerinfo.columns) == (
-        len(input1_layerinfo.columns) + len(input2_layerinfo.columns) + 1
-    )
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Check the contents of the result file
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-
-
-@pytest.mark.parametrize(
-    "expected_error, input1_path, input2_path, output_path",
-    [
-        (
-            "select_two_layers: output_path must not equal one of input paths",
-            test_helper.get_testfile("polygon-parcel"),
-            test_helper.get_testfile("polygon-zone"),
-            test_helper.get_testfile("polygon-parcel"),
-        ),
-        (
-            "select_two_layers: output_path must not equal one of input paths",
-            test_helper.get_testfile("polygon-parcel"),
-            test_helper.get_testfile("polygon-zone"),
-            test_helper.get_testfile("polygon-zone"),
-        ),
-        (
-            "select_two_layers: input1_path doesn't exist: not_existing_path",
-            "not_existing_path",
-            test_helper.get_testfile("polygon-zone"),
-            "output.gpkg",
-        ),
-        (
-            "select_two_layers: input2_path doesn't exist: not_existing_path",
-            test_helper.get_testfile("polygon-zone"),
-            "not_existing_path",
-            "output.gpkg",
-        ),
-    ],
-)
-def test_select_two_layers_invalid_params(
-    tmp_path, input1_path, input2_path, output_path, expected_error
-):
-    """
-    select_two_layers doesn't get info on input layers up-front, so this is the best
-    function to test the lower level checks in _two_layer_vector_operation.
-    """
-    # Prepare query to execute. Doesn't really matter what as an error is normally raise
-    # raise before it gets executed.
-    sql_stmt = """
-        SELECT layer1.{input1_geometrycolumn}
-              {layer1_columns_prefix_alias_str}
-              {layer2_columns_prefix_alias_str}
-          FROM {input1_databasename}."{input1_layer}" layer1
-          LEFT OUTER JOIN {input2_databasename}."{input2_layer}" layer2
-            ON layer1.join_id = layer2.join_id
-         WHERE 1=1
-           AND ST_Area(layer1.{input1_geometrycolumn}) > 5
-    """
-    with pytest.raises(ValueError, match=expected_error):
-        gfo.select_two_layers(
-            input1_path=input1_path,
-            input2_path=input2_path,
-            output_path=output_path,
-            sql_stmt=sql_stmt,
-        )
-
-
-@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
-@pytest.mark.parametrize(
-    "nb_parallel, has_batch_filter, exp_raise",
-    [(1, False, False), (2, True, False), (2, False, True)],
-)
-def test_select_two_layers_batch_filter(
-    tmp_path, suffix, nb_parallel, has_batch_filter, exp_raise
-):
-    """
-    Test if batch_filter checks are OK.
-    """
-    input1_path = test_helper.get_testfile("polygon-parcel", tmp_path, suffix)
-    input2_path = input1_path
-    output_path = tmp_path / f"{input1_path.stem}-output{suffix}"
-    sql_stmt = """
-        SELECT layer1.{input1_geometrycolumn}
-              {layer1_columns_prefix_alias_str}
-              {layer2_columns_prefix_alias_str}
-          FROM "{input1_layer}" layer1
-          CROSS JOIN "{input2_layer}" layer2
-         WHERE 1=1
-    """
-    if has_batch_filter:
-        sql_stmt += "{batch_filter}"
-
-    if exp_raise:
-        with pytest.raises(
-            ValueError,
-            match="Number batches > 1 requires a batch_filter placeholder in ",
-        ):
-            gfo.select_two_layers(
-                input1_path, input2_path, output_path, sql_stmt, nb_parallel=nb_parallel
-            )
-    else:
-        gfo.select_two_layers(
-            input1_path, input2_path, output_path, sql_stmt, nb_parallel=nb_parallel
-        )
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
-)
-def test_split(tmp_path, suffix, epsg):
-    # Prepare test data
-    input1_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
-    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
-    output_path = tmp_path / f"{input1_path.stem}-output{suffix}"
-
-    # Test
-    gfo.split(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        batchsize=batchsize,
-    )
-
-    # Check if the tmp file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    input2_layerinfo = gfo.get_layerinfo(input2_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 66
-    assert (len(input1_layerinfo.columns) + len(input2_layerinfo.columns)) == len(
-        output_layerinfo.columns
-    )
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Check the contents of the result file
-    # TODO: this test should be more elaborate...
-    output_gfo_gdf = gfo.read_file(output_path)
-    assert output_gfo_gdf["geometry"][0] is not None
-    input1_gdf = gfo.read_file(input1_path)
-    input2_gdf = gfo.read_file(input2_path)
-    output_gpd_gdf = input1_gdf.overlay(input2_gdf, how="identity", keep_geom_type=True)
-    renames = {
-        name_gpd: name_gfo
-        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gfo_gdf.columns)
-    }
-    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
-    # OIDN is float vs int? -> check_column_type=False
-    assert_geodataframe_equal(
-        output_gfo_gdf,
-        output_gpd_gdf,
-        promote_to_multi=True,
-        sort_values=True,
-        check_less_precise=True,
-        normalize=True,
-        check_dtype=False,
-    )
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
-)
-def test_symmetric_difference(tmp_path, suffix, epsg):
-    input1_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
-    input2_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
-
-    # Test
-    output_path = tmp_path / f"{input1_path.stem}_symmdiff_{input2_path.stem}{suffix}"
-    gfo.symmetric_difference(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        batchsize=batchsize,
-    )
-
-    # Check if the tmp file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    output_gfo_gdf = gfo.read_file(output_path)
-    assert output_gfo_gdf["geometry"][0] is not None
-    input1_gdf = gfo.read_file(input1_path)
-    input2_gdf = gfo.read_file(input2_path)
-    output_gpd_gdf = input1_gdf.overlay(
-        input2_gdf, how="symmetric_difference", keep_geom_type=True
-    )
-    renames = {
-        name_gpd: name_gfo
-        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gfo_gdf.columns)
-    }
-    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
-    assert_geodataframe_equal(
-        output_gfo_gdf,
-        output_gpd_gdf,
-        promote_to_multi=True,
-        sort_values=True,
-        check_column_type=False,
-        check_dtype=False,
-        check_less_precise=True,
-        normalize=True,
-    )
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
-)
-def test_union(tmp_path, suffix, epsg):
-    # Prepare test files
-    input1_path = test_helper.get_testfile(
-        "polygon-parcel", dst_dir=tmp_path, suffix=suffix, epsg=epsg
-    )
-    input2_path = test_helper.get_testfile(
-        "polygon-zone", dst_dir=tmp_path, suffix=suffix, epsg=epsg
-    )
-    # Add null TEXT column to each file to make sure it stays TEXT type after union
-    gfo.add_column(input1_path, name="test1_null", type=gfo.DataType.TEXT)
-    gfo.add_column(input2_path, name="test2_null", type=gfo.DataType.TEXT)
-
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
-
-    # Test
-    output_path = tmp_path / f"{input1_path.stem}_union_{input2_path.stem}{suffix}"
-    gfo.union(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        batchsize=batchsize,
-    )
-
-    # Check if the tmp file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    input2_layerinfo = gfo.get_layerinfo(input2_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 71
-    assert (len(input1_layerinfo.columns) + len(input2_layerinfo.columns)) == len(
-        output_layerinfo.columns
-    )
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Check the contents of the result file
-    output_gfo_gdf = gfo.read_file(output_path)
-    assert output_gfo_gdf["geometry"][0] is not None
-    input1_gdf = gfo.read_file(input1_path)
-    input2_gdf = gfo.read_file(input2_path)
-    output_gpd_gdf = input1_gdf.overlay(input2_gdf, how="union", keep_geom_type=True)
-    renames = {
-        name_gpd: name_gfo
-        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gfo_gdf.columns)
-    }
-    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
-    output_gpd_gdf["l1_DATUM"] = pd.to_datetime(output_gpd_gdf["l1_DATUM"])
-    assert_geodataframe_equal(
-        output_gfo_gdf,
-        output_gpd_gdf,
-        promote_to_multi=True,
-        sort_values=True,
-        check_less_precise=True,
-        normalize=True,
-    )
-
-
-@pytest.mark.parametrize(
-    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
-)
-def test_union_circles(tmp_path, suffix, epsg):
-    # Prepare test data
-    input1_path = test_helper.get_testfile(
-        "polygon-overlappingcircles-one", suffix=suffix, epsg=epsg
-    )
-    input2_path = test_helper.get_testfile(
-        "polygon-overlappingcircles-two+three", suffix=suffix, epsg=epsg
-    )
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
-    output_path = tmp_path / f"{input1_path.stem}-output{suffix}"
-
-    # Also run some tests on basic data with circles
-    # Union the single circle towards the 2 circles
-    gfo.union(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        batchsize=batchsize,
-    )
-
-    # Check if the tmp file is correctly created
-    assert output_path.exists()
-    assert gfo.has_spatial_index(output_path)
-    input2_layerinfo = gfo.get_layerinfo(input2_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 5
-    assert (len(input1_layerinfo.columns) + len(input2_layerinfo.columns)) == len(
-        output_layerinfo.columns
-    )
-    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Check the contents of the result file
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-    input1_gdf = gfo.read_file(input1_path)
-    input2_gdf = gfo.read_file(input2_path)
-    output_gpd_gdf = input1_gdf.overlay(input2_gdf, how="union", keep_geom_type=True)
-    renames = {
-        name_gpd: name_gfo
-        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gdf.columns)
-    }
-    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
-    assert_geodataframe_equal(
-        output_gdf,
-        output_gpd_gdf,
-        promote_to_multi=True,
-        sort_values=True,
-        check_less_precise=True,
-        normalize=True,
-    )
-
-    # Union the two circles towards the single circle
-    # Prepare test data
-    input1_path = test_helper.get_testfile(
-        "polygon-overlappingcircles-two+three", suffix=suffix, epsg=epsg
-    )
-    input2_path = test_helper.get_testfile(
-        "polygon-overlappingcircles-one", suffix=suffix, epsg=epsg
-    )
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
-    output_path = tmp_path / f"{input1_path.stem}_union_{input2_path.stem}.gpkg"
-    gfo.union(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        batchsize=batchsize,
-    )
-
-    # Check if the tmp file is correctly created
-    assert output_path.exists()
-    input1_layerinfo = gfo.get_layerinfo(input1_path)
-    input2_layerinfo = gfo.get_layerinfo(input2_path)
-    output_layerinfo = gfo.get_layerinfo(output_path)
-    assert output_layerinfo.featurecount == 5
-    assert (len(input1_layerinfo.columns) + len(input2_layerinfo.columns)) == len(
-        output_layerinfo.columns
-    )
-
-    # Check geometry type
-    if output_path.suffix.lower() == ".shp":
-        # For shapefiles the type stays POLYGON anyway
-        assert output_layerinfo.geometrytype == GeometryType.POLYGON
-    elif output_path.suffix.lower() == ".gpkg":
-        assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
-
-    # Check the contents of the result file
-    output_gdf = gfo.read_file(output_path)
-    assert output_gdf["geometry"][0] is not None
-    input1_gdf = gfo.read_file(input1_path)
-    input2_gdf = gfo.read_file(input2_path)
-    output_gpd_gdf = input1_gdf.overlay(input2_gdf, how="union", keep_geom_type=True)
-    renames = {
-        name_gpd: name_gfo
-        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gdf.columns)
-    }
-    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
-    assert_geodataframe_equal(
-        output_gdf,
-        output_gpd_gdf,
-        promote_to_multi=True,
-        sort_values=True,
-        check_less_precise=True,
-        normalize=True,
-    )
+# -*- coding: utf-8 -*-
+"""
+Tests for operations that are executed using a sql statement on two layers.
+"""
+
+import math
+from pathlib import Path
+import sys
+
+import geopandas as gpd
+import pandas as pd
+import pytest
+
+# Add path so the local geofileops packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
+import geofileops as gfo
+from geofileops import GeometryType, PrimitiveType
+from geofileops.util import _geoops_sql
+from tests import test_helper
+from tests.test_helper import DEFAULT_SUFFIXES, DEFAULT_TESTFILES
+from tests.test_helper import assert_geodataframe_equal
+
+
+@pytest.mark.parametrize("testfile", DEFAULT_TESTFILES)
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_clip(tmp_path, testfile, suffix):
+    input_path = test_helper.get_testfile(testfile, suffix=suffix)
+    clip_path = test_helper.get_testfile("polygon-zone", suffix=suffix)
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+    gfo.clip(
+        input_path=input_path,
+        clip_path=clip_path,
+        output_path=output_path,
+        batchsize=batchsize,
+    )
+
+    # Compare result with geopandas
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_gdf = gfo.read_file(output_path)
+    input_gdf = gfo.read_file(input_path)
+    clip_gdf = gfo.read_file(clip_path)
+    output_gpd_gdf = gpd.clip(input_gdf, clip_gdf, keep_geom_type=True)
+    assert_geodataframe_equal(
+        output_gdf, output_gpd_gdf, promote_to_multi=True, sort_values=True
+    )
+
+
+@pytest.mark.parametrize("testfile", DEFAULT_TESTFILES)
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_erase(tmp_path, testfile, suffix):
+    input_path = test_helper.get_testfile(testfile, suffix=suffix)
+    erase_path = test_helper.get_testfile("polygon-zone", suffix=suffix)
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+    output_path = tmp_path / f"{input_path.stem}-output{suffix}"
+
+    gfo.erase(
+        input_path=input_path,
+        erase_path=erase_path,
+        output_path=output_path,
+        batchsize=batchsize,
+    )
+
+    # Compare result with geopandas
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_gdf = gfo.read_file(output_path)
+    input_gdf = gfo.read_file(input_path)
+    erase_gdf = gfo.read_file(erase_path)
+    output_gpd_gdf = gpd.overlay(
+        input_gdf, erase_gdf, how="difference", keep_geom_type=True
+    )
+    assert_geodataframe_equal(
+        output_gdf,
+        output_gpd_gdf,
+        promote_to_multi=True,
+        sort_values=True,
+        check_less_precise=True,
+        normalize=True,
+    )
+
+
+def test_erase_explodecollections(tmp_path):
+    input_path = test_helper.get_testfile("polygon-parcel")
+    erase_path = test_helper.get_testfile("polygon-zone")
+    input_layerinfo = gfo.get_layerinfo(input_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    output_path = tmp_path / f"{input_path.stem}-output_exploded{input_path.suffix}"
+    gfo.erase(
+        input_path=input_path,
+        erase_path=erase_path,
+        output_path=output_path,
+        explodecollections=True,
+        batchsize=batchsize,
+    )
+
+    # Compare result with geopandas
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_gdf = gfo.read_file(output_path)
+    input_gdf = gfo.read_file(input_path)
+    erase_gdf = gfo.read_file(erase_path)
+    output_gpd_gdf = gpd.overlay(
+        input_gdf, erase_gdf, how="difference", keep_geom_type=True
+    )
+    output_gpd_gdf = output_gpd_gdf.explode(ignore_index=True)  # type: ignore
+    assert_geodataframe_equal(
+        output_gdf,
+        output_gpd_gdf,
+        promote_to_multi=True,
+        sort_values=True,
+        check_less_precise=True,
+        normalize=True,
+    )
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_export_by_location(tmp_path, suffix):
+    input_to_select_from_path = test_helper.get_testfile(
+        "polygon-parcel", suffix=suffix
+    )
+    input_to_compare_with_path = test_helper.get_testfile("polygon-zone", suffix=suffix)
+    output_path = tmp_path / f"{input_to_select_from_path.stem}-output{suffix}"
+    input_layerinfo = gfo.get_layerinfo(input_to_select_from_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+
+    # Test
+    gfo.export_by_location(
+        input_to_select_from_path=input_to_select_from_path,
+        input_to_compare_with_path=input_to_compare_with_path,
+        output_path=output_path,
+        batchsize=batchsize,
+    )
+
+    # Check if the output file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 26
+    assert len(output_layerinfo.columns) == len(input_layerinfo.columns) + 1
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Check the contents of the result file
+    # TODO: this test should be more elaborate...
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+
+
+@pytest.mark.parametrize("testfile", ["polygon-parcel"])
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_export_by_distance(tmp_path, testfile, suffix):
+    input_to_select_from_path = test_helper.get_testfile(testfile, suffix=suffix)
+    input_to_compare_with_path = test_helper.get_testfile("polygon-zone", suffix=suffix)
+    input_layerinfo = gfo.get_layerinfo(input_to_select_from_path)
+    batchsize = math.ceil(input_layerinfo.featurecount / 2)
+    output_path = tmp_path / f"{input_to_select_from_path.stem}-output{suffix}"
+
+    # Test
+    gfo.export_by_distance(
+        input_to_select_from_path=input_to_select_from_path,
+        input_to_compare_with_path=input_to_compare_with_path,
+        max_distance=10,
+        output_path=output_path,
+        batchsize=batchsize,
+    )
+
+    # Check if the tmp file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_layerinfo = gfo.get_layerinfo(input_to_select_from_path)
+    assert input_layerinfo.featurecount == output_layerinfo.featurecount
+    assert len(input_layerinfo.columns) == len(output_layerinfo.columns)
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Check the contents of the result file
+    # TODO: this test should be more elaborate...
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+
+
+@pytest.mark.parametrize("testfile", ["polygon-parcel"])
+@pytest.mark.parametrize(
+    "suffix, epsg, nb_parallel",
+    [
+        (".gpkg", 31370, 1),
+        (".gpkg", 31370, 2),
+        (".gpkg", 4326, 2),
+        (".shp", 31370, 1),
+        (".shp", 31370, 2),
+    ],
+)
+def test_intersection(tmp_path, testfile, suffix, epsg, nb_parallel):
+    input1_path = test_helper.get_testfile(testfile, suffix=suffix, epsg=epsg)
+    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
+
+    # Now run test
+    output_path = (
+        tmp_path / f"{input1_path.stem}_intersection_{input2_path.stem}{suffix}"
+    )
+    batchsize = -1
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    if nb_parallel > 1:
+        batchsize = math.ceil(input1_layerinfo.featurecount / 2)
+    gfo.intersection(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+    )
+
+    # Check if the tmp file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    input2_layerinfo = gfo.get_layerinfo(input2_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 29
+    assert len(output_layerinfo.columns) == (
+        len(input1_layerinfo.columns) + len(input2_layerinfo.columns)
+    )
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Check the contents of the result file
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+
+    input1_gdf = gfo.read_file(input1_path)
+    input2_gdf = gfo.read_file(input2_path)
+    overlay_operation = "intersection"
+    output_gpd_gdf = input1_gdf.overlay(
+        input2_gdf, how=overlay_operation, keep_geom_type=True
+    )
+    renames = {
+        name_gpd: name_gfo
+        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gdf.columns)
+    }
+    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
+    assert_geodataframe_equal(
+        output_gdf, output_gpd_gdf, check_dtype=False, sort_values=True
+    )
+
+
+def test_intersection_input_no_index(tmp_path):
+    """
+    Test if intersection works if the input gpkg files don't have a spatial index.
+    """
+    input1_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
+    input2_path = test_helper.get_testfile("polygon-zone", dst_dir=tmp_path)
+    gfo.remove_spatial_index(input1_path)
+    gfo.remove_spatial_index(input2_path)
+
+    # Now run test
+    output_path = tmp_path / f"{input1_path.stem}_intersection_{input2_path.stem}.gpkg"
+    gfo.intersection(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+    )
+
+    # Check if the tmp file is correctly created
+    assert output_path.exists()
+
+
+@pytest.mark.parametrize(
+    "expected_error, input1_path, input2_path, output_path",
+    [
+        (
+            "intersection: output_path must not equal one of input paths",
+            test_helper.get_testfile("polygon-parcel"),
+            test_helper.get_testfile("polygon-zone"),
+            test_helper.get_testfile("polygon-parcel"),
+        ),
+        (
+            "intersection: output_path must not equal one of input paths",
+            test_helper.get_testfile("polygon-parcel"),
+            test_helper.get_testfile("polygon-zone"),
+            test_helper.get_testfile("polygon-zone"),
+        ),
+        (
+            "input_path doesn't exist: ",
+            "not_existing_path",
+            test_helper.get_testfile("polygon-zone"),
+            "output.gpkg",
+        ),
+        (
+            "input_path doesn't exist: ",
+            test_helper.get_testfile("polygon-zone"),
+            "not_existing_path",
+            "output.gpkg",
+        ),
+    ],
+)
+def test_intersection_invalid_params(
+    tmp_path, input1_path, input2_path, output_path, expected_error
+):
+    """
+    Test if intersection works if the input gpkg files don't have a spatial index.
+    """
+    # Now run test
+    if isinstance(output_path, str):
+        output_path = tmp_path / output_path
+    with pytest.raises(ValueError, match=expected_error):
+        gfo.intersection(
+            input1_path=input1_path,
+            input2_path=input2_path,
+            output_path=output_path,
+        )
+
+
+def test_intersection_output_path_exists(tmp_path):
+    # Prepare test data
+    input1_path = test_helper.get_testfile("polygon-parcel")
+    input2_path = test_helper.get_testfile("polygon-parcel")
+
+    # Now run test
+    output_path = test_helper.get_testfile("polygon-zone")
+    assert output_path.exists()
+    gfo.intersection(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        force=False,
+    )
+
+    # The output file should still be there
+    assert output_path.exists()
+
+
+@pytest.mark.parametrize("suffix", [".gpkg", ".shp"])
+def test_intersection_resultempty(tmp_path, suffix):
+    # Prepare test data
+    # -----------------
+    input1_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    input2_path = test_helper.get_testfile(
+        "polygon-zone", suffix=suffix, dst_dir=tmp_path, empty=True
+    )
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
+    input2_layerinfo = gfo.get_layerinfo(input2_path)
+    assert input2_layerinfo.featurecount == 0
+
+    # Now run test
+    # ------------
+    output_path = (
+        tmp_path / f"{input1_path.stem}_intersection_{input2_path.stem}{suffix}"
+    )
+    gfo.intersection(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Check if the output file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 0
+    assert len(output_layerinfo.columns) == (
+        len(input1_layerinfo.columns) + len(input2_layerinfo.columns)
+    )
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+
+@pytest.mark.parametrize("testfile", ["polygon-parcel"])
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_intersection_columns_fid(tmp_path, testfile, suffix):
+    input1_path = test_helper.get_testfile(testfile, suffix=suffix)
+    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix)
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
+
+    # Now run test
+    output_path = (
+        tmp_path / f"{input1_path.stem}_intersection_{input2_path.stem}{suffix}"
+    )
+    # Also check if fid casing is preserved in output
+    input1_columns = ["lblhfdtlt", "fid"]
+    input2_columns = ["naam", "FiD"]
+    gfo.intersection(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        input1_columns=input1_columns,
+        input2_columns=input2_columns,
+        nb_parallel=2,
+        batchsize=batchsize,
+    )
+
+    # Check if the tmp file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 29
+    assert len(output_layerinfo.columns) == len(input1_columns) + len(input2_columns)
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Check the contents of the result file
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+    assert "l1_fid" in output_gdf.columns
+    assert "l2_FiD" in output_gdf.columns
+    if gfo.GeofileType(input2_path).is_fid_zerobased:
+        assert sorted(output_gdf.l2_FiD.unique().tolist()) == [0, 1, 2, 3, 4]
+    else:
+        assert sorted(output_gdf.l2_FiD.unique().tolist()) == [1, 2, 3, 4, 5]
+
+
+def test_prepare_spatial_relations_filter():
+    # Test all existing named relations
+    named_relations = [
+        "equals",
+        "touches",
+        "within",
+        "overlaps",
+        "crosses",
+        "intersects",
+        "contains",
+        "covers",
+        "coveredby",
+    ]
+    for relation in named_relations:
+        query = f"{relation} is True"
+        filter = _geoops_sql._prepare_spatial_relations_filter(query)
+        assert filter is not None and filter != ""
+
+    # Test extra queries that should work
+    ok_queries = [
+        "intersects is False",
+        "(intersects is False and within is True) and crosses is False"
+        "(((T******** is False)))",
+    ]
+    for query in ok_queries:
+        filter = _geoops_sql._prepare_spatial_relations_filter(query)
+        assert filter is not None and filter != ""
+
+    # Test queries that should fail
+    error_queries = [
+        ("Intersects is False", "named relations should be in lowercase"),
+        ("intersects Is False", "is should be in lowercase"),
+        ("intersects is false", "false should be False"),
+        ("intersects = false", "= should be is"),
+        ("(intersects is False", "not all brackets are closed"),
+        ("intersects is False)", "more closing brackets then opened ones"),
+        ("T**T**T* is False", "predicate should be 9 characters, not 8"),
+        ("T**T**T**T is False", "predicate should be 9 characters, not 10"),
+        ("A**T**T** is False", "A is not a valid character in a predicate"),
+        ("'T**T**T**' is False", "predicates should not be quoted"),
+        ("[T**T**T** is False ]", "square brackets are not supported"),
+    ]
+    for query, error_reason in error_queries:
+        try:
+            _ = _geoops_sql._prepare_spatial_relations_filter(query)
+            error = False
+        except Exception:
+            error = True
+        assert error is True, error_reason
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg, spatial_relations_query, discard_nonmatching, "
+    "min_area_intersect, area_inters_column_name, expected_featurecount",
+    [
+        (".gpkg", 31370, "intersects is False", False, None, None, 46),
+        (".gpkg", 31370, "intersects is False", True, None, None, 0),
+        (".gpkg", 31370, "intersects is True", False, 1000, "area_test", 48),
+        (".gpkg", 31370, "intersects is True", False, None, None, 49),
+        (".gpkg", 31370, "intersects is True", True, 1000, None, 25),
+        (".gpkg", 31370, "intersects is True", True, None, None, 29),
+        (".gpkg", 4326, "T******** is True or *T******* is True", True, None, None, 29),
+        (".gpkg", 4326, "intersects is True", False, None, None, 49),
+        (".shp", 31370, "intersects is True", False, None, None, 49),
+    ],
+)
+def test_join_by_location(
+    tmp_path,
+    suffix: str,
+    spatial_relations_query: str,
+    epsg: int,
+    discard_nonmatching: bool,
+    min_area_intersect: float,
+    area_inters_column_name: str,
+    expected_featurecount: int,
+):
+    input1_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
+    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
+    name = f"{input1_path.stem}_{discard_nonmatching}_{min_area_intersect}{suffix}"
+    output_path = tmp_path / name
+
+    gfo.join_by_location(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        spatial_relations_query=spatial_relations_query,
+        discard_nonmatching=discard_nonmatching,
+        min_area_intersect=min_area_intersect,
+        area_inters_column_name=area_inters_column_name,
+        batchsize=batchsize,
+        force=True,
+    )
+
+    # Check if the output file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    input2_layerinfo = gfo.get_layerinfo(input2_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == expected_featurecount
+
+    exp_nb_columns = len(input1_layerinfo.columns) + len(input2_layerinfo.columns) + 1
+    if area_inters_column_name is not None:
+        assert area_inters_column_name in output_layerinfo.columns
+        exp_nb_columns += 1
+    assert len(output_layerinfo.columns) == exp_nb_columns
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Check the contents of the result file
+    # TODO: this test should be more elaborate...
+    output_gdf = gfo.read_file(output_path)
+    assert len(output_gdf) == expected_featurecount
+    if expected_featurecount > 0:
+        assert output_gdf["geometry"][0] is not None
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4384), (".shp", 31370)]
+)
+def test_join_nearest(tmp_path, suffix, epsg):
+    # Prepare test data
+    input1_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
+    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
+
+    # Now run test
+    output_path = tmp_path / f"{input1_path.stem}-output{suffix}"
+    nb_nearest = 2
+    input1_columns = ["OIDN", "UIDN", "HFDTLT", "fid"]
+    gfo.join_nearest(
+        input1_path=input1_path,
+        input1_columns=input1_columns,
+        input2_path=input2_path,
+        output_path=output_path,
+        nb_nearest=nb_nearest,
+        batchsize=batchsize,
+        force=True,
+    )
+
+    # Check if the output file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    input2_layerinfo = gfo.get_layerinfo(input2_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == nb_nearest * input1_layerinfo.featurecount
+    assert len(output_layerinfo.columns) == (
+        len(input1_columns) + len(input2_layerinfo.columns) + 2
+    )
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Check the contents of the result file
+    # TODO: this test should be more elaborate...
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+    if gfo.GeofileType(input1_path).is_fid_zerobased:
+        assert output_gdf.l1_fid.min() == 0
+    else:
+        assert output_gdf.l1_fid.min() == 1
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
+)
+def test_select_two_layers(tmp_path, suffix, epsg):
+    # Prepare test data
+    input1_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
+    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
+    output_path = tmp_path / f"{input1_path.stem}-output{suffix}"
+
+    # Prepare query to execute. At the moment this is just the query for the
+    # intersection() operation.
+    input1_layer_info = gfo.get_layerinfo(input1_path)
+    input2_layer_info = gfo.get_layerinfo(input2_path)
+    primitivetype_to_extract = PrimitiveType(
+        min(
+            input1_layer_info.geometrytype.to_primitivetype.value,
+            input2_layer_info.geometrytype.to_primitivetype.value,
+        )
+    )
+    rtree_layer1 = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    rtree_layer2 = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_stmt = f"""
+        SELECT ST_CollectionExtract(
+                 ST_Intersection(
+                     layer1.{{input1_geometrycolumn}},
+                     layer2.{{input2_geometrycolumn}}),
+              {primitivetype_to_extract.value}) as geom
+              {{layer1_columns_prefix_alias_str}}
+              {{layer2_columns_prefix_alias_str}}
+              ,CASE
+                 WHEN layer2.naam = 'zone1' THEN 'in_zone1'
+                 ELSE 'niet_in_zone1'
+               END AS category
+          FROM {{input1_databasename}}."{{input1_layer}}" layer1
+          JOIN {{input1_databasename}}."{rtree_layer1}" layer1tree
+            ON layer1.fid = layer1tree.id
+          JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+          JOIN {{input2_databasename}}."{rtree_layer2}" layer2tree
+            ON layer2.fid = layer2tree.id
+         WHERE 1=1
+           {{batch_filter}}
+           AND layer1tree.minx <= layer2tree.maxx
+           AND layer1tree.maxx >= layer2tree.minx
+           AND layer1tree.miny <= layer2tree.maxy
+           AND layer1tree.maxy >= layer2tree.miny
+           AND ST_Intersects(
+                  layer1.{{input1_geometrycolumn}},
+                  layer2.{{input2_geometrycolumn}}) = 1
+           AND ST_Touches(
+                  layer1.{{input1_geometrycolumn}},
+                  layer2.{{input2_geometrycolumn}}) = 0
+    """
+    gfo.select_two_layers(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        sql_stmt=sql_stmt,
+    )
+
+    # Check if the tmp file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    input2_layerinfo = gfo.get_layerinfo(input2_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 29
+    assert len(output_layerinfo.columns) == (
+        len(input1_layerinfo.columns) + len(input2_layerinfo.columns) + 1
+    )
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Check the contents of the result file
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+
+
+@pytest.mark.parametrize(
+    "expected_error, input1_path, input2_path, output_path",
+    [
+        (
+            "select_two_layers: output_path must not equal one of input paths",
+            test_helper.get_testfile("polygon-parcel"),
+            test_helper.get_testfile("polygon-zone"),
+            test_helper.get_testfile("polygon-parcel"),
+        ),
+        (
+            "select_two_layers: output_path must not equal one of input paths",
+            test_helper.get_testfile("polygon-parcel"),
+            test_helper.get_testfile("polygon-zone"),
+            test_helper.get_testfile("polygon-zone"),
+        ),
+        (
+            "select_two_layers: input1_path doesn't exist: not_existing_path",
+            "not_existing_path",
+            test_helper.get_testfile("polygon-zone"),
+            "output.gpkg",
+        ),
+        (
+            "select_two_layers: input2_path doesn't exist: not_existing_path",
+            test_helper.get_testfile("polygon-zone"),
+            "not_existing_path",
+            "output.gpkg",
+        ),
+    ],
+)
+def test_select_two_layers_invalid_params(
+    tmp_path, input1_path, input2_path, output_path, expected_error
+):
+    """
+    select_two_layers doesn't get info on input layers up-front, so this is the best
+    function to test the lower level checks in _two_layer_vector_operation.
+    """
+    # Prepare query to execute. Doesn't really matter what as an error is normally raise
+    # raise before it gets executed.
+    sql_stmt = """
+        SELECT layer1.{input1_geometrycolumn}
+              {layer1_columns_prefix_alias_str}
+              {layer2_columns_prefix_alias_str}
+          FROM {input1_databasename}."{input1_layer}" layer1
+          LEFT OUTER JOIN {input2_databasename}."{input2_layer}" layer2
+            ON layer1.join_id = layer2.join_id
+         WHERE 1=1
+           AND ST_Area(layer1.{input1_geometrycolumn}) > 5
+    """
+    with pytest.raises(ValueError, match=expected_error):
+        gfo.select_two_layers(
+            input1_path=input1_path,
+            input2_path=input2_path,
+            output_path=output_path,
+            sql_stmt=sql_stmt,
+        )
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+def test_select_two_layers_invalid_sql(tmp_path, suffix):
+    # Prepare test data
+    input1_path = test_helper.get_testfile("polygon-parcel", suffix=suffix)
+    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix)
+
+    # Now run test
+    output_path = tmp_path / f"output{suffix}"
+    sql_stmt = """
+        SELECT layer1.{input1_geometrycolumn}
+              {layer1_columns_prefix_alias_str}
+              {layer2_columns_prefix_alias_str}
+              layer1.invalid_column
+          FROM {input1_databasename}."{input1_layer}" layer1
+          CROSS JOIN {input2_databasename}."{input2_layer}" layer2
+         WHERE 1=1
+           AND ST_Area(layer1.{input1_geometrycolumn}) > 5
+    """
+    with pytest.raises(Exception, match='Error <Error near "layer1": syntax error'):
+        gfo.select_two_layers(
+            input1_path=input1_path,
+            input2_path=input2_path,
+            output_path=output_path,
+            sql_stmt=sql_stmt,
+        )
+
+
+@pytest.mark.parametrize("suffix", DEFAULT_SUFFIXES)
+@pytest.mark.parametrize(
+    "nb_parallel, has_batch_filter, exp_raise",
+    [(1, False, False), (2, True, False), (2, False, True)],
+)
+def test_select_two_layers_batch_filter(
+    tmp_path, suffix, nb_parallel, has_batch_filter, exp_raise
+):
+    """
+    Test if batch_filter checks are OK.
+    """
+    input1_path = test_helper.get_testfile("polygon-parcel", tmp_path, suffix)
+    input2_path = input1_path
+    output_path = tmp_path / f"{input1_path.stem}-output{suffix}"
+    sql_stmt = """
+        SELECT layer1.{input1_geometrycolumn}
+              {layer1_columns_prefix_alias_str}
+              {layer2_columns_prefix_alias_str}
+          FROM "{input1_layer}" layer1
+          CROSS JOIN "{input2_layer}" layer2
+         WHERE 1=1
+    """
+    if has_batch_filter:
+        sql_stmt += "{batch_filter}"
+
+    if exp_raise:
+        with pytest.raises(
+            ValueError,
+            match="Number batches > 1 requires a batch_filter placeholder in ",
+        ):
+            gfo.select_two_layers(
+                input1_path, input2_path, output_path, sql_stmt, nb_parallel=nb_parallel
+            )
+    else:
+        gfo.select_two_layers(
+            input1_path, input2_path, output_path, sql_stmt, nb_parallel=nb_parallel
+        )
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
+)
+def test_split(tmp_path, suffix, epsg):
+    # Prepare test data
+    input1_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
+    input2_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
+    output_path = tmp_path / f"{input1_path.stem}-output{suffix}"
+
+    # Test
+    gfo.split(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        batchsize=batchsize,
+    )
+
+    # Check if the tmp file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    input2_layerinfo = gfo.get_layerinfo(input2_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 66
+    assert (len(input1_layerinfo.columns) + len(input2_layerinfo.columns)) == len(
+        output_layerinfo.columns
+    )
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Check the contents of the result file
+    # TODO: this test should be more elaborate...
+    output_gfo_gdf = gfo.read_file(output_path)
+    assert output_gfo_gdf["geometry"][0] is not None
+    input1_gdf = gfo.read_file(input1_path)
+    input2_gdf = gfo.read_file(input2_path)
+    output_gpd_gdf = input1_gdf.overlay(input2_gdf, how="identity", keep_geom_type=True)
+    renames = {
+        name_gpd: name_gfo
+        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gfo_gdf.columns)
+    }
+    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
+    # OIDN is float vs int? -> check_column_type=False
+    assert_geodataframe_equal(
+        output_gfo_gdf,
+        output_gpd_gdf,
+        promote_to_multi=True,
+        sort_values=True,
+        check_less_precise=True,
+        normalize=True,
+        check_dtype=False,
+    )
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
+)
+def test_symmetric_difference(tmp_path, suffix, epsg):
+    input1_path = test_helper.get_testfile("polygon-zone", suffix=suffix, epsg=epsg)
+    input2_path = test_helper.get_testfile("polygon-parcel", suffix=suffix, epsg=epsg)
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
+
+    # Test
+    output_path = tmp_path / f"{input1_path.stem}_symmdiff_{input2_path.stem}{suffix}"
+    gfo.symmetric_difference(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        batchsize=batchsize,
+    )
+
+    # Check if the tmp file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    output_gfo_gdf = gfo.read_file(output_path)
+    assert output_gfo_gdf["geometry"][0] is not None
+    input1_gdf = gfo.read_file(input1_path)
+    input2_gdf = gfo.read_file(input2_path)
+    output_gpd_gdf = input1_gdf.overlay(
+        input2_gdf, how="symmetric_difference", keep_geom_type=True
+    )
+    renames = {
+        name_gpd: name_gfo
+        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gfo_gdf.columns)
+    }
+    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
+    assert_geodataframe_equal(
+        output_gfo_gdf,
+        output_gpd_gdf,
+        promote_to_multi=True,
+        sort_values=True,
+        check_column_type=False,
+        check_dtype=False,
+        check_less_precise=True,
+        normalize=True,
+    )
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
+)
+def test_union(tmp_path, suffix, epsg):
+    # Prepare test files
+    input1_path = test_helper.get_testfile(
+        "polygon-parcel", dst_dir=tmp_path, suffix=suffix, epsg=epsg
+    )
+    input2_path = test_helper.get_testfile(
+        "polygon-zone", dst_dir=tmp_path, suffix=suffix, epsg=epsg
+    )
+    # Add null TEXT column to each file to make sure it stays TEXT type after union
+    gfo.add_column(input1_path, name="test1_null", type=gfo.DataType.TEXT)
+    gfo.add_column(input2_path, name="test2_null", type=gfo.DataType.TEXT)
+
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
+
+    # Test
+    output_path = tmp_path / f"{input1_path.stem}_union_{input2_path.stem}{suffix}"
+    gfo.union(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        batchsize=batchsize,
+    )
+
+    # Check if the tmp file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    input2_layerinfo = gfo.get_layerinfo(input2_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 71
+    assert (len(input1_layerinfo.columns) + len(input2_layerinfo.columns)) == len(
+        output_layerinfo.columns
+    )
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Check the contents of the result file
+    output_gfo_gdf = gfo.read_file(output_path)
+    assert output_gfo_gdf["geometry"][0] is not None
+    input1_gdf = gfo.read_file(input1_path)
+    input2_gdf = gfo.read_file(input2_path)
+    output_gpd_gdf = input1_gdf.overlay(input2_gdf, how="union", keep_geom_type=True)
+    renames = {
+        name_gpd: name_gfo
+        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gfo_gdf.columns)
+    }
+    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
+    output_gpd_gdf["l1_DATUM"] = pd.to_datetime(output_gpd_gdf["l1_DATUM"])
+    assert_geodataframe_equal(
+        output_gfo_gdf,
+        output_gpd_gdf,
+        promote_to_multi=True,
+        sort_values=True,
+        check_less_precise=True,
+        normalize=True,
+    )
+
+
+@pytest.mark.parametrize(
+    "suffix, epsg", [(".gpkg", 31370), (".gpkg", 4326), (".shp", 31370)]
+)
+def test_union_circles(tmp_path, suffix, epsg):
+    # Prepare test data
+    input1_path = test_helper.get_testfile(
+        "polygon-overlappingcircles-one", suffix=suffix, epsg=epsg
+    )
+    input2_path = test_helper.get_testfile(
+        "polygon-overlappingcircles-two+three", suffix=suffix, epsg=epsg
+    )
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
+    output_path = tmp_path / f"{input1_path.stem}-output{suffix}"
+
+    # Also run some tests on basic data with circles
+    # Union the single circle towards the 2 circles
+    gfo.union(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        batchsize=batchsize,
+    )
+
+    # Check if the tmp file is correctly created
+    assert output_path.exists()
+    assert gfo.has_spatial_index(output_path)
+    input2_layerinfo = gfo.get_layerinfo(input2_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 5
+    assert (len(input1_layerinfo.columns) + len(input2_layerinfo.columns)) == len(
+        output_layerinfo.columns
+    )
+    assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Check the contents of the result file
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+    input1_gdf = gfo.read_file(input1_path)
+    input2_gdf = gfo.read_file(input2_path)
+    output_gpd_gdf = input1_gdf.overlay(input2_gdf, how="union", keep_geom_type=True)
+    renames = {
+        name_gpd: name_gfo
+        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gdf.columns)
+    }
+    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
+    assert_geodataframe_equal(
+        output_gdf,
+        output_gpd_gdf,
+        promote_to_multi=True,
+        sort_values=True,
+        check_less_precise=True,
+        normalize=True,
+    )
+
+    # Union the two circles towards the single circle
+    # Prepare test data
+    input1_path = test_helper.get_testfile(
+        "polygon-overlappingcircles-two+three", suffix=suffix, epsg=epsg
+    )
+    input2_path = test_helper.get_testfile(
+        "polygon-overlappingcircles-one", suffix=suffix, epsg=epsg
+    )
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    batchsize = math.ceil(input1_layerinfo.featurecount / 2)
+    output_path = tmp_path / f"{input1_path.stem}_union_{input2_path.stem}.gpkg"
+    gfo.union(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        batchsize=batchsize,
+    )
+
+    # Check if the tmp file is correctly created
+    assert output_path.exists()
+    input1_layerinfo = gfo.get_layerinfo(input1_path)
+    input2_layerinfo = gfo.get_layerinfo(input2_path)
+    output_layerinfo = gfo.get_layerinfo(output_path)
+    assert output_layerinfo.featurecount == 5
+    assert (len(input1_layerinfo.columns) + len(input2_layerinfo.columns)) == len(
+        output_layerinfo.columns
+    )
+
+    # Check geometry type
+    if output_path.suffix.lower() == ".shp":
+        # For shapefiles the type stays POLYGON anyway
+        assert output_layerinfo.geometrytype == GeometryType.POLYGON
+    elif output_path.suffix.lower() == ".gpkg":
+        assert output_layerinfo.geometrytype == GeometryType.MULTIPOLYGON
+
+    # Check the contents of the result file
+    output_gdf = gfo.read_file(output_path)
+    assert output_gdf["geometry"][0] is not None
+    input1_gdf = gfo.read_file(input1_path)
+    input2_gdf = gfo.read_file(input2_path)
+    output_gpd_gdf = input1_gdf.overlay(input2_gdf, how="union", keep_geom_type=True)
+    renames = {
+        name_gpd: name_gfo
+        for name_gpd, name_gfo in zip(output_gpd_gdf.columns, output_gdf.columns)
+    }
+    output_gpd_gdf = output_gpd_gdf.rename(columns=renames)
+    assert_geodataframe_equal(
+        output_gdf,
+        output_gpd_gdf,
+        promote_to_multi=True,
+        sort_values=True,
+        check_less_precise=True,
+        normalize=True,
+    )
```

### Comparing `geofileops-0.8.0a1/tests/test_geometry_util.py` & `geofileops-0.8.0a2/tests/test_geometry_util.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,682 +1,679 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for functionalities in vector_util, regarding geometry operations.
-"""
-
-from pathlib import Path
-import sys
-
-import geopandas as gpd
-import numpy as np
-import pytest
-import shapely.geometry as sh_geom
-
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
-import geofileops as gfo
-from geofileops import geometry_util
-from geofileops import GeometryType, PrimitiveType
-from geofileops.util import grid_util
-from tests import test_helper
-
-
-def test_geometrytype():
-    # Creating a GeometryType from None is invalid
-    with pytest.raises(ValueError, match="None is not a valid GeometryType"):
-        geometrytype = GeometryType(None)
-
-    # Create different types of Geometrytype
-    geometrytype = GeometryType(3)
-    assert geometrytype is GeometryType.POLYGON
-    geometrytype = GeometryType("PoLyGoN")
-    assert geometrytype is GeometryType.POLYGON
-    geometrytype = GeometryType(GeometryType.POLYGON)
-    assert geometrytype is GeometryType.POLYGON
-
-    # Test to_primitivetype
-    primitivetype = GeometryType.POLYGON.to_primitivetype
-    assert primitivetype is PrimitiveType.POLYGON
-    primitivetype = GeometryType.MULTIPOLYGON.to_primitivetype
-    assert primitivetype is PrimitiveType.POLYGON
-
-    # A geometry collection doesn't have a primitive type
-    with pytest.raises(
-        Exception, match="Geometrycollection doesn't have a primitive type"
-    ):
-        GeometryType.GEOMETRYCOLLECTION.to_primitivetype
-
-
-def test_primitivetype():
-    primitivetype = PrimitiveType(3)
-    assert primitivetype is PrimitiveType.POLYGON
-    primitivetype = PrimitiveType("PoLyGoN")
-    assert primitivetype is PrimitiveType.POLYGON
-    primitivetype = PrimitiveType(PrimitiveType.POLYGON)
-    assert primitivetype is PrimitiveType.POLYGON
-
-
-def test_makevalid():
-    # Test Point
-    point_valid = geometry_util.make_valid(test_helper.TestData.point)
-    assert isinstance(point_valid, sh_geom.Point)
-
-    # Test MultiPoint
-    multipoint_valid = geometry_util.make_valid(test_helper.TestData.multipoint)
-    assert isinstance(multipoint_valid, sh_geom.MultiPoint)
-
-    # Test LineString
-    linestring_valid = geometry_util.make_valid(test_helper.TestData.linestring)
-    assert isinstance(linestring_valid, sh_geom.LineString)
-
-    # Test MultiLineString
-    multilinestring_valid = geometry_util.make_valid(
-        test_helper.TestData.multilinestring
-    )
-    assert isinstance(multilinestring_valid, sh_geom.MultiLineString)
-
-    # Test Polygon, self-intersecting
-    polygon_invalid = sh_geom.Polygon(
-        shell=[(0, 0), (0, 10), (5, 10), (4, 11), (4, 9), (10, 10), (10, 0), (0, 0)],
-        holes=[[(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]],
-    )
-    poly_valid = geometry_util.make_valid(polygon_invalid)
-    assert isinstance(poly_valid, sh_geom.MultiPolygon)
-    assert len(poly_valid.geoms) == 2
-    assert len(poly_valid.geoms[0].interiors) == 1
-
-    # Test MultiPolygon
-    multipolygon_invalid = sh_geom.MultiPolygon(
-        [polygon_invalid, test_helper.TestData.polygon_no_islands]
-    )
-    multipoly_valid = geometry_util.make_valid(multipolygon_invalid)
-    assert isinstance(multipoly_valid, sh_geom.MultiPolygon)
-
-    # Test GeometryCollection (as combination of all previous ones)
-    geometrycollection_invalid = sh_geom.GeometryCollection(
-        [
-            test_helper.TestData.point,
-            test_helper.TestData.multipoint,
-            test_helper.TestData.linestring,
-            test_helper.TestData.multilinestring,
-            polygon_invalid,
-            multipolygon_invalid,
-        ]
-    )
-    geometrycollection_valid = geometry_util.make_valid(geometrycollection_invalid)
-    assert isinstance(geometrycollection_valid, sh_geom.GeometryCollection)
-
-
-def test_numberpoints():
-    # Test Point
-    numberpoints = geometry_util.numberpoints(test_helper.TestData.point)
-    numberpoints_geometrycollection = numberpoints
-    assert numberpoints == 1
-
-    # Test MultiPoint
-    numberpoints = geometry_util.numberpoints(test_helper.TestData.multipoint)
-    numberpoints_geometrycollection += numberpoints
-    assert numberpoints == 3
-
-    # Test LineString
-    numberpoints = geometry_util.numberpoints(test_helper.TestData.linestring)
-    numberpoints_geometrycollection += numberpoints
-    assert numberpoints == 3
-
-    # Test MultiLineString
-    numberpoints = geometry_util.numberpoints(test_helper.TestData.multilinestring)
-    numberpoints_geometrycollection += numberpoints
-    assert numberpoints == 6
-
-    # Test Polygon
-    numberpoints = geometry_util.numberpoints(test_helper.TestData.polygon_with_island)
-    numberpoints_geometrycollection += numberpoints
-    assert numberpoints == 11
-
-    # Test MultiPolygon
-    numberpoints = geometry_util.numberpoints(test_helper.TestData.multipolygon)
-    numberpoints_geometrycollection += numberpoints
-    assert numberpoints == 16
-
-    # Test GeometryCollection (as combination of all previous ones)
-    numberpoints = geometry_util.numberpoints(test_helper.TestData.geometrycollection)
-    assert numberpoints == numberpoints_geometrycollection
-
-
-def test_remove_inner_rings():
-    # Apply to single Polygon, with area tolerance smaller than holes
-    polygon_removerings_withholes = sh_geom.Polygon(
-        shell=[(0, 0), (0, 10), (1, 10), (10, 10), (10, 0), (0, 0)],
-        holes=[
-            [(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)],
-            [(5, 5), (5, 6), (7, 6), (7, 5), (5, 5)],
-        ],
-    )
-    poly_result = geometry_util.remove_inner_rings(
-        polygon_removerings_withholes, min_area_to_keep=1, crs=None
-    )
-    assert isinstance(poly_result, sh_geom.Polygon)
-    assert len(poly_result.interiors) == 2
-
-    # Apply to single Polygon, with area tolerance between
-    # smallest hole (= 2m²) and largest (= 4m²)
-    poly_result = geometry_util.remove_inner_rings(
-        polygon_removerings_withholes, min_area_to_keep=3, crs=None
-    )
-    assert isinstance(poly_result, sh_geom.Polygon)
-    assert len(poly_result.interiors) == 1
-
-    # Apply to single polygon and remove all holes
-    poly_result = geometry_util.remove_inner_rings(
-        polygon_removerings_withholes, min_area_to_keep=0, crs=None
-    )
-    assert isinstance(poly_result, sh_geom.Polygon)
-    assert len(poly_result.interiors) == 0
-    polygon_removerings_noholes = sh_geom.Polygon(
-        shell=[(100, 100), (100, 110), (110, 110), (110, 100), (100, 100)]
-    )
-    poly_result = geometry_util.remove_inner_rings(
-        polygon_removerings_noholes, min_area_to_keep=0, crs=None
-    )
-    assert isinstance(poly_result, sh_geom.Polygon)
-    assert len(poly_result.interiors) == 0
-
-    # Apply to MultiPolygon, with area tolerance between
-    # smallest hole (= 2m²) and largest (= 4m²)
-    multipoly_removerings = sh_geom.MultiPolygon(
-        [polygon_removerings_withholes, polygon_removerings_noholes]
-    )
-    poly_result = geometry_util.remove_inner_rings(
-        multipoly_removerings, min_area_to_keep=3, crs=None
-    )
-    assert isinstance(poly_result, sh_geom.MultiPolygon)
-    assert len(poly_result.geoms[0].interiors) == 1  # type: ignore
-
-
-def test_simplify_coords_lang():
-    # Test LineString, lookahead -1, via coordinates
-    linestring = sh_geom.LineString([(0, 0), (10, 10), (20, 20)])
-    coords_simplified = geometry_util.simplify_coords_lang(
-        coords=linestring.coords, tolerance=1, lookahead=-1
-    )
-    assert isinstance(coords_simplified, np.ndarray)
-    assert len(coords_simplified) < len(linestring.coords)
-    assert len(coords_simplified) == 2
-
-
-def test_simplify_coords_lang_list():
-    # Test LineString, lookahead -1, via coordinates
-    linestring = sh_geom.LineString([(0, 0), (10, 10), (20, 20)])
-    coords_simplified = geometry_util.simplify_coords_lang(
-        coords=list(linestring.coords), tolerance=1, lookahead=-1
-    )
-    assert isinstance(coords_simplified, list)
-    assert len(coords_simplified) < len(linestring.coords)
-    assert len(coords_simplified) == 2
-
-
-def test_simplify_ext_lang_basic():
-    # Test LineString, lookahead -1, via geometry
-    linestring = sh_geom.LineString([(0, 0), (10, 10), (20, 20)])
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=linestring,
-        algorithm=geometry_util.SimplifyAlgorithm.LANG,
-        tolerance=1,
-        lookahead=-1,
-    )
-    assert isinstance(geom_simplified, sh_geom.LineString)
-    assert len(geom_simplified.coords) < len(linestring.coords)
-    assert len(geom_simplified.coords) == 2
-
-    # Test Polygon lookahead -1
-    poly = sh_geom.Polygon(
-        shell=[(0, 0), (0, 10), (1, 10), (10, 10), (10, 0), (0, 0)],
-        holes=[[(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]],
-    )
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=poly,
-        algorithm=geometry_util.SimplifyAlgorithm.LANG,
-        tolerance=1,
-        lookahead=-1,
-    )
-    assert isinstance(geom_simplified, sh_geom.Polygon)
-    assert geom_simplified.exterior is not None
-    assert poly.exterior is not None
-    assert len(geom_simplified.exterior.coords) < len(poly.exterior.coords)
-    assert len(geom_simplified.exterior.coords) == 5
-
-    # Test Point simplification
-    point = sh_geom.Point((0, 0))
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=point, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
-    )
-    assert isinstance(geom_simplified, sh_geom.Point)
-    assert len(geom_simplified.coords) == 1
-
-    # Test MultiPoint simplification
-    multipoint = sh_geom.MultiPoint([(0, 0), (10, 10), (20, 20)])
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=multipoint, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
-    )
-    assert isinstance(geom_simplified, sh_geom.MultiPoint)
-    assert len(geom_simplified.geoms) == 3
-
-    # Test LineString simplification
-    linestring = sh_geom.LineString([(0, 0), (10, 10), (20, 20)])
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=linestring, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
-    )
-    assert isinstance(geom_simplified, sh_geom.LineString)
-    assert len(geom_simplified.coords) < len(linestring.coords)
-    assert len(geom_simplified.coords) == 2
-
-    # Test MultiLineString simplification
-    multilinestring = sh_geom.MultiLineString(
-        [list(linestring.coords), [(100, 100), (110, 110), (120, 120)]]
-    )
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=multilinestring,
-        algorithm=geometry_util.SimplifyAlgorithm.LANG,
-        tolerance=1,
-    )
-    assert isinstance(geom_simplified, sh_geom.MultiLineString)
-    assert len(geom_simplified.geoms) == 2
-    assert len(geom_simplified.geoms[0].coords) < len(
-        multilinestring.geoms[0].coords  # type: ignore
-    )
-    assert len(geom_simplified.geoms[0].coords) == 2
-
-    # Test Polygon simplification
-    poly = sh_geom.Polygon(
-        shell=[(0, 0), (0, 10), (1, 10), (10, 10), (10, 0), (0, 0)],
-        holes=[[(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]],
-    )
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=poly, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
-    )
-    assert isinstance(geom_simplified, sh_geom.Polygon)
-    assert geom_simplified.exterior is not None
-    assert poly.exterior is not None
-    assert len(geom_simplified.exterior.coords) < len(poly.exterior.coords)
-    assert len(geom_simplified.exterior.coords) == 5
-
-    # Test MultiPolygon simplification
-    poly2 = sh_geom.Polygon(
-        shell=[(100, 100), (100, 110), (110, 110), (110, 100), (100, 100)]
-    )
-    multipoly = sh_geom.MultiPolygon([poly, poly2])
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=multipoly, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
-    )
-    assert isinstance(geom_simplified, sh_geom.MultiPolygon)
-    assert len(geom_simplified.geoms) == 2
-    assert len(geom_simplified.geoms[0].exterior.coords) < len(poly.exterior.coords)
-    assert len(geom_simplified.geoms[0].exterior.coords) == 5
-
-    # Test GeometryCollection (as combination of all previous ones) simplification
-    geom = sh_geom.GeometryCollection(
-        [point, multipoint, linestring, multilinestring, poly, multipoly]
-    )
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=geom, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
-    )
-    assert isinstance(geom_simplified, sh_geom.GeometryCollection)
-    assert len(geom_simplified.geoms) == 6
-
-
-def test_simplify_ext_lang_preservetopology():
-    # Test Polygon lookahead -1
-    poly = sh_geom.Polygon(
-        shell=[(0, 0), (0, 10), (1, 10), (10, 10), (10, 0), (0, 0)],
-        holes=[[(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]],
-    )
-    # If preserve_topology True, the original polygon is returned...
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=poly,
-        algorithm=geometry_util.SimplifyAlgorithm.LANG,
-        tolerance=10,
-        preserve_topology=True,
-        lookahead=-1,
-    )
-    assert isinstance(geom_simplified, sh_geom.Polygon)
-    assert poly.equals(geom_simplified) is True
-
-    # If preserve_topology True, the original polygon is returned...
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=poly,
-        algorithm=geometry_util.SimplifyAlgorithm.LANG,
-        tolerance=10,
-        preserve_topology=False,
-        lookahead=-1,
-    )
-    assert geom_simplified is None
-
-
-def test_simplify_ext_invalid():
-    # Test Polygon simplification, with invalid exterior ring
-    poly = sh_geom.Polygon(
-        shell=[(0, 0), (0, 10), (5, 10), (3, 12), (3, 9), (10, 10), (10, 0), (0, 0)],
-        holes=[[(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]],
-    )
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=poly, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
-    )
-    assert isinstance(geom_simplified, sh_geom.MultiPolygon)
-    assert poly.exterior is not None
-    assert len(geom_simplified.geoms[0].exterior.coords) < len(poly.exterior.coords)
-    assert len(geom_simplified.geoms[0].exterior.coords) == 7
-    assert len(geom_simplified.geoms[0].interiors) == len(poly.interiors)
-
-    # Test Polygon simplification, with exterior ring that touches itself
-    # due to simplification and after make_valid results in multipolygon of
-    # 2 equally large parts (left and right part of M shape).
-    poly_m_touch = sh_geom.Polygon(
-        shell=[
-            (0, 0),
-            (0, 10),
-            (5, 5),
-            (10, 10),
-            (10, 0),
-            (8, 0),
-            (8, 5),
-            (5, 4),
-            (2, 5),
-            (2, 0),
-            (0, 0),
-        ]
-    )
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=poly_m_touch,
-        algorithm=geometry_util.SimplifyAlgorithm.LANG,
-        tolerance=1,
-    )
-    assert geom_simplified is not None
-    assert geom_simplified.is_valid
-    assert isinstance(geom_simplified, sh_geom.MultiPolygon)
-    assert len(geom_simplified.geoms) == 2
-    assert geometry_util.numberpoints(geom_simplified) < geometry_util.numberpoints(
-        poly
-    )
-
-    # Test Polygon simplification, with exterior ring that crosses itself
-    # due to simplification and after make_valid results in multipolygon of
-    # 3 parts (left, middle and right part of M shape).
-    poly_m_cross = sh_geom.Polygon(
-        shell=[
-            (0, 0),
-            (0, 10),
-            (5, 5),
-            (10, 10),
-            (10, 0),
-            (8, 0),
-            (8, 5.5),
-            (5, 4.5),
-            (2, 5.5),
-            (2, 0),
-            (0, 0),
-        ]
-    )
-    geom_simplified = geometry_util.simplify_ext(
-        geometry=poly_m_cross,
-        algorithm=geometry_util.SimplifyAlgorithm.LANG,
-        tolerance=1,
-    )
-    assert geom_simplified is not None
-    assert geom_simplified.is_valid
-    assert isinstance(geom_simplified, sh_geom.MultiPolygon)
-    assert len(geom_simplified.geoms) == 3
-
-
-def test_simplify_ext_keep_points_on_lang(tmp_path):
-    # First init some stuff
-    input_path = test_helper.get_testfile("polygon-simplify-onborder-testcase")
-    input_gdf = gfo.read_file(input_path)
-
-    # Create geometry where we want the points kept
-    grid_gdf = grid_util.create_grid(
-        total_bounds=(
-            210431.875 - 1000,
-            176640.125 - 1000,
-            210431.875 + 1000,
-            176640.125 + 1000,
-        ),
-        nb_columns=2,
-        nb_rows=2,
-        crs="epsg:31370",
-    )
-    gfo.to_file(grid_gdf, tmp_path / "grid.gpkg")
-    grid_coords = [tile.exterior.coords for tile in grid_gdf.geometry]
-    grid_lines_geom = sh_geom.MultiLineString(grid_coords)
-
-    # Test lang
-    # Without keep_points_on, the following point that is on the test data +
-    # on the grid is removed by lang
-    point_on_input_and_border = sh_geom.Point(210431.875, 176606.125)
-    tolerance_lang = 0.25
-    step_lang = 8
-
-    # Determine the number of intersects with the input test data
-    nb_intersects_with_input = len(
-        input_gdf[input_gdf.intersects(point_on_input_and_border)]
-    )
-    assert nb_intersects_with_input > 0
-    # Test if intersects > 0
-    assert len(input_gdf[grid_gdf.intersects(point_on_input_and_border)]) > 0
-
-    # Without keep_points_on the number of intersections changes
-    simplified_gdf = input_gdf.copy()
-    # assert to evade pyLance warning
-    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
-    simplified_gdf.geometry = input_gdf.geometry.apply(
-        lambda geom: geometry_util.simplify_ext(
-            geom,
-            algorithm=geometry_util.SimplifyAlgorithm.LANG,
-            tolerance=tolerance_lang,
-            lookahead=step_lang,
-        )
-    )
-    gfo.to_file(
-        simplified_gdf, tmp_path / f"simplified_lang;{tolerance_lang};{step_lang}.gpkg"
-    )
-    assert (
-        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
-        != nb_intersects_with_input
-    )
-
-    # With keep_points_on specified, the number of intersections stays the same
-    simplified_gdf = input_gdf.copy()
-    # assert to evade pyLance warning
-    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
-    simplified_gdf.geometry = input_gdf.geometry.apply(
-        lambda geom: geometry_util.simplify_ext(
-            geom,
-            algorithm=geometry_util.SimplifyAlgorithm.LANG,
-            tolerance=tolerance_lang,
-            lookahead=step_lang,
-            keep_points_on=grid_lines_geom,
-        )
-    )
-    output_path = (
-        tmp_path / f"simplified_lang;{tolerance_lang};{step_lang}_keep_points_on.gpkg"
-    )
-    gfo.to_file(simplified_gdf, output_path)
-    assert (
-        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
-        == nb_intersects_with_input
-    )
-
-
-def test_simplify_ext_keep_points_on_rdp(tmp_path):
-    # Skip test if simplification is not available
-    _ = pytest.importorskip("simplification")
-
-    # First init some stuff
-    input_path = test_helper.get_testfile("polygon-simplify-onborder-testcase")
-    input_gdf = gfo.read_file(input_path)
-
-    # Create geometry where we want the points kept
-    grid_gdf = grid_util.create_grid(
-        total_bounds=(
-            210431.875 - 1000,
-            176640.125 - 1000,
-            210431.875 + 1000,
-            176640.125 + 1000,
-        ),
-        nb_columns=2,
-        nb_rows=2,
-        crs="epsg:31370",
-    )
-    gfo.to_file(grid_gdf, tmp_path / "grid.gpkg")
-    grid_coords = [tile.exterior.coords for tile in grid_gdf.geometry]
-    grid_lines_geom = sh_geom.MultiLineString(grid_coords)
-
-    # Test rdp (ramer–douglas–peucker)
-    # Without keep_points_on, the following point that is on the test data +
-    # on the grid is removed by rdp
-    point_on_input_and_border = sh_geom.Point(210431.875, 176599.375)
-    tolerance_rdp = 0.5
-
-    # Determine the number of intersects with the input test data
-    nb_intersects_with_input = len(
-        input_gdf[input_gdf.intersects(point_on_input_and_border)]
-    )
-    assert nb_intersects_with_input > 0
-    # Test if intersects > 0
-    assert len(input_gdf[grid_gdf.intersects(point_on_input_and_border)]) > 0
-
-    # Without keep_points_on the number of intersections changes
-    simplified_gdf = input_gdf.copy()
-    # assert to evade pyLance warning
-    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
-    simplified_gdf.geometry = input_gdf.geometry.apply(
-        lambda geom: geometry_util.simplify_ext(
-            geom,
-            algorithm=geometry_util.SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
-            tolerance=tolerance_rdp,
-        )
-    )
-    gfo.to_file(simplified_gdf, tmp_path / f"simplified_rdp{tolerance_rdp}.gpkg")
-    assert (
-        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
-        != nb_intersects_with_input
-    )
-
-    # With keep_points_on specified, the number of intersections stays the same
-    simplified_gdf = input_gdf.copy()
-    # assert to evade pyLance warning
-    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
-    simplified_gdf.geometry = input_gdf.geometry.apply(
-        lambda geom: geometry_util.simplify_ext(
-            geom,
-            algorithm=geometry_util.SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
-            tolerance=tolerance_rdp,
-            keep_points_on=grid_lines_geom,
-        )
-    )
-    gfo.to_file(
-        simplified_gdf, tmp_path / f"simplified_rdp{tolerance_rdp}_keep_points_on.gpkg"
-    )
-    assert (
-        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
-        == nb_intersects_with_input
-    )
-
-
-def test_simplify_ext_keep_points_on_vw(tmp_path):
-    # Skip test if simplification is not available
-    _ = pytest.importorskip("simplification")
-
-    # First init some stuff
-    input_path = test_helper.get_testfile("polygon-simplify-onborder-testcase")
-    input_gdf = gfo.read_file(input_path)
-
-    # Create geometry where we want the points kept
-    grid_gdf = grid_util.create_grid(
-        total_bounds=(
-            210431.875 - 1000,
-            176640.125 - 1000,
-            210431.875 + 1000,
-            176640.125 + 1000,
-        ),
-        nb_columns=2,
-        nb_rows=2,
-        crs="epsg:31370",
-    )
-    gfo.to_file(grid_gdf, tmp_path / "grid.gpkg")
-    grid_coords = [tile.exterior.coords for tile in grid_gdf.geometry]
-    grid_lines_geom = sh_geom.MultiLineString(grid_coords)
-
-    # Test vw (visvalingam-whyatt)
-    # Without keep_points_on, the following point that is on the test data +
-    # on the grid is removed by vw
-    point_on_input_and_border = sh_geom.Point(210430.125, 176640.125)
-    tolerance_vw = 16 * 0.25 * 0.25  # 1m²
-
-    # Determine the number of intersects with the input test data
-    nb_intersects_with_input = len(
-        input_gdf[input_gdf.intersects(point_on_input_and_border)]
-    )
-    assert nb_intersects_with_input > 0
-    # Test if intersects > 0
-    assert len(input_gdf[grid_gdf.intersects(point_on_input_and_border)]) > 0
-
-    # Without keep_points_on the number of intersections changes
-    simplified_gdf = input_gdf.copy()
-    # assert to evade pyLance warning
-    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
-    simplified_gdf.geometry = input_gdf.geometry.apply(
-        lambda geom: geometry_util.simplify_ext(
-            geom,
-            algorithm=geometry_util.SimplifyAlgorithm.VISVALINGAM_WHYATT,
-            tolerance=tolerance_vw,
-        )
-    )
-    gfo.to_file(simplified_gdf, tmp_path / f"simplified_vw{tolerance_vw}.gpkg")
-    assert (
-        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
-        != nb_intersects_with_input
-    )
-
-    # With keep_points_on specified, the number of intersections stays the same
-    simplified_gdf = input_gdf.copy()
-    # assert to evade pyLance warning
-    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
-    simplified_gdf.geometry = input_gdf.geometry.apply(
-        lambda geom: geometry_util.simplify_ext(
-            geom,
-            algorithm=geometry_util.SimplifyAlgorithm.VISVALINGAM_WHYATT,
-            tolerance=tolerance_vw,
-            keep_points_on=grid_lines_geom,
-        )
-    )
-    gfo.to_file(
-        simplified_gdf, tmp_path / f"simplified_vw{tolerance_vw}_keep_points_on.gpkg"
-    )
-    assert (
-        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
-        == nb_intersects_with_input
-    )
-
-
-def test_simplify_ext_no_simplification():
-    # Backup reference to simplification module
-    _temp_simplification = None
-    if sys.modules.get("simplification"):
-        _temp_simplification = sys.modules["simplification"]
-    try:
-        # Fake that the module is not available
-        sys.modules["simplification"] = None  # type: ignore
-
-        # Using RDP needs simplification module, so should give ImportError
-        geometry_util.simplify_ext(
-            geometry=sh_geom.LineString([(0, 0), (10, 10), (20, 20)]),
-            algorithm=geometry_util.SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
-            tolerance=1,
-        )
-        assert True is False
-    except ImportError:
-        assert True is True
-    finally:
-        if _temp_simplification:
-            sys.modules["simplification"] = _temp_simplification
-        else:
-            del sys.modules["simplification"]
+# -*- coding: utf-8 -*-
+"""
+Tests for functionalities in vector_util, regarding geometry operations.
+"""
+
+import sys
+
+import geopandas as gpd
+import numpy as np
+import pytest
+import shapely.geometry as sh_geom
+
+import geofileops as gfo
+from geofileops import GeometryType, PrimitiveType
+from geofileops.util import geometry_util
+from geofileops.util import grid_util
+from tests import test_helper
+
+
+def test_geometrytype():
+    # Creating a GeometryType from None is invalid
+    with pytest.raises(ValueError, match="None is not a valid GeometryType"):
+        geometrytype = GeometryType(None)
+
+    # Create different types of Geometrytype
+    geometrytype = GeometryType(3)
+    assert geometrytype is GeometryType.POLYGON
+    geometrytype = GeometryType("PoLyGoN")
+    assert geometrytype is GeometryType.POLYGON
+    geometrytype = GeometryType(GeometryType.POLYGON)
+    assert geometrytype is GeometryType.POLYGON
+
+    # Test to_primitivetype
+    primitivetype = GeometryType.POLYGON.to_primitivetype
+    assert primitivetype is PrimitiveType.POLYGON
+    primitivetype = GeometryType.MULTIPOLYGON.to_primitivetype
+    assert primitivetype is PrimitiveType.POLYGON
+
+    # A geometry collection doesn't have a primitive type
+    with pytest.raises(
+        Exception, match="Geometrycollection doesn't have a primitive type"
+    ):
+        GeometryType.GEOMETRYCOLLECTION.to_primitivetype
+
+
+def test_primitivetype():
+    primitivetype = PrimitiveType(3)
+    assert primitivetype is PrimitiveType.POLYGON
+    primitivetype = PrimitiveType("PoLyGoN")
+    assert primitivetype is PrimitiveType.POLYGON
+    primitivetype = PrimitiveType(PrimitiveType.POLYGON)
+    assert primitivetype is PrimitiveType.POLYGON
+
+
+def test_makevalid():
+    # Test Point
+    point_valid = geometry_util.make_valid(test_helper.TestData.point)
+    assert isinstance(point_valid, sh_geom.Point)
+
+    # Test MultiPoint
+    multipoint_valid = geometry_util.make_valid(test_helper.TestData.multipoint)
+    assert isinstance(multipoint_valid, sh_geom.MultiPoint)
+
+    # Test LineString
+    linestring_valid = geometry_util.make_valid(test_helper.TestData.linestring)
+    assert isinstance(linestring_valid, sh_geom.LineString)
+
+    # Test MultiLineString
+    multilinestring_valid = geometry_util.make_valid(
+        test_helper.TestData.multilinestring
+    )
+    assert isinstance(multilinestring_valid, sh_geom.MultiLineString)
+
+    # Test Polygon, self-intersecting
+    polygon_invalid = sh_geom.Polygon(
+        shell=[(0, 0), (0, 10), (5, 10), (4, 11), (4, 9), (10, 10), (10, 0), (0, 0)],
+        holes=[[(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]],
+    )
+    poly_valid = geometry_util.make_valid(polygon_invalid)
+    assert isinstance(poly_valid, sh_geom.MultiPolygon)
+    assert len(poly_valid.geoms) == 2
+    assert len(poly_valid.geoms[0].interiors) == 1
+
+    # Test MultiPolygon
+    multipolygon_invalid = sh_geom.MultiPolygon(
+        [polygon_invalid, test_helper.TestData.polygon_no_islands]
+    )
+    multipoly_valid = geometry_util.make_valid(multipolygon_invalid)
+    assert isinstance(multipoly_valid, sh_geom.MultiPolygon)
+
+    # Test GeometryCollection (as combination of all previous ones)
+    geometrycollection_invalid = sh_geom.GeometryCollection(
+        [
+            test_helper.TestData.point,
+            test_helper.TestData.multipoint,
+            test_helper.TestData.linestring,
+            test_helper.TestData.multilinestring,
+            polygon_invalid,
+            multipolygon_invalid,
+        ]
+    )
+    geometrycollection_valid = geometry_util.make_valid(geometrycollection_invalid)
+    assert isinstance(geometrycollection_valid, sh_geom.GeometryCollection)
+
+
+def test_numberpoints():
+    # Test Point
+    numberpoints = geometry_util.numberpoints(test_helper.TestData.point)
+    numberpoints_geometrycollection = numberpoints
+    assert numberpoints == 1
+
+    # Test MultiPoint
+    numberpoints = geometry_util.numberpoints(test_helper.TestData.multipoint)
+    numberpoints_geometrycollection += numberpoints
+    assert numberpoints == 3
+
+    # Test LineString
+    numberpoints = geometry_util.numberpoints(test_helper.TestData.linestring)
+    numberpoints_geometrycollection += numberpoints
+    assert numberpoints == 3
+
+    # Test MultiLineString
+    numberpoints = geometry_util.numberpoints(test_helper.TestData.multilinestring)
+    numberpoints_geometrycollection += numberpoints
+    assert numberpoints == 6
+
+    # Test Polygon
+    numberpoints = geometry_util.numberpoints(test_helper.TestData.polygon_with_island)
+    numberpoints_geometrycollection += numberpoints
+    assert numberpoints == 11
+
+    # Test MultiPolygon
+    numberpoints = geometry_util.numberpoints(test_helper.TestData.multipolygon)
+    numberpoints_geometrycollection += numberpoints
+    assert numberpoints == 16
+
+    # Test GeometryCollection (as combination of all previous ones)
+    numberpoints = geometry_util.numberpoints(test_helper.TestData.geometrycollection)
+    assert numberpoints == numberpoints_geometrycollection
+
+
+def test_remove_inner_rings():
+    # Apply to single Polygon, with area tolerance smaller than holes
+    polygon_removerings_withholes = sh_geom.Polygon(
+        shell=[(0, 0), (0, 10), (1, 10), (10, 10), (10, 0), (0, 0)],
+        holes=[
+            [(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)],
+            [(5, 5), (5, 6), (7, 6), (7, 5), (5, 5)],
+        ],
+    )
+    poly_result = geometry_util.remove_inner_rings(
+        polygon_removerings_withholes, min_area_to_keep=1, crs=None
+    )
+    assert isinstance(poly_result, sh_geom.Polygon)
+    assert len(poly_result.interiors) == 2
+
+    # Apply to single Polygon, with area tolerance between
+    # smallest hole (= 2m²) and largest (= 4m²)
+    poly_result = geometry_util.remove_inner_rings(
+        polygon_removerings_withholes, min_area_to_keep=3, crs=None
+    )
+    assert isinstance(poly_result, sh_geom.Polygon)
+    assert len(poly_result.interiors) == 1
+
+    # Apply to single polygon and remove all holes
+    poly_result = geometry_util.remove_inner_rings(
+        polygon_removerings_withholes, min_area_to_keep=0, crs=None
+    )
+    assert isinstance(poly_result, sh_geom.Polygon)
+    assert len(poly_result.interiors) == 0
+    polygon_removerings_noholes = sh_geom.Polygon(
+        shell=[(100, 100), (100, 110), (110, 110), (110, 100), (100, 100)]
+    )
+    poly_result = geometry_util.remove_inner_rings(
+        polygon_removerings_noholes, min_area_to_keep=0, crs=None
+    )
+    assert isinstance(poly_result, sh_geom.Polygon)
+    assert len(poly_result.interiors) == 0
+
+    # Apply to MultiPolygon, with area tolerance between
+    # smallest hole (= 2m²) and largest (= 4m²)
+    multipoly_removerings = sh_geom.MultiPolygon(
+        [polygon_removerings_withholes, polygon_removerings_noholes]
+    )
+    poly_result = geometry_util.remove_inner_rings(
+        multipoly_removerings, min_area_to_keep=3, crs=None
+    )
+    assert isinstance(poly_result, sh_geom.MultiPolygon)
+    assert len(poly_result.geoms[0].interiors) == 1  # type: ignore
+
+
+def test_simplify_coords_lang():
+    # Test LineString, lookahead -1, via coordinates
+    linestring = sh_geom.LineString([(0, 0), (10, 10), (20, 20)])
+    coords_simplified = geometry_util.simplify_coords_lang(
+        coords=linestring.coords, tolerance=1, lookahead=-1
+    )
+    assert isinstance(coords_simplified, np.ndarray)
+    assert len(coords_simplified) < len(linestring.coords)
+    assert len(coords_simplified) == 2
+
+
+def test_simplify_coords_lang_list():
+    # Test LineString, lookahead -1, via coordinates
+    linestring = sh_geom.LineString([(0, 0), (10, 10), (20, 20)])
+    coords_simplified = geometry_util.simplify_coords_lang(
+        coords=list(linestring.coords), tolerance=1, lookahead=-1
+    )
+    assert isinstance(coords_simplified, list)
+    assert len(coords_simplified) < len(linestring.coords)
+    assert len(coords_simplified) == 2
+
+
+def test_simplify_ext_lang_basic():
+    # Test LineString, lookahead -1, via geometry
+    linestring = sh_geom.LineString([(0, 0), (10, 10), (20, 20)])
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=linestring,
+        algorithm=geometry_util.SimplifyAlgorithm.LANG,
+        tolerance=1,
+        lookahead=-1,
+    )
+    assert isinstance(geom_simplified, sh_geom.LineString)
+    assert len(geom_simplified.coords) < len(linestring.coords)
+    assert len(geom_simplified.coords) == 2
+
+    # Test Polygon lookahead -1
+    poly = sh_geom.Polygon(
+        shell=[(0, 0), (0, 10), (1, 10), (10, 10), (10, 0), (0, 0)],
+        holes=[[(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]],
+    )
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=poly,
+        algorithm=geometry_util.SimplifyAlgorithm.LANG,
+        tolerance=1,
+        lookahead=-1,
+    )
+    assert isinstance(geom_simplified, sh_geom.Polygon)
+    assert geom_simplified.exterior is not None
+    assert poly.exterior is not None
+    assert len(geom_simplified.exterior.coords) < len(poly.exterior.coords)
+    assert len(geom_simplified.exterior.coords) == 5
+
+    # Test Point simplification
+    point = sh_geom.Point((0, 0))
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=point, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
+    )
+    assert isinstance(geom_simplified, sh_geom.Point)
+    assert len(geom_simplified.coords) == 1
+
+    # Test MultiPoint simplification
+    multipoint = sh_geom.MultiPoint([(0, 0), (10, 10), (20, 20)])
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=multipoint, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
+    )
+    assert isinstance(geom_simplified, sh_geom.MultiPoint)
+    assert len(geom_simplified.geoms) == 3
+
+    # Test LineString simplification
+    linestring = sh_geom.LineString([(0, 0), (10, 10), (20, 20)])
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=linestring, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
+    )
+    assert isinstance(geom_simplified, sh_geom.LineString)
+    assert len(geom_simplified.coords) < len(linestring.coords)
+    assert len(geom_simplified.coords) == 2
+
+    # Test MultiLineString simplification
+    multilinestring = sh_geom.MultiLineString(
+        [list(linestring.coords), [(100, 100), (110, 110), (120, 120)]]
+    )
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=multilinestring,
+        algorithm=geometry_util.SimplifyAlgorithm.LANG,
+        tolerance=1,
+    )
+    assert isinstance(geom_simplified, sh_geom.MultiLineString)
+    assert len(geom_simplified.geoms) == 2
+    assert len(geom_simplified.geoms[0].coords) < len(
+        multilinestring.geoms[0].coords  # type: ignore
+    )
+    assert len(geom_simplified.geoms[0].coords) == 2
+
+    # Test Polygon simplification
+    poly = sh_geom.Polygon(
+        shell=[(0, 0), (0, 10), (1, 10), (10, 10), (10, 0), (0, 0)],
+        holes=[[(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]],
+    )
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=poly, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
+    )
+    assert isinstance(geom_simplified, sh_geom.Polygon)
+    assert geom_simplified.exterior is not None
+    assert poly.exterior is not None
+    assert len(geom_simplified.exterior.coords) < len(poly.exterior.coords)
+    assert len(geom_simplified.exterior.coords) == 5
+
+    # Test MultiPolygon simplification
+    poly2 = sh_geom.Polygon(
+        shell=[(100, 100), (100, 110), (110, 110), (110, 100), (100, 100)]
+    )
+    multipoly = sh_geom.MultiPolygon([poly, poly2])
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=multipoly, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
+    )
+    assert isinstance(geom_simplified, sh_geom.MultiPolygon)
+    assert len(geom_simplified.geoms) == 2
+    assert len(geom_simplified.geoms[0].exterior.coords) < len(poly.exterior.coords)
+    assert len(geom_simplified.geoms[0].exterior.coords) == 5
+
+    # Test GeometryCollection (as combination of all previous ones) simplification
+    geom = sh_geom.GeometryCollection(
+        [point, multipoint, linestring, multilinestring, poly, multipoly]
+    )
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=geom, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
+    )
+    assert isinstance(geom_simplified, sh_geom.GeometryCollection)
+    assert len(geom_simplified.geoms) == 6
+
+
+def test_simplify_ext_lang_preservetopology():
+    # Test Polygon lookahead -1
+    poly = sh_geom.Polygon(
+        shell=[(0, 0), (0, 10), (1, 10), (10, 10), (10, 0), (0, 0)],
+        holes=[[(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]],
+    )
+    # If preserve_topology True, the original polygon is returned...
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=poly,
+        algorithm=geometry_util.SimplifyAlgorithm.LANG,
+        tolerance=10,
+        preserve_topology=True,
+        lookahead=-1,
+    )
+    assert isinstance(geom_simplified, sh_geom.Polygon)
+    assert poly.equals(geom_simplified) is True
+
+    # If preserve_topology True, the original polygon is returned...
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=poly,
+        algorithm=geometry_util.SimplifyAlgorithm.LANG,
+        tolerance=10,
+        preserve_topology=False,
+        lookahead=-1,
+    )
+    assert geom_simplified is None
+
+
+def test_simplify_ext_invalid():
+    # Test Polygon simplification, with invalid exterior ring
+    poly = sh_geom.Polygon(
+        shell=[(0, 0), (0, 10), (5, 10), (3, 12), (3, 9), (10, 10), (10, 0), (0, 0)],
+        holes=[[(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]],
+    )
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=poly, algorithm=geometry_util.SimplifyAlgorithm.LANG, tolerance=1
+    )
+    assert isinstance(geom_simplified, sh_geom.MultiPolygon)
+    assert poly.exterior is not None
+    assert len(geom_simplified.geoms[0].exterior.coords) < len(poly.exterior.coords)
+    assert len(geom_simplified.geoms[0].exterior.coords) == 7
+    assert len(geom_simplified.geoms[0].interiors) == len(poly.interiors)
+
+    # Test Polygon simplification, with exterior ring that touches itself
+    # due to simplification and after make_valid results in multipolygon of
+    # 2 equally large parts (left and right part of M shape).
+    poly_m_touch = sh_geom.Polygon(
+        shell=[
+            (0, 0),
+            (0, 10),
+            (5, 5),
+            (10, 10),
+            (10, 0),
+            (8, 0),
+            (8, 5),
+            (5, 4),
+            (2, 5),
+            (2, 0),
+            (0, 0),
+        ]
+    )
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=poly_m_touch,
+        algorithm=geometry_util.SimplifyAlgorithm.LANG,
+        tolerance=1,
+    )
+    assert geom_simplified is not None
+    assert geom_simplified.is_valid
+    assert isinstance(geom_simplified, sh_geom.MultiPolygon)
+    assert len(geom_simplified.geoms) == 2
+    assert geometry_util.numberpoints(geom_simplified) < geometry_util.numberpoints(
+        poly
+    )
+
+    # Test Polygon simplification, with exterior ring that crosses itself
+    # due to simplification and after make_valid results in multipolygon of
+    # 3 parts (left, middle and right part of M shape).
+    poly_m_cross = sh_geom.Polygon(
+        shell=[
+            (0, 0),
+            (0, 10),
+            (5, 5),
+            (10, 10),
+            (10, 0),
+            (8, 0),
+            (8, 5.5),
+            (5, 4.5),
+            (2, 5.5),
+            (2, 0),
+            (0, 0),
+        ]
+    )
+    geom_simplified = geometry_util.simplify_ext(
+        geometry=poly_m_cross,
+        algorithm=geometry_util.SimplifyAlgorithm.LANG,
+        tolerance=1,
+    )
+    assert geom_simplified is not None
+    assert geom_simplified.is_valid
+    assert isinstance(geom_simplified, sh_geom.MultiPolygon)
+    assert len(geom_simplified.geoms) == 3
+
+
+def test_simplify_ext_keep_points_on_lang(tmp_path):
+    # First init some stuff
+    input_path = test_helper.get_testfile("polygon-simplify-onborder-testcase")
+    input_gdf = gfo.read_file(input_path)
+
+    # Create geometry where we want the points kept
+    grid_gdf = grid_util.create_grid(
+        total_bounds=(
+            210431.875 - 1000,
+            176640.125 - 1000,
+            210431.875 + 1000,
+            176640.125 + 1000,
+        ),
+        nb_columns=2,
+        nb_rows=2,
+        crs="epsg:31370",
+    )
+    gfo.to_file(grid_gdf, tmp_path / "grid.gpkg")
+    grid_coords = [tile.exterior.coords for tile in grid_gdf.geometry]
+    grid_lines_geom = sh_geom.MultiLineString(grid_coords)
+
+    # Test lang
+    # Without keep_points_on, the following point that is on the test data +
+    # on the grid is removed by lang
+    point_on_input_and_border = sh_geom.Point(210431.875, 176606.125)
+    tolerance_lang = 0.25
+    step_lang = 8
+
+    # Determine the number of intersects with the input test data
+    nb_intersects_with_input = len(
+        input_gdf[input_gdf.intersects(point_on_input_and_border)]
+    )
+    assert nb_intersects_with_input > 0
+    # Test if intersects > 0
+    assert len(input_gdf[grid_gdf.intersects(point_on_input_and_border)]) > 0
+
+    # Without keep_points_on the number of intersections changes
+    simplified_gdf = input_gdf.copy()
+    # assert to evade pyLance warning
+    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
+    simplified_gdf.geometry = input_gdf.geometry.apply(
+        lambda geom: geometry_util.simplify_ext(
+            geom,
+            algorithm=geometry_util.SimplifyAlgorithm.LANG,
+            tolerance=tolerance_lang,
+            lookahead=step_lang,
+        )
+    )
+    gfo.to_file(
+        simplified_gdf, tmp_path / f"simplified_lang;{tolerance_lang};{step_lang}.gpkg"
+    )
+    assert (
+        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
+        != nb_intersects_with_input
+    )
+
+    # With keep_points_on specified, the number of intersections stays the same
+    simplified_gdf = input_gdf.copy()
+    # assert to evade pyLance warning
+    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
+    simplified_gdf.geometry = input_gdf.geometry.apply(
+        lambda geom: geometry_util.simplify_ext(
+            geom,
+            algorithm=geometry_util.SimplifyAlgorithm.LANG,
+            tolerance=tolerance_lang,
+            lookahead=step_lang,
+            keep_points_on=grid_lines_geom,
+        )
+    )
+    output_path = (
+        tmp_path / f"simplified_lang;{tolerance_lang};{step_lang}_keep_points_on.gpkg"
+    )
+    gfo.to_file(simplified_gdf, output_path)
+    assert (
+        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
+        == nb_intersects_with_input
+    )
+
+
+def test_simplify_ext_keep_points_on_rdp(tmp_path):
+    # Skip test if simplification is not available
+    _ = pytest.importorskip("simplification")
+
+    # First init some stuff
+    input_path = test_helper.get_testfile("polygon-simplify-onborder-testcase")
+    input_gdf = gfo.read_file(input_path)
+
+    # Create geometry where we want the points kept
+    grid_gdf = grid_util.create_grid(
+        total_bounds=(
+            210431.875 - 1000,
+            176640.125 - 1000,
+            210431.875 + 1000,
+            176640.125 + 1000,
+        ),
+        nb_columns=2,
+        nb_rows=2,
+        crs="epsg:31370",
+    )
+    gfo.to_file(grid_gdf, tmp_path / "grid.gpkg")
+    grid_coords = [tile.exterior.coords for tile in grid_gdf.geometry]
+    grid_lines_geom = sh_geom.MultiLineString(grid_coords)
+
+    # Test rdp (ramer–douglas–peucker)
+    # Without keep_points_on, the following point that is on the test data +
+    # on the grid is removed by rdp
+    point_on_input_and_border = sh_geom.Point(210431.875, 176599.375)
+    tolerance_rdp = 0.5
+
+    # Determine the number of intersects with the input test data
+    nb_intersects_with_input = len(
+        input_gdf[input_gdf.intersects(point_on_input_and_border)]
+    )
+    assert nb_intersects_with_input > 0
+    # Test if intersects > 0
+    assert len(input_gdf[grid_gdf.intersects(point_on_input_and_border)]) > 0
+
+    # Without keep_points_on the number of intersections changes
+    simplified_gdf = input_gdf.copy()
+    # assert to evade pyLance warning
+    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
+    simplified_gdf.geometry = input_gdf.geometry.apply(
+        lambda geom: geometry_util.simplify_ext(
+            geom,
+            algorithm=geometry_util.SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
+            tolerance=tolerance_rdp,
+        )
+    )
+    gfo.to_file(simplified_gdf, tmp_path / f"simplified_rdp{tolerance_rdp}.gpkg")
+    assert (
+        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
+        != nb_intersects_with_input
+    )
+
+    # With keep_points_on specified, the number of intersections stays the same
+    simplified_gdf = input_gdf.copy()
+    # assert to evade pyLance warning
+    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
+    simplified_gdf.geometry = input_gdf.geometry.apply(
+        lambda geom: geometry_util.simplify_ext(
+            geom,
+            algorithm=geometry_util.SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
+            tolerance=tolerance_rdp,
+            keep_points_on=grid_lines_geom,
+        )
+    )
+    gfo.to_file(
+        simplified_gdf, tmp_path / f"simplified_rdp{tolerance_rdp}_keep_points_on.gpkg"
+    )
+    assert (
+        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
+        == nb_intersects_with_input
+    )
+
+
+def test_simplify_ext_keep_points_on_vw(tmp_path):
+    # Skip test if simplification is not available
+    _ = pytest.importorskip("simplification")
+
+    # First init some stuff
+    input_path = test_helper.get_testfile("polygon-simplify-onborder-testcase")
+    input_gdf = gfo.read_file(input_path)
+
+    # Create geometry where we want the points kept
+    grid_gdf = grid_util.create_grid(
+        total_bounds=(
+            210431.875 - 1000,
+            176640.125 - 1000,
+            210431.875 + 1000,
+            176640.125 + 1000,
+        ),
+        nb_columns=2,
+        nb_rows=2,
+        crs="epsg:31370",
+    )
+    gfo.to_file(grid_gdf, tmp_path / "grid.gpkg")
+    grid_coords = [tile.exterior.coords for tile in grid_gdf.geometry]
+    grid_lines_geom = sh_geom.MultiLineString(grid_coords)
+
+    # Test vw (visvalingam-whyatt)
+    # Without keep_points_on, the following point that is on the test data +
+    # on the grid is removed by vw
+    point_on_input_and_border = sh_geom.Point(210430.125, 176640.125)
+    tolerance_vw = 16 * 0.25 * 0.25  # 1m²
+
+    # Determine the number of intersects with the input test data
+    nb_intersects_with_input = len(
+        input_gdf[input_gdf.intersects(point_on_input_and_border)]
+    )
+    assert nb_intersects_with_input > 0
+    # Test if intersects > 0
+    assert len(input_gdf[grid_gdf.intersects(point_on_input_and_border)]) > 0
+
+    # Without keep_points_on the number of intersections changes
+    simplified_gdf = input_gdf.copy()
+    # assert to evade pyLance warning
+    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
+    simplified_gdf.geometry = input_gdf.geometry.apply(
+        lambda geom: geometry_util.simplify_ext(
+            geom,
+            algorithm=geometry_util.SimplifyAlgorithm.VISVALINGAM_WHYATT,
+            tolerance=tolerance_vw,
+        )
+    )
+    gfo.to_file(simplified_gdf, tmp_path / f"simplified_vw{tolerance_vw}.gpkg")
+    assert (
+        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
+        != nb_intersects_with_input
+    )
+
+    # With keep_points_on specified, the number of intersections stays the same
+    simplified_gdf = input_gdf.copy()
+    # assert to evade pyLance warning
+    assert isinstance(simplified_gdf, gpd.GeoDataFrame)
+    simplified_gdf.geometry = input_gdf.geometry.apply(
+        lambda geom: geometry_util.simplify_ext(
+            geom,
+            algorithm=geometry_util.SimplifyAlgorithm.VISVALINGAM_WHYATT,
+            tolerance=tolerance_vw,
+            keep_points_on=grid_lines_geom,
+        )
+    )
+    gfo.to_file(
+        simplified_gdf, tmp_path / f"simplified_vw{tolerance_vw}_keep_points_on.gpkg"
+    )
+    assert (
+        len(simplified_gdf[simplified_gdf.intersects(point_on_input_and_border)])
+        == nb_intersects_with_input
+    )
+
+
+def test_simplify_ext_no_simplification():
+    # Backup reference to simplification module
+    _temp_simplification = None
+    if sys.modules.get("simplification"):
+        _temp_simplification = sys.modules["simplification"]
+    try:
+        # Fake that the module is not available
+        sys.modules["simplification"] = None  # type: ignore
+
+        # Using RDP needs simplification module, so should give ImportError
+        geometry_util.simplify_ext(
+            geometry=sh_geom.LineString([(0, 0), (10, 10), (20, 20)]),
+            algorithm=geometry_util.SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER,
+            tolerance=1,
+        )
+        assert True is False
+    except ImportError:
+        assert True is True
+    finally:
+        if _temp_simplification:
+            sys.modules["simplification"] = _temp_simplification
+        else:
+            del sys.modules["simplification"]
```

### Comparing `geofileops-0.8.0a1/tests/test_geoseries_util.py` & `geofileops-0.8.0a2/tests/test_geoseries_util.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,327 +1,325 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for functionalities in geoseries_util.
-"""
-
-from pathlib import Path
-import sys
-
-import geopandas as gpd
-import pytest
-import shapely
-import shapely.geometry as sh_geom
-
-SHAPELY_GE_20 = str(shapely.__version__).split(".")[0] >= "2"
-
-# Add path so the local geofileops packages are found
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
-import geofileops as gfo
-from geofileops.util import geoseries_util
-from geofileops.util.geometry_util import GeometryType, PrimitiveType, SimplifyAlgorithm
-from tests import test_helper
-
-
-def test_get_geometrytypes():
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            None,
-            sh_geom.Point(),
-            sh_geom.LineString(),
-            sh_geom.Polygon(),
-            test_helper.TestData.point,
-            test_helper.TestData.multipoint,
-            test_helper.TestData.polygon_with_island,
-            test_helper.TestData.polygon_no_islands,
-            test_helper.TestData.multipolygon,
-            test_helper.TestData.geometrycollection,
-        ]
-    )
-    # None and empty geometries are by default ignored in get_geometrytypes
-    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
-    assert len(test_geometrytypes) == 5
-
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            None,
-            sh_geom.Point(),
-            sh_geom.LineString(),
-            sh_geom.Polygon(),
-            test_helper.TestData.point,
-        ]
-    )
-    # None and empty geometries are by default ignored in get_geometrytypes
-    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
-    assert len(test_geometrytypes) == 1
-    assert GeometryType.POINT in test_geometrytypes
-
-    # Empty geometries are counted with ignore_empty_geometries=False.
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            None,
-            sh_geom.Point(),
-            sh_geom.LineString(),
-            sh_geom.Polygon(),
-            test_helper.TestData.point,
-        ]
-    )
-    test_geometrytypes = geoseries_util.get_geometrytypes(
-        test_gdf.geometry, ignore_empty_geometries=False
-    )
-    # In shapely 2, empty geometries get the correct type, in shapely 1 they were always
-    # of type geometrycollection
-    if SHAPELY_GE_20:
-        assert len(test_geometrytypes) == 3
-        assert GeometryType.POINT in test_geometrytypes
-        assert GeometryType.LINESTRING in test_geometrytypes
-        assert GeometryType.POLYGON in test_geometrytypes
-        assert GeometryType.GEOMETRYCOLLECTION not in test_geometrytypes
-    else:
-        assert len(test_geometrytypes) == 2
-
-
-def test_geometry_collection_extract():
-    # Test for gdf with all types of geometrytypes, extract!
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            test_helper.TestData.point,
-            test_helper.TestData.multipoint,
-            test_helper.TestData.polygon_with_island,
-            test_helper.TestData.polygon_no_islands,
-            test_helper.TestData.multipolygon,
-            test_helper.TestData.geometrycollection,
-        ]
-    )
-    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
-    assert len(test_geometrytypes) == 5
-    test_result_gdf = test_gdf.copy()
-    assert isinstance(test_result_gdf, gpd.GeoDataFrame)
-    test_result_gdf.geometry = geoseries_util.geometry_collection_extract(
-        test_result_gdf.geometry, PrimitiveType.POLYGON
-    )
-    test_result_geometrytypes = geoseries_util.get_geometrytypes(
-        test_result_gdf.geometry
-    )
-    assert len(test_result_geometrytypes) == 2
-    for index, geom in test_result_gdf.items():
-        assert geom is not None
-
-
-def test_harmonize_geometrytypes():
-    # Test for gdf with None + point + multipoint -> all multipoint
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            None,
-            sh_geom.Point(),
-            test_helper.TestData.point,
-            test_helper.TestData.multipoint,
-            test_helper.TestData.point,
-            test_helper.TestData.multipoint,
-        ]
-    )
-    test_gdf_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
-    assert len(test_gdf_geometrytypes) == 2
-    test_result_gdf = test_gdf.copy()
-    assert isinstance(test_result_gdf, gpd.GeoDataFrame)
-    test_result_gdf.geometry = geoseries_util.harmonize_geometrytypes(
-        test_result_gdf.geometry
-    )
-    test_result_geometrytypes = geoseries_util.get_geometrytypes(
-        test_result_gdf.geometry
-    )
-    assert len(test_result_geometrytypes) == 1
-    assert test_result_geometrytypes[0] == GeometryType.MULTIPOINT
-    for index, geom in test_result_gdf.geometry.items():
-        if index in [0, 1]:
-            assert geom is None
-        else:
-            assert geom is not None
-
-    # Test for gdf with linestring + multilinestring -> all multilinestring
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            None,
-            sh_geom.LineString(),
-            test_helper.TestData.linestring,
-            test_helper.TestData.multilinestring,
-            test_helper.TestData.linestring,
-            test_helper.TestData.multilinestring,
-        ]
-    )
-    test_gdf_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
-    assert len(test_gdf_geometrytypes) == 2
-    test_result_gdf = test_gdf.copy()
-    assert isinstance(test_result_gdf, gpd.GeoDataFrame)
-    test_result_gdf.geometry = geoseries_util.harmonize_geometrytypes(
-        test_result_gdf.geometry
-    )
-    test_result_geometrytypes = geoseries_util.get_geometrytypes(
-        test_result_gdf.geometry
-    )
-    assert len(test_result_geometrytypes) == 1
-    assert test_result_geometrytypes[0] == GeometryType.MULTILINESTRING
-    for index, geom in test_result_gdf.geometry.items():
-        if index in [0, 1]:
-            assert geom is None
-        else:
-            assert geom is not None
-
-    # Test for gdf with polygon + multipolygon -> all multipolygon
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            test_helper.TestData.polygon_with_island,
-            None,
-            sh_geom.Polygon(),
-            test_helper.TestData.polygon_with_island,
-            test_helper.TestData.multipolygon,
-        ]
-    )
-    test_gdf_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
-    assert len(test_gdf_geometrytypes) == 2
-    # Filter the gdf a bit to test that the indexes are retained properly in
-    test_gdf = test_gdf.iloc[[1, 2, 3, 4]]  # type: ignore
-    test_result_gdf = test_gdf.copy()
-    assert isinstance(test_result_gdf, gpd.GeoDataFrame)
-    test_result_gdf.geometry = geoseries_util.harmonize_geometrytypes(
-        test_result_gdf.geometry
-    )
-    test_result_geometrytypes = geoseries_util.get_geometrytypes(
-        test_result_gdf.geometry
-    )
-    assert len(test_result_geometrytypes) == 1
-    assert test_result_geometrytypes[0] == GeometryType.MULTIPOLYGON
-    for index, geom in test_result_gdf.geometry.items():
-        if index in [1, 2]:
-            assert geom is None
-        else:
-            assert geom is not None
-
-    # Test for gdf with all types of geometrytypes -> no harmonization possible
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            None,
-            sh_geom.Polygon(),
-            test_helper.TestData.point,
-            test_helper.TestData.multipoint,
-            test_helper.TestData.polygon_with_island,
-            test_helper.TestData.polygon_no_islands,
-            test_helper.TestData.multipolygon,
-            test_helper.TestData.geometrycollection,
-        ]
-    )
-    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
-    assert len(test_geometrytypes) == 5
-    test_result_gdf = test_gdf.copy()
-    assert isinstance(test_result_gdf, gpd.GeoDataFrame)
-    test_result_gdf.geometry = geoseries_util.harmonize_geometrytypes(
-        test_result_gdf.geometry
-    )
-    test_result_geometrytypes = geoseries_util.get_geometrytypes(
-        test_result_gdf.geometry
-    )
-    assert len(test_result_geometrytypes) == 5
-    for index, geom in test_result_gdf.geometry.items():
-        if index in [0]:
-            # Only None is None, empty geometry is not changed!
-            assert geom is None
-        else:
-            assert geom is not None
-
-
-def test_is_valid_reason(tmp_path):
-    # Test with valid data + Empty geometry
-    # -------------------------------------
-    test_gdf = gpd.GeoDataFrame(
-        geometry=[  # type: ignore
-            sh_geom.Polygon(),
-            test_helper.TestData.point,
-            test_helper.TestData.multipoint,
-            test_helper.TestData.polygon_with_island,
-            test_helper.TestData.polygon_no_islands,
-            test_helper.TestData.multipolygon,
-            test_helper.TestData.geometrycollection,
-        ]
-    )
-    result = geoseries_util.is_valid_reason(test_gdf.geometry)
-
-    assert len(result) == len(test_gdf)
-    assert result.unique() == "Valid Geometry"
-
-    # Test if indexas are retained
-    # ----------------------------
-    test_filtered_gdf = test_gdf[3:-1]
-    assert isinstance(test_filtered_gdf.geometry, gpd.GeoSeries)
-    result = geoseries_util.is_valid_reason(test_filtered_gdf.geometry)
-
-    assert len(result) == len(test_filtered_gdf)
-    assert result.unique() == "Valid Geometry"
-    assert result.index.to_list() == test_filtered_gdf.index.to_list()
-
-    # Test with None
-    # --------------
-    test_gdf = gpd.GeoDataFrame(geometry=[None])  # type: ignore
-    result = geoseries_util.is_valid_reason(test_gdf.geometry)
-
-    # is_valid_reason returns None for None geometries
-    assert result[0] is None
-
-    # Test with invalid data
-    # ----------------------
-    # Prepare test data
-    path = test_helper.get_testfile("polygon-invalid")
-    gdf = gfo.read_file(path)
-    result = geoseries_util.is_valid_reason(gdf.geometry)
-
-    assert len(result) == len(gdf)
-    assert result[0].startswith("Ring Self-intersection")
-
-
-def test_polygons_to_lines():
-    # Test with polygons
-    test_geoseries = gpd.GeoSeries(
-        data=[
-            None,
-            sh_geom.Polygon(),
-            test_helper.TestData.multipolygon,
-            test_helper.TestData.polygon_with_island,
-            test_helper.TestData.polygon_no_islands,
-            test_helper.TestData.multipolygon,
-        ]
-    )
-    lines_series = geoseries_util.polygons_to_lines(test_geoseries)
-    assert len(lines_series) == 9
-
-
-@pytest.mark.parametrize(
-    "algorithm", [SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER, SimplifyAlgorithm.LANG]
-)
-def test_simplify_ext(algorithm):
-    input_path = test_helper.get_testfile("polygon-parcel")
-    input_gdf = gfo.read_file(input_path)
-    result_geoseries = geoseries_util.simplify_ext(
-        input_gdf.geometry, tolerance=1, algorithm=algorithm
-    )
-
-    assert len(result_geoseries) == len(input_gdf.geometry)
-    assert len(result_geoseries[1].exterior.coords) < len(
-        input_gdf.geometry[1].geoms[0].exterior.coords
-    )
-
-
-@pytest.mark.parametrize(
-    "algorithm", [SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER, SimplifyAlgorithm.LANG]
-)
-def test_simplify_topo_ext(algorithm):
-    # Skip test if simplification is not available
-    _ = pytest.importorskip("simplification")
-
-    input_path = test_helper.get_testfile("polygon-parcel")
-    input_gdf = gfo.read_file(input_path)
-    result_geoseries = geoseries_util.simplify_topo_ext(
-        input_gdf.geometry, tolerance=1, algorithm=algorithm
-    )
-
-    assert len(result_geoseries) == len(input_gdf.geometry)
-    assert len(result_geoseries[1].geoms[0].exterior.coords) < len(
-        input_gdf.geometry[1].geoms[0].exterior.coords
-    )
+# -*- coding: utf-8 -*-
+"""
+Tests for functionalities in geoseries_util.
+"""
+
+from pathlib import Path
+import sys
+
+import geopandas as gpd
+import pytest
+import shapely.geometry as sh_geom
+
+# Add path so the local geofileops packages are found
+# Add path so the local geofileops packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
+import geofileops as gfo
+import geofileops._compat as compat
+from geofileops.util import geoseries_util
+from geofileops.util.geometry_util import GeometryType, PrimitiveType, SimplifyAlgorithm
+from tests import test_helper
+
+
+def test_get_geometrytypes():
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            None,
+            sh_geom.Point(),
+            sh_geom.LineString(),
+            sh_geom.Polygon(),
+            test_helper.TestData.point,
+            test_helper.TestData.multipoint,
+            test_helper.TestData.polygon_with_island,
+            test_helper.TestData.polygon_no_islands,
+            test_helper.TestData.multipolygon,
+            test_helper.TestData.geometrycollection,
+        ]
+    )
+    # None and empty geometries are by default ignored in get_geometrytypes
+    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
+    assert len(test_geometrytypes) == 5
+
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            None,
+            sh_geom.Point(),
+            sh_geom.LineString(),
+            sh_geom.Polygon(),
+            test_helper.TestData.point,
+        ]
+    )
+    # None and empty geometries are by default ignored in get_geometrytypes
+    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
+    assert len(test_geometrytypes) == 1
+    assert GeometryType.POINT in test_geometrytypes
+
+    # Empty geometries are counted with ignore_empty_geometries=False.
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            None,
+            sh_geom.Point(),
+            sh_geom.LineString(),
+            sh_geom.Polygon(),
+            test_helper.TestData.point,
+        ]
+    )
+    test_geometrytypes = geoseries_util.get_geometrytypes(
+        test_gdf.geometry, ignore_empty_geometries=False
+    )
+    # In shapely 2, empty geometries get the correct type, in shapely 1 they were always
+    # of type geometrycollection
+    if compat.SHAPELY_GE_20:
+        assert len(test_geometrytypes) == 3
+        assert GeometryType.POINT in test_geometrytypes
+        assert GeometryType.LINESTRING in test_geometrytypes
+        assert GeometryType.POLYGON in test_geometrytypes
+        assert GeometryType.GEOMETRYCOLLECTION not in test_geometrytypes
+    else:
+        assert len(test_geometrytypes) == 2
+
+
+def test_geometry_collection_extract():
+    # Test for gdf with all types of geometrytypes, extract!
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            test_helper.TestData.point,
+            test_helper.TestData.multipoint,
+            test_helper.TestData.polygon_with_island,
+            test_helper.TestData.polygon_no_islands,
+            test_helper.TestData.multipolygon,
+            test_helper.TestData.geometrycollection,
+        ]
+    )
+    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
+    assert len(test_geometrytypes) == 5
+    test_result_gdf = test_gdf.copy()
+    assert isinstance(test_result_gdf, gpd.GeoDataFrame)
+    test_result_gdf.geometry = geoseries_util.geometry_collection_extract(
+        test_result_gdf.geometry, PrimitiveType.POLYGON
+    )
+    test_result_geometrytypes = geoseries_util.get_geometrytypes(
+        test_result_gdf.geometry
+    )
+    assert len(test_result_geometrytypes) == 2
+    for index, geom in test_result_gdf.items():
+        assert geom is not None
+
+
+def test_harmonize_geometrytypes():
+    # Test for gdf with None + point + multipoint -> all multipoint
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            None,
+            sh_geom.Point(),
+            test_helper.TestData.point,
+            test_helper.TestData.multipoint,
+            test_helper.TestData.point,
+            test_helper.TestData.multipoint,
+        ]
+    )
+    test_gdf_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
+    assert len(test_gdf_geometrytypes) == 2
+    test_result_gdf = test_gdf.copy()
+    assert isinstance(test_result_gdf, gpd.GeoDataFrame)
+    test_result_gdf.geometry = geoseries_util.harmonize_geometrytypes(
+        test_result_gdf.geometry
+    )
+    test_result_geometrytypes = geoseries_util.get_geometrytypes(
+        test_result_gdf.geometry
+    )
+    assert len(test_result_geometrytypes) == 1
+    assert test_result_geometrytypes[0] == GeometryType.MULTIPOINT
+    for index, geom in test_result_gdf.geometry.items():
+        if index in [0, 1]:
+            assert geom is None
+        else:
+            assert geom is not None
+
+    # Test for gdf with linestring + multilinestring -> all multilinestring
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            None,
+            sh_geom.LineString(),
+            test_helper.TestData.linestring,
+            test_helper.TestData.multilinestring,
+            test_helper.TestData.linestring,
+            test_helper.TestData.multilinestring,
+        ]
+    )
+    test_gdf_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
+    assert len(test_gdf_geometrytypes) == 2
+    test_result_gdf = test_gdf.copy()
+    assert isinstance(test_result_gdf, gpd.GeoDataFrame)
+    test_result_gdf.geometry = geoseries_util.harmonize_geometrytypes(
+        test_result_gdf.geometry
+    )
+    test_result_geometrytypes = geoseries_util.get_geometrytypes(
+        test_result_gdf.geometry
+    )
+    assert len(test_result_geometrytypes) == 1
+    assert test_result_geometrytypes[0] == GeometryType.MULTILINESTRING
+    for index, geom in test_result_gdf.geometry.items():
+        if index in [0, 1]:
+            assert geom is None
+        else:
+            assert geom is not None
+
+    # Test for gdf with polygon + multipolygon -> all multipolygon
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            test_helper.TestData.polygon_with_island,
+            None,
+            sh_geom.Polygon(),
+            test_helper.TestData.polygon_with_island,
+            test_helper.TestData.multipolygon,
+        ]
+    )
+    test_gdf_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
+    assert len(test_gdf_geometrytypes) == 2
+    # Filter the gdf a bit to test that the indexes are retained properly in
+    test_gdf = test_gdf.iloc[[1, 2, 3, 4]]  # type: ignore
+    test_result_gdf = test_gdf.copy()
+    assert isinstance(test_result_gdf, gpd.GeoDataFrame)
+    test_result_gdf.geometry = geoseries_util.harmonize_geometrytypes(
+        test_result_gdf.geometry
+    )
+    test_result_geometrytypes = geoseries_util.get_geometrytypes(
+        test_result_gdf.geometry
+    )
+    assert len(test_result_geometrytypes) == 1
+    assert test_result_geometrytypes[0] == GeometryType.MULTIPOLYGON
+    for index, geom in test_result_gdf.geometry.items():
+        if index in [1, 2]:
+            assert geom is None
+        else:
+            assert geom is not None
+
+    # Test for gdf with all types of geometrytypes -> no harmonization possible
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            None,
+            sh_geom.Polygon(),
+            test_helper.TestData.point,
+            test_helper.TestData.multipoint,
+            test_helper.TestData.polygon_with_island,
+            test_helper.TestData.polygon_no_islands,
+            test_helper.TestData.multipolygon,
+            test_helper.TestData.geometrycollection,
+        ]
+    )
+    test_geometrytypes = geoseries_util.get_geometrytypes(test_gdf.geometry)
+    assert len(test_geometrytypes) == 5
+    test_result_gdf = test_gdf.copy()
+    assert isinstance(test_result_gdf, gpd.GeoDataFrame)
+    test_result_gdf.geometry = geoseries_util.harmonize_geometrytypes(
+        test_result_gdf.geometry
+    )
+    test_result_geometrytypes = geoseries_util.get_geometrytypes(
+        test_result_gdf.geometry
+    )
+    assert len(test_result_geometrytypes) == 5
+    for index, geom in test_result_gdf.geometry.items():
+        if index in [0]:
+            # Only None is None, empty geometry is not changed!
+            assert geom is None
+        else:
+            assert geom is not None
+
+
+def test_is_valid_reason(tmp_path):
+    # Test with valid data + Empty geometry
+    # -------------------------------------
+    test_gdf = gpd.GeoDataFrame(
+        geometry=[  # type: ignore
+            sh_geom.Polygon(),
+            test_helper.TestData.point,
+            test_helper.TestData.multipoint,
+            test_helper.TestData.polygon_with_island,
+            test_helper.TestData.polygon_no_islands,
+            test_helper.TestData.multipolygon,
+            test_helper.TestData.geometrycollection,
+        ]
+    )
+    result = geoseries_util.is_valid_reason(test_gdf.geometry)
+
+    assert len(result) == len(test_gdf)
+    assert result.unique() == "Valid Geometry"
+
+    # Test if indexas are retained
+    # ----------------------------
+    test_filtered_gdf = test_gdf[3:-1]
+    assert isinstance(test_filtered_gdf.geometry, gpd.GeoSeries)
+    result = geoseries_util.is_valid_reason(test_filtered_gdf.geometry)
+
+    assert len(result) == len(test_filtered_gdf)
+    assert result.unique() == "Valid Geometry"
+    assert result.index.to_list() == test_filtered_gdf.index.to_list()
+
+    # Test with None
+    # --------------
+    test_gdf = gpd.GeoDataFrame(geometry=[None])  # type: ignore
+    result = geoseries_util.is_valid_reason(test_gdf.geometry)
+
+    # is_valid_reason returns None for None geometries
+    assert result[0] is None
+
+    # Test with invalid data
+    # ----------------------
+    # Prepare test data
+    path = test_helper.get_testfile("polygon-invalid")
+    gdf = gfo.read_file(path)
+    result = geoseries_util.is_valid_reason(gdf.geometry)
+
+    assert len(result) == len(gdf)
+    assert result[0].startswith("Ring Self-intersection")
+
+
+def test_polygons_to_lines():
+    # Test with polygons
+    test_geoseries = gpd.GeoSeries(
+        data=[
+            None,
+            sh_geom.Polygon(),
+            test_helper.TestData.multipolygon,
+            test_helper.TestData.polygon_with_island,
+            test_helper.TestData.polygon_no_islands,
+            test_helper.TestData.multipolygon,
+        ]
+    )
+    lines_series = geoseries_util.polygons_to_lines(test_geoseries)
+    assert len(lines_series) == 9
+
+
+@pytest.mark.parametrize(
+    "algorithm", [SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER, SimplifyAlgorithm.LANG]
+)
+def test_simplify_ext(algorithm):
+    input_path = test_helper.get_testfile("polygon-parcel")
+    input_gdf = gfo.read_file(input_path)
+    result_geoseries = geoseries_util.simplify_ext(
+        input_gdf.geometry, tolerance=1, algorithm=algorithm
+    )
+
+    assert len(result_geoseries) == len(input_gdf.geometry)
+    assert len(result_geoseries[1].exterior.coords) < len(
+        input_gdf.geometry[1].geoms[0].exterior.coords
+    )
+
+
+@pytest.mark.parametrize(
+    "algorithm", [SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER, SimplifyAlgorithm.LANG]
+)
+def test_simplify_topo_ext(algorithm):
+    # Skip test if simplification is not available
+    _ = pytest.importorskip("simplification")
+
+    input_path = test_helper.get_testfile("polygon-parcel")
+    input_gdf = gfo.read_file(input_path)
+    result_geoseries = geoseries_util.simplify_topo_ext(
+        input_gdf.geometry, tolerance=1, algorithm=algorithm
+    )
+
+    assert len(result_geoseries) == len(input_gdf.geometry)
+    assert len(result_geoseries[1].geoms[0].exterior.coords) < len(
+        input_gdf.geometry[1].geoms[0].exterior.coords
+    )
```

### Comparing `geofileops-0.8.0a1/tests/test_grid_util.py` & `geofileops-0.8.0a2/tests/test_grid_util.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for functionalities in vector_util.
-"""
-
-from pathlib import Path
-import sys
-
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
-import geofileops as gfo
-from geofileops.util import grid_util
-from tests import test_helper
-
-
-def test_create_grid2():
-    # Test for small number of cells
-    for i in range(1, 10):
-        grid_gdf = grid_util.create_grid2(
-            total_bounds=(40000.0, 160000.0, 45000.0, 210000.0),
-            nb_squarish_tiles=i,
-            crs="epsg:31370",
-        )
-        assert len(grid_gdf) == i
-
-    # Test for larger number of cells
-    grid_gdf = grid_util.create_grid2(
-        total_bounds=(40000.0, 160000.0, 45000.0, 210000.0),
-        nb_squarish_tiles=100,
-        crs="epsg:31370",
-    )
-    assert len(grid_gdf) == 96
-
-
-def test_split_tiles():
-    input_tiles_path = test_helper.get_testfile("BEFL-kbl")
-    input_tiles = gfo.read_file(input_tiles_path)
-    nb_tiles_wanted = len(input_tiles) * 8
-    result = grid_util.split_tiles(
-        input_tiles=input_tiles, nb_tiles_wanted=nb_tiles_wanted
-    )
-
-    assert len(result) == len(input_tiles) * 8
+# -*- coding: utf-8 -*-
+"""
+Tests for functionalities in vector_util.
+"""
+
+from pathlib import Path
+import sys
+
+# Add path so the local geofileops packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
+import geofileops as gfo
+from geofileops.util import grid_util
+from tests import test_helper
+
+
+def test_create_grid2():
+    # Test for small number of cells
+    for i in range(1, 10):
+        grid_gdf = grid_util.create_grid2(
+            total_bounds=(40000.0, 160000.0, 45000.0, 210000.0),
+            nb_squarish_tiles=i,
+            crs="epsg:31370",
+        )
+        assert len(grid_gdf) == i
+
+    # Test for larger number of cells
+    grid_gdf = grid_util.create_grid2(
+        total_bounds=(40000.0, 160000.0, 45000.0, 210000.0),
+        nb_squarish_tiles=100,
+        crs="epsg:31370",
+    )
+    assert len(grid_gdf) == 96
+
+
+def test_split_tiles():
+    input_tiles_path = test_helper.get_testfile("BEFL-kbl")
+    input_tiles = gfo.read_file(input_tiles_path)
+    nb_tiles_wanted = len(input_tiles) * 8
+    result = grid_util.split_tiles(
+        input_tiles=input_tiles, nb_tiles_wanted=nb_tiles_wanted
+    )
+
+    assert len(result) == len(input_tiles) * 8
```

### Comparing `geofileops-0.8.0a1/tests/test_layer_styles.py` & `geofileops-0.8.0a2/tests/test_layerstyles.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,60 +1,60 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for functionalities in helpers.layer_styles.
-"""
-
-import pytest
-
-import geofileops as gfo
-from geofileops.helpers import layer_styles
-from tests import test_helper
-
-
-def test_has_layerstyles_table(tmp_path):
-    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
-
-    assert not layer_styles._has_layerstyles_table(test_path)
-    layer_styles._init_layerstyles(test_path)
-    assert layer_styles._has_layerstyles_table(test_path)
-
-
-def test_add_get_remove_layer_styles(tmp_path):
-    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
-
-    assert not layer_styles._has_layerstyles_table(test_path)
-    layer_styles._init_layerstyles(test_path)
-    assert layer_styles._has_layerstyles_table(test_path)
-
-    # Add layer style to "parcel" layer
-    with open(test_helper._data_dir / "polygonstyle.sld") as file:
-        sld = file.read()
-    with open(test_helper._data_dir / "polygonstyle.qml") as file:
-        qml = file.read()
-    gfo.add_layerstyle(
-        path=test_path,
-        layer="parcels",
-        name="test_style",
-        sld=sld,
-        qml=qml,
-        use_as_default=True,
-    )
-    layerstyles_df = gfo.get_layerstyles(test_path)
-    assert len(layerstyles_df) == 1
-
-    # Adding the same style again should give an error
-    with pytest.raises(ValueError, match="layer style exists already: "):
-        gfo.add_layerstyle(
-            path=test_path, layer="parcels", name="test_style", qml="test_qml"
-        )
-
-    # Backup the styled file to be a able to check it manually in QGIS
-    styled_path = tmp_path / f"{test_path.stem}_styled{test_path.suffix}"
-    gfo.copy(src=test_path, dst=styled_path)
-
-    # Remove the style again
-    gfo.remove_layerstyle(test_path, id=1)
-    layerstyles_df = gfo.get_layerstyles(test_path)
-    assert len(layerstyles_df) == 0
-
-    # Removing a style that doesn't exist is OK
-    gfo.remove_layerstyle(test_path, id=1)
+# -*- coding: utf-8 -*-
+"""
+Tests for functionalities in helpers.layer_styles.
+"""
+
+import pytest
+
+import geofileops as gfo
+from geofileops.helpers import layerstyles
+from tests import test_helper
+
+
+def test_has_layerstyles_table(tmp_path):
+    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
+
+    assert not layerstyles._has_layerstyles_table(test_path)
+    layerstyles._init_layerstyles(test_path)
+    assert layerstyles._has_layerstyles_table(test_path)
+
+
+def test_add_get_remove_layer_styles(tmp_path):
+    test_path = test_helper.get_testfile("polygon-parcel", dst_dir=tmp_path)
+
+    assert not layerstyles._has_layerstyles_table(test_path)
+    layerstyles._init_layerstyles(test_path)
+    assert layerstyles._has_layerstyles_table(test_path)
+
+    # Add layer style to "parcel" layer
+    with open(test_helper._data_dir / "polygonstyle.sld") as file:
+        sld = file.read()
+    with open(test_helper._data_dir / "polygonstyle.qml") as file:
+        qml = file.read()
+    gfo.add_layerstyle(
+        path=test_path,
+        layer="parcels",
+        name="test_style",
+        sld=sld,
+        qml=qml,
+        use_as_default=True,
+    )
+    layerstyles_df = gfo.get_layerstyles(test_path)
+    assert len(layerstyles_df) == 1
+
+    # Adding the same style again should give an error
+    with pytest.raises(ValueError, match="layer style exists already: "):
+        gfo.add_layerstyle(
+            path=test_path, layer="parcels", name="test_style", qml="test_qml"
+        )
+
+    # Backup the styled file to be a able to check it manually in QGIS
+    styled_path = tmp_path / f"{test_path.stem}_styled{test_path.suffix}"
+    gfo.copy(src=test_path, dst=styled_path)
+
+    # Remove the style again
+    gfo.remove_layerstyle(test_path, id=1)
+    layerstyles_df = gfo.get_layerstyles(test_path)
+    assert len(layerstyles_df) == 0
+
+    # Removing a style that doesn't exist is OK
+    gfo.remove_layerstyle(test_path, id=1)
```

### Comparing `geofileops-0.8.0a1/tests/test_ogr_sql_util.py` & `geofileops-0.8.0a2/tests/test_ogr_sql_util.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,124 +1,124 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for functionalities in sql_util.
-"""
-
-from pathlib import Path
-import sys
-from typing import Iterable, List, Optional
-
-import pytest
-
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
-from geofileops.util import _ogr_sql_util
-
-
-@pytest.mark.parametrize(
-    "descr, columns_specified, columns_available, table_alias, columnname_prefix, "
-    "fid_column, "
-    "exp_quoted, exp_prefixed, exp_prefixed_aliased, "
-    "exp_null_aliased, exp_from_subselect",
-    [
-        (
-            "2 columns asked out of 3 in layer",
-            ["test1", "TesT2"],
-            ["test1", "test3", "test2"],
-            "",
-            "",
-            "fid",
-            ',"test1", "test2"',
-            ',"test1", "test2"',
-            ',"test1" "test1", "test2" "TesT2"',
-            ',NULL "test1", NULL "TesT2"',
-            ',sub."test1", sub."TesT2"',
-        ),
-        (
-            "fid asked as well as fid_1",
-            ["fid", "fid_1", "test2"],
-            ["fid_1", "fid_2", "test2"],
-            "",
-            "",
-            "",  # No actual fid column, eg. shapefile
-            ',"rowid", "fid_1", "test2"',
-            ',"rowid", "fid_1", "test2"',
-            ',"rowid" "fid_2", "fid_1" "fid_1", "test2" "test2"',
-            ',NULL "fid_2", NULL "fid_1", NULL "test2"',
-            ',sub."fid_2", sub."fid_1", sub."test2"',
-        ),
-        (
-            "fid asked and fid_column is fid",
-            ["fid", "test1", "test2"],
-            ["test2", "test3", "test1"],
-            "",
-            "",
-            "fid",  # Actual" fid" column, eg. geopackage
-            ',CAST("fid" AS INT), "test1", "test2"',
-            ',CAST("fid" AS INT), "test1", "test2"',
-            ',CAST("fid" AS INT) "fid_1", "test1" "test1", "test2" "test2"',
-            ',NULL "fid_1", NULL "test1", NULL "test2"',
-            ',sub."fid_1", sub."test1", sub."test2"',
-        ),
-        (
-            "fid asked with table alias",
-            ["fid", "test1"],
-            ["test2", "test3", "test1"],
-            "table_alias1",
-            "",
-            "fid",  # Actual "fid" column, eg. geopackage
-            ',CAST("fid" AS INT), "test1"',
-            ',CAST(table_alias1."fid" AS INT), table_alias1."test1"',
-            ',CAST(table_alias1."fid" AS INT) "fid_1", table_alias1."test1" "test1"',
-            ',NULL "fid_1", NULL "test1"',
-            ',sub."fid_1", sub."test1"',
-        ),
-        (
-            "fid asked with table alias and prefix",
-            ["fid", "test1"],
-            ["test2", "test3", "test1"],
-            "table_alias1",
-            "l1_",
-            "ogc_fid",  # Actual fid column named "ogc_fid", eg. sqlite
-            ',"ogc_fid", "test1"',
-            ',table_alias1."ogc_fid", table_alias1."test1"',
-            ',table_alias1."ogc_fid" "l1_fid", table_alias1."test1" "l1_test1"',
-            ',NULL "l1_fid", NULL "l1_test1"',
-            ',sub."l1_fid", sub."l1_test1"',
-        ),
-        ("No columns asked", [], ["test1"], "", "", "fid", "", "", "", "", ""),
-    ],
-)
-def test_ColumnFormatter(
-    descr: str,
-    columns_specified: Optional[List[str]],
-    columns_available: Iterable[str],
-    table_alias: str,
-    columnname_prefix: str,
-    fid_column: str,
-    exp_quoted: str,
-    exp_prefixed: str,
-    exp_prefixed_aliased: str,
-    exp_null_aliased: str,
-    exp_from_subselect: str,
-):
-    column_frmt = _ogr_sql_util.ColumnFormatter(
-        columns_asked=columns_specified,
-        columns_in_layer=columns_available,
-        fid_column=fid_column,
-        table_alias=table_alias,
-        column_alias_prefix=columnname_prefix,
-    )
-    assert column_frmt.quoted() == exp_quoted
-    assert column_frmt.prefixed() == exp_prefixed
-    assert column_frmt.prefixed_aliased() == exp_prefixed_aliased
-    assert column_frmt.null_aliased() == exp_null_aliased
-    assert column_frmt.from_subselect() == exp_from_subselect
-
-
-def test_ColumnFormatter_invalidcolumn():
-    with pytest.raises(ValueError, match="columns_asked contains columns not in"):
-        _ogr_sql_util.ColumnFormatter(
-            columns_asked=["test"],
-            columns_in_layer=["test1"],
-            fid_column="fid",
-        )
+# -*- coding: utf-8 -*-
+"""
+Tests for functionalities in sql_util.
+"""
+
+from pathlib import Path
+import sys
+from typing import Iterable, List, Optional
+
+import pytest
+
+# Add path so the local geofileops packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
+from geofileops.util import _ogr_sql_util
+
+
+@pytest.mark.parametrize(
+    "descr, columns_specified, columns_available, table_alias, columnname_prefix, "
+    "fid_column, "
+    "exp_quoted, exp_prefixed, exp_prefixed_aliased, "
+    "exp_null_aliased, exp_from_subselect",
+    [
+        (
+            "2 columns asked out of 3 in layer",
+            ["test1", "TesT2"],
+            ["test1", "test3", "test2"],
+            "",
+            "",
+            "fid",
+            ',"test1", "test2"',
+            ',"test1", "test2"',
+            ',"test1" "test1", "test2" "TesT2"',
+            ',NULL "test1", NULL "TesT2"',
+            ',sub."test1", sub."TesT2"',
+        ),
+        (
+            "fid asked as well as fid_1",
+            ["fid", "fid_1", "test2"],
+            ["fid_1", "fid_2", "test2"],
+            "",
+            "",
+            "",  # No actual fid column, eg. shapefile
+            ',"rowid", "fid_1", "test2"',
+            ',"rowid", "fid_1", "test2"',
+            ',"rowid" "fid_2", "fid_1" "fid_1", "test2" "test2"',
+            ',NULL "fid_2", NULL "fid_1", NULL "test2"',
+            ',sub."fid_2", sub."fid_1", sub."test2"',
+        ),
+        (
+            "fid asked and fid_column is fid",
+            ["fid", "test1", "test2"],
+            ["test2", "test3", "test1"],
+            "",
+            "",
+            "fid",  # Actual" fid" column, eg. geopackage
+            ',CAST("fid" AS INT), "test1", "test2"',
+            ',CAST("fid" AS INT), "test1", "test2"',
+            ',CAST("fid" AS INT) "fid_1", "test1" "test1", "test2" "test2"',
+            ',NULL "fid_1", NULL "test1", NULL "test2"',
+            ',sub."fid_1", sub."test1", sub."test2"',
+        ),
+        (
+            "fid asked with table alias",
+            ["fid", "test1"],
+            ["test2", "test3", "test1"],
+            "table_alias1",
+            "",
+            "fid",  # Actual "fid" column, eg. geopackage
+            ',CAST("fid" AS INT), "test1"',
+            ',CAST(table_alias1."fid" AS INT), table_alias1."test1"',
+            ',CAST(table_alias1."fid" AS INT) "fid_1", table_alias1."test1" "test1"',
+            ',NULL "fid_1", NULL "test1"',
+            ',sub."fid_1", sub."test1"',
+        ),
+        (
+            "fid asked with table alias and prefix",
+            ["fid", "test1"],
+            ["test2", "test3", "test1"],
+            "table_alias1",
+            "l1_",
+            "ogc_fid",  # Actual fid column named "ogc_fid", eg. sqlite
+            ',"ogc_fid", "test1"',
+            ',table_alias1."ogc_fid", table_alias1."test1"',
+            ',table_alias1."ogc_fid" "l1_fid", table_alias1."test1" "l1_test1"',
+            ',NULL "l1_fid", NULL "l1_test1"',
+            ',sub."l1_fid", sub."l1_test1"',
+        ),
+        ("No columns asked", [], ["test1"], "", "", "fid", "", "", "", "", ""),
+    ],
+)
+def test_ColumnFormatter(
+    descr: str,
+    columns_specified: Optional[List[str]],
+    columns_available: Iterable[str],
+    table_alias: str,
+    columnname_prefix: str,
+    fid_column: str,
+    exp_quoted: str,
+    exp_prefixed: str,
+    exp_prefixed_aliased: str,
+    exp_null_aliased: str,
+    exp_from_subselect: str,
+):
+    column_frmt = _ogr_sql_util.ColumnFormatter(
+        columns_asked=columns_specified,
+        columns_in_layer=columns_available,
+        fid_column=fid_column,
+        table_alias=table_alias,
+        column_alias_prefix=columnname_prefix,
+    )
+    assert column_frmt.quoted() == exp_quoted
+    assert column_frmt.prefixed() == exp_prefixed
+    assert column_frmt.prefixed_aliased() == exp_prefixed_aliased
+    assert column_frmt.null_aliased() == exp_null_aliased
+    assert column_frmt.from_subselect() == exp_from_subselect
+
+
+def test_ColumnFormatter_invalidcolumn():
+    with pytest.raises(ValueError, match="columns_asked contains columns not in"):
+        _ogr_sql_util.ColumnFormatter(
+            columns_asked=["test"],
+            columns_in_layer=["test1"],
+            fid_column="fid",
+        )
```

### Comparing `geofileops-0.8.0a1/tests/test_ogr_util.py` & `geofileops-0.8.0a2/tests/test_ogr_util.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,99 +1,99 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for functionalities in ogr_util.
-"""
-
-import os
-from pathlib import Path
-import sys
-
-from osgeo import gdal
-
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
-from geofileops.util import _ogr_util
-
-
-def test_get_drivers():
-    drivers = _ogr_util.get_drivers()
-    assert len(drivers) > 0
-    assert "GPKG" in drivers
-    assert "ESRI Shapefile" in drivers
-
-
-def test_prepare_gdal_options():
-    # Some basic variants that should all be OK
-    options_ok = [
-        {"LAYER_CREATION.SPATIAL_INDEX": True},
-        {"layer_creation.spatial_index": True},
-        {" LAYER_CREATION . SPATIAL_INDEX ": True},
-    ]
-    for option in options_ok:
-        prepared = _ogr_util._prepare_gdal_options(option)
-        assert prepared["LAYER_CREATION.SPATIAL_INDEX"] == "YES"
-
-        prepared = _ogr_util._prepare_gdal_options(option, split_by_option_type=True)
-        assert "LAYER_CREATION" in prepared
-        assert prepared["LAYER_CREATION"]["SPATIAL_INDEX"] == "YES"
-
-    # Some more specific cases
-    prepared = _ogr_util._prepare_gdal_options({"LAYER_CREATION.SPATIAL_INDEX": False})
-    assert prepared["LAYER_CREATION.SPATIAL_INDEX"] == "NO"
-
-    # These options should give an error
-    options_nok = [
-        {"LAYER_CREATION-SPATIAL_INDEX": True},
-        {"NOT_EXISTING_OPTION_TYPE.SPATIAL_INDEX": True},
-        {"LAYER_CREATION.SPATIAL_INDEX": True, "layer_creation.spatial_index": False},
-    ]
-    for option in options_nok:
-        try:
-            _ = _ogr_util._prepare_gdal_options(option)
-            error_raised = False
-        except Exception:
-            error_raised = True
-        assert error_raised is True, f"Error should have been raised for {option}"
-
-
-def test_set_config_options():
-    # Init
-    test1_config_notset = "TEST_CONFIG_OPTION_1"
-    test2_config_alreadyset = "TEST_CONFIG_OPTION_2"
-    test3_config_envset = "TEST_CONFIG_OPTION_3"
-    test4_bool_true = "TEST_CONFIG_OPTION_4"
-    test5_bool_false = "TEST_CONFIG_OPTION_5"
-    test6_int_50 = "TEST_CONFIG_OPTION_6"
-    assert gdal.GetConfigOption(test1_config_notset) is None
-    assert gdal.GetConfigOption(test2_config_alreadyset) is None
-    gdal.SetConfigOption(test2_config_alreadyset, "test2_original_value")
-    assert test3_config_envset not in os.environ
-    os.environ[test3_config_envset] = "test3_original_env_value"
-
-    # Set config options with context manager
-    with _ogr_util.set_config_options(
-        {
-            test1_config_notset: "test1_context_value",
-            test2_config_alreadyset: "test2_context_value",
-            test3_config_envset: "test3_context_value",
-            test4_bool_true: True,
-            test5_bool_false: False,
-            test6_int_50: 50,
-        }
-    ):
-        assert gdal.GetConfigOption(test1_config_notset) == "test1_context_value"
-        assert gdal.GetConfigOption(test2_config_alreadyset) == "test2_context_value"
-        assert gdal.GetConfigOption(test3_config_envset) == "test3_context_value"
-        assert gdal.GetConfigOption(test4_bool_true) == "YES"
-        assert gdal.GetConfigOption(test5_bool_false) == "NO"
-        assert gdal.GetConfigOption(test6_int_50) == "50"
-
-    # The options set with context manager should be gone
-    assert gdal.GetConfigOption(test1_config_notset) is None
-    # TODO: delete next line + uncomment 2nd if GetConfigOptions is supported
-    assert gdal.GetConfigOption(test2_config_alreadyset) is None
-    # assert gdal.GetConfigOption(test2_config_alreadyset) == "test2_original_value"
-    assert gdal.GetConfigOption(test3_config_envset) == "test3_original_env_value"
-
-    # If option via env is changed, it changes here as well
-    os.environ[test3_config_envset] = "test3_new_env_value"
-    assert gdal.GetConfigOption(test3_config_envset) == "test3_new_env_value"
+# -*- coding: utf-8 -*-
+"""
+Tests for functionalities in ogr_util.
+"""
+
+import os
+from pathlib import Path
+import sys
+
+from osgeo import gdal
+
+# Add path so the local geofileops packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
+from geofileops.util import _ogr_util
+
+
+def test_get_drivers():
+    drivers = _ogr_util.get_drivers()
+    assert len(drivers) > 0
+    assert "GPKG" in drivers
+    assert "ESRI Shapefile" in drivers
+
+
+def test_prepare_gdal_options():
+    # Some basic variants that should all be OK
+    options_ok = [
+        {"LAYER_CREATION.SPATIAL_INDEX": True},
+        {"layer_creation.spatial_index": True},
+        {" LAYER_CREATION . SPATIAL_INDEX ": True},
+    ]
+    for option in options_ok:
+        prepared = _ogr_util._prepare_gdal_options(option)
+        assert prepared["LAYER_CREATION.SPATIAL_INDEX"] == "YES"
+
+        prepared = _ogr_util._prepare_gdal_options(option, split_by_option_type=True)
+        assert "LAYER_CREATION" in prepared
+        assert prepared["LAYER_CREATION"]["SPATIAL_INDEX"] == "YES"
+
+    # Some more specific cases
+    prepared = _ogr_util._prepare_gdal_options({"LAYER_CREATION.SPATIAL_INDEX": False})
+    assert prepared["LAYER_CREATION.SPATIAL_INDEX"] == "NO"
+
+    # These options should give an error
+    options_nok = [
+        {"LAYER_CREATION-SPATIAL_INDEX": True},
+        {"NOT_EXISTING_OPTION_TYPE.SPATIAL_INDEX": True},
+        {"LAYER_CREATION.SPATIAL_INDEX": True, "layer_creation.spatial_index": False},
+    ]
+    for option in options_nok:
+        try:
+            _ = _ogr_util._prepare_gdal_options(option)
+            error_raised = False
+        except Exception:
+            error_raised = True
+        assert error_raised is True, f"Error should have been raised for {option}"
+
+
+def test_set_config_options():
+    # Init
+    test1_config_notset = "TEST_CONFIG_OPTION_1"
+    test2_config_alreadyset = "TEST_CONFIG_OPTION_2"
+    test3_config_envset = "TEST_CONFIG_OPTION_3"
+    test4_bool_true = "TEST_CONFIG_OPTION_4"
+    test5_bool_false = "TEST_CONFIG_OPTION_5"
+    test6_int_50 = "TEST_CONFIG_OPTION_6"
+    assert gdal.GetConfigOption(test1_config_notset) is None
+    assert gdal.GetConfigOption(test2_config_alreadyset) is None
+    gdal.SetConfigOption(test2_config_alreadyset, "test2_original_value")
+    assert test3_config_envset not in os.environ
+    os.environ[test3_config_envset] = "test3_original_env_value"
+
+    # Set config options with context manager
+    with _ogr_util.set_config_options(
+        {
+            test1_config_notset: "test1_context_value",
+            test2_config_alreadyset: "test2_context_value",
+            test3_config_envset: "test3_context_value",
+            test4_bool_true: True,
+            test5_bool_false: False,
+            test6_int_50: 50,
+        }
+    ):
+        assert gdal.GetConfigOption(test1_config_notset) == "test1_context_value"
+        assert gdal.GetConfigOption(test2_config_alreadyset) == "test2_context_value"
+        assert gdal.GetConfigOption(test3_config_envset) == "test3_context_value"
+        assert gdal.GetConfigOption(test4_bool_true) == "YES"
+        assert gdal.GetConfigOption(test5_bool_false) == "NO"
+        assert gdal.GetConfigOption(test6_int_50) == "50"
+
+    # The options set with context manager should be gone
+    assert gdal.GetConfigOption(test1_config_notset) is None
+    # TODO: delete next line + uncomment 2nd if GetConfigOptions is supported
+    assert gdal.GetConfigOption(test2_config_alreadyset) is None
+    # assert gdal.GetConfigOption(test2_config_alreadyset) == "test2_original_value"
+    assert gdal.GetConfigOption(test3_config_envset) == "test3_original_env_value"
+
+    # If option via env is changed, it changes here as well
+    os.environ[test3_config_envset] = "test3_new_env_value"
+    assert gdal.GetConfigOption(test3_config_envset) == "test3_new_env_value"
```

### Comparing `geofileops-0.8.0a1/tests/test_parameter_helper.py` & `geofileops-0.8.0a2/tests/test_parameter_helper.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,75 +1,75 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for functionalities in _processing_util.
-"""
-
-import re
-import pytest
-
-from geofileops.helpers import _parameter_helper
-
-
-@pytest.mark.parametrize(
-    "agg_columns_value",
-    [
-        None,
-        {"columns": [{"column": "UIDN", "agg": "count", "as": "123"}]},
-        {"json": ["UIDN", "OIDN"]},
-        {"json": None},
-    ],
-)
-def test_validate_agg_columns(agg_columns_value):
-    _parameter_helper.validate_agg_columns(agg_columns=agg_columns_value)
-
-
-@pytest.mark.parametrize(
-    "expected_error, agg_columns_value",
-    [
-        ("agg_columns must be a dict with exactly one top-level key", {"a": 1, "b": 2}),
-        ("agg_columns has invalid top-level key", {"a": 1}),
-        ('agg_columns["columns"] does not contain a list of dicts', {"columns": 1}),
-        (
-            'agg_columns["columns"] does not contain a list of dicts',
-            {"columns": {"column": "abc"}},
-        ),
-        (
-            'agg_columns["columns"] list contains a non-dict element',
-            {"columns": ["column", "abc"]},
-        ),
-        (
-            'each dict in agg_columns["columns"] needs a "column" element',
-            {"columns": [{"agg": "mean", "as": "uidn"}]},
-        ),
-        (
-            'each dict in agg_columns["columns"] needs an "agg" element',
-            {"columns": [{"column": "UIDN", "as": "uidn"}]},
-        ),
-        (
-            'each dict in agg_columns["columns"] needs an "as" element',
-            {"columns": [{"column": "UIDN", "agg": "mean"}]},
-        ),
-        (
-            'agg_columns["columns"] contains unsupported aggregation NOK',
-            {"columns": [{"column": "UIDN", "agg": "NOK", "as": "uidn"}]},
-        ),
-        (
-            'agg_columns["columns"], "as" value should be string',
-            {"columns": [{"column": "UIDN", "agg": "count", "as": 123}]},
-        ),
-        (
-            'agg_columns["json"] does not contain a list of strings',
-            {"json": {"column": "UIDN", "agg": "count", "as": 123}},
-        ),
-        (
-            'agg_columns["json"] list contains a non-string element',
-            {"json": [{"column": "UIDN", "agg": "count", "as": 123}]},
-        ),
-        (
-            'agg_columns["json"] list contains a non-string element',
-            {"json": ["UIDN", 123]},
-        ),
-    ],
-)
-def test_validate_agg_columns_invalid(expected_error, agg_columns_value):
-    with pytest.raises(ValueError, match=re.escape(expected_error)):
-        _parameter_helper.validate_agg_columns(agg_columns_value)
+# -*- coding: utf-8 -*-
+"""
+Tests for functionalities in _processing_util.
+"""
+
+import re
+import pytest
+
+from geofileops.helpers import _parameter_helper
+
+
+@pytest.mark.parametrize(
+    "agg_columns_value",
+    [
+        None,
+        {"columns": [{"column": "UIDN", "agg": "count", "as": "123"}]},
+        {"json": ["UIDN", "OIDN"]},
+        {"json": None},
+    ],
+)
+def test_validate_agg_columns(agg_columns_value):
+    _parameter_helper.validate_agg_columns(agg_columns=agg_columns_value)
+
+
+@pytest.mark.parametrize(
+    "expected_error, agg_columns_value",
+    [
+        ("agg_columns must be a dict with exactly one top-level key", {"a": 1, "b": 2}),
+        ("agg_columns has invalid top-level key", {"a": 1}),
+        ('agg_columns["columns"] does not contain a list of dicts', {"columns": 1}),
+        (
+            'agg_columns["columns"] does not contain a list of dicts',
+            {"columns": {"column": "abc"}},
+        ),
+        (
+            'agg_columns["columns"] list contains a non-dict element',
+            {"columns": ["column", "abc"]},
+        ),
+        (
+            'each dict in agg_columns["columns"] needs a "column" element',
+            {"columns": [{"agg": "mean", "as": "uidn"}]},
+        ),
+        (
+            'each dict in agg_columns["columns"] needs an "agg" element',
+            {"columns": [{"column": "UIDN", "as": "uidn"}]},
+        ),
+        (
+            'each dict in agg_columns["columns"] needs an "as" element',
+            {"columns": [{"column": "UIDN", "agg": "mean"}]},
+        ),
+        (
+            'agg_columns["columns"] contains unsupported aggregation NOK',
+            {"columns": [{"column": "UIDN", "agg": "NOK", "as": "uidn"}]},
+        ),
+        (
+            'agg_columns["columns"], "as" value should be string',
+            {"columns": [{"column": "UIDN", "agg": "count", "as": 123}]},
+        ),
+        (
+            'agg_columns["json"] does not contain a list of strings',
+            {"json": {"column": "UIDN", "agg": "count", "as": 123}},
+        ),
+        (
+            'agg_columns["json"] list contains a non-string element',
+            {"json": [{"column": "UIDN", "agg": "count", "as": 123}]},
+        ),
+        (
+            'agg_columns["json"] list contains a non-string element',
+            {"json": ["UIDN", 123]},
+        ),
+    ],
+)
+def test_validate_agg_columns_invalid(expected_error, agg_columns_value):
+    with pytest.raises(ValueError, match=re.escape(expected_error)):
+        _parameter_helper.validate_agg_columns(agg_columns_value)
```

### Comparing `geofileops-0.8.0a1/tests/test_processing_util.py` & `geofileops-0.8.0a2/tests/test_processing_util.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,45 +1,45 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for functionalities in _processing_util.
-"""
-
-import os
-
-from geofileops.util import _processing_util
-
-
-def test_processnice():
-    # Test setting and getting some values for nice
-    # Remark: the nice values tests are spcifically written to accomodate for
-    # windows specificalities:
-    #     - windows only supports 6 niceness classes. setprocessnice en
-    #       getprocessnice maps niceness values to these classes.
-    #     - when setting REALTIME priority (-20 niceness) apparently this
-    #       results only to HIGH priority.
-    nice_orig = _processing_util.getprocessnice()
-    for niceness in [-15, -10, 0, 10, 19]:
-        # Decreasing niceness (sometimes) isn't possible on linux, so skip
-        if os.name != "nt":
-            continue
-
-        # Test!
-        _processing_util.setprocessnice(niceness)
-        nice = _processing_util.getprocessnice()
-        assert nice == niceness
-
-    # Test invalid values for nice value
-    try:
-        _processing_util.setprocessnice(20)
-        exception_raised = False
-    except ValueError:
-        exception_raised = True
-    assert exception_raised is True
-    try:
-        _processing_util.setprocessnice(-21)
-        exception_raised = False
-    except ValueError:
-        exception_raised = True
-    assert exception_raised is True
-
-    # Reset niceness to original value before test
-    _processing_util.setprocessnice(nice_orig)
+# -*- coding: utf-8 -*-
+"""
+Tests for functionalities in _processing_util.
+"""
+
+import os
+
+from geofileops.util import _processing_util
+
+
+def test_processnice():
+    # Test setting and getting some values for nice
+    # Remark: the nice values tests are spcifically written to accomodate for
+    # windows specificalities:
+    #     - windows only supports 6 niceness classes. setprocessnice en
+    #       getprocessnice maps niceness values to these classes.
+    #     - when setting REALTIME priority (-20 niceness) apparently this
+    #       results only to HIGH priority.
+    nice_orig = _processing_util.getprocessnice()
+    for niceness in [-15, -10, 0, 10, 19]:
+        # Decreasing niceness (sometimes) isn't possible on linux, so skip
+        if os.name != "nt":
+            continue
+
+        # Test!
+        _processing_util.setprocessnice(niceness)
+        nice = _processing_util.getprocessnice()
+        assert nice == niceness
+
+    # Test invalid values for nice value
+    try:
+        _processing_util.setprocessnice(20)
+        exception_raised = False
+    except ValueError:
+        exception_raised = True
+    assert exception_raised is True
+    try:
+        _processing_util.setprocessnice(-21)
+        exception_raised = False
+    except ValueError:
+        exception_raised = True
+    assert exception_raised is True
+
+    # Reset niceness to original value before test
+    _processing_util.setprocessnice(nice_orig)
```

### Comparing `geofileops-0.8.0a1/tests/test_spatialite.py` & `geofileops-0.8.0a2/tests/test_spatialite.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-# -*- coding: utf-8 -*-
-"""
-Tests for functionalities in ogr_util.
-"""
-
-import os
-from pathlib import Path
-import sys
-
-import pytest
-
-# Add path so the local geofileops packages are found
-sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
-import geofileops as gfo
-from tests import test_helper
-
-
-@pytest.mark.skipif(
-    "GITHUB_ACTIONS" in os.environ,
-    reason="Don't run on CI: just to followup odd behaviour in spatialite.",
-)
-def test_st_difference_null(tmp_path):
-    """
-    ST_difference returns NULL when 2nd argument is NULL, which is odd.
-
-    In several spatial operations IIF statements are used to avoid this behaviour.
-    """
-    input_path = test_helper.get_testfile(testfile="polygon-parcel")
-
-    sql_stmt = """
-        SELECT *
-          FROM "{input_layer}"
-         WHERE ST_difference({geometrycolumn}, NULL) IS NULL
-    """
-    output_path = tmp_path / "output.gpkg"
-    gfo.select(input_path, output_path, sql_stmt=sql_stmt)
-
-    input_gdf = gfo.read_file(input_path)
-    output_gdf = gfo.read_file(output_path)
-    assert len(input_gdf) == len(output_gdf)
+# -*- coding: utf-8 -*-
+"""
+Tests for functionalities in ogr_util.
+"""
+
+import os
+from pathlib import Path
+import sys
+
+import pytest
+
+# Add path so the local geofileops packages are found
+sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
+import geofileops as gfo
+from tests import test_helper
+
+
+@pytest.mark.skipif(
+    "GITHUB_ACTIONS" in os.environ,
+    reason="Don't run on CI: just to followup odd behaviour in spatialite.",
+)
+def test_st_difference_null(tmp_path):
+    """
+    ST_difference returns NULL when 2nd argument is NULL, which is odd.
+
+    In several spatial operations IIF statements are used to avoid this behaviour.
+    """
+    input_path = test_helper.get_testfile(testfile="polygon-parcel")
+
+    sql_stmt = """
+        SELECT *
+          FROM "{input_layer}"
+         WHERE ST_difference({geometrycolumn}, NULL) IS NULL
+    """
+    output_path = tmp_path / "output.gpkg"
+    gfo.select(input_path, output_path, sql_stmt=sql_stmt)
+
+    input_gdf = gfo.read_file(input_path)
+    output_gdf = gfo.read_file(output_path)
+    assert len(input_gdf) == len(output_gdf)
```

